<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>相遇即是缘分</title>
    <url>/2016/02/29/001/</url>
    <content><![CDATA[<blockquote>
<p>真是巧了！</p>
<p>2016 年 02 月 21 日，注册微信公众号。</p>
<p>2018 年 12 月 21 日，发布 github 博客。</p>
<p>小三年的时间过去了，重温了一遍下面的文字，怎一个土字了得，</p>
<p>那时快要毕业了，就要步入社会自己打拼了，文字里还是透着很强的稚嫩和愤青，看着挺感慨的。</p>
<p>要学习的东西太多了，都来不及抒发情感了，溜了~</p>
</blockquote>
<p>2016 年 2 月 21 日晚 20：00，内心一直有一个声音在呼唤我做出一个举动 —— 注册微信公众号，这个微信公众号的功能是用来记录自己的心路历程，我看见一些个人微信公众号的文章十分专业专一，而我，一个普普通通的小人物，没有太多的专业性知识体系书写价值含量高的文章，因此我所写的文章基本上为个人文章，以前有博客，后来有微博，现在有微信，我只是用了目前最潮流的媒体形式来抒发小情绪而已，并期望通过这个微信公众号与屏幕前的你相遇。我总觉得一切的相遇都是缘分，我相信缘分也是有因果关系的，我希望自己的一点点努力和成长能帮助到身边的人，并在我们有生之年能够相互成长，共同进步！</p>
<p><img src="https://image.woodwhales.cn/001/images/1.png" alt="相遇即是缘分"></p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>编程随想</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀博客集锦</title>
    <url>/2018/12/22/002/</url>
    <content><![CDATA[<h4 id="一、感谢他们"><a href="#一、感谢他们" class="headerlink" title="一、感谢他们"></a>一、感谢他们</h4><p><strong>初识博客</strong></p>
<p>2017 年 10 月之后，正式接触编程，找资料的唯一入口就是某度，期间就发现不少高质量的优秀博文，于是脑子里有了博客的样子。从最开始的 CSDN、博客园等平台到个人博客，期间看到技术文章的衍生品：gitBook，通过它知道了全球最大的同性交友平台。</p>
<p>每看到优秀精致的博客，频频羡慕佩服，自己也想模仿着做一个。</p>
<p>还没入门的自己，想建博客却完全不知道怎么下手，只了解个大概：</p>
<p>首先需要花钱买个或者租个服务器，然后要搞个博客的前端和管理后台，再然后是部署，最重要的是搭建了要有输出，不然建着玩么。对当时的建博客流程的认知让自己有了放弃的想法。</p>
<p><strong>搭建起来</strong></p>
<p>最近越来越懒癌犯了<span class="github-emoji" style="font-size:1.5em;font-weight:null"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，细说起来是这两件事情：</p>
<ol>
<li>最近在找<a href="https://woodwhales.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>资料的时候，发现许多博文网址的后缀都是<code>github.io</code>，羡慕 + 敬佩 = 跃跃欲试，尤其是<a href="https://blog.dreamtobe.cn/">Jacksgong/Blog</a>博客对我的触动，很惊讶于为何如此干净优雅。</li>
<li>使用微信公众号默认的文本编辑器排版文章，想要好看得小心翼翼比较花精力，于是找了些资料搞了个流程化的图文排版：<a href="https://mp.weixin.qq.com/s/kKUVd-HtYord3jQuo27MFQ">高效地一键图文排版</a>，虽然这种方式已经很实用方便了，但是有个小 bug：公众号对列表样式不渲染，所以每次还得手动调试，有种费力不讨好的感觉。</li>
</ol>
<p>想想现在自己都是猿了，怎么也得搞个博客吧，于是就有了现在这个<a href="https://woodwhales.github.io/">woodwhale’s blog</a>。</p>
<p>感谢众大佬的博客搭建教程。</p>
<blockquote>
<p>如果有任何问题，请<a href="mailto:woodwhales@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>邮件</a>联系或者关注<a href="/uploads/woodwhale-wechat-qcode.gif" target="_blank" title="E-Mail"><i class="fa fa-weixin"></i> 木鲸鱼</a>留言即可，欢迎交流。</p>
</blockquote>
<h4 id="二、较个性化的博客"><a href="#二、较个性化的博客" class="headerlink" title="二、较个性化的博客"></a>二、较个性化的博客</h4><blockquote>
<p>内含一些搭建博客教程，值得学习。</p>
</blockquote>
<ul>
<li><a href="https://reuixiy.github.io/">reuixiy</a></li>
<li><a href="https://www.oyohyee.com/tags/">Oyohyee’s Blog</a></li>
<li><a href="https://yfzhou.coding.me/">Felix</a></li>
<li><a href="https://blog.dongleizhang.com/">BanbanRamble</a></li>
<li><a href="https://me.idealli.com/">兰州小红鸡</a></li>
<li><a href="https://music.liuzhijin.cn/">刘志进实验室</a></li>
<li><a href="https://chungzh.cn/">ChungZH’s Blog</a></li>
<li><a href="https://asdfv1929.github.io/">asdfv1929 ‘s Home</a></li>
<li><a href="https://loremwalker.github.io/">loremwalker</a></li>
<li><a href="https://www.ofind.cn/">偶发现</a></li>
<li><a href="https://asdfv1929.github.io/">asdfv1929 ‘s Home</a></li>
</ul>
<h5 id="Hexo-主题及插件"><a href="#Hexo-主题及插件" class="headerlink" title="Hexo 主题及插件"></a>Hexo 主题及插件</h5><ul>
<li><a href="https://github.com/Molunerfinn/hexo-theme-melody">melody主题</a></li>
<li><a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md">Hexo 标签云插件</a></li>
</ul>
<h4 id="三、Java-博客"><a href="#三、Java-博客" class="headerlink" title="三、Java 博客"></a>三、Java 博客</h4><blockquote>
<p>高质量博文。</p>
</blockquote>
<ul>
<li><a href="http://www.ityouknow.com/">纯洁的微笑</a></li>
<li><a href="https://blog.dreamtobe.cn/">Jacksgong/Blog</a></li>
<li><a href="https://monkeysayhi.github.io/">猴子007</a></li>
<li><a href="https://www.barretlee.com/entry/">小胡子哥</a></li>
<li><a href="https://www.codesheep.cn/">CodeSheep · 程序羊</a></li>
<li><a href="http://tengj.top/">嘟嘟独立博客</a></li>
<li><a href="http://www.hollischuang.com/">HollisChuang’s Blog</a></li>
<li><a href="https://www.pdai.tech/">Java 全栈知识体系</a></li>
<li><a href="https://www.springcloud.cc/">Spring Cloud 中文网</a></li>
<li><a href="https://www.docs4dev.com/docs/zh">docs4dev</a></li>
<li><a href="https://doocs.github.io/advanced-java/#/">互联网 Java 工程师进阶知识完全扫盲</a></li>
<li><a href="https://javakk.com/">老K的Java博客</a></li>
<li><a href="https://doocs.github.io/jvm/">JVM 底层原理最全知识总结</a></li>
<li><a href="https://thonatos.gitbooks.io/be-a-professional-programmer/content/">be-a-professional-programmer</a></li>
<li><a href="https://q.shanyue.tech/">互联网大厂面试每日一题</a></li>
<li><a href="https://www.r2coding.com/#/">Road To Coding</a></li>
</ul>
<h4 id="四、其他高质量博客"><a href="#四、其他高质量博客" class="headerlink" title="四、其他高质量博客"></a>四、其他高质量博客</h4><blockquote>
<p>高质量博文。</p>
</blockquote>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><ul>
<li><a href="https://www.yangcs.net/">Ryan Yang</a></li>
<li><a href="https://www.liaoxuefeng.com/">廖雪峰的官方网站</a></li>
<li><a href="https://www.zhangxinxu.com/">张鑫旭-鑫空间-鑫生活</a></li>
<li><a href="http://www.cssmagic.net/">CSS魔法</a></li>
<li><a href="http://yunkus.com/">云库网</a></li>
<li><a href="https://wolfx.cn/">Legend of WolfX</a></li>
<li><a href="https://lienjack.github.io/Blog/">lien的知识库</a></li>
<li><a href="https://www.miaoroom.com/">喵容</a></li>
</ul>
<h5 id="技术团队"><a href="#技术团队" class="headerlink" title="技术团队"></a>技术团队</h5><ul>
<li><a href="http://mysql.taobao.org/monthly/">数据库内核月报</a></li>
<li><a href="https://tech.youzan.com/">有赞技术团队</a></li>
<li><a href="https://tech.meituan.com/">美团技术团队</a></li>
<li><a href="http://140.205.61.252/">阿里中间件团队博客</a></li>
<li><a href="http://blog.netlab.360.com/">360 Netlab Blog</a></li>
</ul>
<h5 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h5><ul>
<li><a href="https://coolshell.cn/">酷壳</a></li>
<li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
<li><a href="http://icyfenix.cn/">凤凰架构</a></li>
<li><a href="http://mindhacks.cn/">刘未鹏 | Mind Hacks</a></li>
<li><a href="http://lovestblog.cn/">你假笨</a></li>
<li><a href="https://greatdk.com/">王登科-DK博客</a></li>
<li><a href="https://www.barretlee.com/">小胡子哥</a></li>
<li><a href="http://jinnianshilongnian.iteye.com/">开涛的博客</a></li>
<li><a href="https://c1rew.github.io/">蝦米逮寄</a></li>
<li><a href="http://www.rendoumi.com/">八戒的blog</a></li>
<li><a href="https://blog.fooleap.org/">Fooleap’s Blog</a></li>
<li><a href="http://www.kailing.pub/index/index.html">KL博客</a></li>
<li><a href="https://blog.csdn.net/lianggzone">梁桂钊的博客</a></li>
<li><a href="https://thinkinjava.cn/">莫那·鲁道の技术博客</a></li>
<li><a href="https://anatasluo.github.io/">Anatas Luo’s Blog</a></li>
<li><a href="https://blog.codingnow.com/">云风的 BLOG</a></li>
<li><a href="https://www.programmercarl.com/">代码随想录</a></li>
<li><a href="https://cyc2018.github.io/page.html">郑永川</a></li>
<li><a href="http://www.daxiblog.com/">大席的博客</a></li>
<li><a href="https://leonax.net/">LEONA+</a></li>
<li><a href="http://www.bootdo.com/">bootdo</a></li>
<li><a href="http://www.itcodai.com/">itcodai</a></li>
<li><a href="https://blog.bywind.cn/">御风大世界</a></li>
<li><a href="https://www.iocoder.cn/">芋道源码</a></li>
<li><a href="https://jaskey.github.io/">薛定谔的风口猪</a></li>
<li><a href="https://u.sb/">烧饼博客</a></li>
<li><a href="http://sighingnow.github.io/archive/">He Tao博客</a></li>
<li><a href="https://www.geekonomics10000.com/">学而时嘻之 | 用理工科思维理解世界</a></li>
<li><a href="http://chriszou.com/">小创作</a></li>
<li><a href="https://houbb.github.io/">Echo Blog</a></li>
<li><a href="http://blog.cuzz.site/">cuzz’s blog</a></li>
<li><a href="https://mypython.me/">Tim’s blog</a></li>
<li><a href="http://www.youmeek.com/">youmeek</a></li>
<li><a href="https://www.cnblogs.com/wang-meng/">一枝花算不算浪漫</a></li>
<li><a href="https://qiankunli.github.io/">李乾坤的博客</a></li>
<li><a href="http://alexstocks.github.io/">于雨氏(AlexStocks) 的小站</a></li>
<li><a href="http://qiuchengjia.cn/">邱承佳的技术博客</a></li>
<li><a href="https://muguang.me/">暮光博客</a></li>
<li><a href="https://www.diguage.com/">“地瓜哥”博客网</a></li>
<li><a href="https://www.bbsmax.com/">bbsmax</a></li>
<li><a href="https://www.awaimai.com/">歪麦博客</a></li>
<li><a href="http://www.pandablog.cn/">熊猫大仙技术博客</a></li>
<li><a href="http://www.lidetao.com/">李德涛博客</a></li>
<li><a href="http://dapengde.com/">大鹏志</a></li>
<li><a href="https://www.jianshu.com/u/oSuHPw">qinyu-简书</a></li>
<li><a href="https://www.zhihu.com/org/thoughtworks-zhong-guo/activities">ThoughtWorks中国-知乎</a></li>
<li><a href="https://blog.csdn.net/luoshengyang">老罗的Android之旅</a></li>
<li><a href="http://www.yinwang.org/">当然我在扯淡</a></li>
<li><a href="https://www.byvoid.com/">beyond the void</a></li>
<li><a href="http://blog.yufeng.info/">系统技术非业余研究</a></li>
<li><a href="http://xushiwei.com/">许式伟的个人空间</a></li>
<li><a href="https://my.oschina.net/javayou">红薯</a></li>
<li><a href="http://hzwer.com/">hzwer</a></li>
<li><a href="https://pugs.blogs.com/">时鹏亮的blog</a></li>
<li><a href="https://www.anji66.net/">西枫里博客</a></li>
<li><a href="https://zhangge.net/">张戈博客</a></li>
<li><a href="https://jszbug.com/">技术宅</a></li>
<li><a href="https://zhiku8.com/">知库吧</a></li>
<li><a href="https://loomob.com/">橘子书</a></li>
<li><a href="https://moe.best/cross.html">神代綺凜</a></li>
<li><a href="https://insights.thoughtworks.cn/">ThoughtWorks洞见</a></li>
<li><a href="https://lightless.me/">不发光的博客</a></li>
<li><a href="https://sendya.me/">远子</a></li>
<li><a href="https://yushuangqi.com/">虞双齐的博客</a></li>
<li><a href="http://www.cnblogs.com/3body/">这个男人来自三体</a></li>
<li><a href="https://www.zhaoj.in/">初心</a></li>
<li><a href="https://www.starduster.me/">星尘独奏曲</a></li>
<li><a href="https://xuanwo.io/">Xuanwo’s Blog</a></li>
<li><a href="https://fqk.io/">Fang</a></li>
<li><a href="http://lovesoo.org/">大爱</a></li>
<li><a href="http://liyangliang.me/">李阳良博客</a></li>
<li><a href="http://www.forestli.com/">forestli</a></li>
<li><a href="https://webzhao.me/">webzhao</a></li>
<li><a href="https://www.h5jun.com/">十年踪迹的博客</a></li>
<li><a href="https://blog.farbox.com/">farbox</a></li>
<li><a href="http://blog.sina.com.cn/cmmi">人月神话的博客</a></li>
<li><a href="https://kevien.github.io/">M0rk’s Bolg</a></li>
<li><a href="http://blog.icoolxue.com/">爱酷</a></li>
<li><a href="https://www.shennongmin.org/">神农民博客</a></li>
<li><a href="http://kuailejim.com/">Developer Center</a></li>
<li><a href="https://me.jinchuang.org/">靳闯博客</a></li>
<li><a href="https://www.iewb.net/">启光博客</a></li>
<li><a href="https://pdf-lib.org/">黄兵的个人博客</a></li>
<li><a href="https://www.ssdax.com/">伤逝的安详</a></li>
<li><a href="http://blog.tsyinpin.com/">乐魂a的博客</a></li>
<li><a href="http://mtoou.info/index.html">关注电脑知识与技术应用_穆童博客</a></li>
<li><a href="https://blog.guorenxi.com/">果仁博客</a></li>
<li><a href="https://www.aneasystone.com/">aneasystone’s blog</a></li>
<li><a href="https://lai.yuweining.cn/about.html">不死鸟</a></li>
<li><a href="http://mouxuejie.com/">某学姐</a></li>
<li><a href="http://yangcongchufang.com/">Diggzhang 掘客张</a></li>
<li><a href="https://www.doncui.com/">学习，工作备忘录-DonCui</a></li>
<li><a href="https://mrdear.cn/">屈定’s Blog</a></li>
<li><a href="https://www.mmuaa.com/">斐斐のBlog</a></li>
<li><a href="https://www.liuchuo.net/">柳婼 の blog</a></li>
<li><a href="https://segmentfault.com/blog/camile">泊浮说</a></li>
<li><a href="http://blog.dragon-yuan.me/">DragonYuan - 袁宝龙</a></li>
<li><a href="http://tomxin.cn/">tomxin</a></li>
<li><a href="http://codingxiaxw.cn/">codingXiaxw’s blog</a></li>
<li><a href="http://zhangtielei.com/">铁蕾的个人博客</a></li>
<li><a href="https://www.diguage.com/">“地瓜哥”博客网</a></li>
<li><a href="https://blog.csdn.net/AirMario">码猿同学</a></li>
<li><a href="http://www.open-open.com/">深度开源</a></li>
<li><a href="http://www.code123.cc/">code123</a></li>
<li><a href="https://www.cnblogs.com/superdo/">宝宝巴士 SD.Team</a></li>
<li><a href="http://axuebin.com/blog/">薛彬的博客</a></li>
<li><a href="http://tedhacker.top/">Ted’s Blog</a></li>
<li><a href="https://www.tianmaying.com/user/david">david</a></li>
<li><a href="https://radishblog.github.io/">Johnson Zhou</a></li>
<li><a href="https://jackchan1999.github.io/">秋过冬漫长</a></li>
<li><a href="https://www.cnblogs.com/vipyoumay/">帅虫哥的博客</a></li>
<li><a href="https://www.cnblogs.com/caowei/">Captain Cool的BLOG</a></li>
<li><a href="https://blog.csdn.net/javazejian">zejian的博客</a></li>
<li><a href="http://blog.lichengwu.cn/">李小武</a></li>
<li><a href="http://www.flyne.org/">flyne</a></li>
<li><a href="https://zhum.in/blog/">SilverLining’s Blog</a></li>
<li><a href="http://www.dongcoder.com/">dongcoder</a></li>
<li><a href="https://www.freebuf.com/">freebuf</a></li>
<li><a href="https://blog.csdn.net/m_buddy">m_buddy的博客</a></li>
<li><a href="https://segmentfault.com/u/dalong_591b8e7e6ab46">达龙</a></li>
<li><a href="https://wenchao.ren/">被遗忘的博客</a></li>
<li><a href="https://cnbin.github.io/">陈斌彬的技术博客</a></li>
<li><a href="https://liuyandong.com/">栋哥的博客</a></li>
<li><a href="http://cmsblogs.com/">Java 技术驿站</a></li>
<li><a href="https://www.infoq.cn/profile/1277812">方腾飞</a></li>
<li><a href="https://vinoit.me/">VZ’s Blog</a></li>
<li><a href="https://waylau.com/">柳伟卫/老卫/Way Lau’s Personal Site</a></li>
<li><a href="https://www.cnblogs.com/wutianqi/">安静的boy</a></li>
<li><a href="https://blog.phpgao.com/">老高的技术博客</a></li>
<li><a href="https://www.liuboping.com/">刘博平的部落格</a></li>
<li><a href="https://blog.whsir.com/">吴昊博客</a></li>
<li><a href="https://www.3ewl.cc/">清风不识字</a></li>
<li><a href="https://notemi.cn/">小米笔记</a></li>
<li><a href="https://gaomf.cn/">高明飞</a></li>
<li><a href="https://laod.cn/">老D博客</a></li>
<li><a href="https://pjax.cn/">Finally</a></li>
<li><a href="https://www.xiaomastack.com/">M&amp;M</a></li>
<li><a href="http://kayle.win/">KayleZhuang</a></li>
<li><a href="http://blog.sinovale.com/">平凡之路</a></li>
<li><a href="http://wuchong.me/">Jark’s Blog</a></li>
<li><a href="https://www.myvoipapp.com/blogs/yxh/">静水潜流</a></li>
<li><a href="http://blog.itbdw.com/">IT不倒翁</a></li>
<li><a href="https://imququ.com/">JerryQu 的小站</a></li>
<li><a href="https://rocko.xyz/">Rocko’s blog</a></li>
<li><a href="http://blog.stormma.me/">一北’s blog</a></li>
<li><a href="http://chengjianhua.github.io/">@jianhua.cheng</a></li>
<li><a href="https://www.colabug.com/">CoLaBug</a></li>
<li><a href="http://www.liyonge.com/">GAVIN LEE-李大头的生活小站</a></li>
<li><a href="http://www.hudongdong.com/">胡东东博客</a></li>
<li><a href="http://blog.sead.co/">FOX-JIMMY ‘S BLOG.</a></li>
<li><a href="https://www.itfanr.cc/">IT范儿</a></li>
<li><a href="http://www.mdslq.cn/">DongSheng’s Blog</a></li>
<li><a href="https://jin-yang.github.io/">jin-yang</a></li>
<li><a href="https://sxxkearth.github.io/">嗜血星空earth</a></li>
<li><a href="http://etrd.org/">ETRD博客</a></li>
<li><a href="https://neveryu.github.io/">Never_yu’s blog</a></li>
<li><a href="https://www.xncoding.com/">飞污熊</a></li>
<li><a href="https://fangjian0423.github.io/">Format’s Notes</a></li>
<li><a href="https://wdxtub.com/">小土刀</a></li>
<li><a href="http://www.laruence.com/">风雪之隅</a></li>
<li><a href="http://www.cppblog.com/vczh">λ-calculus</a></li>
<li><a href="https://www.cnblogs.com/zhuweisky/">zhuweisky</a></li>
<li><a href="http://www.ideawu.net/">idea’s web</a></li>
<li><a href="http://roosephu.github.io/">AFAIK</a></li>
<li><a href="http://cuitianyi.com/">崔添翼 § 翼若垂天之云</a></li>
<li><a href="http://www.shuizilong.com/house/">某岛</a></li>
<li><a href="http://www.matrix67.com/">matrix67</a></li>
<li><a href="http://wangcong.org/">A Geek’s Page</a></li>
<li><a href="http://www.shuangjiuhengyi.com/">桥心博客 / Blog</a></li>
<li><a href="http://www.chengweiyang.cn/">Chengwei’s Words</a></li>
<li><a href="http://www.51niux.com/">柴少鹏的官方网站</a></li>
<li><a href="http://tony.ecy.ren/">柚呦柚</a></li>
<li><a href="https://fatesinger.com/">大发贼志</a></li>
<li><a href="https://sixu.life/">思绪的空中生活</a></li>
<li><a href="https://www.c0smx.com/">c0smx</a></li>
<li><a href="https://cuiqingcai.com/">静觅-崔庆才的个人博客</a></li>
<li><a href="http://www.javacui.com/">java小强</a></li>
<li><a href="http://blog.xdite.net/">blog.xdite.net</a></li>
<li><a href="https://www.chen101.cn/">Seven、love | 柒爱-陈小军个人博客</a></li>
<li><a href="https://blog.hexiangyu.me/">hexiangyu</a></li>
<li><a href="https://minghe.me/">minghe</a></li>
<li><a href="https://boyux.me/">boyux</a></li>
<li><a href="https://www.gblm.net/">乐意分享</a></li>
<li><a href="http://shandian.biz/">闪电站博客</a></li>
<li><a href="http://morfans.cn/">魔帆博客</a></li>
<li><a href="http://www.zimug.com/">字母哥博客</a></li>
</ul>
<h5 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h5><ul>
<li><a href="http://vinnyxiong.cn/">VinnyXiong’s Notes</a></li>
<li><a href="http://blog.cnbang.net/">bang’s blog</a></li>
</ul>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul>
<li><a href="https://program-think.blogspot.com/">编程随想</a></li>
<li><a href="http://www.cnfeat.com/">笨方法学写作</a></li>
<li><a href="https://www.mocakemagic.com/">魔法月饼</a></li>
<li><a href="http://zyan.cc/">张宴的博客</a></li>
<li><a href="http://www.easycolor.cc/">easycolor</a></li>
<li><a href="https://zhangdashuo.github.io/">业余Linux管理员</a></li>
<li><a href="http://www.youxiuboke.com/en/index.html">优秀博客</a></li>
<li><a href="https://justyy.com/">小赖子的英国生活和资讯</a></li>
<li><a href="http://www.shejidaren.com/">设计达人</a></li>
<li><a href="https://www.isharepc.com/">乐软博客</a></li>
<li><a href="https://blog.nchyn.com/">Nchyn’sBlog</a></li>
<li><a href="https://mkblog.cn/">孟坤博客</a></li>
<li><a href="https://www.wlphp.com/">菜鸟博客</a></li>
<li><a href="https://2heng.xin/">樱花庄的白猫</a></li>
<li><a href="http://jwcyber.com/">jwcyber</a></li>
<li><a href="http://www.icefifi.com/">FIFI DESIGN</a></li>
<li><a href="http://www.metsky.com/">天缘博客</a></li>
<li><a href="https://www.cnblogs.com/liuzhaoyzz/">陈晓猫</a></li>
<li><a href="http://www.wjdiankong.cn/">尼古拉斯.赵四</a></li>
<li><a href="https://blog.yasking.org/">东东’s Blog</a></li>
<li><a href="https://mahongfei.com/">马洪飞博客</a></li>
<li><a href="https://www.ccava.cc/">三叔带你看世界</a></li>
<li><a href="https://www.xiaoweigod.com/">小伟博客 </a></li>
<li><a href="https://cokebar.info/">飞羽博客</a></li>
<li><a href="https://urenko.github.io/Accesser/">Accesser</a></li>
<li><a href="http://www.auiou.com/">王志勇的Blog</a></li>
</ul>
<h5 id="非技术"><a href="#非技术" class="headerlink" title="非技术"></a>非技术</h5><ul>
<li><a href="https://chenghouwen.com/">程心诚意</a></li>
<li><a href="https://www.laojilu.com/">老记录</a></li>
<li><a href="http://www.jlpcn.net/">记录片天地</a></li>
<li><a href="http://www.daofire.com/">盗火纪录片</a></li>
<li><a href="https://www.zhangxinghui.com/">慧眼 Wisdom Eyes</a></li>
<li><a href="http://www.maguang.net/">半省堂</a></li>
<li><a href="http://blog.gujun-sky.com/">Junjun’s Home</a></li>
<li><a href="http://www.wangxiaofeng.me/">不许联想</a></li>
<li><a href="http://www.zhuangbiaowei.com/blog/">读书、思考、生活</a></li>
<li><a href="http://tianchunbinghe.blog.163.com/">Chun Tian (binghe) - 冰河</a></li>
<li><a href="https://pugs.blogs.com/">凤</a></li>
<li><a href="http://zhaoxixiong.com/">朝夕熊</a></li>
<li><a href="http://gonghonglou.com/">与佳期的个人博客</a></li>
<li><a href="https://www.gaomingsong.com/">高明松博客</a></li>
<li><a href="https://blog.linuxeye.cn/">Linux运维笔记</a></li>
<li><a href="https://www.johntitorblog.com/">约翰提托博客</a></li>
<li><a href="https://mednoter.com/">吕小荣</a></li>
</ul>
<h4 id="五、信息资源"><a href="#五、信息资源" class="headerlink" title="五、信息资源"></a>五、信息资源</h4><ul>
<li><a href="https://fadeer.github.io/">Fadeer的日志</a></li>
<li><a href="https://hellogithub.com/">hellogithub</a></li>
<li><a href="https://www.52doc.com/">我爱电子书</a></li>
</ul>
<h4 id="六、导航大全"><a href="#六、导航大全" class="headerlink" title="六、导航大全"></a>六、导航大全</h4><ul>
<li><a href="https://github.com/xingshaocheng/architect-awesome">《后端架构师技术图谱》</a></li>
<li><a href="https://yuchengkai.cn/docs/frontend/">前端面试之道</a></li>
<li><a href="http://how2j.cn/">how2j.cn</a></li>
<li><a href="http://www.oudahe.com/">编程小技巧</a></li>
<li><a href="https://github.com/kamranahmedse/developer-roadmap">Developer Roadmap - 网络开发者的路线图</a></li>
<li><a href="https://elf8848.iteye.com/blog/905484">优秀IT技术文章集(最新)(高质量)</a></li>
<li><a href="https://www.itcodemonkey.com/category/OpenSourceTop/">开源最前线(github 每月最 star 项目排行榜)</a></li>
<li><a href="https://juejin.im/post/5b8df353f265da431e7b993d">Github最火开源项目</a></li>
<li><a href="https://docschina.org/">印记中文</a></li>
<li><a href="http://www.ittwz.com/jsjc">天天网站-技术教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22315098">有哪些值得关注的技术博客（Java篇）</a></li>
<li><a href="https://www.sojson.com/">sojson在线工具</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/">MDN Web 文档</a></li>
<li><a href="https://www.qianduanmei.com/">前端美</a></li>
<li><a href="http://www.jetli.com.cn/">优秀个人独立博客导航</a></li>
<li><a href="http://p.codekk.com/">Android 开源项目集合</a></li>
<li><a href="http://www.ldcx.net/jishuzhai123">技术宅必备导航</a></li>
<li><a href="https://aws.amazon.com/cn/">AWS</a></li>
<li><a href="http://ucdchina.com/123/">ucdchina网址导航</a></li>
<li><a href="http://caibaojian.com/links">前端开发博客</a></li>
<li><a href="https://baomidou.oschina.io/mybatis-plus-doc/#/">Mybatis-Plus</a></li>
<li><a href="https://github.com/reedmi/drp">drp系统</a></li>
<li><a href="http://jsonapi.org.cn/">jsonapi</a></li>
<li><a href="https://tool.lu/">在线工具 - 程序员的工具箱</a></li>
<li><a href="http://www.jikedaohang.com/">极客导航</a></li>
<li><a href="http://ac.scmor.com/">谷歌学术镜像_Google学术搜索导航</a></li>
<li><a href="http://www.3wfw.com/">三旺 - 程序员垂直导航</a></li>
<li><a href="http://www.fengfly.com/document/springsecurity3/springsecurity.html">Spring Security</a></li>
<li><a href="http://www.java2s.com/">Programming Tutorials and Source Code Examples</a></li>
<li><a href="http://www.yyyweb.com/">前端里</a></li>
<li><a href="https://legacy.gitbook.com/@waylau">waylau</a></li>
<li><a href="http://www.hollischuang.com/archives/2223">你离BAT之间，只差这一套Java面试题。</a></li>
<li><a href="http://www.46design.com/">46设计导航</a></li>
<li><a href="https://idesign.qq.com/#!index/feed">设计导航</a></li>
<li><a href="http://icondrawer.com/">icondrawer</a></li>
<li><a href="http://dlanham.com/">David Lanham</a></li>
<li><a href="http://louiemantia.com/">louiemantia</a></li>
<li><a href="https://www.24kdh.com/favorites/juhesousuo">24k导航</a></li>
<li><a href="https://jubt.fun/cn/index.html">聚BT</a></li>
</ul>
<h4 id="七、开源项目"><a href="#七、开源项目" class="headerlink" title="七、开源项目"></a>七、开源项目</h4><ul>
<li><a href="https://github.com/CyC2018/CS-Notes">CS-Notes</a></li>
<li><a href="https://github.com/hollischuang/toBeTopJavaer">To Be Top Javaer - Java工程师成神之路</a></li>
<li><a href="https://github.com/crossoverJie/JCSprout">JCSprout</a></li>
<li><a href="https://hansimov.gitbook.io/csapp/">深入理解计算机系统在线版</a></li>
<li><a href="https://github.com/csarron/ITBlogs">技术博客网站推荐</a></li>
<li><a href="https://github.com/edagarli/tuiblogs">优秀的计算机编程类博客和文章</a></li>
<li><a href="https://github.com/iluwatar/java-design-patterns">Design patterns implemented in Java - Java 设计模式</a></li>
<li><a href="https://github.com/akullpp/awesome-java">Awesome Java</a></li>
<li><a href="https://github.com/shengxinjing/programmer-job-blacklist">程序员找工作黑名单</a></li>
<li><a href="https://github.com/stanzhai/be-a-professional-programmer">be-a-professional-programmer</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide">Java学习+面试指南</a></li>
<li><a href="https://github.com/jobbole/awesome-java-cn">Java资源大全中文版</a></li>
<li><a href="https://github.com/wyh-spring-ecosystem-student/spring-boot-student">spring-boot-student</a></li>
<li><a href="https://github.com/v5developer/maven-framework-project">maven-framework-project</a></li>
<li><a href="http://www.chengweiyang.cn/gitbook/index.html">GitBook 简明教程</a></li>
<li><a href="https://leohxj.gitbooks.io/a-programmer-prepares/content/">程序员的自我修养</a></li>
<li><a href="https://github.com/eson15/MyBatis_Study">MyBatis学习</a></li>
<li><a href="https://github.com/handexing/PinkyLam-blog">PinkyLam-blog</a></li>
<li><a href="https://github.com/giantray/stackoverflow-java-top-qa">stackoverflow-Java-top-qa</a></li>
<li><a href="https://github.com/xwjie/PLMCodeTemplate">晓风轻的Spring开发代码模板</a></li>
<li><a href="https://github.com/xwjie/ElementVueSpringbootCodeTemplate">晓风轻SpringBoot+Vue代码模板</a></li>
<li><a href="https://github.com/codingXiaxw/CustomerManagement">JavaWeb项目之客户管理系统</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html">Servlet 工作原理解析</a></li>
<li><a href="https://waylau.gitbooks.io/servlet-3-1-specification/content/">JSR 340: Java Servlet 3.1 Specification《Java Servlet 3.1 规范》</a></li>
<li><a href="https://doc.yonyoucloud.com/doc/wiki/project/servlet/overview.html">Servlet 教程</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/topics/">IBM Developer 技术主题</a></li>
<li><a href="https://alleniverson.gitbooks.io/javaweb/content/">JavaWeb开发笔记</a></li>
<li><a href="https://github.com/forezp/SpringCloudLearning">SpringCloudLearning</a>\</li>
<li><a href="https://github.com/EbookFoundation/free-programming-books">free-programming-books</a></li>
<li><a href="http://tengj.top/2017/05/05/javabook/#%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%AA%E4%BA%BA%E4%BF%AE%E5%85%BB">Java后端2018书单推荐</a></li>
<li><a href="https://gof.quanke.name/">设计模式</a></li>
<li><a href="http://www.javased.com/?action=example-index">Top 500 Java Classes</a></li>
<li><a href="https://lvii.gitbooks.io/outman/content/">科学上网漫游指南</a></li>
<li><a href="https://www.btsynckeys.com/">Public keys</a></li>
<li><a href="https://github.com/qiurunze123/miaosha">互联网Java秒杀系统设计与架构</a></li>
<li><a href="https://github.com/lihengming/spring-boot-api-project-seed">一个基于Spring Boot &amp; MyBatis的种子项目，用于快速构建中小型API、RESTful API项目</a></li>
<li><a href="https://github.com/aisuhua/restful-api-design-references">RESTful API 设计参考文献列表</a></li>
<li><a href="https://coding.net/u/scaffrey/p/hosts/git">scaffrey/hosts</a></li>
<li><a href="https://kkfileview.keking.cn/zh-cn/index.html">kkFileView（在线文档预览）</a></li>
<li><a href="https://searcher.ejlchina.com/">Bean Searcher</a></li>
</ul>
<h4 id="八、博客搭建"><a href="#八、博客搭建" class="headerlink" title="八、博客搭建"></a>八、博客搭建</h4><p>颜色搭配</p>
<ul>
<li><a href="https://www.materialpalette.com/colors">materialpalette</a></li>
</ul>
<p>渐变配色</p>
<ul>
<li><a href="https://shapefactory.co/">shapefactory</a></li>
<li><a href="https://webgradients.com/">webgradients</a><br>   <a href="https://webkul.github.io/coolhue/">coolhue</a></li>
</ul>
<p>	</p>
<p>博客搭建</p>
<ul>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>
<li><a href="https://www.zybuluo.com/MrXiao/note/1088558">Hexo + Next主题博客优化</a></li>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2018/05/09/related-popular-recommended-posts.html">相关 / 热门 / 推荐文章</a></li>
<li><a href="https://zealot.top/Hexo-Github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A22.html">Hexo-Github搭建自己的博客 — 心得汇总2018版（主题配置篇）</a></li>
</ul>
<p>内容折叠</p>
<ul>
<li><a href="https://www.lansheng.net.cn/blog/d2d7d040/">hexo next 首页显示自定义目录及其在文章中的展开折叠</a></li>
<li><a href="https://blog.rmiao.top/hexo-fold-block/">Hexo next博客添加折叠块功能添加折叠代码块</a></li>
<li><a href="https://www.greateman.top/Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%86%85%E5%AE%B9%E6%8A%98%E5%8F%A0.html">Next主题添加内容折叠</a></li>
</ul>
<p>emoji 表情</p>
<ul>
<li><a href="http://www.biueo.com/2018/01/12/Hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0emoji%E8%A1%A8%E6%83%85/">Hexo文章添加emoji表情和自定义表情包</a></li>
<li><a href="http://liuqingwen.me/blog/2017/05/16/share-several-extra-functionality-of-hexo-plugins/">分享几个实用的HEXO博客功能插件</a></li>
<li><a href="https://chaxiaoniu.oschina.io/2017/07/10/HexoAddEmoji/">Hexo中添加emoji表情</a></li>
<li><a href="https://novnan.github.io/Hexo/emojis-for-hexo-next/">让 Hexo NexT 支持 emoji 表情</a></li>
</ul>
<p>优化博客</p>
<ul>
<li><a href="http://www.ehcoo.com/seo.html">【搜索优化】Hexo-next百度和谷歌搜索优化</a></li>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2018/05/30/speed-up-hexo.html">加速 Hexo 博客</a></li>
</ul>
<p>动态背景</p>
<ul>
<li><a href="https://asdfv1929.github.io/2018/07/07/next-add-dynamicbg/">Hexo NexT主题内加入动态背景</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化配置教程</a></li>
</ul>
<p>SVG 学习</p>
<ul>
<li><a href="https://shields.io/">在线生成svg</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/08/svg.html">SVG 图像入门教程</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial">SVG教程</a></li>
<li><a href="http://www.runoob.com/svg/svg-reference.html">SVG 参考手册</a></li>
<li><a href="https://www.w3cplus.com/svg/svg-pocket-guide.html">编写 SVG 的指南</a></li>
</ul>
<p>Markdown</p>
<ul>
<li><a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/">Markdown Preview Enhanced</a></li>
<li><a href="http://www.tablesgenerator.com/">在线表格生成器</a></li>
<li><a href="https://pandao.github.io/editor.md/">开源在线 Markdown 编辑器</a></li>
</ul>
<p>git 教程</p>
<ul>
<li><a href="http://www.worldhello.net/gotgithub/">gotgithub</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git教程</a></li>
</ul>
<p>高手在民间，欢迎补充。</p>
<blockquote>
<p>本博客禁用了<code>next主题</code>自带的评论系统，因为个人觉得太丑了，调试样式很费时间，并且预估评论的人不多。<br>另外，我喜欢自己编写标题的序号，因此禁用了自动标题序号。</p>
</blockquote>
]]></content>
      <categories>
        <category>干货推荐</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程的艺术 | 学习笔记（一）</title>
    <url>/2018/12/18/003/</url>
    <content><![CDATA[<h3 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h3><p>并发编程的目的是为了让程序运行得更快，而不是让程序最大限度的并发运行。</p>
<p>从上述描述中可以得知：<strong>快是终极目标，而并发只是一种达成目的的手段</strong>，因此如果一味的追求极限并发，那么会遇到很多挑战：上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p>
<h4 id="一、上下文切换"><a href="#一、上下文切换" class="headerlink" title="一、上下文切换"></a>一、上下文切换</h4><p><strong>时间片</strong></p>
<p>即使是单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。时间片是 CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</p>
<p><strong>上下文切换</strong></p>
<p>CPU通过<strong>时间片分配算法</strong>来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<blockquote>
<p>时间片分配算法中的<strong>时间片轮转调度算法</strong>是一种最古老，最简单，最公平且使用最广的算法。</p>
<p>基本原理：</p>
<p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列,每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾。然后再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片的处理机执行时间。</p>
</blockquote>
<p>从上述描述中可以得 CPU 给线程频繁分配时间片的过程中，会频繁的记录任务状态再加载任务状态，简称为上下文切换，会存在隐形的性能开销问题。</p>
<h5 id="1-1-测试上下文切换次数和时长"><a href="#1-1-测试上下文切换次数和时长" class="headerlink" title="1.1 测试上下文切换次数和时长"></a>1.1 测试上下文切换次数和时长</h5><p>测试工具：</p>
<ul>
<li>使用<code>Lmbench3</code>可以测量上下文切换的时长。<br>下载地址：<code>http://www.bitmover.com/lmbench/get_lmbench.html</code></li>
<li>使用<code>vmstat</code>可以测量上下文切换的次数。<br>vmstat（Virtual Meomory Statistics，虚拟内存统计）是 Linux 系统中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视。</li>
</ul>
<h5 id="1-2-如何减少上下文切换"><a href="#1-2-如何减少上下文切换" class="headerlink" title="1.2 如何减少上下文切换"></a>1.2 如何减少上下文切换</h5><p>减少上下文切换的方法有：无锁并发编程、CAS 算法、使用最少线程和使用协程。</p>
<p><strong>无锁并发编程</strong></p>
<p>多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</p>
<p><strong>CAS 算法</strong></p>
<p>Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</p>
<p><strong>使用最少线程</strong></p>
<p>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</p>
<p><strong>协程</strong></p>
<p>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>
<h5 id="1-3-减少上下文切换实战"><a href="#1-3-减少上下文切换实战" class="headerlink" title="1.3 减少上下文切换实战"></a>1.3 减少上下文切换实战</h5><p>如果发现有大量线程处于 WAITING 状态，那么可以使用 Java 自带的<code>jstack命令</code>dump 出所有线程状态的统计信息，通过统计信息可以找出相应的 WAITING 线程，并将这个 WAITING 线程池的线程数减少一些，因为 WAITING 的原因正是由于上下文切换占用了 CPU 的大量资源。</p>
<h5 id="二、死锁"><a href="#二、死锁" class="headerlink" title="二、死锁"></a>二、死锁</h5><p>死锁模拟：</p>
<figure class="highlight java"><figcaption><span>死锁模拟</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> {</span><br><span class="line">    privat <span class="keyword">static</span> <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>().deadLock();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deadLock</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    publicvoid <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                            <span class="keyword">synchronized</span> (A) {</span><br><span class="line">                                    <span class="keyword">try</span> { Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                    }</span><br><span class="line">                                    <span class="keyword">synchronized</span> (B) {</span><br><span class="line">                                            System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                                    }</span><br><span class="line">                            }</span><br><span class="line">                    }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    publicvoid <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                            <span class="keyword">synchronized</span> (B) {</span><br><span class="line">                                    <span class="keyword">synchronized</span> (A) {</span><br><span class="line">                                            System.out.println(<span class="string">"2"</span>);</span><br><span class="line">                                    }</span><br><span class="line">                            }</span><br><span class="line">                    }</span><br><span class="line">            });</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>线程 t1 在抓 A 锁的同时还要 B 锁，线程 tA 在抓 B 锁的同时还要 A 锁，当出现两者都抓着其中一把，等着对方把另一把锁释放时，死锁就出现了。</p>
<p>在一些复杂的场景中，可能会遇到上述这样类似的问题，比如 t1 拿到锁之后，因为一些异常情况没有释放锁（死循环）。又或者是 t1 拿到一个数据库锁，释放锁的时候抛出了异常，没释放掉。</p>
<p>一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么只能通过 dump 线程查看到底是哪个线程出现了问题。</p>
<p><strong>避免死锁的几个常见方法</strong></p>
<ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
<h5 id="三、资源限制"><a href="#三、资源限制" class="headerlink" title="三、资源限制"></a>三、资源限制</h5><h5 id="1-1-什么是资源限制"><a href="#1-1-什么是资源限制" class="headerlink" title="1.1 什么是资源限制"></a>1.1 什么是资源限制</h5><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。</p>
<ul>
<li><strong>硬件资源限制</strong>有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。</li>
<li><strong>软件资源限制</strong>有数据库的连接数和 socket 连接数等。</li>
</ul>
<p>使用并发编程并不会改变这些硬件资源物理限制，数据库连接数限制虽然属于软件资源，但是对于调用者来说，也是不可逾越的屏障。</p>
<h5 id="1-2-资源限制带来的问题"><a href="#1-2-资源限制带来的问题" class="headerlink" title="1.2 资源限制带来的问题"></a>1.2 资源限制带来的问题</h5><p>因为受到资源限制问题，导致并发编程的程序得不到充分的施展，因为当某段代码本来可以串行执行，结果改成了并发执行，由于资源限制，它们仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p>
<h5 id="1-3-如何解决资源限制的问题"><a href="#1-3-如何解决资源限制的问题" class="headerlink" title="1.3 如何解决资源限制的问题"></a>1.3 如何解决资源限制的问题</h5><p><strong>对于硬件资源限制</strong>可以考虑使用集群并行执行程序。</p>
<p>既然单机的资源有限制，那么就让程序在多机上运行。比如使用 ODPS、Hadoop 或者自己搭建服务器集群，不同的机器处理不同的数据。</p>
<blockquote>
<p>可以通过”数据 ID% 机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。</p>
</blockquote>
<p><strong>对于软件资源限制</strong>可以考虑使用资源池将资源复用。</p>
<p>比如使用连接池将数据库和 Socket 连接复用，或者在调用对方 webservice 接口获取数据时，只建立一个连接。</p>
<h5 id="1-4-在资源限制情况下进行并发编程"><a href="#1-4-在资源限制情况下进行并发编程" class="headerlink" title="1.4 在资源限制情况下进行并发编程"></a>1.4 在资源限制情况下进行并发编程</h5><p>如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度。</p>
<p>比如下载文件程序依赖于两个资源：带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果 SQL 语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程的艺术 | 学习笔记（二）</title>
    <url>/2018/12/20/004/</url>
    <content><![CDATA[<h3 id="第2章-Java-并发机制的底层实现原理"><a href="#第2章-Java-并发机制的底层实现原理" class="headerlink" title="第2章　Java 并发机制的底层实现原理"></a>第2章　Java 并发机制的底层实现原理</h3><p>Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，JVM 再将字节码翻译转化为汇编指令，使其在 CPU 上执行。</p>
<p>Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 的指令。本章将深入底层一起探索下 Java 并发机制的底层实现原理。</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/specs/index.html">Java 虚拟机规范官方文档</a></p>
</blockquote>
<h4 id="一、volatile-的应用"><a href="#一、volatile-的应用" class="headerlink" title="一、volatile 的应用"></a>一、volatile 的应用</h4><p>在多线程并发编程中 synchronized 和 volatile 都扮演着重要的角色，volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的”可见性”。</p>
<p><strong>可见性就是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</strong></p>
<p>如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。本文将深入分析在硬件层面上 Intel 处理器是如何实现 volatile 的，通过深入分析帮助我们正确地使用 volatile 变量。</p>
<blockquote>
<p>移步阅读笔者之前写过的学习笔记：</p>
<p>细说Java多线程之内存可见性：学习笔记（一）</p>
<p>细说Java多线程之内存可见性：学习笔记（二）</p>
</blockquote>
<h5 id="1-1-volatile-的定义与实现原理"><a href="#1-1-volatile-的定义与实现原理" class="headerlink" title="1.1 volatile 的定义与实现原理"></a>1.1 volatile 的定义与实现原理</h5><h5 id="1-1-1-volatile-定义"><a href="#1-1-1-volatile-定义" class="headerlink" title="1.1.1 volatile 定义"></a>1.1.1 volatile 定义</h5><p>Java 语言规范第 3 版中对 volatile 的定义如下：Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。因此 Java 语言提供了 volatile，在某些情况下比 synchronized 锁要更加方便。如果一个字段被声明成 volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的。</p>
<blockquote>
<p>从上述描述中可知：volatile 可以保证共享变量的可见性，并没有保证原子性。</p>
</blockquote>
<p><strong>CPU 术语说明：</strong></p>
<p>volatile 保证线程的可见性，在 JVM 的底层中一定使用到了 CPU 操作指令，因此有必要先了解一下 CPU 中的一些基础术语：</p>
<ul>
<li><strong>内存屏障（memory barriers）</strong><br>是一组处理器指令，用于实现对内存操作的顺序限制。</li>
<li><strong>缓冲行（cache line）</strong><br>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存的读周期。</li>
<li><strong>原子操作（atomic operations）</strong><br>不可中断的一个或一系列操作。</li>
<li><strong>缓冲行填充（cache line fill）</strong><br>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3 的或所有）。</li>
<li><strong>缓冲命中（cache hit）</strong><br>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取。</li>
<li><strong>写命中（write hit）</strong><br>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被成为写命中。</li>
<li><strong>写缺失（write misses the cache）</strong><br>一个有效的缓存行被写入到不存在的内存区域。</li>
</ul>
<h5 id="1-1-2-volatile-的实现原理"><a href="#1-1-2-volatile-的实现原理" class="headerlink" title="1.1.2 volatile 的实现原理"></a>1.1.2 volatile 的实现原理</h5><p>如果对声明了 volatile 的共享变量进行写操作时，JVM 就会向处理器发送一条 Lock 前缀的指令（JVM 翻译转化成的汇编指令），目的就是将这个变量所在缓存行的数据写回到系统内存。</p>
<p>当某个线程写完自己工作内存的操作数，并通过 JVM 携带的 Lock 前缀指令告知当前写完的操作数要及时更新到系统内存。</p>
<p>仅仅这一步还不够，因为其他线程的工作内存中的操作数还是原来的状态，而不是当前系统内存中最新的操作数。同时处理器本身的机制决定了线程之前不能直接通信：为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</p>
<p><strong>那如何保证其他线程操作数之前能拿到最新的操作数呢？</strong></p>
<p><strong>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址在系统内存中被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<h5 id="1-1-3-volatile-的两条实现原则"><a href="#1-1-3-volatile-的两条实现原则" class="headerlink" title="1.1.3 volatile 的两条实现原则"></a>1.1.3 volatile 的两条实现原则</h5><ul>
<li><p><strong>Lock 前缀指令会引起处理器缓存回写到内存</strong></p>
<p>对于不同的处理器版本，Lock 前缀指令导致在执行指令期间，对声言处理器的<code>LOCK#</code>信号有不同的处理机制：</p>
<p>对于 Intel 486 和 Pentium 处理器，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存，因为它会<strong>锁住总线</strong>，导致其他 CPU 不能访问总线，不能访问总线就意味着不能访问系统内存。</p>
<p>在 P 6 和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言 LOCK# 信号。它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为**”缓存锁定”**，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p>
</li>
<li><p><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong></p>
<p>IA-32 处理器和 Intel 64 处理器使用<code>MESI</code>（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。</p>
<p><strong>处理器的嗅探技术：</strong></p>
<p>在多核处理器系统中进行操作的时候，处理器能嗅探其他处理器访问系统内存和它们的内部缓存，以保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。</p>
<p>例如，在 Pentium 和 P 6 family 处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址（并且这个地址当前处于共享状态），那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。</p>
</li>
</ul>
<h5 id="1-1-4-volatile的使用优化"><a href="#1-1-4-volatile的使用优化" class="headerlink" title="1.1.4 volatile的使用优化"></a>1.1.4 volatile的使用优化</h5><p>在 JDK 7 的并发包里新增一个队列集合类<code>Linked-TransferQueue</code>，它在使用 volatile 变量时，用一种追加字节的方式来优化队列出队和入队的性能。</p>
<p>这个内部类<code>PaddedAtomicReference</code>相对于父类<code>AtomicReference</code>只做了一件事情，就是将共享变量追加到 64 字节。因为目前主流处理器高速缓存行是 64 个字节宽，不支持部分填充缓存行，通过追加到 64 字节的方式填满高速缓冲区的缓存行，避免各元素加载到同一缓存行而互相锁定。</p>
<blockquote>
<p>并不是所有的使用 volatile 变量时都应该追加到 64 字节：</p>
<p>1）对于缓存行非 64 字节宽的处理器。如 P 6 系列和奔腾处理器，它们的 L1 和L2 高速缓存行是32个字节宽。</p>
<p>2）如果共享变量不被频繁写的话，锁的机率很小，就没必要通过追加字节的方式来避免相互锁定。因为追加字节的方式需要处理器读取更多的字节到高速缓冲区，需要更高的性能消耗。</p>
</blockquote>
<p>不过这种追加字节的方式在Java 7下可能不生效，因为Java 7变得更加智慧，它会淘汰或重新排列无用字段，需要使用其他追加字节的方式。</p>
<h4 id="二、synchronized-的应用"><a href="#二、synchronized-的应用" class="headerlink" title="二、synchronized 的应用"></a>二、synchronized 的应用</h4><p>synchronized 常被称为重量级锁，但是随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了，因为有了偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p>
<p>Java 中的每一个对象都可以作为锁。具体表现为以下 3 种形式：</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象（this）。</li>
<li>对于静态同步方法，锁是当前类的 Class 对象。</li>
<li>对于同步方法块，锁是 synchonized 括号里配置的对象。</li>
</ul>
<p><strong>synchonized 在 JVM 里的实现原理</strong></p>
<p>从 JVM 规范中可以看到 Synchonized 在 JVM 里的实现原理：JVM 基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。</p>
<p>代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，而方法同步是使用另外一种方式实现（JVM 规范里并没有详细说明），但可以使用这两个指令来实现。</p>
<p><strong>JVM 里的 Monitor</strong></p>
<p><code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，<code>monitorexit</code>指令是插入到方法结束处和异常处。</p>
<p>JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
<h5 id="2-2-1-Java-对象头"><a href="#2-2-1-Java-对象头" class="headerlink" title="2.2.1 Java 对象头"></a>2.2.1 Java 对象头</h5><p>synchronized 用的锁是存在 Java 对象头里的。Java 对象头针对数组类型对象和非数组类型对象存储的信息不同，前者存 3 个字宽（Word）的信息，后者存 2 个字宽的信息。</p>
<p>在不同的位数操作系统中，字宽对应的字节大小不同：</p>
<ul>
<li>在 32 位虚拟机中，1 字宽等于 4 字节，即 32 bit</li>
<li>在 64 位虚拟机中，1 字宽等于 8 字节，即 64 bit</li>
</ul>
<p>每个字宽中存储着不同的信息标识：</p>
<p><img src="https://image.woodwhales.cn/004/images/1.png" alt="Java 对象头存储内容"></p>
<p>在 Java 对象头里的<code>Mark Word</code>里默认存储对象的 HashCode、分代年龄和<strong>锁标记位</strong>。32 位 JVM 的<code>Mark Word</code>的默认存储结构如下图所示：</p>
<p><img src="https://image.woodwhales.cn/004/images/2.png" alt="32 位 JVM 的 Mark Word 的默认存储结构表"></p>
<p>在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化，以下 4 种数据变化：</p>
<p><img src="https://image.woodwhales.cn/004/images/3.png" alt="Mark Word 里存储的数据会随锁标志位的变化"></p>
<p>用一张图来描述上述的各种表结构之间的关系：</p>
<p><img src="https://image.woodwhales.cn/004/images/4.png" alt="java 对象头 Mark Word 图解"></p>
<p>在 64 位虚拟机下，Mark Word 是 64 bit 大小的，其存储结构如下表：</p>
<p><img src="https://image.woodwhales.cn/004/images/5.png" alt="64 位虚拟机中的 Mark Word 存储结构"></p>
<p>注意：上表中偏向锁的状态的头信息中出现了线程 ID，并且偏向锁的值为 1。</p>
<h4 id="三、锁的升级与对比"><a href="#三、锁的升级与对比" class="headerlink" title="三、锁的升级与对比"></a>三、锁的升级与对比</h4><p>Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了”偏向锁”和”轻量级锁”，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。</p>
<p>这几个状态会随着竞争情况逐渐升级，并且这种升级之后不可降级，因此偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</p>
<h5 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h5><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。偏向锁在 Java 6 和 Java 7 里是默认启用的，但是它在应用程序启动几秒钟之后才激活。</p>
<p><strong>3.1.1 偏向锁的初始化</strong></p>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，存储之前会测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。</p>
<p>如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。</p>
<p><strong>3.1.2 偏向锁的撤销</strong></p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以<strong>当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</strong></p>
<p>偏向锁撤销的前提是需要等待全局安全点，即在这个时间点上没有正在执行的字节码。撤销之后的偏向锁会变成无锁状态，即具体 Mark Word 信息体中不含本线程 ID。</p>
<p>以下为撤销流程文字描述：</p>
<p>偏向锁撤销时首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p>
<p>下图中的线程 1 演示了偏向锁初始化的流程，线程 2 演示了偏向锁撤销的流程。</p>
<p><img src="https://image.woodwhales.cn/004/images/6.png" alt="偏向锁的获得和撤销流程"></p>
<p><strong>3.1.3 偏向锁的关闭</strong></p>
<p>偏向锁在 Java 6 和 Java 7 里会默认在应用程序启动几秒钟之后激活，可以使用 JVM 参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay=0</code>。</p>
<p>如果确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p>
<h5 id="3-2-自旋锁"><a href="#3-2-自旋锁" class="headerlink" title="3.2 自旋锁"></a>3.2 自旋锁</h5><p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p>
<p>线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作。同时可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。</p>
<p>所谓”自旋”，就是让线程去执行一个无意义的循环，循环结束后再去重新竞争锁，如果竞争不到继续循环，循环过程中线程会一直处于 running 状态，但是基于 JVM 的线程调度，会出让时间片，所以其他线程依旧有申请锁和释放锁的机会。</p>
<p>自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是长时间自旋就变成了”忙式等待”，忙式等待显然还不如阻塞锁。如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<p>自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要。</p>
<p>JVM 对于自旋周期的选择，JDK 1.5 中这限度是一定要写死，在 JDK 1.6 引入了<strong>适应性自旋锁</strong>，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化。</p>
<h5 id="3-3-轻量级锁"><a href="#3-3-轻量级锁" class="headerlink" title="3.3 轻量级锁"></a>3.3 轻量级锁</h5><p>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。<strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此轻量级锁是相对于重量级锁而言的。</p>
<p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。</p>
<p><strong>轻量级锁的加锁</strong></p>
<p>线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。</p>
<ul>
<li>如果成功，当前线程获得锁。</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
</ul>
<blockquote>
<p>当轻量级锁使用自旋的方式获取锁仍然失败时，表示存在其他线程竞争锁（两条或两条以上的线程竞争同一个锁），则轻量级锁会膨胀成重量级锁。</p>
</blockquote>
<p><strong>轻量级锁的解锁</strong></p>
<p>轻量级解锁时，会使用原子的 CAS 操作来将 Displaced Mark Word 替换回到对象头：</p>
<ul>
<li>如果成功，则表示同步过程已完成。</li>
<li>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。在释放锁的同时，唤醒被挂起的线程。</li>
</ul>
<p><strong>轻量锁与偏向锁不同的是：</strong></p>
<ul>
<li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>
<li>每次进入退出同步块都需要 CAS 更新对象头</li>
<li>争夺轻量级锁失败时，自旋尝试抢占锁</li>
</ul>
<p><img src="https://image.woodwhales.cn/004/images/7.png" alt="轻量级锁及膨胀流程图"></p>
<p>因为自旋会消耗 CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<h5 id="3-4-重量级锁"><a href="#3-4-重量级锁" class="headerlink" title="3.4 重量级锁"></a>3.4 重量级锁</h5><p>重量锁在 JVM 中又叫对象监视器（Monitor），它很像 C 中的<code>Mutex</code>，除了具备 Mutex(0|1) 互斥的功能，它还负责实现了 Semaphore （信号量）的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait 队列），前者负责做互斥，后一个用于做线程同步。</p>
<h5 id="3-5-锁的优缺点的对比"><a href="#3-5-锁的优缺点的对比" class="headerlink" title="3.5 锁的优缺点的对比"></a>3.5 锁的优缺点的对比</h5><h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><ul>
<li><strong>优点</strong><br>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</li>
<li><strong>缺点</strong><br>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</li>
<li><strong>适用场景</strong><br>适用于只有一个线程访问同步块场景。</li>
</ul>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><ul>
<li><strong>优点</strong><br>竞争的线程不会阻塞，提高了程序的响应速度。</li>
<li><strong>缺点</strong><br>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</li>
<li><strong>适用场景</strong><br>追求响应时间，锁占用时间很短（同步块执行速度非常快）。</li>
</ul>
<h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><ul>
<li><strong>优点</strong><br>线程竞争不使用自旋，不会消耗 CPU 。</li>
<li><strong>缺点</strong><br>线程阻塞，响应时间缓慢。</li>
<li><strong>适用场景</strong><br>追求吞吐量，同步块执行速度较长。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 定时任务全解</title>
    <url>/2018/12/17/005/</url>
    <content><![CDATA[<p>在项目开发过程中，经常需要定时任务来帮助我们来做一些内容，springboot 默认已经帮我们实行了，开发者只需要添加相应的注解就可以实现。 </p>
<h4 id="一、Spring-Task-定时任务"><a href="#一、Spring-Task-定时任务" class="headerlink" title="一、Spring Task 定时任务"></a>一、Spring Task 定时任务</h4><h5 id="1-1-静态定时任务（基于-Scheduled-注解）"><a href="#1-1-静态定时任务（基于-Scheduled-注解）" class="headerlink" title="1.1 静态定时任务（基于 @Scheduled 注解）"></a>1.1 静态定时任务（基于 @Scheduled 注解）</h5><h5 id="1-1-1-pom-配置"><a href="#1-1-1-pom-配置" class="headerlink" title="1.1.1 pom 配置"></a>1.1.1 pom 配置</h5><p>pom 包里面只需要引入<code>springboot starter</code>包即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-1-2-启动类启用定时"><a href="#1-1-2-启动类启用定时" class="headerlink" title="1.1.2 启动类启用定时"></a>1.1.2 启动类启用定时</h5><p>在启动类上面加上<code>@EnableScheduling</code>即可开启定时：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingApplication</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(KingApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：这里的<code>@EnableScheduling</code>注解，它的作用是发现注解<code>@Scheduled</code>的任务并由后台执行。没有它的话将无法执行定时任务。 </p>
<blockquote>
<p>引用官方文档原文：<br><code>@EnableScheduling</code> ensures that a background task executor is created. Without it, nothing gets scheduled.</p>
<p>官方文档地址：<code>http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#scheduling-enable-annotation-support</code></p>
</blockquote>
<h6 id="1-1-3-创建定时任务实现类"><a href="#1-1-3-创建定时任务实现类" class="headerlink" title="1.1.3 创建定时任务实现类"></a>1.1.3 创建定时任务实现类</h6><p>定时任务1：每过 6 秒执行</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scheduler1Task</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron="*/6 * * * * ?")</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"this is scheduler task runing  "</span>+(count++));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定时任务2：每过 6 秒执行</p>
<p><strong>注意：</strong>上一次执行完毕时间点之后 6 秒再执行，不会等待上一个定时任务执行完毕再启动下一个定时任务，不论上次定时任务执行时间是多少。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scheduler2Task</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 6000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportCurrentTime</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在时间："</span> + dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>定时任务3：每过上一个定时任务执行完毕之后的 6 秒执行</p>
<p><strong>注意：</strong>上一次执行完毕时间点之后 6 秒再执行，等待上一次定时任务执行完毕之后再间隔 6 秒执行下一个定时任务。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scheduler3Task</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 6000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportCurrentTime</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"现在时间："</span> + dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h6 id="1-1-4-参数说明"><a href="#1-1-4-参数说明" class="headerlink" title="1.1.4 参数说明"></a>1.1.4 参数说明</h6><p><code>@Scheduled</code> 参数可以接受两种定时的设置每隔 6 秒执行定时任务：</p>
<p>一种是我们常用的<code>cron="*/6 * * * * ?"</code>，另一种是 <code>fixedRate = 6000</code></p>
<p><strong>fixedRate 说明</strong></p>
<ul>
<li><code>fixedRate</code> ：上一次<strong>开始执行</strong>时间点之后再执行，参数类型为 long，单位 ms；</li>
<li><code>fixedRateString</code>：与<code>fixedRate</code>的含义一样，只是将参数类型变为 String；</li>
<li><code>fixedDelay</code> ：上一次<strong>执行完毕</strong>时间点之后再执行，参数类型为 long，单位 ms；</li>
<li><code>fixedDelayString</code>：与<code>fixedDelay</code>含义一样，只是参数类型变为 String；</li>
<li><code>initialDelay</code> ：表示延迟多久再第一次执行任务，参数类型为 long，单位 ms；</li>
<li><code>initialDelayString</code>：与<code>initialDelay</code>的含义一样，只是将参数类型变为 String；</li>
<li><code>zone</code>：时区，默认为当前时区，一般没有用到。</li>
</ul>
<h6 id="1-1-5-Cron-表达式"><a href="#1-1-5-Cron-表达式" class="headerlink" title="1.1.5 Cron 表达式"></a>1.1.5 Cron 表达式</h6><p>Cron 表达式有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。</p>
<p>Cron 表达式是由一串字符串表示，使用<code>数字+空格+特殊字符</code>的形式组合成完整表达式，Cron 表达式由空格将其划分为 6 或 7 个域，每一个域代表一个含义解释：</p>
<p><strong>1.1.5.1 域解释</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* 第一位，表示秒，取值：0-59</span><br><span class="line">* 第二位，表示分，取值：0-59</span><br><span class="line">* 第三位，表示小时，取值：0-23</span><br><span class="line">* 第四位，日期天/日，取值：1-31</span><br><span class="line">* 第五位，日期月份，取值：1-12</span><br><span class="line">* 第六位，星期，取值：1-7</span><br><span class="line">* 第七位，年份，可以留空，取值：1970-2099</span><br></pre></td></tr></tbody></table></figure>

<p>注意：第六位的取值：1-7 表示的是星期一至星期日 </p>
<p><strong>1.1.5.2 特殊符号解释</strong></p>
<p><strong>(*)星号</strong></p>
<p>可以理解为每的意思，每秒，每分，每天，每月，每年；</p>
<p><strong>(?)问号</strong></p>
<p>只能用在每月第几天和星期两个域。表示不指定值，当 2 个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为<code>?</code>；</p>
<p><strong>(-)减号</strong></p>
<p>表达一个范围，如在小时字段中使用 “10-12”，则表示从10到12点，即 10, 11, 12；</p>
<p><strong>(,)逗号</strong></p>
<p>表达一个列表值，如在星期字段中使用 “1, 2, 4”，则表示星期一，星期二，星期四，也可以使用单词缩写来指定，例如：”MON,WED,FRI” 在星期域里表示 “星期一、星期三、星期五；</p>
<p><strong>(/)斜杠</strong></p>
<p>表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用 5/20 ，则意味着5分，25分，45分，分别触发一次，另外：<code>*/y</code>，等同于<code>0/y</code>；</p>
<p><strong>(L)字符</strong></p>
<p>表示最后，只能出现在星期和每月第几天域，如果在星期域使用 1L，意味着在最后的一个星期日触发；</p>
<p><strong>(W)字符</strong></p>
<p>表示有效工作日（周一到周五），只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W 的最近寻找不会跨过月份； LW : 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。</p>
<p><strong>(#)字符</strong></p>
<p>用于确定每个月第几个星期几，只能出现在每月第几天域，例如在1#3，表示某月的第三个星期日。</p>
<p>官方例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">"0 0 * * * *"              表示每小时0分0秒执行一次</span><br><span class="line"></span><br><span class="line">" */10 * * * * *"          表示每10秒执行一次</span><br><span class="line"></span><br><span class="line">"0 0 8-10 * * *"           表示每天8，9，10点执行</span><br><span class="line"></span><br><span class="line">"0 0/30 8-10 * * *"        表示每天8点到10点，每半小时执行</span><br><span class="line"></span><br><span class="line">"0 0 9-17 * * MON-FRI"     表示每周一至周五，9点到17点的0分0秒执行</span><br><span class="line"></span><br><span class="line">"0 0 0 25 12 ?"            表示每年圣诞节（12月25日）0时0分0秒执行</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-2-动态定时任务（基于-SchedulingConfigurer-接口）"><a href="#1-2-动态定时任务（基于-SchedulingConfigurer-接口）" class="headerlink" title="1.2 动态定时任务（基于 SchedulingConfigurer 接口）"></a>1.2 动态定时任务（基于 SchedulingConfigurer 接口）</h5><p>为了演示效果，这里选用 Mysql 数据库保存 Cron 表达式，使用 Mybatis 框架来查询和调整定时任务的执行周期，然后观察定时任务的执行情况。当然，可以使用静态配置文件的形式配置。</p>
<h6 id="1-2-1-pom-配置"><a href="#1-2-1-pom-配置" class="headerlink" title="1.2.1 pom 配置"></a>1.2.1 pom 配置</h6><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加Mybatis依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--添加MySql依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="1-2-2-添加数据库记录"><a href="#1-2-2-添加数据库记录" class="headerlink" title="1.2.2 添加数据库记录"></a>1.2.2 添加数据库记录</h6><p>在 mysql 数据库中创建<code>socks</code>数据库，并创建<code>cron</code>数据库表：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `socks`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `socks`;</span><br><span class="line">USE `SOCKS`;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `cron`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cron`  (</span><br><span class="line">  `cron_id` <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  `cron` <span class="type">varchar</span>(<span class="number">30</span>) </span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `cron` <span class="keyword">VALUES</span> (<span class="string">'1'</span>, <span class="string">'0/5 * * * * ?'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>在项目中的<code>application.yml</code>添加数据源： </p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/socks?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></tbody></table></figure>

<h6 id="1-2-3-创建定时器"><a href="#1-2-3-创建定时器" class="headerlink" title="1.2.3 创建定时器"></a>1.2.3 创建定时器</h6><p>数据库准备好数据之后，编写要定时执行的任务类，实现<code>SchedulingConfigurer</code>接口，重写<code>configureTasks</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompleteScheduleConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span>{</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapper</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CronMapper</span> {</span><br><span class="line">        <span class="meta">@Select("select cron from cron limit 1")</span></span><br><span class="line">        String <span class="title function_">getCron</span><span class="params">()</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CronMapper cronMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行定时任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> {</span><br><span class="line">        taskRegistrar.addTriggerTask(</span><br><span class="line">                <span class="comment">//1.添加任务内容(Runnable)</span></span><br><span class="line">                () -&gt; {</span><br><span class="line">                    System.out.println(<span class="string">"执行定时任务2: "</span> + getNow());</span><br><span class="line">                    logger.debug(<span class="string">"执行定时任务2: "</span> + getNow());</span><br><span class="line">                },</span><br><span class="line">                <span class="comment">//2.设置执行周期(Trigger)</span></span><br><span class="line">                triggerContext -&gt; {</span><br><span class="line">                    <span class="comment">//2.1 从数据库获取执行周期</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">cron</span> <span class="operator">=</span> cronMapper.getCron();</span><br><span class="line">                    <span class="comment">//2.2 合法性校验.</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(cron)) {</span><br><span class="line">                        <span class="comment">// Omitted Code ..</span></span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">//2.3 返回执行周期(Date)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cron).nextExecutionTime(triggerContext);</span><br><span class="line">                }</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getNow</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="三、Timer-定时任务"><a href="#三、Timer-定时任务" class="headerlink" title="三、Timer 定时任务"></a>三、Timer 定时任务</h4><p>这个<code>API</code>目前在项目中很少用，直接给出示例代码。具体的介绍可以查看<code>API</code>。<code>Timer</code>的内部只有<strong>一个线程</strong>，如果<strong>多个任务</strong>的话就会<strong>顺序执行</strong>，这样任务的<strong>延迟时间</strong>和<strong>循环时间</strong>就会出现问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerService</span> {</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">TimerTask</span> <span class="variable">timerTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> counter.incrementAndGet();</span><br><span class="line">                logger.info(<span class="string">"Schedule timerTask {} times"</span>, count);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="comment">// 设置 初始化延迟时间 为 1s，定时执行间隔 为 2s</span></span><br><span class="line">        timer.schedule(timerTask, <span class="number">1000L</span>, <span class="number">2</span> * <span class="number">1000L</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">TimerService</span> <span class="variable">timerService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerService</span>();</span><br><span class="line">        timerService.schedule();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>观察测试结果，能够发现<code>TimerTask</code>配置的任务，每隔<code>10s</code>被执行了一次，执行线程默认都是<code>Timer-0</code>这个线程，并且启动的时机是 new 出 Timer 并执行<code>schedule()</code>方法的时候。 </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">17:42:48.576 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 1 times</span><br><span class="line">17:42:50.569 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 2 times</span><br><span class="line">17:42:52.569 [Timer-0] INFO org.woodwhale.king.service.TimerService - Schedule timerTask 3 times</span><br></pre></td></tr></tbody></table></figure>

<h4 id="四、ScheduledExecutorService-定时任务"><a href="#四、ScheduledExecutorService-定时任务" class="headerlink" title="四、ScheduledExecutorService 定时任务"></a>四、ScheduledExecutorService 定时任务</h4><p><code>ScheduledExecutorService</code> 是 <strong>延时执行</strong> 的线程池，对于 <strong>多线程</strong> 环境下的 <strong>定时任务</strong>，推荐用 <code>ScheduledExecutorService</code> 代替 <code>Timer</code> 定时器。</p>
<p><strong>4.1 等待定时任务执行完毕再进行下一次定时任务</strong></p>
<p>创建一个线程数量为<code>4</code>的<strong>任务线程池</strong>，同一时刻并向它提交<code>4</code>个定时任务，用于测试延时任务的<strong>并发处理</strong>。执行<code>ScheduledExecutorService</code>的<code>scheduleWithFixedDelay()</code>方法，设置任务线程池的<strong>初始任务延迟时间</strong>为<code>2</code>秒，并在上一次<strong>执行完毕时间点</strong>之后<code>2</code>秒再执行下一次任务。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleWithFixedDelay</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        scheduledExecutor.scheduleWithFixedDelay(() -&gt; {</span><br><span class="line">            <span class="comment">// 定时任务延迟完成 2 秒</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2</span> * <span class="number">1000L</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                LOGGER.error(<span class="string">"Interrupted exception"</span>, e);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> counter.incrementAndGet();</span><br><span class="line">            logger.info(<span class="string">"Schedule executor {} times with fixed delay"</span>, count);</span><br><span class="line">        }, <span class="number">2000L</span>, <span class="number">2</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS); </span><br><span class="line">        <span class="comment">// 初始任务延迟时间 为 2 秒，并在上一次 执行完毕时间点 之后 2 秒再执行下一次任务</span></span><br><span class="line">    }</span><br><span class="line">    logger.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试结果如下，我们可以发现每隔<code>2</code>秒的时间间隔，就会有<code>4</code>个定时任务同时执行。因为在任务线程池初始化时，我们同时向线程池提交了<code>4</code>个任务，这<strong>四个任务</strong>会完全利用线程池中的<code>4</code>个线程进行任务执行。 </p>
<p><strong>4.2 固定时间进行定时任务</strong></p>
<p>创建一个线程数量为<code>4</code>的<strong>任务线程池</strong>，同一时刻并向它提交<code>4</code>个定时任务，用于测试延时任务的<strong>并发处理</strong>。每个任务分别执行<code>ScheduledExecutorService</code>的<code>scheduleAtFixedRate()</code>方法，设置任务线程池的<strong>初始任务延迟时间</strong>为<code>2</code>秒，并在上一次<strong>开始执行时间点</strong>之后<code>2</code>秒再执行下一次任务。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleAtFixedRate</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        scheduledExecutor.scheduleAtFixedRate(() -&gt; {</span><br><span class="line">            <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> counter.incrementAndGet();</span><br><span class="line">            logger.info(<span class="string">"Schedule executor {} times at fixed rate"</span>, count);</span><br><span class="line">        }, <span class="number">2000L</span>, <span class="number">2</span> * <span class="number">1000L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 初始任务延迟时间 为 2 秒，并在上一次 执行时间开始 之后 2 秒再执行下一次任务</span></span><br><span class="line">    }</span><br><span class="line">    logger.info(<span class="string">"Start to schedule"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试结果如下，我们可以发现每隔&nbsp;<code>2</code>&nbsp;秒的时间间隔，就会有&nbsp;<code>4</code>&nbsp;个定时任务同时执行，因为在任务线程池初始化时，我们同时向线程池提交了&nbsp;<code>4</code>&nbsp;个任务，这&nbsp;<strong>四个任务</strong>会完全利用线程池中的&nbsp;<code>4</code>个线程进行任务执行。 </p>
<h4 id="五、配置任务线程池（实现多线程并发处理）"><a href="#五、配置任务线程池（实现多线程并发处理）" class="headerlink" title="五、配置任务线程池（实现多线程并发处理）"></a>五、配置任务线程池（实现多线程并发处理）</h4><p>上述配置都是基于<strong>单线程</strong>的任务调度，如何引入<strong>多线程</strong>提高<strong>延时任务</strong>的<strong>并发处理</strong>能力？</p>
<p><code>Spring Boot</code>提供了一个<code>SchedulingConfigurer</code>配置接口。我们通过 <code>ScheduleConfig</code>配置文件实现<code>ScheduleConfiguration</code>接口，并重写 <code>configureTasks()</code>方法，向<code>ScheduledTaskRegistrar</code>注册一个<code>ThreadPoolTaskScheduler</code>任务线程对象即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程执行定时任务</span></span><br><span class="line"><span class="comment"> * 所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConfiguration</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> {</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> {</span><br><span class="line">        taskRegistrar.setTaskScheduler(taskScheduler());</span><br><span class="line">        <span class="comment">// 采用jdk 自带的执行器线程池 java.util.concurrent.Executors</span></span><br><span class="line">        <span class="comment">// taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title function_">taskScheduler</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">taskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">4</span>); <span class="comment">//设定一个长度4的定时任务线程池</span></span><br><span class="line">        taskScheduler.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">"schedule"</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="literal">true</span>);</span><br><span class="line">        taskScheduler.setErrorHandler(t -&gt; logger.error(<span class="string">"Error occurs"</span>, t));</span><br><span class="line">        <span class="keyword">return</span> taskScheduler;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>参考博文：</strong></p>
<p>SpringBoot 创建定时任务（配合数据库动态执行）<br><code>https://www.jianshu.com/p/d160f2536de7</code></p>
<p>springboot(九)：定时任务<br><code>https://www.cnblogs.com/ityouknow/p/6132645.html</code></p>
<p>spring boot项目中处理Schedule定时任务<br><code>https://www.rjkf.cn/springboot-schedule-cron/</code></p>
<p>SpringBoot定时任务及Cron表达式详解<br><code>https://my.oschina.net/jack90john/blog/1506474</code></p>
<p>实战Spring Boot 2.0系列(六) - 单机定时任务的几种实现<br><code>https://juejin.im/post/5b31b9eff265da598826c200</code></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot 瘦身打包</title>
    <url>/2018/12/16/006/</url>
    <content><![CDATA[<p>在实际生产过程中，常常会遇到资源打包文件太大，在部署的时候很不方便，传统的打包方式会将所有的文件（jar 和 资源配置文件）都打包在了一个 jar 文件中，这样后期在修改配置信息的时候，相当的不方便。</p>
<p>因此，如何将项目本身的 jar 文件和依赖 jar 文件分离，并把资源文件也分离出来，分别独立成自己的文件目录是很有必要的。</p>
<h4 id="一、传统打包方式"><a href="#一、传统打包方式" class="headerlink" title="一、传统打包方式"></a>一、传统打包方式</h4><p>传统的打包方式在 pom.xml 中只需要在 build 插件中配置<code>spring-boot-maven-plugin</code>即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>打包出来的 jar 包是下面这样的，项目生成了<code>target</code>文件目录，里面打包好了一个完整的 jar 文件，直接使用：<code>java -jar king-0.0.1-SNAPSHOT.jar</code>就能运行了。 </p>
<p><img src="https://image.woodwhales.cn/006/images/1.png" alt="打成完整 jar 包 "></p>
<p>将 jar 包解压开，会得到下面的目录结构： </p>
<p><img src="https://image.woodwhales.cn/006/images/2.png" alt="打成完整 jar 包内部结构"></p>
<p>注意在<code>META-INF</code>文件目录中存在<code>MANIFEST.MF</code>文件，里面记录了启动类<code>Start-Class</code> 、依赖类<code>Spring-Boot-Lib</code>等信息。</p>
<p>运行 jar 包的时候，首先启动的是启动类，并依赖<code>BOOT-INF/lib/</code>文件目录中的 jar 文件。</p>
<h4 id="二、springboot-打包-lib-和资源文件分离"><a href="#二、springboot-打包-lib-和资源文件分离" class="headerlink" title="二、springboot 打包 lib 和资源文件分离"></a>二、springboot 打包 lib 和资源文件分离</h4><p>现在有如下的打包需求：</p>
<p>项目自身 jar 文件打包在 zip 包根目录下，其他所有依赖包打包在<code>lib</code>文件夹下，资源文件全部打包在<code>resources</code>文件目录下，项目运行的脚本文件打包在<code>bin</code>文件目录下。</p>
<p><img src="https://image.woodwhales.cn/006/images/3.png" alt="项目打包需求"></p>
<p>在<code>pom.xml</code>配置： </p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--打包jar --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不打包资源文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>bin/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>config/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>static/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>templates/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                &lt;archive&gt;</span></span><br><span class="line"><span class="comment">                    &lt;manifest&gt;</span></span><br><span class="line"><span class="comment">                        &lt;addClasspath&gt;true&lt;/addClasspath&gt;</span></span><br><span class="line"><span class="comment">                        // MANIFEST.MF 中 Class-Path 加入前缀，不需要配置，在外部命令行指定                         </span></span><br><span class="line"><span class="comment">                        &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; </span></span><br><span class="line"><span class="comment">                        // jar包不包含唯一版本标识 </span></span><br><span class="line"><span class="comment">                        &lt;useUniqueVersions&gt;false&lt;/useUniqueVersions&gt; </span></span><br><span class="line"><span class="comment">`                       // 指定入口类,如果程序里只有一个main方法就建议不要手动配置 </span></span><br><span class="line"><span class="comment">                        &lt;mainClass&gt;org.woodwhale.king.KingApplication&lt;/mainClass&gt;</span></span><br><span class="line"><span class="comment">                        &lt;/manifest&gt;</span></span><br><span class="line"><span class="comment">                    &lt;manifestEntries&gt; </span></span><br><span class="line"><span class="comment">                    // MANIFEST.MF 中 Class-Path 加入资源文件目录，不需要配置，在外部命令行指</span></span><br><span class="line"><span class="comment">                    &lt;Class-Path&gt;./resources/&lt;/Class-Path&gt; </span></span><br><span class="line"><span class="comment">                    &lt;/manifestEntries&gt;</span></span><br><span class="line"><span class="comment">                &lt;/archive&gt;</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                    生成到 target 目录下，</span></span><br><span class="line"><span class="comment">                    也可以放到指定目录，例如： ${project.build.directory}/boot</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${project.build.directory}<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--拷贝依赖 copy-dependencies --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${project.build.directory}/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteReleases</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteReleases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteSnapshots</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteSnapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteIfNewer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWriteIfNewer</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--拷贝资源文件 copy-resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${project.build.directory}/resources<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            spring boot repackage，</span></span><br><span class="line"><span class="comment">            依赖 maven-jar-plugin 打包的jar包 </span></span><br><span class="line"><span class="comment">            重新打包成 spring boot的jar包</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 包含本地 jar 依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 重写包含依赖，包含不存在的依赖，jar里没有pom里的依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>null<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>null<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 使用外部配置文件，jar包里没有资源文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${project.build.directory}<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">                        配置jar包特殊标识 配置后，保留原文件，</span></span><br><span class="line"><span class="comment">                        生成新文件 *-run.jar 配置jar包特殊标识 不配置， </span></span><br><span class="line"><span class="comment">                        原文件命名为 *.jar.original，生成新文件 *.jar</span></span><br><span class="line"><span class="comment">                        --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>run<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打包发布时，跳过单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用assembly打zip包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- assembly配置文件位置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：在<code>spring-boot-maven-plugin</code>中配置了包含本地jar依赖的配置<code>&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;</code></p>
<p>在项目根目录下存在放置<code>assembly.xml</code>配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>${project.artifactId}<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 压缩包下是否生成和项目名相同的根目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baseDirectory</span>&gt;</span>${project.artifactId}-${project.version}<span class="tag">&lt;/<span class="name">baseDirectory</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>${project.build.directory}<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span><span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>${artifact.artifactId}-${artifact.version}.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${file.separator}resources<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>bin/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${file.separator}bin<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>${file.separator}lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用项目的artifact，第三方 jar 打包进zip文件的 lib 目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>${groupId}:${artifactId}<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.springframework.boot:spring-boot-devtools<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>bin</code>脚本文件目录中放置脚本文件和配置文件：</p>
<p>配置文件用于指定 jar 的名称及版本信息</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ARTIFACTID=king</span><br><span class="line">VERSION=0.0.1</span><br></pre></td></tr></tbody></table></figure>

<p>windows 脚本<code>start.bat</code>文件： </p>
<figure class="highlight bat"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ECHO</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">ECHO</span> "checking config.ini..."</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET</span> ROOT=%~dp0</span><br><span class="line"><span class="built_in">SET</span> CONFIG_FILE=<span class="variable">%ROOT%</span>config.ini</span><br><span class="line"><span class="comment">REM **从配置文件中读取内容**</span></span><br><span class="line"><span class="keyword">FOR</span> /F "tokens=<span class="number">1</span>,<span class="number">2</span> delims==" <span class="variable">%%i</span> <span class="keyword">IN</span> (<span class="variable">%CONFIG_FILE%</span>) <span class="keyword">DO</span> (</span><br><span class="line"> <span class="built_in">SET</span> <span class="variable">%%i</span>=<span class="variable">%%j</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">SET</span> APP_NAME=<span class="variable">%ARTIFACTID%</span>-<span class="variable">%VERSION%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span> "<span class="variable">%APP_NAME%</span>" == "" (</span><br><span class="line">    <span class="built_in">ECHO</span> "this config.ini is <span class="keyword">not</span> <span class="keyword">exist</span>，please check this config file."  </span><br><span class="line">    <span class="keyword">GOTO</span> End</span><br><span class="line">) <span class="keyword">ELSE</span> (</span><br><span class="line">    <span class="built_in">ECHO</span> "checking JAVA_HOME config from checking config.ini..."</span><br><span class="line">    <span class="keyword">GOTO</span> OkPath</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:OkPath</span><br><span class="line"><span class="built_in">echo</span> "check java_home..."</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> "<span class="variable">%JAVA_HOME%</span>" == "" <span class="keyword">GOTO</span> OkJHome</span><br><span class="line"></span><br><span class="line">:OkJHome</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> "<span class="variable">%JAVA_HOME%</span>\bin\java.exe" <span class="keyword">GOTO</span> Runserver</span><br><span class="line"></span><br><span class="line">:Runserver</span><br><span class="line"><span class="built_in">SET</span> JAR_NAME=<span class="variable">%APP_NAME%</span>.jar</span><br><span class="line"><span class="built_in">SET</span> APP_CONFIG=-Dloader.<span class="built_in">path</span>=.,resources,lib</span><br><span class="line"></span><br><span class="line"><span class="built_in">ECHO</span> "<span class="number">111</span>:<span class="variable">%RUN_JAVA%</span>"</span><br><span class="line"><span class="built_in">ECHO</span> "Starting the <span class="variable">%JAR_NAME%</span>"</span><br><span class="line"></span><br><span class="line"><span class="built_in">ECHO</span> "<span class="variable">%JAVA_HOME%</span>\bin\java -Xms512m -Xmx512m -jar <span class="variable">%APP_CONFIG%</span> <span class="variable">%JAR_NAME%</span>"</span><br><span class="line"><span class="built_in">CD</span> ..</span><br><span class="line"><span class="variable">%JAVA_HOME%</span>\bin\java.exe -Xms512m -Xmx512m -jar <span class="variable">%APP_CONFIG%</span> <span class="variable">%JAR_NAME%</span></span><br><span class="line"><span class="keyword">GOTO</span> End</span><br><span class="line"></span><br><span class="line">:End</span><br><span class="line"><span class="built_in">PAUSE</span></span><br></pre></td></tr></tbody></table></figure>

<p>脚本解释：最为关键的就是运行jar 文件的时候携带<code>-Dloader.path=.,resources,lib</code></p>
<p>linux 脚本<code>startup.sh</code>文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># java env</span></span></span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_162</span><br><span class="line">API_NAME=./king-0.0.1.jar</span><br><span class="line"></span><br><span class="line">export JRE_HOME=JAVA_HOME/jre</span><br><span class="line">API_CONFIG=.,resources,lib</span><br><span class="line">JAR_NAME=$API_NAME.jar</span><br><span class="line">PID=$API_NAME.pid</span><br><span class="line"></span><br><span class="line">usage() {</span><br><span class="line">    echo "Usage: sh startup.sh [start|stop|restart|status]"</span><br><span class="line">    exit 1</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">is_exist(){</span><br><span class="line">  pid=`ps -ef|grep $JAR_NAME|grep -v grep|awk '{print $2}' `</span><br><span class="line">  if [ -z "${pid}" ]; then</span><br><span class="line">   return 1</span><br><span class="line">  else</span><br><span class="line">    return 0</span><br><span class="line">  fi</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">start(){</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then </span><br><span class="line">    echo "&gt;&gt;&gt; ${JAR_NAME} is already running PID=${pid} &lt;&lt;&lt;" </span><br><span class="line">  else </span><br><span class="line">    nohup $JRE_HOME/bin/java -Xms256m -Xmx512m -jar -Dloader.path=$API_CONFIG $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    echo $! &gt; $PID</span><br><span class="line">    echo "&gt;&gt;&gt; start $JAR_NAME successed PID=$! &lt;&lt;&lt;" </span><br><span class="line">   fi</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">stop(){</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">is_exist</span></span><br><span class="line">  pidf=$(cat $PID)</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"<span class="variable">$pidf</span>"</span></span>  </span><br><span class="line">  echo "&gt;&gt;&gt; api PID = $pidf begin kill $pidf &lt;&lt;&lt;"</span><br><span class="line">  kill $pidf</span><br><span class="line">  rm -rf $PID</span><br><span class="line">  sleep 2</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then </span><br><span class="line">    echo "&gt;&gt;&gt; api 2 PID = $pid begin kill -9 $pid  &lt;&lt;&lt;"</span><br><span class="line">    kill -9  $pid</span><br><span class="line">    sleep 2</span><br><span class="line">    echo "&gt;&gt;&gt; $JAR_NAME process stopped &lt;&lt;&lt;"  </span><br><span class="line">  else</span><br><span class="line">    echo "&gt;&gt;&gt; ${JAR_NAME} is not running &lt;&lt;&lt;"</span><br><span class="line">  fi  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">status(){</span><br><span class="line">  is_exist</span><br><span class="line">  if [ $? -eq "0" ]; then</span><br><span class="line">    echo "&gt;&gt;&gt; ${JAR_NAME} is running PID is ${pid} &lt;&lt;&lt;"</span><br><span class="line">  else</span><br><span class="line">    echo "&gt;&gt;&gt; ${JAR_NAME} is not running &lt;&lt;&lt;"</span><br><span class="line">  fi</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">restart(){</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">  "start")</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">  "stop")</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">  "status")</span><br><span class="line">    status</span><br><span class="line">    ;;</span><br><span class="line">  "restart")</span><br><span class="line">    restart</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    usage</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></tbody></table></figure>

<p>shell 脚本里需要配置<code>JAVA_HOME</code>路径和 jar 文件名即可。 </p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Maven Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web 如何超清无码</title>
    <url>/2018/11/30/007/</url>
    <content><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><h5 id="1-文件编码格式通用设置"><a href="#1-文件编码格式通用设置" class="headerlink" title="1. 文件编码格式通用设置"></a>1. 文件编码格式通用设置</h5><p>在使用 eclipse 开发工具的时候，首先需要确定工作空间的编码格式：</p>
<p><code>windows</code>菜单 –» <code>perferences</code>选项 –» <code>General</code>选项中的<code>Workspace</code>工作空间选项，设置文件编码格式。</p>
<p><img src="https://image.woodwhales.cn/007/images/1.png" alt="设置工作空间文件编码格式 "></p>
<h5 id="2-文件编码格式单独设置"><a href="#2-文件编码格式单独设置" class="headerlink" title="2. 文件编码格式单独设置"></a>2. 文件编码格式单独设置</h5><p>单个项目编码格式设置：<strong>项目 –» 右键 –» Properties –» Text file encoding</strong></p>
<p>单个页面文件编码格式设置：<strong>页面 –» 右键 –» Properties –» Text file encoding</strong></p>
<h4 id="一、response-响应乱码"><a href="#一、response-响应乱码" class="headerlink" title="一、response 响应乱码"></a>一、response 响应乱码</h4><p>response 响应数据回浏览器之前，程序可以将数据转换成字节流的形式输出内容，也可以使用字符流的形式输出内容，但是字符流形式仅限于文本数据，因此前者在 web 开发中需要更谨慎的关注和理解原理。</p>
<h5 id="1-2-字节流响应"><a href="#1-2-字节流响应" class="headerlink" title="1.2 字节流响应"></a>1.2 字节流响应</h5><p>在 web 工程中创建一个简单的<code>servlet</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span><span class="string">"木鲸鱼"</span>;</span><br><span class="line"></span><br><span class="line">        response.getOutputStream().write(data.getBytes());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，此时的源码文件编码类型为：<code>UTF-8</code>，查看文件编码类型可右击文件属性，在<code>Resource</code>选项中的<code>Text file encoding</code>中可见。</p>
<p>servlet 资源访问路径映射配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;description&gt;&lt;/description&gt;</span><br><span class="line">	&lt;servlet-name&gt;responseDemo1&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;org.king.response.ResponseDemo1&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;responseDemo1&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/responseDemo1&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>使用 IE 浏览器访问 web 工程，此时浏览器显示中文乱码，并且通过查看网页编码可知，默认使用<code>GB2312</code>编码解析响应文本。 </p>
<p><img src="https://image.woodwhales.cn/007/images/2.png" alt="显示中文乱码 "></p>
<p>为什么默认使用<code>GB2312</code>码表呢？因为 windows 系统本地的时区语言是中文，因此浏览器会默认使用<code>GB2312</code>解码响应体。当手动更改编码格式为<code>UTF-8</code>时，浏览器显示汉字内容正常。</p>
<p>那么问题来了，默认用户都是电脑小白，不能等用户看到网页乱码再自己手动修改浏览器解码格式，这似乎不是雅的 web 程序可以出现的问题。</p>
<p><strong>解决方案 1：响应头设置</strong></p>
<p>于是在程序响应回浏览器之前，设置响应头：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span><span class="string">"木鲸鱼"</span>;</span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=UTF-8"</span>); <span class="comment">// 增加响应头设置</span></span><br><span class="line">response.getOutputStream().write(data.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<p>通过响应头的设置，使得浏览器必须以程序设置的编码格式解析 html 文本内容： </p>
<p><img src="https://image.woodwhales.cn/007/images/3.png" alt="通过响应头设置，要求浏览器以特定编码解析响应文本 "></p>
<p><strong>注意：</strong>在上述代码中，存在一个很隐蔽的隐患，因为源码文件就是<code>UTF-8</code>字符集编码的代码，并且工作空间设置的是<code>UTF-8</code>编码，因此在<code>问题 1</code>中设置浏览器为<code>UTF-8</code>编码解析文本的时候才能正常显示，因此对于输出字节流的时候，也就是在上述源码中对<code>data</code>字符串对象进行数组转换的时候指定字符集。 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span><span class="string">"木鲸鱼"</span>;</span><br><span class="line">response.setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=UTF-8"</span>); <span class="comment">// 增加响应头设置</span></span><br><span class="line">response.getOutputStream().write(data.getBytes(“UTF-<span class="number">8</span>”));</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决方案 2：模拟 http 头文件</strong></p>
<p>在 html 文件中，可以使用<code>meta</code>标签中的<code>http-equiv</code>属性指定：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">httpHeader</span> <span class="operator">=</span> <span class="string">"&lt;html&gt;&lt;meta http-equiv='Content-Type' content='charset=UTF-8'&gt;&lt;body&gt;"</span>;</span><br><span class="line">        response.getOutputStream().write(httpHeader.getBytes());</span><br><span class="line">        response.getOutputStream().write((data).getBytes());</span><br><span class="line">        response.getOutputStream().write(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>.getBytes());</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/007/images/4.png" alt="模拟 http 头文件 "></p>
<p>查看源码可知，html 解析了<code>meta</code>标签及其属性。另外需要注意：在 W3C 文档中说明了使用 http-equiv 已经不是规定 HTML 文档的字符集的唯一方式： </p>
<blockquote>
<p>HTML 4.01 与 HTML5之间的差异：<br>HTML 4.01：<code>&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt;</code><br>HTML5：<code>&lt;meta charset="UTF-8"&gt;</code><br>参考地址：<a href="http://www.w3school.com.cn/tags/tag_meta.asp">http://www.w3school.com.cn/tags/tag_meta.asp</a></p>
</blockquote>
<h5 id="1-2-字符流响应"><a href="#1-2-字符流响应" class="headerlink" title="1.2 字符流响应"></a>1.2 字符流响应</h5><p>由于大多数数据都是以字符文本的形式响应回浏览器，那么可以将数据转成字符流传输。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span><span class="string">"木鲸鱼"</span>;</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.write(data);</span><br></pre></td></tr></tbody></table></figure>

<p>注意，即使是使用字符流传输，在网络传输过程中，均将字符数据按照一定的码表解析成机器码进行数字传输，到了目的地再通过指定的码表进行翻译解析。因此，上面简单的使用字符流数据响应回浏览器的时候一定是按照某种编码格式进行解析成二进制信息并传输的，因为项目使用的是 Tomcat 服务器，所以默认的编码格式为<code>ISO8859-1</code>，在 Tomcat 官方文档中的过滤器一章有这样一句说明，意思就是说，如果不指定字符集就使用 ISO8859-1传输数据： </p>
<blockquote>
<p>The HTTP specification is clear that if no character set is specified for media sub-types of the “text” media type, the ISO-8859-1 character set must be used.<br>参考地址：<a href="%60http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html%60">http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html</a></p>
</blockquote>
<p><strong>解决方案：设置 response 字符集编码及响应头</strong></p>
<p>设置 response 响应对象以特定字符集编码格式读取数据，并设置响应头，要求浏览器以特定格式解析，即可保证数据不会乱码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span><span class="string">"木鲸鱼"</span>;</span><br><span class="line"><span class="comment">// 要求 response 以 UTF-8 字符集输出</span></span><br><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 通知浏览器以 UTF-8 字符集解析数据</span></span><br><span class="line"><span class="comment">// response.setHeader("Content-Type", "text/html;charset=UTF-8"); // 等效下面的代码</span></span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.write(data);</span><br></pre></td></tr></tbody></table></figure>

<p>注意：Java 设计者在设计<code>HttpServletResponse</code>对象的时候提供了<code>setContentType()</code>方法，它的作用就是通知浏览器以指定字符集解析文本数据，并要求 response 对象以指定字符集读取数据。</p>
<p><strong>扩展：</strong></p>
<p>响应头的信息中不允许包含中文编码，只能是 ASCII 码字符，那么对于图片文件需要传输文件名，就必须使用<code>URLEncoding</code>类对字符串进行转码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(data,<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二、request-请求乱码"><a href="#二、request-请求乱码" class="headerlink" title="二、request 请求乱码"></a>二、request 请求乱码</h4><p>目前，request 请求的主流请求类型为<code>GET</code>和<code>POST</code>，其中<code>GET</code>请求的方式，可以是在表单中提交，也可以在浏览器地址栏中显示请求。</p>
<h5 id="2-1-表单中的-POST-请求"><a href="#2-1-表单中的-POST-请求" class="headerlink" title="2.1 表单中的 POST 请求"></a>2.1 表单中的 POST 请求</h5><p>post 请求数据在发送时一定经过某种字符集编码成二进制信息，再经过网络传输到服务器，post 请求在 html 页面和 jsp 页面中会有不同的表现。</p>
<p><strong>[1] post 请求在html页面表现：</strong></p>
<p>在 html 页面中，如果有<code>meta</code>信息指定字符集编码，则使用此编码传输数据，没有则使用操作系统默认编码，中文操作系统一般使用<code>GB2312</code>字符集编码。</p>
<p>下面 html 页面指定了<code>meta</code>信息：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=GBK"</span>&gt;</span> </span><br><span class="line">// 或者</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"GBK"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时数据传输到服务器是经过<code>UTF-8</code>编码解析，后台获取请求数据 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">"username"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">"password"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>此时一定是会出现中文乱码问题，因为在<code>request.getParameter()</code>的瞬间，Tomcat 会将网络数据中的二进制查询<code>ISO8859-1</code>字符集试图解码成可见字符并返回。 </p>
<p>「 解决方案 」</p>
<p>在<code>request.getParameter()</code>调用之前，要求 request 对象获取请求参数的时候指定字符集：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>也就是 request 对象获取请求参数时，不要依赖服务器的 API 实现，而是使用程序员自己的字符集编码。</p>
<p>完美解决方案代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">request.setCharacterEncoding("UTF-8");</span><br><span class="line">String username = request.getParameter("username");</span><br><span class="line">String password = request.getParameter("password");</span><br></pre></td></tr></tbody></table></figure>

<p><strong>[2] post 请求在 jsp 页面表现：</strong></p>
<p>在 jsp 页面中，可以在<code>@page</code>中指定<code>"contentType"</code>，也可以在 html 文本中指定<code>meta</code>信息，当有<code>@page</code>指定<code>charset</code>时，此配置信息优与<code>meta</code>配置，就是说下面 jsp 页面在浏览器中显示的默认编码格式为<code>GBK</code>：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page language="java" contentType="text/html; charset=GBK" pageEncoding="UTF-8"%&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/king-world/index"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提 交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>对于服务器获取参数的解决方案和在上一小结点是一致的。 </p>
<h5 id="2-2-表单中及地址栏中的-GET-请求"><a href="#2-2-表单中及地址栏中的-GET-请求" class="headerlink" title="2.2 表单中及地址栏中的 GET 请求"></a>2.2 表单中及地址栏中的 GET 请求</h5><p>页面及地址栏中的<code>GET</code>请求，在数据传输时使用的编码，不依赖于页面的<code>meta</code>或者<code>contentType</code>信息，GET 请求的本质是使用统一资源标志符，当表单中的<code>GET</code>请求发生之后，其请求地址会打印到地址栏中。</p>
<p>注意：在 IE 浏览器中不可以使用中文作为参数直接发请求，而 chrome 浏览器会将中文进行<code>URL</code>编码再发请求，至于其他浏览器是否自动转码，笔者没测试了。</p>
<p><code>GET</code>请求由 Tomcat 服务容器接收，会将这个<code>URL</code>中的参数对进行<code>ISO8859-1</code>编码，官方文档作出了下面的解释：</p>
<blockquote>
<p>在 Tomcat 系统参数配置中提到了关于<code>URIEncoding</code>的解释：<br>This specifies the character encoding used to decode the URI bytes, after %xx decoding the URL. If not specified, ISO-8859-1 will be used.<br>参考地址：<a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html">https://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a></p>
</blockquote>
<p><strong>解决方案 1</strong></p>
<p>从上述描述中可知，在 Tomcat 服务器的<code>conf</code>配置文件目录下的<code>server.xml</code>中配置了连接器信息：</p>
<figure class="highlight xml"><figcaption><span>文件路径：%tomcat root%\conf\server.xml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>Connector</code>连接器中增加<code>URIEncoding="UTF-8"</code>属性配置。 </p>
<p><strong>解决方案 2</strong></p>
<p>在 Tomcat 的<code>server.xml</code>下的<code>connector</code>属性中添加参数<code>useBodyEncodingForURI="true"</code>（注意，并不是对整个 URI 都采用 BodyEncoding，只是应用于 Query String 而已）。这样，Tomcat 便会用<code>request.setCharacterEncoding()</code>指定的编码来解析 GET 参数了。</p>
<p><strong>解决方案 3</strong></p>
<p>在 servlet 中手动转码，在 Tomcat 服务器中，将<code>ISO8859-1</code>转码成<code>UTF-8</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">"username"</span>);    </span><br><span class="line"><span class="keyword">if</span>(username != <span class="literal">null</span> &amp;&amp; !username.trim().isEmpty()) {</span><br><span class="line">    username = <span class="keyword">new</span> <span class="title class_">String</span>(username.getBytes(<span class="string">"ISO8859-1"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>解决方案 4</strong></p>
<p>实现过滤器，对所有的请求进行拦截过滤，并在<code>web.xml</code>中配置<code>filter</code>和<code>filter-mapping</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp,</span></span><br><span class="line"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果希望匿名内部类使用一个在外部定义的对象，那么编译器会要求其参数引用是final的</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) resp;</span><br><span class="line"></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">// POST提交有效</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决：对HttpServletRequest接口的getParameter方法进行功能扩展，识别GET请求，可以使用动态代理!</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">proxyRequest</span> <span class="operator">=</span> (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] { HttpServletRequest.class },</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// args对象数组，代表被调用方法的参数</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method,</span></span><br><span class="line"><span class="params">                            Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">                        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"getParameter"</span>.equals(methodName)) {</span><br><span class="line">                            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> request.getParameter(args[<span class="number">0</span>]</span><br><span class="line">                                    .toString());</span><br><span class="line">                            <span class="type">String</span> <span class="variable">requestMethodName</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">"GET"</span>.equals(requestMethodName)) {</span><br><span class="line">                                <span class="comment">// 排除空对象及空字符串</span></span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; !<span class="string">""</span>.equals(value.trim())) {</span><br><span class="line">                                    value = <span class="keyword">new</span> <span class="title class_">String</span>(value</span><br><span class="line">                                            .getBytes(<span class="string">"iso-8859-1"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line">                                }                               </span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">return</span> value;</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">return</span> method.invoke(request, args);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                });</span><br><span class="line">        <span class="comment">//放行 (执行下一个过滤器或者servlet)</span></span><br><span class="line">        chain.doFilter(proxyRequest, response); </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>推荐使用方案 4。 </p>
<h4 id="三、jsp-页面的编码原理"><a href="#三、jsp-页面的编码原理" class="headerlink" title="三、jsp 页面的编码原理"></a>三、jsp 页面的编码原理</h4><h5 id="3-1-jsp-页面的编码三阶段"><a href="#3-1-jsp-页面的编码三阶段" class="headerlink" title="3.1 jsp 页面的编码三阶段"></a>3.1 jsp 页面的编码三阶段</h5><p><code>JSP</code>要经过两次的”编码”，第一阶段会用<code>pageEncoding</code>，第二阶段会用<code>UTF-8</code>至<code>UTF-8</code>，第三阶段就是由 Tomcat 出来的网页， 用的是<code>contentType</code>。</p>
<p>第一阶段：JVM 将<code>.jsp</code>文件编译为<code>.java</code>文件。JVM 先读取<code>pageEncoding</code>的值，根据该值去读取<code>.jsp</code>文件，然后由指定的编码方案生成<code>UTF-8</code>的<code>.java</code>文件。</p>
<blockquote>
<p>证明：在 Tomcat 服务器目录下<code>work</code>文件夹下的<code>Catalina</code>目录中找到<code>.java</code>文件（由<code>jsp</code>源码文件生成），其文件的编码是<code>UTF-8</code>格式，文件中的文本内容是根据<code>pageEncoding</code>的字符集进行记录。 </p>
</blockquote>
<p>第二阶段：JVM 将<code>java</code>文件转换为<code>class</code>文件，从<code>UTF-8</code>至<code>UTF-8</code>。这个过程就与任何编码的设置都没有关系了，经过这个阶段后<code>.java</code>文件就转换成了统一的<code>UTF-8</code>编码的<code>class</code>文件了。</p>
<p>第三阶段：服务器将处理的结果返回给浏览器，这个阶段则依靠<code>contentType</code>的<code>charset</code>，如果设置了<code>charset</code>则浏览器就会使用指定的编码格式进行解码，否则采用默认的<code>ISO-8859-1</code>编码格式进行解码处理。</p>
<blockquote>
<p>证明：在<code>jsp</code>对应的<code>.java</code>文件源码中可以看到 response 响应已经指定了<code>Content-Type</code>：<br>response.setContentType(“text/html; charset=UTF-8”);</p>
</blockquote>
<h5 id="3-2-jsp-页面中设置字符集"><a href="#3-2-jsp-页面中设置字符集" class="headerlink" title="3.2 jsp 页面中设置字符集"></a>3.2 jsp 页面中设置字符集</h5><p><strong>1. pageEncoding</strong></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page pageEncoding="UTF-8"%&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>上文中第一阶段，使用该值去读取<code>jsp</code>文件，为避免中文乱码，跟<code>jsp</code>文件编码一致；对服务器响应进行重新编码，即<code>jsp</code>的输出流在浏览器中显示的编码（不是主要作用）。 </p>
<p><strong>2. contentType</strong> </p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page contentType="text/html;charset=UTF-8"%&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>使用该值对服务器响应进行重新编码，即<code>jsp</code>的输出流在浏览器中显示的编码；对表单<code>get</code>和<code>post</code>请求数据编码；上文中第一阶段，使用该值去读取<code>jsp</code>文件（不是主要作用）。 </p>
<p><strong>3. META</strong> </p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>网页的编码信息 ，说明页面制作所使用的编码。</p>
<p>因此编写<code>jsp</code>页面的<strong>最佳实践</strong>是统一配置成<code>UTF-8</code>编码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=”text/html;charset=UTF-8” pageEncoding="UTF-8"%&gt;</span><br><span class="line">…</span><br><span class="line">&lt; META http-equiv=”Content-Type” content=”text/html;charset=UTF-8”&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 学习笔记 | 安装与启动</title>
    <url>/2019/01/01/008/</url>
    <content><![CDATA[<h4 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h4><p>官网地址：<a href="https://redis.io/">https://redis.io/</a></p>
<p>目前最新稳定版本是：<code>redis-5.0.3</code></p>
<p>下载链接：<a href="http://download.redis.io/releases/redis-5.0.3.tar.gz">http://download.redis.io/releases/redis-5.0.3.tar.gz</a></p>
<p>官方快速入门文档：<a href="https://redis.io/topics/quickstart">https://redis.io/topics/quickstart</a></p>
<blockquote>
<p>如果不想安装 redis，官网提供了个网页版体验模拟器：<a href="https://redis.io/commands">Web Redis</a> </p>
</blockquote>
<h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><p><strong>步骤 1：</strong> 本文安装环境为：<code>CentOS Linux release 7.4.1708 (Core)</code></p>
<figure class="highlight shell"><figcaption><span>查看 linux 系统版本</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br><span class="line">或者</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤 2：</strong> 将 gz 安装包在<code>/usr/</code>目录下进行解压：</p>
<figure class="highlight shell"><figcaption><span>解压 redis 安装包</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">tar xvzf redis-stable.tar.gz</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤 3：</strong> 编译</p>
<p>进入 redis 安装文件夹，执行<code>make</code>命令进行编译：</p>
<figure class="highlight shell"><figcaption><span>编译 redis</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></tbody></table></figure>

<p>编译完成之后，出现下面的信息提示，就表示安装成功：</p>
<figure class="highlight shell"><figcaption><span>编译完成之后的日志提示</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">    CC redis-benchmark.o</span><br><span class="line">    LINK redis-benchmark</span><br><span class="line">    INSTALL redis-check-rdb</span><br><span class="line">    INSTALL redis-check-aof</span><br><span class="line"></span><br><span class="line">Hint: It's a good idea to run 'make test' ;)</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory `/usr/redis-5.0.3/src'</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4：</strong> 编译完成之后，会在当前目录下生成了一个<code>src</code>文件，进入此目录进行安装操作：</p>
<figure class="highlight shell"><figcaption><span>安装redis</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">cd src/</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>

<p>提示下面信息，表示安装成功：</p>
<figure class="highlight shell"><figcaption><span>安装完成后的日志提示</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">    CC Makefile.dep</span><br><span class="line"></span><br><span class="line">Hint: It's a good idea to run 'make test' ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br></pre></td></tr></tbody></table></figure>

<p>并且可以在<code>src</code>目录下看到：<code>redis-server</code>和<code>redis-cli</code>等可执行文件。 </p>
<p>另外，在<code>/usr/local/bin/</code>文件目录下已经存在了下面这些可执行文件：</p>
<figure class="highlight shell"><figcaption><span>redis 安装之后的 src 文件目录结构</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis-benchmark  # Redis服务器端启动程序</span><br><span class="line">redis-check-aof  # Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作</span><br><span class="line">redis-check-rdb  # Redis性能测试工具</span><br><span class="line">redis-cli        # 数据修复工具</span><br><span class="line">redis-server     # 检查导出工具</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：</p>
<p>1、make 安装过程如果报找不到 cc 命令错：<br><code>/bin/sh: cc: command not found</code><br>上面的错误提示表示系统没有 gcc 编译器，需要安装 gcc 编译器：&nbsp;<code>yum install gcc</code></p>
<p>2、安装 gcc 编译工具之后，继续出现下面错误：<br><code>zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</code><br>则需要将&nbsp;<code>make</code>&nbsp;命令改为&nbsp;<code>make MALLOC=libc</code> 再执行<br>或者使用 <code>make distclean</code> 进行清理再执行&nbsp;<code>make</code>&nbsp;命令</p>
</blockquote>
<h4 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h4><p>在<code>src</code>目录下必须先启动服务：</p>
<figure class="highlight shell"><figcaption><span>启动 redis</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></tbody></table></figure>

<p>系统提示了 redis 启动画面，即可表示启动成功：</p>
<figure class="highlight shell"><figcaption><span>redis 启动日志</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">[root@bogon src]# ./redis-server</span><br><span class="line">5688:C 27 Dec 2018 02:00:10.120 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">5688:C 27 Dec 2018 02:00:10.120 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=5688, just started</span><br><span class="line">5688:C 27 Dec 2018 02:00:10.120 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf</span><br><span class="line">5688:M 27 Dec 2018 02:00:10.121 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ ''-._</span><br><span class="line">      _.-``    `.  `_.  ''-._           Redis 5.0.3 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ ''-._</span><br><span class="line"> (    '      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-'    |     PID: 5688</span><br><span class="line">  `-._    `-._  `-./  _.-'    _.-'</span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|</span><br><span class="line"> |    `-._`-._        _.-'_.-'    |           http://redis.io</span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'</span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|</span><br><span class="line"> |    `-._`-._        _.-'_.-'    |</span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'</span><br><span class="line">      `-._    `-.__.-'    _.-'</span><br><span class="line">          `-._        _.-'</span><br><span class="line">              `-.__.-'</span><br><span class="line"></span><br><span class="line">5688:M 27 Dec 2018 02:00:10.122 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">5688:M 27 Dec 2018 02:00:10.122 # Server initialized</span><br><span class="line">5688:M 27 Dec 2018 02:00:10.122 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><br><span class="line">5688:M 27 Dec 2018 02:00:10.122 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">5688:M 27 Dec 2018 02:00:10.122 * Ready to accept connections</span><br></pre></td></tr></tbody></table></figure>

<p>注意：redis 服务默认端口是：<code>6379</code>，此时进程一直停留在了 redis 服务界面，如果要停止就得<code>ctrl + C</code>强行终止程序。</p>
<blockquote>
<p>验证启动是否成功：<br>1、查看是否有redis服务 ： <code>ps -ef | grep redis</code><br>2、查看端口：<code>netstat -tunpl | grep 6379</code></p>
</blockquote>
<h4 id="四、设置后台运行"><a href="#四、设置后台运行" class="headerlink" title="四、设置后台运行"></a>四、设置后台运行</h4><p>回到 redis 安装目录，在此目录下，会存在一个<code>redis.conf</code>配置文件，修改配置信息设置 redis 服务为后台启动，将<code>daemonize</code>的属性由<code>no</code>改为<code>yes</code>：</p>
<figure class="highlight plaintext"><figcaption><span>redis 后台启动配置设置</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"># By default Redis does not run as a daemon. Use 'yes' if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：每次修改完<code>redis.conf</code>文件需要重启 redis 并读取最新的配置文件。</p>
</blockquote>
<h4 id="五、设置快捷启动"><a href="#五、设置快捷启动" class="headerlink" title="五、设置快捷启动"></a>五、设置快捷启动</h4><p>将 redis 安装文件目录中的<code>redis.conf</code>文件复制一份到<code>/etc/</code>目录：</p>
<figure class="highlight shell"><figcaption><span>复制一份原生配置到系统配置目录</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">cp ./redis.conf /etc/</span><br></pre></td></tr></tbody></table></figure>

<p>进入<code>/usr/local/bin</code>目录，启动 redis 服务：</p>
<figure class="highlight shell"><figcaption><span>启动 redis</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">./redis-server /etc/redis.conf</span><br></pre></td></tr></tbody></table></figure>

<p>如果启动成功，则提示下面信息：</p>
<figure class="highlight shell"><figcaption><span>redis 启动成功的系统日志</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">[root@bogon src]# cd /usr/local/bin/</span><br><span class="line">[root@bogon bin]# redis-server /etc/redis.conf</span><br><span class="line">5780:C 27 Dec 2018 02:28:34.575 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">5780:C 27 Dec 2018 02:28:34.576 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=5780, just started</span><br><span class="line">5780:C 27 Dec 2018 02:28:34.576 # Configuration loaded</span><br></pre></td></tr></tbody></table></figure>

<h4 id="六、查看-redis-服务启动情况"><a href="#六、查看-redis-服务启动情况" class="headerlink" title="六、查看 redis 服务启动情况"></a>六、查看 redis 服务启动情况</h4><figure class="highlight shell"><figcaption><span>检查 redis 是否启动</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></tbody></table></figure>

<p>看到下面信息也表示 redis 服务启动成功：</p>
<figure class="highlight shell"><figcaption><span>redis 进程日志</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">[root@bogon bin]# ps -ef | grep redis</span><br><span class="line">root       5781      1  0 02:28 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root       5786   1229  0 02:29 pts/0    00:00:00 grep --color=auto redis</span><br></pre></td></tr></tbody></table></figure>

<h4 id="七、开启防火墙端口"><a href="#七、开启防火墙端口" class="headerlink" title="七、开启防火墙端口"></a>七、开启防火墙端口</h4><figure class="highlight shell"><figcaption><span>开启端口</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久开启 6379 端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启端口</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>

<h4 id="八、使用-redis-cli-连接-redis-服务"><a href="#八、使用-redis-cli-连接-redis-服务" class="headerlink" title="八、使用 redis-cli 连接 redis 服务"></a>八、使用 redis-cli 连接 redis 服务</h4><p>在<code>/usr/local/bin</code>目录下，存在 redis 的客户端可执行文件：<code>redis-cli</code></p>
<blockquote>
<p>redis-cli 执行命令：<code>redis-cli -h 主机IP -p 端口号 -a 密码</code><br>例： redis-cli -h 127.0.0.1 -p 6379 -a root123</p>
</blockquote>
<p>使用<code>redis-cli</code>连接 redis 服务，进行 ping-pong 测试及插入 key-value 进行进测试：</p>
<figure class="highlight shell"><figcaption><span>客户端连接 redis</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">[root@bogon bin]# redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; set mykey abc</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get mykey</span><br><span class="line">"abc"</span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：<br><code>redis-cli</code>连接 redis 服务成功之后，会进入服务 IP + 端口的命令控制台，<br>停止 redis 服务命令：<code>shutdown</code><br>退出当前<code>redis-cli</code>与 redis 服务连接命令：<code>quit</code> </p>
</blockquote>
<h4 id="九、设置-redis-服务开机自启动"><a href="#九、设置-redis-服务开机自启动" class="headerlink" title="九、设置 redis 服务开机自启动"></a>九、设置 redis 服务开机自启动</h4><p>让 redis 服务开机运行，可以将其添加到<code>rc.local</code>文件，或者将其添加为系统的 service 服务。</p>
<p><strong>1. 配置 rc.local 文件</strong></p>
<p>本文使用<code>rc.local</code>的方式，命令： </p>
<figure class="highlight shell"><figcaption><span>配置 redis 启动命令到系统启动文件内</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">echo "/usr/local/bin/redis-server /etc/redis.conf" &gt;&gt; /etc/rc.local</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2. 配置到 service 服务</strong></p>
<blockquote>
<p>配置到系统服务的基本原理：<br>系统开机启动时会去加载<code>/etc/init.d/</code>文件目录下面的所有脚本文件，通常每个脚本文件会自定义实现程序的启动；若想将新的程序开机自启动，只需在该目录下添加一个自定义启动程序的脚本，然后设置相应启动规则即可。 </p>
</blockquote>
<p>如在这里我们在<code>/etc/init.d/</code>文件目录下（和<code>/etc/rc.d/init.d/</code>目录相同）创建一个<code>redis</code>脚本，</p>
<p>比较方便的是：在 redis 安装目录下的<code>utils</code>目录下存在一个：<code>redis_init_script</code>可执行脚本，将其拷贝到<code>&nbsp; /etc/init.d</code> 下，并修改名字为<code>redis</code>： </p>
<figure class="highlight shell"><figcaption><span>复制 redis 启动脚本</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">cp /usr/redis-5.0.3/utils/redis_init_script /etc/init.d/redis</span><br></pre></td></tr></tbody></table></figure>

<p>在脚本文件中增加启动注释信息（下方的最后两行）：</p>
<figure class="highlight shell"><figcaption><span>增加系统 chkconfig 注释</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">as it does use of the /proc filesystem.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig: 2345 90 10</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: Redis is a persistent key-value database</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>说明：redis 服务必须在运行级 2，3，4，5 下被启动或关闭，启动的优先级是 90，关闭的优先级是 10。 </p>
</blockquote>
<p>修改该脚本中<code>CONF</code>的配置文件路径为本地自定义的配置文件路径： </p>
<figure class="highlight shell"><figcaption><span>自定义配置路径</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">CONF="/etc/redis.conf"</span><br></pre></td></tr></tbody></table></figure>

<p>配置脚本文件初始化及设置开机自启：</p>
<figure class="highlight shell"><figcaption><span>授权脚本并设置开机自启</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/redis</span><br><span class="line">chkconfig redis on</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><figcaption><span>chkconfig 常用命令</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">chkconfig --list			    #列出所有的系统服务</span><br><span class="line">chkconfig --add httpd			#增加httpd服务</span><br><span class="line">chkconfig --del httpd			#删除httpd服务</span><br><span class="line">chkconfig --level httpd 2345 on  #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态</span><br><span class="line">chkconfig --list			    #列出系统所有的服务启动情况</span><br><span class="line">chkconfig --list mysqld          #列出mysqld服务设置情况</span><br><span class="line">chkconfig --level 35 mysqld on   #设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭</span><br><span class="line">chkconfig mysqld on              #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级</span><br><span class="line"></span><br><span class="line">等级0表示：表示关机</span><br><span class="line">等级1表示：单用户模式</span><br><span class="line">等级2表示：无网络连接的多用户命令行模式</span><br><span class="line">等级3表示：有网络连接的多用户命令行模式</span><br><span class="line">等级4表示：不可用</span><br><span class="line">等级5表示：带图形界面的多用户模式</span><br><span class="line">等级6表示：重新启动</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>测试脚本运行情况，启动：<code>service redis start</code>，停止：<code>service redis stop</code></p>
<figure class="highlight shell"><figcaption><span>redis 服务脚本启动或停止</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">service redis start</span><br><span class="line">service redis stop</span><br></pre></td></tr></tbody></table></figure>

<h4 id="十、设置密码"><a href="#十、设置密码" class="headerlink" title="十、设置密码"></a>十、设置密码</h4><p><strong>1. 初始化 redis 密码</strong></p>
<p>redis 没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑<code>redis.conf</code>配置来启用认证。在<code>redis.conf</code>配置文件中找到<code>requirepass</code>：</p>
<figure class="highlight plaintext"><figcaption><span>密码配置</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"># requirepass foobared</span><br></pre></td></tr></tbody></table></figure>

<p>将其注释符号去掉，并修改成自己的密码，如：<code>requirepass root123</code>即可。</p>
<p>配置修改完毕之后，需要重新启动 redis 服务。 </p>
<blockquote>
<p>注意：</p>
<p>redis 查询速度极快，<code>auth</code>这种命令每秒能处理 10w 次以上，简单的 redis 的密码极容易被攻击者暴破，因此建议<code>requirepass</code>至少长度 20 位以上，为方便可使用一个特殊串 sha256sum 命令生成64位的无特殊字符串。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">"dfasdERQEWRQEW31341dfadsfadsf"</span> | <span class="built_in">sha256sum</span></span></span><br><span class="line">af970b3691a0774b2a5adae1375e14cd9e5db3591564f0eb789c2324cc02362f</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><strong>2. 不重启 redis 设置密码</strong> </p>
<p>在配置文件中配置<code>requirepass</code>的密码（当 redis 重启时密码依然有效）。 </p>
<figure class="highlight shell"><figcaption><span>设置密码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config set requirepass  ed4c39b015b0e46f074dbfd0a9a4ab278f63340a6d640999f25c68a932fef815 </span><br></pre></td></tr></tbody></table></figure>

<p>查询密码：</p>
<figure class="highlight shell"><figcaption><span>查询密码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">   (error) ERR operation not permitted</span><br></pre></td></tr></tbody></table></figure>

<p>密码验证： </p>
<figure class="highlight shell"><figcaption><span>密码验证</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; auth ed4c39b015b0e46f074dbfd0a9a4ab278f63340a6d640999f25c68a932fef815</span><br><span class="line"></span><br><span class="line">   OK</span><br></pre></td></tr></tbody></table></figure>

<p>再次查询： </p>
<figure class="highlight shell"><figcaption><span>查询密码配置</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">   1) "requirepass"</span><br><span class="line">   2) "ed4c39b015b0e46f074dbfd0a9a4ab278f63340a6d640999f25c68a932fef815"</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：如果配置文件中没添加密码，那么 redis 重启后，密码会失效。 </p>
</blockquote>
<p><strong>3. 登陆带密码的 redis</strong></p>
<p>在登录的时候的时候输入密码： </p>
<figure class="highlight shell"><figcaption><span>登录时需要密码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a ed4c39b015b0e46f074dbfd0a9a4ab278f63340a6d640999f25c68a932fef815</span><br></pre></td></tr></tbody></table></figure>

<p>先登陆后验证： </p>
<figure class="highlight shell"><figcaption><span>先验证密码再连接</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">redis 127.0.0.1:6379&gt; auth ed4c39b015b0e46f074dbfd0a9a4ab278f63340a6d640999f25c68a932fef815</span><br><span class="line"></span><br><span class="line">   OK</span><br></pre></td></tr></tbody></table></figure>

<p><code>AUTH</code>命令跟其他 redis 命令一样，是不加密的，因此不能完全阻止攻击者窃取密码。</p>
<p>认证层的目标是提供多一层的轻量级保护。如果防火墙或者用来保护 redis 的系统防御外部攻击失败的话，外部用户如果没有通过密码认证还是无法访问 redis 服务。</p>
<h4 id="十一、禁用或重命名危险命令"><a href="#十一、禁用或重命名危险命令" class="headerlink" title="十一、禁用或重命名危险命令"></a>十一、禁用或重命名危险命令</h4><p>攻击者常利用<code>config / save</code>两个命令完成 redis 攻击 （因为 redis 无用户权限限制），因此建议对这两个危险的命令，使用<code>rename</code>配置项进行禁用或重命名，这样外部不了解重命名规则攻击者，就不能执行这类命令。</p>
<p>在<code>redis.conf</code>配置文件禁用<code>FLUSHDB</code>、<code>FLUSHALL</code>两个命令，或者重命名<code>CONFIG</code>、<code>SHUTDOWN</code>命令（添加一个特殊的后缀）。这样 redis 服务启动后，只能运行重命名之后的命令，不能执行原始的<code>CONFIG</code>命令：</p>
<figure class="highlight shell"><figcaption><span>禁用 redis 命令</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">It is also possible to completely <span class="built_in">kill</span> a <span class="built_in">command</span> by renaming it into</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">an empty string:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">rename-command CONFIG CONFIG_b9fc8327c4dee7</span></span><br><span class="line">rename-command SHUTDOWN SHUTDOWN_b9fc8327c4dee7</span><br><span class="line">rename-command FLUSHDB ""  #禁用此命令</span><br><span class="line">rename-command FLUSHALL ""  #禁用此命令</span><br></pre></td></tr></tbody></table></figure>

<p>注意：如果重命名命令之后，再启动 redis 服务报下面错误：</p>
<figure class="highlight shell"><figcaption><span>重命名命令之后提示错误</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">DENIED Redis is running protected mode because protected mode is enabled,</span><br><span class="line">no bind address was specified, no authentication password is requested to clients.</span><br><span class="line">In this mode connections are only accepted from the loopback interface.</span><br></pre></td></tr></tbody></table></figure>

<p>可以参见官方文档解释：<a href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line"></span><br><span class="line"># 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程</span><br><span class="line"># 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span><br><span class="line">#</span><br><span class="line"># AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）</span><br><span class="line"># 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis</span><br><span class="line"># 能只丢失1秒的写操作。</span><br><span class="line">#</span><br><span class="line"># AOF和RDB持久化能同时启动并且不会有问题。</span><br><span class="line"># 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span><br><span class="line">#</span><br><span class="line"># 请查看 http://redis.io/topics/persistence 来获取更多信息.</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># 纯累加文件名字（默认："appendonly.aof"）</span><br><span class="line"></span><br><span class="line">appendfilename "appendonly.aof"</span><br></pre></td></tr></tbody></table></figure>

<p>把配置改了<code>appendonly</code>的 yes 改为 no，重启 redis 服务即可。 </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 2018 与 2019</title>
    <url>/2019/01/09/009/</url>
    <content><![CDATA[<h4 id="一、2018"><a href="#一、2018" class="headerlink" title="一、2018 "></a>一、2018 <i class="fa fa-hourglass-end" aria-hidden="true"></i></h4><p>今早翻看程序视界的一篇《<a href="https://mp.weixin.qq.com/s/9J11QkTNF1VSQwIfgO0CYA">活动+福利：来立个不倒的Flag</a>》文章，里面讲到一个观点很好：</p>
<p><strong>如果这个目标可以延后两年实现，那多半今年你不会花精力去做它。</strong></p>
<p>时间流逝很快，2019 年的第 2 个工作周已经快过完了。</p>
<p><strong>转行</strong></p>
<p>第一次主动做出很令人诧异的转行决定，有种沉舟破斧的状态，闭门自学半年多，感谢自己，给自己一个成为一枚程序员的机会，第一次体会到只要付出就有回报，即使这话有逻辑错误，但不付出是等着买彩票中大奖吗，付出了还是没收获，那一定是付出少了，这碗鸡汤，我做的，我自己全干了。</p>
<p><strong>爱情</strong></p>
<p>农历春节临近，听村里人常谈优秀的她，因不苟且于自己的爱情被世俗绑架，而婉拒了大批优秀的追求者。偶然，在家人亲戚的撮合下，与她相遇，从尝试着接收对方的示好开始，有种相见恨晚的感觉，能被她相中，是自己的幸运，有种缘分天注定的感觉。</p>
<p>感谢有她，在找工作无果而迷茫彷徨时给我信心和勇气，爱她一生。</p>
<p><strong>学习</strong></p>
<p><em>学如逆水行舟，不进则退。</em></p>
<p>感谢老板原意栽培，这个入行机会来之不易，算是事业的转折点，深知与科班大牛之间的差距，敲起第一行商业代码开始，对自身技术能力能不足以适应未来的多端变化，存在深深的担忧。下半年被疯传的互联网寒冬消息，虽未亲接触但已不明觉厉，更加焦虑自己成长得太慢了。</p>
<h4 id="二、2019"><a href="#二、2019" class="headerlink" title="二、2019 "></a>二、2019 <i class="fa fa-hourglass-1" aria-hidden="true"></i></h4><table>
<thead>
<tr>
<th>目标</th>
<th>任务拆分</th>
</tr>
</thead>
<tbody><tr>
<td>输出至少 100 篇博文，发布至本博客及微信公众号。</td>
<td>平均每周输出至少两篇文章。</td>
</tr>
<tr>
<td>掌握理解常见设计模式，输出学习笔记</td>
<td>平均每月至少学习两种设计模式。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>编程随想</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统 | 学习笔记（一）</title>
    <url>/2018/10/16/010/</url>
    <content><![CDATA[<h4 id="一、信息就是位-上下文"><a href="#一、信息就是位-上下文" class="headerlink" title="一、信息就是位 + 上下文"></a>一、信息就是位 + 上下文</h4><blockquote>
<p>作者使用的标题是：信息就是位 + 上下文，那么问题来了：什么是位？什么是上下文？</p>
</blockquote>
<p>计算机系统是由<strong>硬件</strong>和<strong>系统软件</strong>组成的，<strong>它们共同工作来运行应用程序</strong>。所有计算机系统都有相似的硬件和软件组件，它们执行着相似的功能。</p>
<p>从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// hello 程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员利用编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1 组成的位（bit）序列，8 个位被组织成一组，称为字节。每个字节表示程序中某个文本字符。</p>
<p>hello 源程序是文本编辑器编写的一个文件，使用 HxD （免费的十六进制和磁盘数据编辑器）对源文件进行源码查看：</p>
<p><img src="https://image.woodwhales.cn/010/images/1.png" alt="使用 HxD 查看源文件"></p>
<p>从上图可以看见，所有的源码字符最终都会被转为对应的数字。像 hello.c 这样<em>只由 ASCII 字符构成</em>的文件称为文本文件，所有其他文件都称为二进制文件。hello.c 的表示方法说明了一个基本的思想 ：<strong>系统中所有的信息（包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据），都是由一串位表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。</strong>比如，在不同的上下文中，一个同样<br>的字节序列可能表示一个整数、浮点数、字符串或者机器指令。</p>
<blockquote>
<p>构成计算机信息存储单元是 bit（位），如果以 1 位为单位记录信息，未免有点低效。如果采用 8 个位为一个字节单位，可以组合出 256 种不同的符号表示，这样传输也方便，也便于计算机存储信息。<br>知道位的概念还不够，计算机对当前的某一个位中的信息可以通过字符编码规则得知，但是文本文件除外，还有纯二进制的文件（图片、音视频），计算机如何得知某几个位连接起来是一串有意义的数据，并知道从哪里截取开始到哪里结束，这就需要通过上下文来得知。</p>
</blockquote>
<h4 id="二、ASCII-码"><a href="#二、ASCII-码" class="headerlink" title="二、ASCII 码"></a>二、ASCII 码</h4><p>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。</p>
<p>计算机里，一个字节有 8 个 bit（位），用二进制（1 和 0）组合表示，则有 2 的 8 次方种可能数字，从零开始计数，则为 0 - 255，早期的计算机科学家们以为这 256 种数字够表示日常使用的符号信息了（英文字母，阿拉伯数字，控制字符等）。</p>
<ul>
<li><p>第一部分：ASCII 非打印控制字符表</p>
<p>ASCII 表上的数字 0–31 分配给了控制字符，用于控制像打印机等一些外围设备。例如，12 代表换页/新页功能。此命令指示打印机跳到下一页的开头。</p>
</li>
</ul>
<p><img src="https://image.woodwhales.cn/010/images/2.png" alt="ASCII 表"></p>
<ul>
<li><p>第二部分：ASCII 打印字符</p>
<p>数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字 127 代表 DELETE 命令。</p>
</li>
<li><p>第三部分：扩展 ASCII 打印字符</p>
<p>扩展的 ASCII 字符满足了对更多字符的需求。扩展的 ASCII 包含 ASCII 中已有的 128 个字符（数字 0–32 显示在下图中），又增加了 128 个字符，总共是 256 个。</p>
<p><img src="https://image.woodwhales.cn/010/images/3.png" alt="ASCII 扩展表"></p>
</li>
</ul>
<p>ASCII 码表有它的局限性：随着全世界人都在使用计算机，而全世界使用符号的种类远超过了 256 种，因此 ASCII 码表已经装不下更多的符号信息（非英语国家的文字符号信息：拉丁文、中文、日韩文等），于是计算机科学家们又规定出了 Unicode（中文译为：万国码、国际码、统一码、单一码），即全球通用字符集的标准。</p>
<p>Unicode 标准规定：使用两个字节单位表示一个数字，因此可以表示符号的种类为 2 的16 次方，也就是 65536 种，这样全世界人使用的符号信息都可以囊括。</p>
<p>值得注意的是 Unicode 是一种计算机工业标准，而不是指定是什么字符集实现，它涵兼容了 ASCII 码表规则，因此目前所有的计算都会至少认识 ASCII 码表规则。</p>
<p>现在国际常用的<strong>UTF-8 编码就是遵循了 Unicode 标准的一种字符集实现。</strong></p>
<h4 id="三、程序被其他程序翻译成不同的格式"><a href="#三、程序被其他程序翻译成不同的格式" class="headerlink" title="三、程序被其他程序翻译成不同的格式"></a>三、程序被其他程序翻译成不同的格式</h4><p>hello.c 是肉眼可直接识别的文本文件，但作为机器来说，它只认识二进制数字（物理逻辑上对应的是：不同大小电流或高低的电压），文件均附生在操作系统之上，我们需要一套完整的流程将源文件翻译成机器可以直接看懂并执行的可执行文件，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。</p>
<p><img src="https://image.woodwhales.cn/010/images/5.png" alt="编译系统之编译过程"></p>
<p>使用 gcc++ 编译工具编译 hello.c 源文件：</p>
<p><img src="https://image.woodwhales.cn/010/images/6.png" alt="gcc++ 编译四步骤"></p>
<blockquote>
<p><strong>gcc 常用编译命令</strong></p>
<ol>
<li><p>无选项编译链接<br>用法：<code>gcc hello.c</code><br>作用：将 hello.c <em>预处理、汇编、编译并链接形成可执行文</em>件。这里未指定输出文件，默认输出为 <code>a.out</code>。</p>
</li>
<li><p>选项 -o<br>用法：<code>gcc hello.c -o hello</code><br>作用：将 hello.c 预处理、汇编、编译并链接形成可执行文件 hello。-o 选项用来指定输出文件的文件名。</p>
</li>
<li><p>选项 -E<br>用法：<code>gcc -E hello.c -o hello.i</code><br>作用：将 hello.c 预处理输出 hello.i 文件。</p>
</li>
<li><p>选项 -S<br>用法：<code>gcc -S hello.i</code><br>作用：将预处理输出文件 hello.i 汇编成 hello.s 文件。</p>
</li>
<li><p>选项 -c<br>用法：<code>gcc -c hello.s</code><br>作用：将<em>汇编输出文</em>件 hello.s 编<em>译输</em>出 hello.o 文件。</p>
</li>
<li><p>无选项链接<br>用法：<code>gcc hello.o -o hello</code><br>作用：将编译输出文件test.o<em>链接成最终</em>可执行文件test。</p>
</li>
<li><p>选项 -O<br>用法：<code>gcc -O1 hello.c -o hello</code><br>作用：使用编译优化级别1编译程序。级别为1~3，<em>级别越大优化效果</em>越好，但编译时间越长。</p>
</li>
</ol>
</blockquote>
<ul>
<li><strong>预处理阶段。</strong>预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的 #include 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入到程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。</li>
<li><strong>编译阶段。</strong>编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C 编译器和 Fortran 编译器产生的输出文件用的都是一样的汇编语言。</li>
<li><strong>汇编阶段。</strong>接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。如果我们在文本编辑器中打开 hello.o 文件，看到的将是一堆乱码。</li>
<li><strong>链接阶段。</strong>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都会提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行。</li>
</ul>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>基础原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统 | 学习笔记（二）</title>
    <url>/2018/10/17/011/</url>
    <content><![CDATA[<p>在 Unix 系统中，我们可以使用 shell 窗口（windows 系统里是 dos 窗口）执行已经编译好的可执行文件 hello：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">unix&gt; </span><span class="language-bash">./hello</span></span><br><span class="line">hello, world</span><br><span class="line"><span class="meta prompt_">unix&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>shell 是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的外壳命令，那么外壳就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<blockquote>
<p>说白了，shell 解释器就是对命令行进行解释运行，即使是可执行文件，也是由可运行的命令行组成。</p>
</blockquote>
<p>在第一篇笔记中提到：计算机系统就是由硬件和系统软件组成，因此想要了解可执行文件如何运行起来的，需要知道计算机系统到底有那些硬件和软件。</p>
<h4 id="一、系统的硬件组成"><a href="#一、系统的硬件组成" class="headerlink" title="一、系统的硬件组成"></a>一、系统的硬件组成</h4><p>下图展示的是一个典型计算机系统需要具备的硬件结构：</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/1.png" alt="一个典型系统的硬件组成"></p>
<p>图中：CPU 是中央处理单元 ；ALU 是算术 / 逻辑单元 ；PC 是程序计数器 ；USB 是通用串行总线。</p>
<p><strong>1. 总线</strong></p>
<p>贯穿整个系统的是一组电子管道，称做总线，它携带信息字节并负责在各个部件间传递。</p>
<p>硬件之间进行信息交流需要有一个统一的标准，也就是二进制信息传递规则，为了高效考虑，通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，在各个系统中的情况都不尽相同。</p>
<blockquote>
<p>操作系统中的 32 位（4 个字节）或 64 （8 个字节）位就叫总线的字长单位。</p>
</blockquote>
<p><strong>2. I/O 设备</strong></p>
<p>输入 / 输出（I/O）设备是系统与外部世界的联系通道。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。</p>
<p><strong>3. 主存</strong></p>
<p>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（即数组索引），这些地址是从零开始的。</p>
<blockquote>
<p>计算机硬件世界里的内存条就是主存。</p>
</blockquote>
<p><strong>4. 处理器</strong></p>
<p>中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个字长的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p>
<blockquote>
<p>术业有专攻，计算机的世界里，你做你的，它做它的，大家各司其职。 如果想要 hello 可执行文件（存储在主存上）运行起来，就要调用程序计数器执行整个程序的每一条指令，并有专门的硬件来处理数值计算逻辑操作，并且在数值处理过程中会产生临时的数据，这就需要有个地方寄存，等待所有程序执行结束之后，再存到主存上。</p>
</blockquote>
<p>处理器从程序计数器（PC）指向的存储器处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定与存储器中刚刚执行的指令相邻。</p>
<p>然而<strong>操作是围绕着主存、寄存器文件（register file）和算术 / 逻辑单元（ALU）进行的。</strong>寄存器文件是一个小的存储设备，由一些 1 字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。</p>
<p>下面列举一些简单操作的例子，CPU 在指令的要求下可能会执行以下操作 ：</p>
<ul>
<li><strong>加载</strong> ：把一个字节或者一个字从主存复制到寄存器，以覆盖寄存器原来的内容。</li>
<li><strong>存储</strong> ：把一个字节或者一个字从寄存器复制到主存的某个位置，以覆盖这个位置上原来的内容。</li>
<li><strong>操作</strong> ：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术操作，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li>
<li><strong>跳转</strong> ：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。</li>
</ul>
<h4 id="二、运行程序过程"><a href="#二、运行程序过程" class="headerlink" title="二、运行程序过程"></a>二、运行程序过程</h4><h5 id="2-1-从键盘上读取-hello-命令"><a href="#2-1-从键盘上读取-hello-命令" class="headerlink" title="2.1 从键盘上读取 hello 命令"></a>2.1 从键盘上读取 hello 命令</h5><p>当在 Unix 系统的 shell 程序命令行里输入”./hello”的时候， shell 程序会将用户输入的字符逐个<em>加载</em>到寄存器里，再把它<em>存储</em>到存储器中，此时 shell 干的事情就是将敲打出来的字符符号显示在显示器上，还没有执行这个可执行文件， 直到用户敲击回车键，则 shell 程序就开始将这个 hello 可执行文件运行起来：</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/2.png" alt="从键盘上读取 hello 命令"></p>
<blockquote>
<p><strong>从磁盘加载可执行文件到主存</strong></p>
<p>计算机还可以利用直接存储器存取（DMA）的技术，可以将数据直接从磁盘到达主存（不通过处理器）：</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/3.png" alt="从磁盘加载可执行文件到主存"></p>
</blockquote>
<h5 id="2-2-将输出字符串从内存写到显示器"><a href="#2-2-将输出字符串从内存写到显示器" class="headerlink" title="2.2 将输出字符串从内存写到显示器"></a>2.2 将输出字符串从内存写到显示器</h5><blockquote>
<p>明确一点：可执行文件 hello 执行的最终目的是打印<code>"hello, world\n"</code>这个字符串，因此它是数据，其他的字符符号均是数据之外的空格符号及机器语言指令。</p>
</blockquote>
<p>首先将 hello 目标文件中的代码和数据（数据就包括<code>"hello, world\n"</code>这个字符串）从磁盘复制到主存，当主存里加载好了 hello 文件的全部信息，处理器就处理器就开始执行 hello 程序的main 程序中的机器语言指令，这些指令在 PC 中逐行执行，目的就是将<code>"hello, world\n"</code>这个字符串中的字节信息从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上：</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/4.png" alt="将输出字符串从内存写到显示器"></p>
<h4 id="三、高速缓存"><a href="#三、高速缓存" class="headerlink" title="三、高速缓存"></a>三、高速缓存</h4><p>根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。类似地，处理器从寄存器文件中读数据的速度比从主存中读取几乎要快 100 倍+。</p>
<p>针对这种处理器与主存之间的差异，系统设计者采用了更小、更快的存储设备，即<strong>高速缓存存储器</strong>（简称<em>高速缓存</em>），作为暂时的集结区域，用来存放处理器近期可能会需要的信息：</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/5.png" alt="典型系统中的高速缓存存储器"></p>
<p>上图中的<code>高速缓存存储器</code>位于处理器芯片上，现代硬件系统一般包含着三级高速缓存 ：L1、L2 和 L3。其中：L1 和 L2 高速缓存是用一种叫做<em>静态随机访问存储器</em>（SRAM）的硬件技术实现的。</p>
<p>计算机通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储器操作都能在快速的高速缓存中完成，因此高速缓存的目的只有两个：快速、高效率，本书有个重要的结论之一，就是意识到高速缓存存在的应用程序员可以利用高速缓存将他们程序的性能提高一个数量级。</p>
<p><strong>存储设备形成层次结构</strong></p>
<p>在小快高价的处理器和大慢廉价的存储设备之间的差异，使得计算机系统在设计存储系统结构之初就遵循一个很重要很普遍的观念：每个计算机系统中的存储设备都被组织成了一个<em>存储器层次结构</em>。</p>
<p><img src="htthttps://image.woodwhales.cn/011/images/6.png" alt="一个存储器层次结构的示例"></p>
<p>在这个层次结构中，从上至下，设备变得访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。</p>
<p>存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<p>正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。</p>
<h4 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h4><p>始终牢记计算机系统是由硬件和程序软件组成，而两者归根到底均为了存储信息而服务，即使是在计算机计算的过程中会产生临时的“多余信息”，也需要有一个物理位置用来寄存以备后用。</p>
<p>一个程序要想运行起来并不是想我们简单想象那样一眼就能识别并“跑起来”，而经过计算机中各司其职的各个组件进行相互合作，从而完美地执行一个程序要想计算机做出的结果。</p>
<p>硬件中核心概念：总线是人们常说的操作系统中的位数；主存是存储驱动器（磁盘）；I/O设备一般包括鼠标、键盘、显示器，还有更狭义的网络；处理器则是的整个计算机运算的核心，它与前两者在总线的基础之上承载着“控制主权”，它是解释（或执行）存储在主存中指令的引擎，其中记录着一行行指令的叫PC（程序计数器），算术 / 逻辑单元（ALU）负责对数值进行算术或逻辑操作，操作过程中的起始和终止信息在寄存器里反复的更新存储，当处理器执行解释完所有的指令之后，将计算出的结果在存储到主存中。</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>基础原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统 | 学习笔记（三）</title>
    <url>/2018/10/19/012/</url>
    <content><![CDATA[<h4 id="一、操作系统管理硬件"><a href="#一、操作系统管理硬件" class="headerlink" title="一、操作系统管理硬件"></a>一、操作系统管理硬件</h4><p>无论是简单的 hello 可执行程序还是 shell 应用程序，它们之所可以运行起来，并没有直接访问键盘、显示器、磁盘或者主存，而是依靠操作系统提供的服务。因此，<strong>我们可以把操作系统看成是应用程序和硬件之间插入的一层软件。</strong></p>
<p>操作系统的两个核心基本功能：</p>
<p>1）防止硬件被失控的应用程序滥用。2）向应用程序提供简单一致的机制（API）来控制复杂而又通常大相径庭的低级硬件设备。</p>
<p>面对花样百出的硬件，操作系统就像是保姆，所有脏活累活都自己大包大揽，只给用户提供一个简单的 API 供程序们幸福的使用。程序运行在操作系统之内，就收到操作系统的管理，如何统一管理各式各样的应用软件是一大看点。</p>
<h5 id="三大抽象概念"><a href="#三大抽象概念" class="headerlink" title="三大抽象概念"></a>三大抽象概念</h5><p>怎么将程序和上篇文章中提到的硬件系统相对应起来，是值得玩味一番。操作系统设计者们设计出以下三个重要的抽象概念来实现上述的核心基础功能：进程、虚拟存储器和文件。</p>
<p><strong>文件</strong>是对 I/O 设备的抽象表示。</p>
<p><strong>虚拟存储器</strong>是对主存和磁盘 I/O 设备的抽象表示。</p>
<p><strong>进程</strong>是对处理器、主存和 I/O 设备的抽象表示。</p>
<p><img src="https://image.woodwhales.cn/012/images/1.png" alt="操作系统提供的抽象表示"></p>
<h5 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h5><p><strong>进程是操作系统对一个正在运行的程序的一种抽象。</strong>进程概念的提出使得所有跑在操作系统上程序一个很逼真的假象：看上去只有这个程序在使用处理器、主存和 I/O 设备，即该程序的代码和数据是系统存储器中唯一的对象。</p>
<p>即使是操作系统上有多个程序（进程）在运行，也让用户感觉到每个程序都是相互独立的<strong>并发运行</strong>：一个进程的指令和另一个进程的指令交错执行。其可以实现这样高效的运行机制是因为硬件技术的支持：CPU 有可以在进程之间来回切换执行进程的功能，操作系统就是利用这一机制实现了这种机制，叫<strong>上下文切换</strong>。</p>
<p>具体来说来讲，操作系统时刻记录并跟踪进程运行所需的所有状态信息（也就是上下文），其中包括PC 和寄存器文件的当前值，以及主存的内容等，以保证能够在一个进程执行到一半并将其暂停，去执行一会儿另一个进程，再待另一个进程执行一段时间将其暂停，再回到本进程继续执行。</p>
<p><img src="https://image.woodwhales.cn/012/images/2.png" alt="进程的上下文切换"></p>
<p><strong>线程</strong></p>
<p>在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>
<p>线程和进程区别在于作用域的不同，进程是在操作系统层面，进程是在某个进程层面。</p>
<h5 id="1-2-虚拟存储器"><a href="#1-2-虚拟存储器" class="headerlink" title="1.2 虚拟存储器"></a>1.2 虚拟存储器</h5><p>虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为虚拟地址空间。</p>
<p><img src="https://image.woodwhales.cn/012/images/3.png" alt="进程的虚拟地址空间"></p>
<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。图中地址空间的底部区域存放用户进程定义的代码和数据，地址从下往上逐渐增大。</p>
<ul>
<li><p><strong>程序代码和数据</strong></p>
<p>对于所有的进程来说，代码是从同一固定地址开始并且只读，之后就紧接着是数据位置（和 C 全局变量相对应的数据位置）。注意：代码和数据区是在进程一开始运行时就被规定了大小。</p>
</li>
<li><p><strong>堆</strong></p>
<p>代码和数据区后紧随着的是运行时堆，堆可以在运行时动态地扩展和收缩。</p>
</li>
<li><p><strong>共享库</strong></p>
<p>大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样共享库的代码和数据的区域。</p>
</li>
<li><p><strong>栈</strong></p>
<p>位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。<em>调用一个函数时，栈就会增长 ；从一个函数返回时，栈就会收缩。</em></p>
</li>
<li><p><strong>内核虚拟存储器</strong></p>
<p>内核总是驻留在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。</p>
</li>
</ul>
<p>虚拟存储器这样结构的设计目的就是实现操作系统对硬件的信息交互，硬件中的电压信息能够被解释转换为计算机操作系统中的位（bit）信息，并与之在软件层面进行更广泛的交互。</p>
<p><strong>虚拟存储器运作的基本思想是把一个进程虚拟存储器的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</strong></p>
<h5 id="1-3-文件"><a href="#1-3-文件" class="headerlink" title="1.3 文件"></a>1.3 文件</h5><p>文件就是字节序列，仅此而已。每个 I/O 设备，包括磁盘、键盘、显示器，甚至网络，都可以视为文件。它向应用程序提供了一个统一的视角，来看待系统中可能含有的所有各式各样的 I/O 设备。</p>
<h4 id="二、系统之间利用网络通信"><a href="#二、系统之间利用网络通信" class="headerlink" title="二、系统之间利用网络通信"></a>二、系统之间利用网络通信</h4><p>现在的计算机已经不是单兵作战，而是通过网络连接着不同的操作系统对应的计算机，但是它们在硬件和系统软件层面都有着相同的结构设计，因此使得全世界的计算机能够互联起来，形成信息巨大的互联网。</p>
<p>从一个单独的系统来看，网络可视为一个 I/O 设备。当系统从主存将一串字节复制到网络适配器时，数据流经过网络到达另一台机器，而不是其他地方，例如本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。</p>
<p><img src="https://image.woodwhales.cn/012/images/4.png" alt="网络也是一种 I/O 设备"></p>
<h4 id="三、并发与并行"><a href="#三、并发与并行" class="headerlink" title="三、并发与并行"></a>三、并发与并行</h4><p><strong>并发（concurrency）是指一个同时具有多个活动的系统。并行（parallelism）指的是用并发使一个系统运行得更快。</strong></p>
<p>并行可以在计算机系统的多个抽象层次上运用。按照系统层次结构中由高到低的顺序分为三层次：</p>
<h5 id="3-1-线程级并发"><a href="#3-1-线程级并发" class="headerlink" title="3.1 线程级并发"></a>3.1 线程级并发</h5><p>在进程的抽象概念下引入了线程，而线程级并发的概念，就是指的<strong>多个线程在同一时间（并非是绝对同时的）活动，即一个一个进程中执行多个控制流。</strong></p>
<p>由一个处理器在多个任务之间来回切换的早期计算机叫单处理器系统。</p>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个多处理器系统。其中多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。</p>
<p>超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件 ；而其他的硬件部分只有一份，比如执行浮点算术运算的单元。</p>
<h5 id="3-2-指令级并行"><a href="#3-2-指令级并行" class="headerlink" title="3.2 指令级并行"></a>3.2 指令级并行</h5><p>可以同时执行多条指令的属性称为指令级并行。计算机使用了流水线（pipelining）技术，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。</p>
<p>如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量（superscalar）<br>处理器。大多数现代处理器都支持超标量操作。</p>
<h5 id="3-3-单指令、多数据并行"><a href="#3-3-单指令、多数据并行" class="headerlink" title="3.3 单指令、多数据并行"></a>3.3 单指令、多数据并行</h5><p>现在的计算机硬件几乎都允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。通俗的讲也可以理解为，一条指令操作多个数据。比如书中所提到的例子，一些处理器具有并行地对4对单精度浮点数做加法的指令。</p>
<p>计算机之所以越来越快，这得益于计算机硬件技术的发展，它从物理逻辑上实现了具有 SIMD 并行、超标量的多核处理器。</p>
<h4 id="四、抽象不简单"><a href="#四、抽象不简单" class="headerlink" title="四、抽象不简单"></a>四、抽象不简单</h4><p>在处理器里，<em>指令集结构</em>提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像它是运行在一个一次只执行一条指令的处理器上。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。</p>
<p>除了上面的三个抽象概念，还有一个上世纪 60 年代提出的重要抽象概念：<strong>虚拟机</strong>，它提供对整个计算机（包括操作系统、处理器和程序）的抽象。</p>
<h4 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h4><p>抽象的概念成为了计算机世系统相互互联的基础，从单台计算机上硬件与操作系统之间的信息交互，到操作系统与本地应用程序之间，再到计算机和网络端的另一台计算机，都遵循着同样的软硬件结合标准，从而使得信息可以在每台计算机之间交流传递。</p>
<p>处理器读取并解释存放在主存里的二进制指令。因为计算机把大量的时间用于存储器、I/O设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构 —— CPU 寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。</p>
<p>为了提升计算机的运行性能，操作系统对硬件中的设备进行抽象：1）文件是对 I/O设备的抽象 ；2）虚拟存储器是对主存和磁盘的抽象 ；3）进程是对处理器、主存和 I/O 设备的抽象。</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>基础原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统 | 学习笔记（四）</title>
    <url>/2018/10/22/013/</url>
    <content><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>现代计算机存储和处理的信息以二值信号表示，即由数学上的数字 0 和 1 并以二进制的形式表示数字信息，在计算机专业中对其有个专业的术语：位（bit）。</p>
<p>十进制是逢十进一，二进制则是逢二进一，八进制是逢八进一，十六进制是逢十六进一。</p>
<p>为什么是二进制成了计算机信息存储的基础机制？因为二值信号能够很容易地被表示、存储和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。另外从技术支持的成本上，硬件处理二进制的能力比其他进制简单可靠。</p>
<p>单个的位没有太多的实际作用，但是把 n 多的位进行组合排列就会产生任何有限集合的元素信息。</p>
<p><img src="https://image.woodwhales.cn/013/images/1.png" alt="不同位组合可以产生更多种信息"></p>
<p>上图中多个位进行组合的可能值信息赋予一定的解释就能进行数学上的数值表示，其中有三种最重要的数字表示：无符号（unsigned）、补码（two’s-complement）、浮点数（floating-point）。</p>
<p>无符号（unsigned）编码基于传统的二进制表示法，表示<br>大于或者等于零的数字。补码（two’s-complement）编码是表示有符号整数的最常见的方式，有<br>符号整数就是可以为正或者为负的数字。浮点数（floating-point）编码是表示实数的科学记数法<br>的以二为基数的版本。</p>
<p>注意的是，计算机的表示法是用有限数量的位来对一个数字编码，当结果太大以至不能表示时（有限的位装不下要表示的数字时），某些运算就会溢出（overflow）。</p>
<p>对于不同的计算机来说，由于数值范围可能有所不同，因此掌握信息相关的内容对于写出跨平台的程序来讲也是很有帮助的。</p>
<h4 id="二、信息存储"><a href="#二、信息存储" class="headerlink" title="二、信息存储"></a>二、信息存储</h4><p>组合的位能够表示更多的信息，因此计算机的信息就存储在这些位中，大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的存储器单位，而不是在存储器中访问单独的位。</p>
<p><strong>机器级程序将存储器视为一个非常大的字节数组，称为虚拟存储器（virtual memory）。存储器的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合称为虚拟地址空间（virtual address space）。</strong></p>
<p>程序跑在操作系统之上，就只需要利用好自己的虚拟地址空间（操作系统分配的），而无需关注硬件是怎么实现位信息的存储，因此有强大庞杂的操作系统完成了与硬件的实现。</p>
<p>具体来说，就是编译器和运行时系统将存储器空间划分为更可管理的单元，以存放不同的程序对象（program object），即程序数据、指令和控制信息。并可以用各种机制来分配和管理程序不同部分的存储，这种管理完全是在虚拟地址空间里完成的。</p>
<p><strong>十六进制</strong></p>
<p>十进制是使用 0 - 9 的自然数字进行表示，十六进制的则是使用 0 - 15 的符号来表示，但是有一个问题在于，一个位只能存储一个符号信息，例如 10 这样的十进制数字需要两位来存储表示，因此需要使用一些符号替代两位数的数字，科学家们规定 10 - 15 对应英文字母的 A - F。在 C 语言中一般是使用“0x”（数字 0 和字母 x )开头表示的数字为十六进制数。</p>
<p>为什么要使用十六进制呢，因为计算机在设计之初就是以 8 位为信息存储单元，使用十六进制可以达到更小的存储单位中表达更多的信息。下图中每个十六进制数字都对 16 个值中的一个进行了编码。</p>
<p><img src="https://image.woodwhales.cn/013/images/2.png" alt="十六进制表示法"></p>
<p><strong>字</strong></p>
<p>每台计算机都有一个字长（word size），指明整数和指针数据的标称大小（nominal size）。因为虚拟地址是以这样的一个字来编码的，所以操作系统的字长决定了虚拟地址空间的最大大小。</p>
<p><img src="https://image.woodwhales.cn/013/images/3.png" alt="操作系统位数限制虚拟地址空间大小"></p>
<h4 id="三、数据类型和大小"><a href="#三、数据类型和大小" class="headerlink" title="三、数据类型和大小"></a>三、数据类型和大小</h4><p>讲述了二进制可以表示整数，如果需要计算机操作小数操作或者计算出的结果是小数，需要如何表示是一个需要值得研究的，同时，计算机中存储的都是 0 和 1 的位信息，计算机是怎么知道从哪里开始到哪里结束表示一个数字呢，这就需要引出数据类型和对应的所占位数大小。</p>
<p><img src="https://image.woodwhales.cn/013/images/4.png" alt="C 语言中数字数据类型的字节数"></p>
<h4 id="四、寻址和字节顺序"><a href="#四、寻址和字节顺序" class="headerlink" title="四、寻址和字节顺序"></a>四、寻址和字节顺序</h4><p>上述已经得知，一个程序运行起来之后，就会由操作系统分配虚拟地址空间供自己自由使用，那么程序总需要一个地方来维护所有信息，并且能够按照与预期效果一致的顺序读取字节信息。</p>
<p>对于跨越多个字节的程序对象（程序对象指指令、数据或者控制信息等，是程序当中对象的统称）来说，我们需要制定两个规则才能唯一确定一个程序对象的值：对象的地址和对象表示的字节顺序。</p>
<p><strong>对象地址</strong></p>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，<strong>对象的地址为所使用字节中最小的地址。</strong>假设一个类型为 int 的变量 a 的地址为 0x100，也就是说，地址表达式 &amp;a 的值为 0x100。那么，a 的 4 个字节将被存储在存储器的 0x100、0x101、0x102 和 0x103 位置。</p>
<p><strong>字节顺序</strong></p>
<p>某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，即最低有效字节在最前面的方式，称为<em>小端法</em>（little endian）。</p>
<p>而另一些机器则按照从最高有效字节到最低有效字节的顺序存储，最高有效字节在最前面的方式，称为<em>大端法</em>（big endian）。</p>
<p><img src="https://image.woodwhales.cn/013/images/5.png" alt="大小端"></p>
<p>有些机器或操作系统支持大端法，有些支持小端法，还有些处理器能够支持双端表示，那么如何在不同计算机之间进行信息传递，尤其是在网络传输数据的过程中，必须遵循全球通用的字节顺序标准，才能使得信息互联，但是大多数情况下，程序员不需要考虑大小端问题，因为编译器已经帮我们做了字节顺序自适应。</p>
<p>参数 12345 的十六进制表示为 0x00003039。我们可以看到在 Linux 32、Windows 和 Linux 64 上，最低有效字节值 0x39 最先输出，这说明它们是小端法机器；而在 Sun 上却最后输出，这说明 Sun 是大端法机器。</p>
<p><img src="https://image.woodwhales.cn/013/images/6.png" alt="不同操作系统的大小端"></p>
<h4 id="五、字符串和代码表示"><a href="#五、字符串和代码表示" class="headerlink" title="五、字符串和代码表示"></a>五、字符串和代码表示</h4><p>计算机如何通过位信息来表示字符串也是值得研究，在 C 语言中，字符串编码是以 NULL 字符结尾的字符数组，因此其字符串在计算机中表示的本质就是以 0 结尾的字符数组。如何将数字编码成对应的数字有一定的国际标准，最常见的就是 ASCII 码编码规则。</p>
<p>以字符串<code>"123456"</code>为例，通过 C 语言转码得到：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">31 32 33 34 35 36 00</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现，字符串中包含的数字 x 在经过 C 语言程序转换，得到的十六进制数为：0x3x，并且最终结尾是：0x00。</p>
<p>在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。</p>
<p>下面代码在不同的操作系统上编码方式不一样：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在不同机器上编译后，得到的机器代码不一样：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Linux 32: 55 89 e5 8b 45 0c 03 45 08 c9 c3</span><br><span class="line">Windows: 55 89 e5 8b 45 0c 03 45 08 5d c3</span><br><span class="line">Sun: 81 c3 e0 08 90 02 00 09</span><br><span class="line">Linux 64: 55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3</span><br></pre></td></tr></tbody></table></figure>

<p>因此，源代码一样的文件在不同操作系统上编译之后，生成的二进制代码是不兼容的。</p>
<h4 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h4><p>计算机与硬件交互是用过二进制信息完成交互，为了方便管理、提升系统性能，操作系统对于数据操作单元的位数选取不同，由于 32 位操作系统对于虚拟地址空间的限制，导致目前的计算机逐渐迁移到了 64 位。</p>
<p>另外，不同的操作系统对于字节的顺序表示和数据类型占用位大小也不同，有大端表示的，也有小端表示的。这种单机的独特性导致计算机在网络中传输的字节顺序不一致，因此信息数据在网络交互过程中需要遵循一个唯一的标准。</p>
<p>所以计算机都遵循 ASCII 码编码标准，使得字符串和代码（字符串编写的文本文件）的编码和解码操作变得可以不依赖平台进行移植。当然代码中定义的数字信息还是需要依赖编译器进行编译成适合本系统的机器代码（二进制文件）。</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>基础原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统 | 学习笔记（五）</title>
    <url>/2018/10/29/014/</url>
    <content><![CDATA[<h4 id="一、布尔代数"><a href="#一、布尔代数" class="headerlink" title="一、布尔代数"></a>一、布尔代数</h4><p>二进制值是计算机编码、存储和操作信息的核心，所以围绕数值 0 和 1 的研究已经演化出了丰富的数学知识体系。其中影响最深的代数体系是布尔代数，数学家布尔注意到通过将逻辑值 TRUE（真）和 FALSE（假）编码为二进制值 1 和 0，能够设计出一种代数，以研究逻辑推理的基本原则。</p>
<p><strong>布尔运算</strong></p>
<p>最简单的布尔代数是在二元集合 {0，1} 基础上的定义，它定义了四种布尔运算法则：</p>
<p><img src="https://image.woodwhales.cn/014/images/1.png" alt="布尔代数的运算"></p>
<p>上图中：</p>
<p><code>~</code>运算符表示<code>非</code>操作，非真就是假，非假就是真。</p>
<p><code>&amp;</code>运算符表示<code>且</code>操作，只有两者同时为真的时候，运算结果才为真。</p>
<p><code>|</code>运算符表示<code>或</code>操作，只要两者之中有一个为真，运算结果则为真。</p>
<p><code>^</code>运算符表示<code>异或</code>操作，只有两者不相同时，运算结果为真（两者相同，运算结果则为假）。</p>
<p><strong>位向量运算</strong></p>
<p>布尔运算规定了两个命题之间的逻辑运算，因此我们可以 4 个布尔运算扩展到位向量的运算，位向量就是有固定长度为 w、由 0 和 1 组成的串。也就是有两个长度为 w 的位向量，分别命名为 a 和 b，那么两者的布尔四则运算表示的是向量位中每一个位对应的相应原算。</p>
<p>假设 w = 4，参数 a =[0110]，b =[1100]。那么 4 种运算 a &amp; b、a | b、a ^ b 和 ~b 分别得到以下结果 ：</p>
<p><img src="https://image.woodwhales.cn/014/images/2.png" alt="位向量运算"></p>
<p>在大量实际应用中，我们都能看到用位向量来对集合编码。例如，在第 8 章，我们会看到有很多不同的信号会中断程序执行。我们能够通过指定一个位向量掩码，有选择地使能或是不能屏蔽一些信号，其中某一位位置上为 1 时，表明信号 i 是有效的，而 0 表明该信号是被屏蔽的。因而，这个掩码表示的就是设置为有效信号的集合。</p>
<h4 id="二、C-语言中的位级运算"><a href="#二、C-语言中的位级运算" class="headerlink" title="二、C 语言中的位级运算"></a>二、C 语言中的位级运算</h4><p>C 语言中有个很有用的特性就是支持<em>按位布尔运算</em>：</p>
<p><code>|</code>就是 OR（或），</p>
<p><code>&amp;</code>就是 AND（与），</p>
<p><code>~</code>就是 NOT（取反），</p>
<p><code>^</code>就是 EXCLUSIVE-OR（异或）</p>
<p>C 语言中的位级运算可以运用到任何“整型”的数据类型上，下图是 C 语言中的位级运算实例：</p>
<p><img src="https://image.woodwhales.cn/014/images/3.png" alt="C语言中的位级运算"></p>
<p>从上图可以看出，如果想要对数字进行位级运算，就需要将运算的数转换成二进制进行计算，计算出二进制结果再转成原来的进制数即可。</p>
<p>位级运算的一个常见用法就是实现<strong>掩码</strong>运算，这里掩码是一个位模式，表示从一个字中选出的位的集合。比如我们知道一个整数 x，如果我们想取得这个整数的最后一个字节的整数值的话，就可以采用位运算。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">     unsigned int i = 0x1234;</span><br><span class="line">     unsigned int j = 0xFF;</span><br><span class="line">     unsigned int k = i &amp; j;</span><br><span class="line">     printf("%X",k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出打印结果为：<code>34</code>，用图来理解掩码<code>0xFF</code>在运算过程中发挥的作用：</p>
<p><img src="https://image.woodwhales.cn/014/images/4.png" alt="掩码运算"></p>
<h4 id="三、C-语言中的逻辑运算"><a href="#三、C-语言中的逻辑运算" class="headerlink" title="三、C 语言中的逻辑运算"></a>三、C 语言中的逻辑运算</h4><p>除了位级运算，C 语言还提供了一组逻辑运算法则，分别对应数学上的命题逻辑中的 OR、AND、NOT。逻辑运算和位级运算容易概念混淆，在逻辑运算中只要是非零的参数，都表示位 TRUE。</p>
<p><code>||</code>运算符表示逻辑与（OR）</p>
<p><code>&amp;&amp;</code>运算符表示逻辑且（AND）</p>
<p><code>！</code>运算符表示逻辑非（NOT）</p>
<p>注意：<code>&amp;&amp;</code>表示的是逻辑与的关系，如果第一个参数的结果为 FALSE，则运算符后面的表达式就不会再计算了，这一点和位级的与（&amp;）不一样，位级的与操作是在位级别的与操作。<code>！</code>表示的是逻辑上的非关系，如果一个参数是非零，进行非操作之后得到的结果只是 1（因为 1 表示逻辑上的真）。</p>
<h4 id="四、C-语言中的位移运算"><a href="#四、C-语言中的位移运算" class="headerlink" title="四、C 语言中的位移运算"></a>四、C 语言中的位移运算</h4><p>C 语言中还提供了一组位移运算，向左或向右移动位模式。</p>
<p>左移：</p>
<p>C 表达式 x &lt;&lt; k 会生成一个值。x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0 。</p>
<p>右移：右移分为算术右移和逻辑右移。逻辑右移：x 向右移动 k 位，丢弃最低的 k 位，并在左端补 k 个 0 。算术右移是因为考虑到带符号的整数的运算：x 向右移动 k 位，丢弃最低的 k 位，并在左端补 k 个最高位的操作数（最高位是 1 就填充 1，最高位是 0 就填充 0，因为在有符号整数中最高位是符号的标识位）。</p>
<p><img src="https://image.woodwhales.cn/014/images/5.png" alt="移位运算"></p>
<p>几乎所有的编译器/机器组合都对有符号数使用算术右移，对于无符号数，右移必须是逻辑右移。</p>
<blockquote>
<p>与 C 相比，Java 表达式有明确定义，表达式<code>x&gt;&gt;k</code>会将 x 算术右移 k 个位置，而<code>x&gt;&gt;&gt;k</code>会对 x 做逻辑运算。</p>
</blockquote>
<h4 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h4><p>计算机系统中出于高效率运行的考虑，信息的存储采用位的形式，并且使用简单的二进制组合形成不同的映射信息，光能存储还不能体现计算机的优势，它必须会计算数值，这也得益于数学概念的发展，计算机实现并拓展了布尔运算，使得计算机能够快递高效的计算数值运算。在布尔运算的完美实现基础之上，拓展到位级运算，再拓展到现实世界的逻辑运算和位移运算。</p>
<p>布尔运算提出了两位命题之间的四则运算：与（&amp;）、或（|）、非（~）、异或（^），计算机中实现并拓展了布尔运算设计出位向量运算，使得 C 语言在设计之初就支持位级运算、逻辑运算和位移运算。</p>
]]></content>
      <categories>
        <category>深入理解计算机系统</category>
      </categories>
      <tags>
        <tag>基础原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis Generator 逆向工程详解</title>
    <url>/2018/10/29/015/</url>
    <content><![CDATA[<blockquote>
<p>本文工程示例源码：<a href="https://github.com/woodwhales/woodwhales-study/tree/master/generate-mapper">https://github.com/woodwhales/woodwhales-study/tree/master/generate-mapper</a></p>
</blockquote>
<h4 id="一、Mysql-数据库数据准备"><a href="#一、Mysql-数据库数据准备" class="headerlink" title="一、Mysql 数据库数据准备"></a>一、Mysql 数据库数据准备</h4><h5 id="1-1-创建数据库"><a href="#1-1-创建数据库" class="headerlink" title="1.1 创建数据库"></a>1.1 创建数据库</h5><figure class="highlight sql"><figcaption><span>创建数据库</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `my_test_db` <span class="comment">/*!40100 COLLATE 'utf8mb4_unicode_ci' */</span>;</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-2-创建用户表"><a href="#2-2-创建用户表" class="headerlink" title="2.2 创建用户表"></a>2.2 创建用户表</h5><figure class="highlight sql"><figcaption><span>创建数据库表</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">User</span>` (</span><br><span class="line">    `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `gender` BIT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `email` <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `born` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `extraInfo` <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">COLLATE</span><span class="operator">=</span><span class="string">'utf8mb4_unicode_ci'</span></span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-3-创建购物车表"><a href="#1-3-创建购物车表" class="headerlink" title="1.3 创建购物车表"></a>1.3 创建购物车表</h5><figure class="highlight sql"><figcaption><span>创建数据库表</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `Cart` (</span><br><span class="line">    `id` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `logisticId` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `number` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `discount` <span class="keyword">DOUBLE</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `total` <span class="keyword">DOUBLE</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `extrainfo` <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `logisticId` (`logisticId`)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">COLLATE</span><span class="operator">=</span><span class="string">'utf8mb4_unicode_ci'</span></span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二、逆向工程生成"><a href="#二、逆向工程生成" class="headerlink" title="二、逆向工程生成"></a>二、逆向工程生成</h4><h5 id="2-1-pom-依赖配置"><a href="#2-1-pom-依赖配置" class="headerlink" title="2.1 pom 依赖配置"></a>2.1 pom 依赖配置</h5><p>在 pom.xml 依赖文件中增加 mybatis generator 插件依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.woodwhales.king<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>generate-mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>generate-mapper<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>king redis project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!--允许移动生成的文件 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 是否覆盖 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 自动生成的配置 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generator/config.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/015/images/1.png" alt="pom 依赖配置"></p>
<h5 id="2-2-配置映射文件"><a href="#2-2-配置映射文件" class="headerlink" title="2.2 配置映射文件"></a>2.2 配置映射文件</h5><p>在<code>&lt;configurationFile&gt;</code>配置的对应目录下，创建对应的逆向生成工程映射文件，并将下列配置粘贴到其中：</p>
<figure class="highlight xml"><figcaption><span>mybatis 逆向工程配置映射</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--xml引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"generator/init.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"Tables"</span>  <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--字符集必须指定，否则生成的文件会根据系统的字符集生成--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 增加生成序列化等插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.EqualsHashCodePlugin"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.ToStringPlugin"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressDate"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否[去除]自动生成的注释  true表示是，false表示否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否携带注释 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addRemarkComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--数据库链接URL、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"${jdbc.driverClass}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">"${jdbc.connectionURL}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">userId</span>=<span class="string">"${jdbc.userId}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">"${jdbc.password}"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 生成 model 和 example的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"${javaModelGenerator.targetPackage}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">"${javaModelGenerator.targetProject}"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 生成 DAO 接口文件的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"${sqlMapGenerator.targetPackage}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">"${sqlMapGenerator.targetProject}"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 生成XML映射文件的包名和位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"${javaClientGenerator.targetPackage}"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">"${javaClientGenerator.targetProject}"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"${tableName}"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableCountByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableDeleteByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableSelectByExample</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">enableUpdateByExample</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">sqlStatement</span>=<span class="string">"Mysql"</span> <span class="attr">identity</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-3-配置自定义配置文件"><a href="#2-3-配置自定义配置文件" class="headerlink" title="2.3 配置自定义配置文件"></a>2.3 配置自定义配置文件</h5><p>在映射文件配置中，可以看到：<code>&lt;properties&gt;</code>元素指定了<code>generator/mybatisGeneratorinit.properties</code>，因此需要创建对应的配置文件：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#Mybatis Generator configuration</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JDBC config</span></span><br><span class="line"><span class="attr">jdbc.driverClass</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#jdbc.driverClass=com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.connectionURL</span>=<span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.userId</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#JavaBean location</span></span><br><span class="line"><span class="attr">javaModelGenerator.targetProject</span>=<span class="string">src/main/java</span></span><br><span class="line"><span class="attr">javaModelGenerator.targetPackage</span>=<span class="string">org.woodwhales.king.user.entity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#interface location</span></span><br><span class="line"><span class="attr">javaClientGenerator.targetProject</span>=<span class="string">src/main/java</span></span><br><span class="line"><span class="attr">javaClientGenerator.targetPackage</span>=<span class="string">org.woodwhales.king.user.mapper</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#mapping location</span></span><br><span class="line"><span class="attr">sqlMapGenerator.targetProject</span>=<span class="string">src/main/resources</span></span><br><span class="line"><span class="attr">sqlMapGenerator.targetPackage</span>=<span class="string">mapper.user</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tableName</span>=<span class="string">hello</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：配置的目录需要提前手动创建出来。</p>
<h5 id="2-4-运行-mybatis-逆向工程"><a href="#2-4-运行-mybatis-逆向工程" class="headerlink" title="2.4 运行 mybatis 逆向工程"></a>2.4 运行 mybatis 逆向工程</h5><p>在项目根目录右击选择<code>"Show in"</code>中的<code>"Terminal"</code>选项，进入 dos 窗口，执行逆向生成命令：<code>mvn mybatis-generator:generate</code></p>
<p>项目生成之后，需要刷新项目。</p>
<h5 id="2-5-mapper-接口既映射文件注册配置"><a href="#2-5-mapper-接口既映射文件注册配置" class="headerlink" title="2.5 mapper 接口既映射文件注册配置"></a>2.5 mapper 接口既映射文件注册配置</h5><p>将 mapper 接口注册到 springboot 中，在要注册的类上增加<code>@Mapper</code>注解，或者使用包扫描的方式进行注册：在启动类上增加<code>@MapperScan(basePackages="org.woodwhale.demo.mapper")</code>，强烈推荐第二种。</p>
<p>将 mapper 映射的 xml 文件注册到 springboot：在<code>application.yml</code>配置文件中增加映射文件扫描：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:org/woodwhale/demo/mapper/*Mapper.xml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="三、MyBatis-Generator-详解"><a href="#三、MyBatis-Generator-详解" class="headerlink" title="三、MyBatis Generator 详解"></a>三、MyBatis Generator 详解</h4><p>MyBatis Generator中文文档地址：<code>mbg.cndocs.ml</code></p>
<p>注：本文后面提到的<strong>MBG</strong>全部指代<code>MyBatis Generator</code>。</p>
<h5 id="3-1-XML-配置详解"><a href="#3-1-XML-配置详解" class="headerlink" title="3.1 XML 配置详解"></a>3.1 XML 配置详解</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="3-2-根节点"><a href="#3-2-根节点" class="headerlink" title="3.2 根节点"></a>3.2 根节点<generatorconfiguration></generatorconfiguration></h5><p><code>&lt;generatorConfiguration&gt;</code>节点没有任何属性，直接写节点即可，如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!-- 具体配置内容 --&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><code>&lt;generatorConfiguration&gt;</code>元素的子元素包含以下子元素（有严格的顺序）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;properties&gt;（0 个或 1 个）</span><br><span class="line">&lt;classPathEntry&gt;（0 个或 1 个）</span><br><span class="line">&lt;context&gt;（1 个或多个）</span><br></pre></td></tr></tbody></table></figure>

<h4 id="四、元素"><a href="#四、元素" class="headerlink" title="四、元素"></a>四、<properties>元素</properties></h4><p>这个元素用来指定外部的属性元素，不是必须的元素。</p>
<p>元素用于指定一个需要在配置中解析使用的外部属性文件，引入属性文件后，可以在配置中使用<code>${property}</code>这种形式的引用，通过这种方式引用属性文件中的属性值，如配置<code>jdbc 信息</code>和<code>targetProject 属性</code>。</p>
<p>这个元素的属性可以通过<code>resource</code>或者<code>url</code>来指定属性文件的位置，这两个属性只能使用其中一个来指定，如果同时使用就会报错。</p>
<ul>
<li><code>resource</code>：指定 <strong>classpath</strong> 下的属性文件，使用类似<code>com/myproject/generatorConfig.properties</code>这样的属性值。</li>
<li><code>url</code>：可以指定文件系统上的特定位置，例如<code>file://C:/myfolder/generatorConfig.properties</code>。</li>
</ul>
<h4 id="五、元素"><a href="#五、元素" class="headerlink" title="五、元素"></a>五、<classpathentry>元素</classpathentry></h4><p>这个元素可以是 0 或多个。最常见的用法是通过这个属性指定驱动的路径，例如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;classPathEntry location="C:\mysql-connector-java-5.1.42.jar"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>注意：如果你需要加载其他用途的 jar 包，<strong>classPathEntry 起不到作用</strong>，解决的办法就是将你用的 jar 包添加到类路径中，在 Eclipse 等 IDE 中运行的时候，添加jar包比较容易。当从命令行执行的时候，需要用<code>java -cp xx.jar,xx2.jar xxxMainClass</code>这种方式在<code>-cp</code>后面指定来使用（注意<code>-jar</code>会导致<code>-cp</code>无效）。</p>
<h4 id="六、元素"><a href="#六、元素" class="headerlink" title="六、元素"></a>六、<context>元素</context></h4><p>在 MBG 的配置中，至少需要有一个<code>&lt;context&gt;</code>元素。</p>
<p><code>&lt;context&gt;</code>元素用于指定生成一组对象的环境。例如指定要连接的数据库，要生成对象的类型和要处理的数据库中的表。运行MBG的时候还可以指定要运行的<code>&lt;context&gt;</code>。</p>
<p>该元素只有一个<strong>必选属性</strong>：</p>
<ul>
<li><code>id</code>：用来唯一确定一个<code>&lt;context&gt;</code>元素，该<code>id</code>属性可以在运行 MBG 的使用。</li>
</ul>
<p>此外还有几个<strong>可选属性</strong>：</p>
<ul>
<li><p><code>defaultModelType</code></p>
<p><strong>这个属性很重要</strong>，这个属性定义了 MBG 如何生成<strong>实体类</strong>。</p>
</li>
<li><p><code>conditional</code>：默认值，这个模型和下面的<code>hierarchical</code>类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此，如果一个表的主键只有一个字段，那么不会为该字段生成单独的实体类，会将该字段合并到基本实体类中。</p>
</li>
<li><p><code>flat</code>：该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。<strong>这种模型最简单，推荐使用。</strong></p>
</li>
<li><p><code>hierarchical</code>：如果表有主键，那么该模型会产生一个单独的主键实体类，如果表还有 BLOB 字段，则会为表生成一个包含所有 BLOB 字段的单独的实体类，然后为所有其他的字段生成一个单独的实体类。MBG 会在所有生成的实体类之间维护一个继承关系。</p>
</li>
<li><p><code>targetRuntime</code>：此属性用于指定生成的代码的运行时环境。该属性支持以下可选值：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">MyBatis3：默认值</span><br><span class="line">MyBatis3Simple</span><br><span class="line">Ibatis2Java2</span><br><span class="line">Ibatis2Java5：一般情况下使用默认值即可，有关这些值的具体作用以及区别请查看中文文档的详细内容。</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>introspectedColumnImpl</code>：该参数可以指定扩展<code>org.mybatis.generator.api.IntrospectedColumn</code>该类的实现类。该属性的作用可以查看扩展 MyBatis Generator。</p>
</li>
</ul>
<blockquote>
<p>扩展 MyBatis Generator：<br><code> http://mbg.cndocs.ml/reference/extending.html</code></p>
</blockquote>
<p>一般情况下，我们使用如下的配置即可：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;context id="Mysql" defaultModelType="flat"&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>如果你希望不生成和<code>Example</code>查询有关的内容，那么可以按照如下进行配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;context id="Mysql" targetRuntime="MyBatis3Simple" defaultModelType="flat"&gt;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：使用<code>MyBatis3Simple</code>可以避免在后面的<code>&lt;table&gt;</code>中逐个进行配置（后面会提到）。</p>
</blockquote>
<p><strong><context>元素的子元素</context></strong></p>
<p>MBG 配置中的其他几个元素，基本上都是<code>&lt;context&gt;</code>的子元素，这些子元素（<strong>有严格的配置顺序</strong>）包括：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;property&gt;（0 个或多个）</span><br><span class="line">&lt;plugin&gt;（0 个或多个）</span><br><span class="line">&lt;commentGenerator&gt;（0 个或 1 个）</span><br><span class="line">&lt;jdbcConnection&gt;（1 个）</span><br><span class="line">&lt;javaTypeResolver&gt;（0 个或 1 个）</span><br><span class="line">&lt;javaModelGenerator&gt;（1 个）</span><br><span class="line">&lt;sqlMapGenerator&gt;（0 个或 1 个）</span><br><span class="line">&lt;javaClientGenerator&gt;（0 个或 1 个）</span><br><span class="line">&lt;table&gt;（1 个或多个）</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-1-属性"><a href="#6-1-属性" class="headerlink" title="6.1 属性"></a>6.1 <property>属性</property></h5><p><code>&lt;property&gt;</code>属性比较特殊，后面讲解的时候都会和父元素一起进行讲解。</p>
<blockquote>
<p>在讲解<code>&lt;property&gt;</code>属性前，我们先看看一个重要的概念：<strong>分隔符</strong></p>
<p>这里通过一个例子说明。假设在 Mysql 数据库中有一个表名为<code>user info</code>，你没有看错，中间是一个空格，这种情况下如果写出<code>select * from user info</code>这样的语句，肯定是要报错的，在 Mysql 中的时候我们一般会写成如下的样子：</p>
<p>select * from `user info`</p>
<p>这里的使用的<strong>反单引号( ` )<strong>就是</strong>分隔符</strong>，<strong>分隔符</strong>可以用于<strong>表名</strong>或者<strong>列名</strong>。</p>
</blockquote>
<p>下面继续看<code>&lt;property&gt;</code>支持的属性：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">autoDelimitKeywords</span><br><span class="line">beginningDelimiter</span><br><span class="line">endingDelimiter</span><br><span class="line">javaFileEncoding</span><br><span class="line">javaFormatter</span><br><span class="line">xmlFormatter</span><br></pre></td></tr></tbody></table></figure>

<p>首先是<code>autoDelimitKeywords</code>，当表名或者字段名为 SQL 关键字的时候，可以设置该属性为 true，MBG 会自动给表名或字段名添加<strong>分隔符</strong>。</p>
<p>由于<code>beginningDelimiter</code>和<code>endingDelimiter</code>的默认值为双引号（”），在 Mysql 中不能这么写，所以还要将这两个默认值改为反单引号（`），配置如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;property name="beginningDelimiter" value="`"/&gt;</span><br><span class="line">&lt;property name="endingDelimiter" value="`"/&gt; </span><br></pre></td></tr></tbody></table></figure>

<p>属性<code>javaFileEncoding</code>设置要使用的 Java 文件的编码，默认使用当前平台的编码，只有当生产的编码需要特殊指定时才需要使用，一般用不到。</p>
<p>最后两个<code>javaFormatter</code>和<code>xmlFormatter</code>属性<strong>可能会</strong>很有用，如果你想使用模板来定制生成的 Java 文件和 xml 文件的样式，你可以通过指定这两个属性的值来实现。</p>
<p>接下来分节对其他的子元素逐个进行介绍。</p>
<h5 id="6-2-元素"><a href="#6-2-元素" class="headerlink" title="6.2 元素"></a>6.2 <plugin>元素</plugin></h5><p>该元素可以配置 0 个或者多个。<code>&lt;plugin&gt;</code>元素用来定义一个插件。插件用于扩展或修改通过 MyBatis Generator (MBG) 代码生成器生成的代码。插件将按在配置中配置的顺序执行。</p>
<blockquote>
<p>有关插件的详细信息可以参考开发插件和提供的插件了解更多。<br>开发插件：<code>http://mbg.cndocs.ml/reference/pluggingIn.html</code><br>提供的插件：<code>http://mbg.cndocs.ml/reference/plugins.html</code></p>
</blockquote>
<h5 id="6-3-元素"><a href="#6-3-元素" class="headerlink" title="6.3 元素"></a>6.3 <commentgenerator>元素</commentgenerator></h5><p>该元素最多可以配置1个。这个元素非常有用，相信很多人都有过这样的需求，就是希望 MBG 生成的代码中可以包含<strong>注释信息</strong>，具体就是生成表或字段的备注信息。</p>
<p>使用这个元素就能很简单的实现我们想要的功能。这里先介绍该元素，介绍完后会举例如何扩展实现该功能。</p>
<p>该元素有一个可选属性 type，可以指定用户的实现类，该类需要实现<code>org.mybatis.generator.api.CommentGenerator</code>接口。而且必有一个默认的构造方法。这个属性接收默认的特殊值 DEFAULT，会使用默认的实现类<code>org.mybatis.generator.internal.DefaultCommentGenerator</code>。</p>
<p>默认的实现类中提供了两个可选属性，需要通过<code>&lt;property&gt;</code>属性进行配置。</p>
<p><code>suppressAllComments</code>：<strong>阻止</strong>生成注释，默认为 false</p>
<p><code>suppressDate</code>：<strong>阻止</strong>生成的注释包含时间戳，默认为 false</p>
<p>一般情况下由于 MBG 生成的注释信息没有任何价值，而且有时间戳的情况下每次生成的注释都不一样，使用<strong>版本控制</strong>的时候每次都会提交，因而一般情况下我们都会屏蔽注释信息，可以如下配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;commentGenerator&gt;</span><br><span class="line">    &lt;property name="suppressAllComments" value="true"/&gt;</span><br><span class="line">    &lt;property name="suppressDate" value="true"/&gt;</span><br><span class="line">&lt;/commentGenerator&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们简单举例实现生成包含表字段注释信息的注释：</p>
<p>因为系统提供了一个默认的实现类，所以对我们来说，自己实现一个会很容易，最简单的方法就是复制默认实现类代码到一个新的文件中，修改类名如<code>MyCommentGenerator</code>，在你自己的实现类中，你可以选择是否继续支持上面的两个属性，你还可以增加对其他属性的支持。</p>
<p>我们通过下面一个方法的修改来了解，其他几个方法请自行修改(写本章的时候我也没有完全实现该类，所以不提供完整源码了)：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFieldComment</span><span class="params">(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (introspectedColumn.getRemarks() != <span class="literal">null</span> &amp;&amp; !introspectedColumn.getRemarks().equals(<span class="string">""</span>)) {</span><br><span class="line">        field.addJavaDocLine(<span class="string">"/**"</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">" * "</span> + introspectedColumn.getRemarks());</span><br><span class="line">        addJavadocTag(field, <span class="literal">false</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">" */"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个方法是给字段添加注释信息的，其中<code>IntrospectedColumn</code>包含了字段的完整信息，通过<code>getRemarks</code>方法可以获取字段的注释信息。上面这个方法修改起来还是很容易的。除了字段的注释外还有 Getter 和 Setter，以及类的注释。此外还有生成 XML 的注释，大家可以根据默认的实现进行修改。</p>
<p>完成我们自己的实现类后，我们还需要做<code>&lt;commentGenerator&gt;</code>元素配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;commentGenerator type="com.github.abel533.mybatis.generator.MyCommentGenerator"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-4-元素"><a href="#6-4-元素" class="headerlink" title="6.4 元素"></a>6.4 <jdbcconnection>元素</jdbcconnection></h5><p><code>&lt;jdbcConnection&gt;</code>用于指定数据库连接信息，<strong>该元素必选，且只能有一个</strong>。</p>
<p>配置该元素只需要注意如果 JDBC 驱动不在 classpath 下，就需要通过<code>&lt;classPathEntry&gt;</code>元素引入 jar 包，这里推荐将 jar 包放到 classpath 下。</p>
<p>该元素<strong>有两个必选属性</strong>：</p>
<ul>
<li><code>driverClass</code>：访问数据库的 JDBC 驱动程序的完全限定类名</li>
<li><code>connectionURL</code>：访问数据库的 JDBC 连接 URL</li>
</ul>
<p>该元素还有<strong>两个可选属性</strong>:</p>
<ul>
<li><code>userId</code>：访问数据库的用户 ID</li>
<li><code>password</code>：访问数据库的密码</li>
</ul>
<p>此外该元素还可以接受多个<code>&lt;property&gt;</code>子元素，这里配置的<code>&lt;property&gt;</code>属性都会添加到 JDBC 驱动的属性中。</p>
<p>这个元素配置起来最容易，这里举个简单例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;jdbcConnection driverClass="com.mysql.jdbc.Driver"</span><br><span class="line">                connectionURL="jdbc:mysql://localhost:3306/test"</span><br><span class="line">                userId="root"</span><br><span class="line">                password="root"&gt;</span><br><span class="line">&lt;/jdbcConnection&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-5-元素"><a href="#6-5-元素" class="headerlink" title="6.5 元素"></a>6.5 <javatyperesolver>元素</javatyperesolver></h5><p>该元素最多可以配置一个。这个元素的配置用来指定 JDBC 类型和 Java 类型如何转换。</p>
<p>该元素提供了一个可选的属<code>type</code>和<code>&lt;commentGenerator&gt;</code>比较类型，提供了默认的实现 DEFAULT，一般情况下使用默认即可，需要特殊处理的情况可以通过其他元素配置来解决，不建议修改该属性。</p>
<p>该属性还有一个可以配置的<code>&lt;property&gt;</code>元素。</p>
<p>可以配置的属性为<code>forceBigDecimals</code>，该属性可以控制是否强制 DECIMAL 和 NUMERIC 类型的字段转换为 Java 类型的<code>java.math.BigDecimal</code>，默认值为 false，一般不需要配置。</p>
<p>默认情况下的转换规则为：</p>
<p>如果精度 &gt; 0 或者长度 &gt; 18，就会使用<code>java.math.BigDecimal</code><br>如果精度 = 0 并且 10 &lt;= 长度 &lt;= 18，就会使用<code>java.lang.Long</code><br>如果精度 = 0 并且5 &lt;= 长度 &lt;= 9，就会使用<code>java.lang.Integer</code><br>如果精度 = 0 并且 长度 &lt; 5，就会使用<code>java.lang.Short</code></p>
<p>如果设置为 true，那么一定会使用<code>java.math.BigDecimal</code>，</p>
<p><code>&lt;javaTypeResolver&gt;</code>元素配置示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;javaTypeResolver &gt;</span><br><span class="line">    &lt;property name="forceBigDecimals" value="true" /&gt;</span><br><span class="line">&lt;/javaTypeResolver&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-6-元素"><a href="#6-6-元素" class="headerlink" title="6.6 元素"></a>6.6 <javamodelgenerator>元素</javamodelgenerator></h5><p>该元素必须配置一个，并且最多一个。该元素用来控制生成的实体类，根据<code>&lt;context&gt;</code>中配置的<code>defaultModelType</code>，一个表可能会对应生成多个不同的实体类。一个表对应多个类实际上并不方便，所以前面也推荐使用 flat，这种情况下一个表对应一个实体类。</p>
<p>该元素只有<strong>两个必选属性</strong>：</p>
<ul>
<li><code>targetPackage</code>：生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响（ 中会提到）。<li><code>targetProject</code>：指定目标项目路径，可以是绝对路径或相对路径（如<code>targetProject="src/main/java"</code>）。</li><p>该元素支持以下几个**<property>子元素属性**：</property></p><ul>
<li><p><code>constructorBased</code>：该属性只对 MyBatis3 有效，如果 true 就会使用构造方法入参，如果 false 就会使用 setter方式。默认为 false。</p>
</li>
<li><p><code>enableSubPackages</code>：如果 true，MBG 会根据 catalog 和 schema 来生成子包。如果 false 就会直接用 targetPackage 属性。默认为false。</p>
</li>
<li><p><code>immutable</code>：该属性用来配置实体类属性是否可变，如果设置为 true，那么 constructorBased 不管设置成什么，都会使用构造方法入参，并且不会生成 setter 方法。如果为 false，实体类属性就可以改变。默认为 false。</p>
</li>
<li><p><code>rootClass</code>：设置所有实体类的基类。如果设置，需要使用类的全限定名称。并且如果 MBG 能够加载rootClass，那么 MBG 不会覆盖和父类中完全匹配的属性。匹配规则：</p>
<figure class="highlight plaintext"></figure></li></ul><table>



</table><table><tbody><tr><td class="code"><pre><span class="line">属性名完全相同</span><br><span class="line">属性类型相同</span><br><span class="line">属性有getter方法</span><br><span class="line">属性有setter方法</span><br></pre></td></tr></tbody></table>
</li>
<li><p><code>trimStrings</code>：是否对数据库查询结果进行 trim 操作，如果设置为 true 就会生成类似这样</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">public void setUsername(String username) {</span><br><span class="line">  this.username = username == null ? null : username.trim();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>的 setter 方法。默认值为 false。</p>
</li>
</ul>
<p><code>&lt;javaModelGenerator&gt;</code>元素配置示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;javaModelGenerator targetPackage="test.model" targetProject="src\main\java"&gt;</span><br><span class="line">    &lt;property name="enableSubPackages" value="true" /&gt;</span><br><span class="line">    &lt;property name="trimStrings" value="true" /&gt;</span><br><span class="line">&lt;/javaModelGenerator&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-7-元素"><a href="#6-7-元素" class="headerlink" title="6.7 元素"></a>6.7 <sqlmapgenerator>元素</sqlmapgenerator></h5><p>该元素可选，最多配置一个。但是有如下两种必选的特殊情况：</p>
<ul>
<li>如果<code>targetRuntime</code>目标是 <strong>iBATIS2</strong>，该元素必须配置一个。如果<code>targetRuntime</code>目标是 <strong>MyBatis3</strong>，只有当<code>&lt;javaClientGenerator&gt;</code>需要XML时，该元素必须配置一个。</li>
<li>如果没有配置 <javaclientgenerator>，则使用以下的规则：<br>如果指定了一个 <sqlmapgenerator>，那么 MBG 将只生成 XML 的 SQL 映射文件和实体类。如果没有指定 <sqlmapgenerator>，那么 MBG 将只生成实体类。</sqlmapgenerator></sqlmapgenerator></javaclientgenerator></li>
</ul>
<p>该元素只有<strong>两个必选属性</strong>（和前面提过的<code>&lt;javaModelGenerator&gt;</code>的属性含义一样）：</p>
<ul>
<li><code>targetPackage</code>：生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(中会提到)。<li><code>targetProject</code>：指定目标项目路径，可以是绝对路径或相对路径（如：<code>targetProject="src/main/resources"</code>）。</li><p>该元素支持<code>&lt;property&gt;</code>子元素，只有一个可以配置的属性：</p><ul>
<li><code>enableSubPackages</code>：如果 true，MBG 会根据 catalog 和 schema 来生成子包。如果 false 就会直接用 targetPackage 属性。默认为 false。</li>
</ul><p><code>&lt;sqlMapGenerator&gt;</code>元素配置示例：</p><figure class="highlight plaintext"></figure><table>





</table><table><tbody><tr><td class="code"><pre><span class="line">&lt;sqlMapGenerator targetPackage="test.xml"  targetProject="src\main\resources"&gt;</span><br><span class="line">    &lt;property name="enableSubPackages" value="true" /&gt;</span><br><span class="line">&lt;/sqlMapGenerator&gt;</span><br></pre></td></tr></tbody></table>

<h5 id="6-8-元素"><a href="#6-8-元素" class="headerlink" title="6.8 元素"></a>6.8 <javaclientgenerator>元素</javaclientgenerator></h5><p>该元素可选，最多配置一个，如果不配置该元素，就不会生成 Mapper 接口。</p>
<p>该元素有 <strong>3 个必选属性</strong>：</p>
<ol>
<li><p><code>type</code>：该属性用于选择一个预定义的客户端代码（可以理解为 Mapper 接口）生成器，用户可以自定义实现，需要继承<code>org.mybatis.generator.codegen.AbstractJavaClientGenerator</code>类，必选有一个默认的构造方法。 该属性提供了以下预定的代码生成器，首先根据<code>&lt;context&gt;</code>的 targetRuntime 分成三类：</p>
<p><strong>1. MyBatis3类：</strong><br><code>ANNOTATEDMAPPER</code>：基于注解的 Mapper 接口，不会有对应的 XML 映射文件。<br><code>MIXEDMAPPER</code>：XML 和注解的混合形式，（上面这种情况中的）SqlProvider 注解方法会被 XML 替代。<br><code>XMLMAPPER</code>：所有的方法都在 XML 中，接口调用依赖 XML 文件。</p>
<p><strong>2. MyBatis3Simple类：</strong><br><code>ANNOTATEDMAPPER</code>：基于注解的 Mapper 接口，不会有对应的 XML 映射文件。<br><code>XMLMAPPER</code>：所有的方法都在 XML 中，接口调用依赖 XML 文件。</p>
<p><strong>3. Ibatis2Java2或Ibatis2Java5类：</strong><br><code>IBATIS</code>：生成的对象符合iBATIS的DAO框架（不建议使用）。<br><code>GENERIC-CI</code>：生成的对象将只依赖于SqlMapClient，通过构造方法注入。<br><code>GENERIC-SI</code>：生成的对象将只依赖于SqlMapClient，通过setter方法注入。<br><code>SPRING</code>：生成的对象符合Spring的DAO接口。</p>
</li>
<li><p><code>targetPackage</code>：生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响（中会提到）。<p></p><li><p><code>targetProject</code>：指定目标项目路径，可以是绝对路径或相对路径（如：<code>targetProject="src/main/java"</code>）。</p>
</li><p>该元素还有<strong>一个可选属性</strong>：</p><ul>
<li><p><code>implementationPackage</code>：如果指定了该属性，实现类就会生成在这个包中。</p>
<p>该元素支持<code>&lt;property&gt;</code>子元素设置的属性：</p>
<figure class="highlight plaintext"></figure></li></ul><table>




</table><table><tbody><tr><td class="code"><pre><span class="line">enableSubPackages</span><br><span class="line">exampleMethodVisibility</span><br><span class="line">methodNameCalculator</span><br><span class="line">rootInterface</span><br><span class="line">useLegacyBuilder</span><br></pre></td></tr></tbody></table></p></li>
</ol></li></ul>
<p>这几个<code>&lt;property&gt;</code>子元素属性不太常用，具体作用请看完整的文档，这里对<code>rootInterface</code>做个简单介绍：</p>
<ul>
<li><code>rootInterface</code>：用于指定一个所有生成的接口都继承的父接口。 这个值可以通过<code>&amp;lt;table\&amp;gt;</code>配置的<code>rootInterface</code>属性覆盖。这个属性对于通用 Mapper 来说，可以让生成的所有接口都继承该接口。</li>
</ul>
<p><code>&lt;javaClientGenerator&gt;</code>元素配置示例：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;javaClientGenerator type="XMLMAPPER" targetPackage="test.dao" targetProject="src\main\java"/&gt;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="6-9-元素"><a href="#6-9-元素" class="headerlink" title="6.9 元素"></a>6.9 元素<p>该元素至少要配置一个。该元素用来配置要通过内省的表。只有配置的才会生成实体类和其他文件。</p><p>该元素有一个<strong>必选属性</strong>：</p><ul>
<li><p><code>tableName</code>：指定要生成的表名，可以使用 SQL 通配符匹配多个表。</p>
<p>例如要生成全部的表，可以按如下配置：<code>&lt;table tableName="%" /&gt;</code></p>
</li>
</ul><p>该元素包含多个<strong>可选属性</strong>：</p><ul>
<li><code>schema</code>：数据库的 schema，可以使用 SQL 通配符匹配。如果设置了该值，生成 SQL 的表名会变成如 schema.tableName 的形式。</li>
<li><code>catalog</code>：数据库的 catalog，如果设置了该值，生成 SQL 的表名会变成如 catalog.tableName 的形式。</li>
<li><code>alias</code>：如果指定，这个值会用在生成的 select 查询 SQL 的表的别名和列名上。 列名会被别名为 alias_actualColumnName（别名_实际列名）这种模式。</li>
<li><code>domainObjectName</code>：生成对象的基本名称。如果没有指定，MBG 会自动根据表名来生成名称。</li>
<li><code>enableXXX</code>：XXX 代表多种 SQL 方法，该属性用来指定是否生成对应的 XXX 语句。</li>
<li><code>selectByPrimaryKeyQueryId</code>：DBA 跟踪工具会用到，具体请看详细文档。</li>
<li><code>selectByExampleQueryId</code>：DBA 跟踪工具会用到，具体请看详细文档。</li>
<li><code>modelType</code>：和<code>&lt;context&gt;</code>的<code>defaultModelType</code>含义一样，这里可以针对表进行配置，这里的配置会覆盖<code>&lt;context&gt;</code>的<code>defaultModelType</code>配置。</li>
<li><code>escapeWildcards</code>：这个属性表示当查询列，是否对 schema 和表名中的 SQL 通配符 （’_’ and ‘%’）进行转义。 对于某些驱动当 schema 或表名中包含 SQL 通配符时（例如，一个表名是 MY_TABLE，有一些驱动需要将下划线进行转义）是必须的。默认值是 false。</li>
<li><code>delimitIdentifiers</code>：是否给标识符增加<strong>分隔符</strong>。默认 false。当 catalog，schema 或 tableName 中包含空白时，默认为true。</li>
<li><code>delimitAllColumns</code>：是否对所有列添加<strong>分隔符</strong>。默认 false。</li>
</ul><p>该元素包含多个可用的<code>&lt;property&gt;</code>子元素，<strong>可选属性</strong>为：</p><ul>
<li><code>constructorBased</code>：和<javamodelgenerator>中的属性含义一样。</javamodelgenerator></li>
<li><code>ignoreQualifiersAtRuntime</code>：生成的 SQL 中的表名将不会包含 schema 和 catalog 前缀。</li>
<li><code>immutable</code>：和<javamodelgenerator>中的属性含义一样。</javamodelgenerator></li>
<li><code>modelOnly</code>：此属性用于配置是否为表只生成实体类。如果设置为 true 就不会有 Mapper 接口。如果配置了<sqlmapgenerator>，并且 modelOnly 为 true，那么 XML 映射文件中只有实体对象的映射元素（ <resultmap>）。如果为 true 还会覆盖属性中的 enableXXX 方法，将不会生成任何 CRUD 方法。</resultmap></sqlmapgenerator></li>
<li><code>rootClass</code>：和<javamodelgenerator>中的属性含义一样。</javamodelgenerator></li>
<li><code>rootInterface</code>：和<javaclientgenerator>中的属性含义一样。</javaclientgenerator></li>
<li><code>runtimeCatalog</code>：运行时的 catalog，当生成表和运行环境的表的 catalog 不一样的时候可以使用该属性进行配置。</li>
<li><code>runtimeSchema</code>：运行时的 schema，当生成表和运行环境的表的 schema 不一样的时候可以使用该属性进行配置。</li>
<li><code>runtimeTableName</code>：运行时的 tableName，当生成表和运行环境的表的 tableName 不一样的时候可以使用该属性进行配置。</li>
<li><code>selectAllOrderByClause</code>：该属性值会追加到 selectAll 方法后的 SQL 中，会直接跟 order by 拼接后添加到 SQL 末尾。</li>
<li><code>useActualColumnNames</code>：如果设置为 true，那么 MBG 会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为 false（默认值），MGB 将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过 元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。</li>
<li><code>useColumnIndexes</code>：如果是 true，MBG 生成 resultMaps 的时候会使用列的索引,而不是结果中列名的顺序。</li>
<li><code>useCompoundPropertyNames</code>：如果是 true，那么 MBG 生成属性名的时候会将列名和列备注接起来。这对于那些通过第四代语言自动生成列（例如：FLD22237），但是备注包含有用信息（例如：”customer id”）的数据库来说很有用。在这种情况下，MBG 会生成属性名 FLD2237_CustomerId。</li>
</ul><h5 id="6-10-子元素"><a href="#6-10-子元素" class="headerlink" title="6.10 子元素"></a>6.10 </h5><table>






</table><p>除了<code>&lt;property&gt;</code>子元素外，<code>&lt;table&gt;</code>还包含以下子元素：</p><figure class="highlight plaintext"></figure><table>
</table>子元素<table><tbody><tr><td class="code"><pre><span class="line">&lt;generatedKey&gt; (0 个或 1 个)</span><br><span class="line">&lt;columnRenamingRule&gt; (0 个或 1 个)</span><br><span class="line">&lt;columnOverride&gt; (0 个或多个)</span><br><span class="line">&lt;ignoreColumn&gt; (0 个或多个)</span><br></pre></td></tr></tbody></table>

<p>下面对这 4 个元素进行详细讲解。</p>
<p><strong>6.10.1 <generatedkey> 元素</generatedkey></strong></p>
<p>这个元素最多可以配置一个。这个元素用来指定自动生成主键的属性（identity 字段或者 sequences 序列）。如果指定这个元素，MBG 在生成 insert 的 SQL 映射文件中插入一个<code>&lt;selectKey&gt;</code>元素。 这个元素非常重要。</p>
<p>这个元素包含下面<strong>两个必选属性</strong>：</p>
<ul>
<li><p><code>column</code>：生成列的列名。</p>
</li>
<li><p><code>sqlStatement</code>：将返回新值的 SQL 语句。如果这是一个 identity 列，您可以使用其中一个预定义的的特殊值。预定义值如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Cloudscape</span><br><span class="line">DB2</span><br><span class="line">DB2_MF</span><br><span class="line">Derby</span><br><span class="line">HSQLDB</span><br><span class="line">Informix</span><br><span class="line">MySql</span><br><span class="line">SqlServer</span><br><span class="line">SYBASE</span><br><span class="line">JDBC</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<blockquote>
<p>JDBC：这会配置 MBG 使用 MyBatis3 支持的 JDBC 标准的生成 key 来生成代码。 这是一个独立于数据库获取标识列中的值的方法。</p>
<p>重要：只有当目标运行为 MyBatis3 时才会产生正确的代码。如果与 iBATIS2 一起使用目标运行时会产生运行时错误的代码。</p>
</blockquote>
<p>这个元素还包含<strong>两个可选属性</strong>：</p>
<ul>
<li><code>identity</code>：当设置为true时,该列会被标记 为identity 列， 并且<code>&lt;selectKey&gt;</code>元素会被插入在 insert 后面。 当设置为false时，<code>&lt;selectKey&gt;</code>会插入到 insert 之前（通常是序列）。<strong>重要</strong>：即使您 type 属性指定为 post，您仍然需要为 identity 列将该参数设置为 true。 这将标志 MBG 从插入列表中删除该列。默认值是 false。</li>
<li><code>type</code>：type = post and identity = true 的时候生成的<code>中的 order=AFTER，当 type=pre 的时候，identity 只能为 false，生成的</code>中的 order = BEFORE。可以这么理解，自动增长的列只有插入到数据库后才能得到 ID，所以是 AFTER，使用序列时，只有先获取序列之后，才能插入数据库，所以是：BEFORE。</li>
</ul>
&nbsp;元素配置示例一：

<figure class="highlight plaintext"></figure><table></table><table><tbody><tr><td class="code"><pre><span class="line">&lt;table tableName="user login info" domainObjectName="UserLoginInfo"&gt;</span><br><span class="line">    &lt;generatedKey column="id" sqlStatement="Mysql"/&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table>

<p>对应的生成的结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;insert id="insert" parameterType="test.model.UserLoginInfo"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer"&gt;</span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into `user login info` (Id, username, logindate, loginip)</span><br><span class="line">    values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP}, #{loginip,jdbcType=VARCHAR})</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></tbody></table></figure>

&nbsp;元素配置示例二：

<figure class="highlight plaintext"></figure><table></table><table><tbody><tr><td class="code"><pre><span class="line">&lt;table tableName="user login info" domainObjectName="UserLoginInfo"&gt;</span><br><span class="line">    &lt;generatedKey column="id" sqlStatement="select SEQ_ID.nextval from dual"/&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table>

<p>对应的生成结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;insert id="insert" parameterType="test.model.UserLoginInfo"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" order="BEFORE" resultType="java.lang.Integer"&gt;</span><br><span class="line">        select SEQ_ID.nextval from dual</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    insert into `user login info` (Id, username, logindate, loginip)</span><br><span class="line">    values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{logindate,jdbcType=TIMESTAMP},#{loginip,jdbcType=VARCHAR})</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>6.10.2 <columnrenamingrule> 元素</columnrenamingrule></strong></p>
<p>该元素最多可以配置一个，使用该元素可以在生成列之前，对列进行重命名。这对那些存在同一前缀的字段想在生成属性名时去除前缀的表非常有用。 例如假设一个表包含以下的列：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CUST_BUSINESS_NAME</span><br><span class="line">CUST_STREET_ADDRESS</span><br><span class="line">CUST_CITY</span><br><span class="line">CUST_STATE</span><br></pre></td></tr></tbody></table></figure>

<p>生成的所有属性名中如果都包含<code>CUST</code>的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;columnRenamingRule searchString="^CUST_" replaceString="" /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>注意：在内部，MBG 使用<code>java.util.regex.Matcher.replaceAll</code>方法实现这个功能。请参阅有关该方法的文档和在 Java 中使用正则表达式的例子。</p>
<p>当<code>&lt;columnOverride&gt;</code>匹配一列时，这个元素（<code>&lt;columnRenamingRule&gt;</code>）会被忽略。<code>&lt;columnOverride&gt;</code>优先于重命名的规则。</p>
<p>该元素有一个<strong>必选属性</strong>：</p>
<ul>
<li><code>searchString</code>：定义将被替换的字符串的正则表达式。</li>
</ul>
<p>该元素有一个<strong>可选属性</strong>：</p>
<ul>
<li><code>replaceString</code>：这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。</li>
</ul>
<blockquote>
<p>关于<code>&lt;table&gt;</code>的<code>&lt;property&gt;</code>属性<code>useActualColumnNames</code>对此的影响可以查看完整文档。</p>
</blockquote>
<p><strong>6.10.3 <columnoverride> 元素</columnoverride></strong></p>
<p>该元素可选，可以配置多个。该元素从将某些属性默认计算的值更改为指定的值。</p>
<p>该元素有一个<strong>必选属性</strong>：</p>
<ul>
<li><code>column</code>：要重写的列名。</li>
</ul>
<p>该元素有多个<strong>可选属性</strong>：</p>
<ul>
<li><code>property</code>：要使用的 Java 属性的名称。如果没有指定，MBG 会根据列名生成。 例如，如果一个表的一列名为STRT_DTE，MBG会根据  的 useActualColumnNames 属性生成 STRT_DTE 或 strtDte。<li><code>javaType</code>：该列属性值为完全限定的 Java 类型。如果需要，这可以覆盖由JavaTypeResolver计算出的类型。 对某些数据库来说，这是必要的用来处理<strong>“奇怪的”</strong>数据库类型（例如 MySql 的 unsigned bigint 类型需要映射为<code>java.lang.Object</code>)。</li><li><code>jdbcType</code>：该列的 JDBC 类型（INTEGER, DECIMAL, NUMERIC, VARCHAR 等等）。 如果需要，这可以覆盖由 JavaTypeResolver 计算出的类型。 对某些数据库来说，这是必要的用来处理怪异的 JDBC 驱动 (例如 DB2 的LONGVARCHAR 类型需要为 iBATIS 映射为 VARCHAR)。</li><li><code>typeHandler</code>：用户定义的需要用来处理这列的类型处理器。它必须是一个继承 iBATIS 的 TypeHandler 类或 TypeHandlerCallback 接口（该接口很容易继承）的全限定的类名。如果没有指定或者是空白，iBATIS会用默认的类型处理器来处理类型。<strong>重要</strong>：MBG 不会校验这个类型处理器是否存在或者可用。 MGB 只是简单的将这个值插入到生成的 SQL 映射的配置文件中。</li><li><code>delimitedColumnName</code>：指定是否应在生成的 SQL 的列名称上增加<strong>分隔符</strong>。 如果列的名称中包含空格，MGB 会自动添加<strong>分隔符</strong>， 所以这个重写只有当列名需要强制为一个合适的名字或者列名是数据库中的保留字时是必要的。</li><p><code>&lt;columnOverride&gt;</code> 元素配置示例：</p><figure class="highlight plaintext"></figure><table>






</table><table><tbody><tr><td class="code"><pre><span class="line">&lt;table schema="DB2ADMIN" tableName="ALLTYPES" &gt;</span><br><span class="line">    &lt;columnOverride column="LONG_VARCHAR_FIELD" javaType="java.lang.String" jdbcType="VARCHAR" /&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table>

<p><strong>6.10.4 <ignorecolumn> 元素</ignorecolumn></strong></p>
<p>该元素可选，可以配置多个。该元素可以用来屏蔽不需要生成的列。</p>
<p>该元素有一个<strong>必选属性</strong>：</p>
<ul>
<li><code>column</code>：要忽略的列名。</li>
</ul>
<p>该元素还有一个<strong>可选属性</strong>：</p>
<ul>
<li><code>delimitedColumnName</code>：匹配列名的时候是否区分大小写。如果为 true 则区分。默认值为false，不区分大小写。</li>
</ul>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p><a href="https://blog.csdn.net/isea533/article/details/42102297">MyBatis Generator 详解</a></p>
<p><a href="http://www.mybatis.org/generator/configreference/xmlconfig.html">MyBatis GeneratorXML Configuration File Reference</a></p>
<p><a href="http://mbg.cndocs.ml/configreference/xmlconfig.html">MyBatis Generator XML 配置参考</a>(中文文档网址失效了，直接看上面官方文档)</p>
<p><a href="http://mbg.cndocs.ml/reference/extending.html">扩展 MyBatis Generator</a></p>
<p><a href="https://www.kancloud.cn/wizardforcel/java-opensource-doc/153024">从源码构建</a></p>
<p><a href="http://www.claredai.win/Mybatis-Generator.html">Mybatis Generator实现代码自动生成</a></p>
</li></ul></h5>]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ndoe.js安装及环境配置(for windows)</title>
    <url>/2019/01/13/016/</url>
    <content><![CDATA[<h4 id="一、下载安装"><a href="#一、下载安装" class="headerlink" title="一、下载安装"></a>一、下载安装</h4><h5 id="1-1-下载"><a href="#1-1-下载" class="headerlink" title="1.1 下载"></a>1.1 下载</h5><p><code>Ｎode.js</code>官网下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<h5 id="1-2-安装"><a href="#1-2-安装" class="headerlink" title="1.2 安装"></a>1.2 安装</h5><p>直接疯狂点击”下一步”，即可完成安装。</p>
<blockquote>
<p>本教程在安装向导中指定 node.js 的安装目录为：D:\programs\nodejs</p>
</blockquote>
<h5 id="1-3-检查是否安装-Node-js-成功"><a href="#1-3-检查是否安装-Node-js-成功" class="headerlink" title="1.3 检查是否安装 Node.js 成功"></a>1.3 检查是否安装 Node.js 成功</h5><p>运行<code>cmd</code>窗口，执行<code>node -v</code>命令查看已安装 node.js 的版本。</p>
<p>执行<code>npm -v</code>命令，查看已安装 npm 的版本。</p>
<p><img src="https://image.woodwhales.cn/016/images/1.png" alt="查看 node.js 和 npm 版本"></p>
<blockquote>
<p>说明：Node.js 安装中已经集成安装了 npm，npm 的作用就是对 Node.js 依赖的包进行管理，可以理解为用来安装/卸载 Node.js 需要装的东西。</p>
</blockquote>
<h4 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h4><blockquote>
<p>说明：环境配置主要配置的是 npm 安装的<code>全局模块所在路径</code>以及<code>缓存 cache 的路径</code>。</p>
<p>因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装命令时，会将安装的模块安装到默认路径中（C:\Users\用户名\AppData\Roaming\npm）路径中，会占用 C 盘空间。</p>
</blockquote>
<h5 id="2-1-全局及缓存安装路径配置"><a href="#2-1-全局及缓存安装路径配置" class="headerlink" title="2.1 全局及缓存安装路径配置"></a>2.1 全局及缓存安装路径配置</h5><p>因为 Node.js 安装的路径是：D:\programs\nodejs，所以将全局和缓存安装路径也配置在这个目录下，方便管理，在安装目录下创建<code>node_global</code>和<code>node_cache</code>空目录：</p>
<p><img src="https://image.woodwhales.cn/016/images/2.png" alt="创建全局及缓存安装目录"></p>
<h5 id="2-2-npm-配置"><a href="#2-2-npm-配置" class="headerlink" title="2.2 npm 配置"></a>2.2 npm 配置</h5><p>创建完两个空文件夹之后，打开 cmd 命令窗口，输入：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix "D:\programs\nodejs\node_global"</span><br><span class="line">npm config <span class="built_in">set</span> cache "D:\programs\nodejs\node_cache"</span><br></pre></td></tr></tbody></table></figure>

<p>查看 npm 配置命令：npm config list</p>
<p>查看 npm 所有配置命令：npm config list -l</p>
<blockquote>
<p>npm 本地安装与全局安装有什么区别？</p>
<p>npm install grunt     // 本地安装，则是将模块下载到当前命令行所在目录。<br>npm install -g grunt // 全局安装，模块将被下载安装到全局目录中。</p>
</blockquote>
<h5 id="2-3-系统环境变量配置"><a href="#2-3-系统环境变量配置" class="headerlink" title="2.3 系统环境变量配置"></a>2.3 系统环境变量配置</h5><p>“我的电脑” - “右键” - “属性” - “高级系统设置” - “高级” - “环境变量”</p>
<ol>
<li><p>进入环境变量对话框，在<strong>系统变量</strong>下新建：</p>
<p><code>NODE_PATH</code>，<code>D:\programs\nodejs\node_global\node_modules</code></p>
<p><img src="https://image.woodwhales.cn/016/images/3.png" alt="创建系统变量"></p>
</li>
<li><p>修改<strong>用户变量</strong>配置：</p>
<p><code>PATH</code>值修改为<code>D:\programs\nodejs\node_global</code></p>
<p><img src="https://image.woodwhales.cn/016/images/4.png" alt="修改用户变量"></p>
</li>
</ol>
<blockquote>
<p>注意：如果在用户变量中的<code>PATH</code>没有看到默认的 node.js 全局目录，那么说明没有安装好，需要重新卸载，重启电脑再安装一次。 </p>
</blockquote>
<h5 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h5><p>配置完后，安装个 module 测试下，我们就安装最常用的<code>express</code>模块，打开 cmd 窗口，<br>输入如下命令进行模块的全局安装：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">npm install express -g  # -g是全局安装的意思</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/016/images/5.png" alt="安装 express 模块"></p>
<p>查看全局模块可以看见刚刚安装成功的模块目录：</p>
<p><img src="https://image.woodwhales.cn/016/images/6.png" alt="查看已安装的全局模块"></p>
<h4 id="三、镜像配置"><a href="#三、镜像配置" class="headerlink" title="三、镜像配置"></a>三、镜像配置</h4><h5 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></tbody></table></figure>

<h5 id="配置-npm-淘宝镜像"><a href="#配置-npm-淘宝镜像" class="headerlink" title="配置 npm 淘宝镜像"></a>配置 npm 淘宝镜像</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></tbody></table></figure>

<p>检查 npm 镜像配置是否生效，查看所有 npm 配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm config ls</span><br></pre></td></tr></tbody></table></figure>

<h5 id="安装-cnpm"><a href="#安装-cnpm" class="headerlink" title="安装 cnpm"></a>安装 cnpm</h5><p>可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></tbody></table></figure>

<h5 id="安装-yarn"><a href="#安装-yarn" class="headerlink" title="安装 yarn"></a>安装 yarn</h5><p>使用 npm 安装 yarn：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></tbody></table></figure>

<p>查看 yarn 版本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yarn --version</span><br></pre></td></tr></tbody></table></figure>

<p>yarn 配置淘宝镜像：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yarn config set registry https://registry.npmmirror.com -g</span><br><span class="line">yarn config set sass_binary_site https://registry.npmmirror.com/mirrors/node-sass -g</span><br></pre></td></tr></tbody></table></figure>





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Ndoe.js</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML 语法之时序图</title>
    <url>/2019/01/13/017/</url>
    <content><![CDATA[<p>plantUML 下载(含《plantUML语法指南手册》)：<a href="http://plantuml.com/download">http://plantuml.com/download</a></p>
<p>本站下载：<a href="https://image.woodwhales.cn/017/PlantUML_Language_Reference_Guide.pdf">官方指南英文版</a></p>
<p>plantUML 在线生成器：<a href="http://www.plantuml.com/plantuml">online demo server</a></p>
<p>Visual Studio Code 安装 plantUML 插件，在插件应用商店中搜索：PlantUML，点击安装即可。</p>
<blockquote>
<p>快捷键：<br>Alt + D 即可快速预览，Ctrl + Shift + P 即可快速调出命令面板，选择”导出当前文件图表”即可导出成图片或者svg文件。</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/017/images/1.png" alt="VS Code 安装 PlantUML 插件"></p>
<p><strong>安装 graphviz</strong></p>
<p>使用 plantuml 画类图的时候还需要在 VS Code 中安装：Graphviz Preview， 如果还是不画类图，就需要安装<a href="https://graphviz.gitlab.io/download/">graphviz</a>。</p>
<p>下载zip 包，将zip包解压，并移动到固定目录（常用软件安装目录即可），复制graphviz 安装包目录下的 bin 目录下的 dot.exe文件的绝对路径，设置到系统的环境变量中：<br>在系统环境变量中曾加<code>GRAPHVIZ_DOT</code>的配置，重启 VS Code。</p>
<p>例如：dot运行文件路径是：<code>D:\programs\graphviz\bin\dot.exe</code>，在系统变量列表中创建一个：GRAPHVIZ_DOT：D:\programs\graphviz\bin\dot.exe 的键值对即可。</p>
<blockquote>
<p>VS Code 默认是英文系统，可安装”Chinese (Simplified) Language”中文语言插件。</p>
</blockquote>
<h4 id="一、简单例子"><a href="#一、简单例子" class="headerlink" title="一、简单例子"></a>一、简单例子</h4><p>消息流向使用 <code>-&gt;</code> 表示, 此时绘制出实线箭头; <code>--&gt;</code> 则绘制点线箭头。若要绘制反向消息流向, 可以使用 <code>&lt;-</code> 或 <code>&lt;--</code>。</p>
<p>注意：没有显示申明模块的类型，默认是矩形图形模块，并且随着代码的书写顺序进行从左向右的展示。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">模块1 -&gt; 模块2: Authentication Request</span><br><span class="line">模块2 --&gt; 模块1: Authentication Response</span><br><span class="line">模块1 -&gt; 模块2: Another authentication Request</span><br><span class="line">模块2 &lt;-- 模块1: another authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="二、申明例图（种类）"><a href="#二、申明例图（种类）" class="headerlink" title="二、申明例图（种类）"></a>二、申明例图（种类）</h4><p>由 <code>participant</code> 声明的参与者的图形是一个矩形，还可以由其它关键字声明一个参与者，不同的关键字声明的参与绘制时使用的图形是不一样的：</p>
<ul>
<li><code>participant</code></li>
<li><code>actor</code></li>
<li><code>boundary</code></li>
<li><code>control</code></li>
<li><code>entity</code></li>
<li><code>database</code></li>
<li><code>collections</code></li>
</ul>
<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgZGF0YS1kaWFncmFtLXR5cGU9IlNFUVVFTkNFIiBoZWlnaHQ9IjMyN3B4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6Mzg1cHg7aGVpZ2h0OjMyN3B4O2JhY2tncm91bmQ6I0ZGRkZGRjsiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDM4NSAzMjciIHdpZHRoPSIzODVweCIgem9vbUFuZFBhbj0ibWFnbmlmeSI+PGRlZnMvPjxnPjxnPjx0aXRsZT4mIzM1MjgyOyYjMzMzOTQ7PC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iMTY1LjY2NDEiIHdpZHRoPSI4IiB4PSIxNy45OTk5IiB5PSI4MS4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjIxIiB4Mj0iMjEiIHkxPSI4MS4yOTY5IiB5Mj0iMjQ2Ljk2MDkiLz48L2c+PGc+PHRpdGxlPiYjMjA5OTg7JiMzMDAyODs8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSIxNjUuNjY0MSIgd2lkdGg9IjgiIHg9IjEwNyIgeT0iODEuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIxMTAuNSIgeDI9IjExMC41IiB5MT0iODEuMjk2OSIgeTI9IjI0Ni45NjA5Ii8+PC9nPjxnPjx0aXRsZT4mIzI1NTExOyYjMjEwNDY7JiMyMjEyMDs8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSIxNjUuNjY0MSIgd2lkdGg9IjgiIHg9IjE2NS40OTk5IiB5PSI4MS4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjE2OC41IiB4Mj0iMTY4LjUiIHkxPSI4MS4yOTY5IiB5Mj0iMjQ2Ljk2MDkiLz48L2c+PGc+PHRpdGxlPiYjMjU5Njg7JiMyNTQ1NDsmIzIzNTQ1OyYjMzU5Mzc7PC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iMTY1LjY2NDEiIHdpZHRoPSI4IiB4PSIyMzAuNDk5NyIgeT0iODEuMjk2OSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NS4wLDUuMDsiIHgxPSIyMzMuNDk5OCIgeDI9IjIzMy40OTk4IiB5MT0iODEuMjk2OSIgeTI9IjI0Ni45NjA5Ii8+PC9nPjxnPjx0aXRsZT4mIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTs8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSIxNjUuNjY0MSIgd2lkdGg9IjgiIHg9IjI5NS40OTk1IiB5PSI4MS4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjI5OC40OTk2IiB4Mj0iMjk4LjQ5OTYiIHkxPSI4MS4yOTY5IiB5Mj0iMjQ2Ljk2MDkiLz48L2c+PGc+PHRpdGxlPiYjMzg1OTg7JiMyMTUxMjs8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSIxNjUuNjY0MSIgd2lkdGg9IjgiIHg9IjM1Mi40OTkzIiB5PSI4MS4yOTY5Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7c3Ryb2tlLWRhc2hhcnJheTo1LjAsNS4wOyIgeDE9IjM1NS40OTk0IiB4Mj0iMzU1LjQ5OTQiIHkxPSI4MS4yOTY5IiB5Mj0iMjQ2Ljk2MDkiLz48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LWhlYWQiIGRhdGEtcGFydGljaXBhbnQ9IiYjMzUyODI7JiMzMzM5NDsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3Ljk5OTkiIHg9IjUiIHk9Ijc3Ljk5NTEiPiYjMzUyODI7JiMzMzM5NDs8L3RleHQ+PGVsbGlwc2UgY3g9IjIxLjk5OTkiIGN5PSIxMy41IiBmaWxsPSIjRTJFMkYwIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik0yMS45OTk5LDIxLjUgTDIxLjk5OTksNDguNSBNOC45OTk5LDI5LjUgTDM0Ljk5OTksMjkuNSBNMjEuOTk5OSw0OC41IEw4Ljk5OTksNjMuNSBNMjEuOTk5OSw0OC41IEwzNC45OTk5LDYzLjUiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtdGFpbCIgZGF0YS1wYXJ0aWNpcGFudD0iJiMzNTI4MjsmIzMzMzk0OyI+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjcuOTk5OSIgeD0iNSIgeT0iMjU4Ljk1NjEiPiYjMzUyODI7JiMzMzM5NDs8L3RleHQ+PGVsbGlwc2UgY3g9IjIxLjk5OTkiIGN5PSIyNzAuNzU3OCIgZmlsbD0iI0UyRTJGMCIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNMjEuOTk5OSwyNzguNzU3OCBMMjEuOTk5OSwzMDUuNzU3OCBNOC45OTk5LDI4Ni43NTc4IEwzNC45OTk5LDI4Ni43NTc4IE0yMS45OTk5LDMwNS43NTc4IEw4Ljk5OTksMzIwLjc1NzggTTIxLjk5OTksMzA1Ljc1NzggTDM0Ljk5OTksMzIwLjc1NzgiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtaGVhZCIgZGF0YS1wYXJ0aWNpcGFudD0iJiMyMDk5ODsmIzMwMDI4OyI+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjcuOTk5OSIgeD0iOTQuMDAwMSIgeT0iNzcuOTk1MSI+JiMyMDk5ODsmIzMwMDI4OzwvdGV4dD48cGF0aCBkPSJNOTAuNSwzNyBMOTAuNSw2MSBNOTAuNSw0OSBMMTA3LjUsNDkiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxlbGxpcHNlIGN4PSIxMTkuNSIgY3k9IjQ5IiBmaWxsPSIjRTJFMkYwIiByeD0iMTIiIHJ5PSIxMiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSImIzIwOTk4OyYjMzAwMjg7Ij48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyNy45OTk5IiB4PSI5NC4wMDAxIiB5PSIyNTguOTU2MSI+JiMyMDk5ODsmIzMwMDI4OzwvdGV4dD48cGF0aCBkPSJNOTAuNSwyNjYuMjU3OCBMOTAuNSwyOTAuMjU3OCBNOTAuNSwyNzguMjU3OCBMMTA3LjUsMjc4LjI1NzgiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxlbGxpcHNlIGN4PSIxMTkuNSIgY3k9IjI3OC4yNTc4IiBmaWxsPSIjRTJFMkYwIiByeD0iMTIiIHJ5PSIxMiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC1oZWFkIiBkYXRhLXBhcnRpY2lwYW50PSImIzI1NTExOyYjMjEwNDY7JiMyMjEyMDsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxLjk5OTgiIHg9IjE0NS41IiB5PSI3Ny45OTUxIj4mIzI1NTExOyYjMjEwNDY7JiMyMjEyMDs8L3RleHQ+PGVsbGlwc2UgY3g9IjE2OS40OTk5IiBjeT0iNDkiIGZpbGw9IiNFMkUyRjAiIHJ4PSIxMiIgcnk9IjEyIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjE2NS40OTk5LDM3LDE3MS40OTk5LDMyLDE2OS40OTk5LDM3LDE3MS40OTk5LDQyLDE2NS40OTk5LDM3IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSImIzI1NTExOyYjMjEwNDY7JiMyMjEyMDsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxLjk5OTgiIHg9IjE0NS41IiB5PSIyNTguOTU2MSI+JiMyNTUxMTsmIzIxMDQ2OyYjMjIxMjA7PC90ZXh0PjxlbGxpcHNlIGN4PSIxNjkuNDk5OSIgY3k9IjI3OC4yNTc4IiBmaWxsPSIjRTJFMkYwIiByeD0iMTIiIHJ5PSIxMiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxNjUuNDk5OSwyNjYuMjU3OCwxNzEuNDk5OSwyNjEuMjU3OCwxNjkuNDk5OSwyNjYuMjU3OCwxNzEuNDk5OSwyNzEuMjU3OCwxNjUuNDk5OSwyNjYuMjU3OCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtaGVhZCIgZGF0YS1wYXJ0aWNpcGFudD0iJiMyNTk2ODsmIzI1NDU0OyYjMjM1NDU7JiMzNTkzNzsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjIwMy40OTk4IiB5PSI3Ny45OTUxIj4mIzI1OTY4OyYjMjU0NTQ7JiMyMzU0NTsmIzM1OTM3OzwvdGV4dD48ZWxsaXBzZSBjeD0iMjM0LjQ5OTciIGN5PSI0OSIgZmlsbD0iI0UyRTJGMCIgcng9IjEyIiByeT0iMTIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjIyMi40OTk3IiB4Mj0iMjQ2LjQ5OTciIHkxPSI2MyIgeTI9IjYzIi8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSImIzI1OTY4OyYjMjU0NTQ7JiMyMzU0NTsmIzM1OTM3OyI+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iMjAzLjQ5OTgiIHk9IjI1OC45NTYxIj4mIzI1OTY4OyYjMjU0NTQ7JiMyMzU0NTsmIzM1OTM3OzwvdGV4dD48ZWxsaXBzZSBjeD0iMjM0LjQ5OTciIGN5PSIyNzguMjU3OCIgZmlsbD0iI0UyRTJGMCIgcng9IjEyIiByeT0iMTIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgeDE9IjIyMi40OTk3IiB4Mj0iMjQ2LjQ5OTciIHkxPSIyOTIuMjU3OCIgeTI9IjI5Mi4yNTc4Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC1oZWFkIiBkYXRhLXBhcnRpY2lwYW50PSImIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxLjk5OTgiIHg9IjI3NS40OTk2IiB5PSI3Ny45OTUxIj4mIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTs8L3RleHQ+PHBhdGggZD0iTTI4MS40OTk1LDI5IEMyODEuNDk5NSwxOSAyOTkuNDk5NSwxOSAyOTkuNDk5NSwxOSBDMjk5LjQ5OTUsMTkgMzE3LjQ5OTUsMTkgMzE3LjQ5OTUsMjkgTDMxNy40OTk1LDU1IEMzMTcuNDk5NSw2NSAyOTkuNDk5NSw2NSAyOTkuNDk5NSw2NSBDMjk5LjQ5OTUsNjUgMjgxLjQ5OTUsNjUgMjgxLjQ5OTUsNTUgTDI4MS40OTk1LDI5IiBmaWxsPSIjRTJFMkYwIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiLz48cGF0aCBkPSJNMjgxLjQ5OTUsMjkgQzI4MS40OTk1LDM5IDI5OS40OTk1LDM5IDI5OS40OTk1LDM5IEMyOTkuNDk5NSwzOSAzMTcuNDk5NSwzOSAzMTcuNDk5NSwyOSIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSImIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTsiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxLjk5OTgiIHg9IjI3NS40OTk2IiB5PSIyNTguOTU2MSI+JiMyNTk2ODsmIzI1NDU0OyYjMjQyMTE7PC90ZXh0PjxwYXRoIGQ9Ik0yODEuNDk5NSwyNzIuMjU3OCBDMjgxLjQ5OTUsMjYyLjI1NzggMjk5LjQ5OTUsMjYyLjI1NzggMjk5LjQ5OTUsMjYyLjI1NzggQzI5OS40OTk1LDI2Mi4yNTc4IDMxNy40OTk1LDI2Mi4yNTc4IDMxNy40OTk1LDI3Mi4yNTc4IEwzMTcuNDk5NSwyOTguMjU3OCBDMzE3LjQ5OTUsMzA4LjI1NzggMjk5LjQ5OTUsMzA4LjI1NzggMjk5LjQ5OTUsMzA4LjI1NzggQzI5OS40OTk1LDMwOC4yNTc4IDI4MS40OTk1LDMwOC4yNTc4IDI4MS40OTk1LDI5OC4yNTc4IEwyODEuNDk5NSwyNzIuMjU3OCIgZmlsbD0iI0UyRTJGMCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7Ii8+PHBhdGggZD0iTTI4MS40OTk1LDI3Mi4yNTc4IEMyODEuNDk5NSwyODIuMjU3OCAyOTkuNDk5NSwyODIuMjU3OCAyOTkuNDk5NSwyODIuMjU3OCBDMjk5LjQ5OTUsMjgyLjI1NzggMzE3LjQ5OTUsMjgyLjI1NzggMzE3LjQ5OTUsMjcyLjI1NzgiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtaGVhZCIgZGF0YS1wYXJ0aWNpcGFudD0iJiMzODU5ODsmIzIxNTEyOyI+PHJlY3QgZmlsbD0iI0UyRTJGMCIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI0MS45OTk5IiB4PSIzMzcuNDk5NCIgeT0iNDYiLz48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjQxLjk5OTkiIHg9IjMzMy40OTk0IiB5PSI1MCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3Ljk5OTkiIHg9IjM0MC40OTk0IiB5PSI2OS45OTUxIj4mIzM4NTk4OyYjMjE1MTI7PC90ZXh0PjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtdGFpbCIgZGF0YS1wYXJ0aWNpcGFudD0iJiMzODU5ODsmIzIxNTEyOyI+PHJlY3QgZmlsbD0iI0UyRTJGMCIgaGVpZ2h0PSIzMC4yOTY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI0MS45OTk5IiB4PSIzMzcuNDk5NCIgeT0iMjQ1Ljk2MDkiLz48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjQxLjk5OTkiIHg9IjMzMy40OTk0IiB5PSIyNDkuOTYwOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3Ljk5OTkiIHg9IjM0MC40OTk0IiB5PSIyNjkuOTU2MSI+JiMzODU5ODsmIzIxNTEyOzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iJiMzNTI4MjsmIzMzMzk0OyIgZGF0YS1wYXJ0aWNpcGFudC0yPSImIzIwOTk4OyYjMzAwMjg7Ij48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9Ijk5LDEwOC40Mjk3LDEwOSwxMTIuNDI5Nyw5OSwxMTYuNDI5NywxMDMsMTEyLjQyOTciIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMjEuOTk5OSIgeDI9IjEwNSIgeTE9IjExMi40Mjk3IiB5Mj0iMTEyLjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NS4wMDAxIiB4PSIyOC45OTk5IiB5PSIxMDcuMzYzOCI+JiMyMTQ1NzsmIzM2ODY1OyYjMjEwNDA7JiMyMDk5ODsmIzMwMDI4OzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iJiMzNTI4MjsmIzMzMzk0OyIgZGF0YS1wYXJ0aWNpcGFudC0yPSImIzI1NTExOyYjMjEwNDY7JiMyMjEyMDsiPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMTU3LjQ5OTksMTM3LjU2MjUsMTY3LjQ5OTksMTQxLjU2MjUsMTU3LjQ5OTksMTQ1LjU2MjUsMTYxLjQ5OTksMTQxLjU2MjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMjEuOTk5OSIgeDI9IjE2My40OTk5IiB5MT0iMTQxLjU2MjUiIHkyPSIxNDEuNTYyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc4LjAwMDEiIHg9IjI4Ljk5OTkiIHk9IjEzNi40OTY2Ij4mIzIxNDU3OyYjMzY4NjU7JiMyMTA0MDsmIzI1NTExOyYjMjEwNDY7JiMyMjEyMDs8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IiYjMzUyODI7JiMzMzM5NDsiIGRhdGEtcGFydGljaXBhbnQtMj0iJiMyNTk2ODsmIzI1NDU0OyYjMjM1NDU7JiMzNTkzNzsiPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMjIyLjQ5OTcsMTY2LjY5NTMsMjMyLjQ5OTcsMTcwLjY5NTMsMjIyLjQ5OTcsMTc0LjY5NTMsMjI2LjQ5OTcsMTcwLjY5NTMiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMjEuOTk5OSIgeDI9IjIyOC40OTk3IiB5MT0iMTcwLjY5NTMiIHkyPSIxNzAuNjk1MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkxLjAwMDEiIHg9IjI4Ljk5OTkiIHk9IjE2NS42Mjk0Ij4mIzIxNDU3OyYjMzY4NjU7JiMyMTA0MDsmIzI1OTY4OyYjMjU0NTQ7JiMyMzU0NTsmIzM1OTM3OzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iJiMzNTI4MjsmIzMzMzk0OyIgZGF0YS1wYXJ0aWNpcGFudC0yPSImIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTsiPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iMjg3LjQ5OTUsMTk1LjgyODEsMjk3LjQ5OTUsMTk5LjgyODEsMjg3LjQ5OTUsMjAzLjgyODEsMjkxLjQ5OTUsMTk5LjgyODEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMjEuOTk5OSIgeDI9IjI5My40OTk1IiB5MT0iMTk5LjgyODEiIHkyPSIxOTkuODI4MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc4LjAwMDEiIHg9IjI4Ljk5OTkiIHk9IjE5NC43NjIyIj4mIzIxNDU3OyYjMzY4NjU7JiMyMTA0MDsmIzI1OTY4OyYjMjU0NTQ7JiMyNDIxMTs8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IiYjMzUyODI7JiMzMzM5NDsiIGRhdGEtcGFydGljaXBhbnQtMj0iJiMzODU5ODsmIzIxNTEyOyI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIzNDQuNDk5MywyMjQuOTYwOSwzNTQuNDk5MywyMjguOTYwOSwzNDQuNDk5MywyMzIuOTYwOSwzNDguNDk5MywyMjguOTYwOSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSIyMS45OTk5IiB4Mj0iMzUwLjQ5OTMiIHkxPSIyMjguOTYwOSIgeTI9IjIyOC45NjA5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjUuMDAwMSIgeD0iMjguOTk5OSIgeT0iMjIzLjg5NSI+JiMyMTQ1NzsmIzM2ODY1OyYjMjEwNDA7JiMzODU5ODsmIzIxNTEyOzwvdGV4dD48L2c+PCEtLVNSQz1bSXFta29JeklVQjV5cWVsRUpMbjktUUx2QU9iNWJHZkZFemdVSi10WElpeEZBb2RBcHI1dXJoVnlRU1VzZnBETlNBTmNiTUlNTDJleWN4aFhNVS13Zi1qdGxqWXVhMmliaUlHbkFSNHU1SVF3UXA5R09xdkVRZDk5UGR2VWlTQkJzTXJGOXRIbUdRbkdxQk0zNmd2V2ZWMnFWLUJCWGlRZDdIa1dyWTZLbTJyNExlTG0xUDkyOThVV2c0THM4OFJvTlBFbmcwS3c2dzRHdWNYYUxIMEgwMDAwXS0tPjwvZz48L3N2Zz4=">

<h4 id="三、使用别名及背景颜色"><a href="#三、使用别名及背景颜色" class="headerlink" title="三、使用别名及背景颜色"></a>三、使用别名及背景颜色</h4><p><strong>别名</strong></p>
<p>若参与者名称过长，特别是参与者名字由多个单词组成的情况下，可以使用关键字 <code>as</code> 给参与者取一个别名，之后就可以使用别名指代该参与者。</p>
<p><strong>参与者背景色</strong></p>
<p>在参与者名称之后以 <code>#COLOR</code> 的形式可以设定参与者图标的背景色。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">actor 管理员 #red</span><br><span class="line">' 定义颜色角色的背景颜色，以区别不用的元素</span><br><span class="line">participant 服务1</span><br><span class="line">' 定义别名</span><br><span class="line">participant "请求日志" as R #99FF99</span><br><span class="line">' 也可以下面这种方式定义别名</span><br><span class="line">participant S as "响应日志" #99FF00</span><br><span class="line">participant 服务2</span><br><span class="line"></span><br><span class="line">服务1-&gt;服务2: 验证请求</span><br><span class="line">服务1-&gt;R: 日志记录</span><br><span class="line"></span><br><span class="line">服务2-&gt;服务1: 验证响应</span><br><span class="line">服务2-&gt;S: 日志记录</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>
<h4 id="四、设置箭头颜色"><a href="#四、设置箭头颜色" class="headerlink" title="四、设置箭头颜色"></a>四、设置箭头颜色</h4><p>在箭头语法中间以 <code>[#COLOR]</code> 的形式可以设置箭头颜色：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">' 设置箭头颜色</span><br><span class="line">服务1 -[#Red]-&gt; 服务2: 发送请求 [虚线箭头]</span><br><span class="line">'虚线箭头 --&gt;</span><br><span class="line">服务2 -[#Green]&gt; 服务3: 发送请求 [实线箭头]</span><br><span class="line">'实线箭头 -&gt;</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="五、设置箭头风格"><a href="#五、设置箭头风格" class="headerlink" title="五、设置箭头风格"></a>五、设置箭头风格</h4><ul>
<li><code>x</code>. 将其放到箭头符号前或后，UML 中表示丢失消息.</li>
<li>使用 <code>/</code> 代替 <code>&gt;</code> 或 使用 <code>\</code> 代替 <code>&lt;</code>，图标箭头只有半个.</li>
<li>使用 <code>//</code>， <code>&gt;&gt;</code>， <code>&lt;&lt;</code>， <code>\\</code> 将产生细箭头.</li>
<li>使用 <code>--</code> 代替 <code>-</code> 将产生虚线.</li>
<li>在箭头或箭尾放置 <code>o</code>, 相应位置会绘制 ‘o’.</li>
<li>可以产生双向箭头</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">客户端 -&gt;x 服务器</span><br><span class="line">客户端 -&gt; 服务器</span><br><span class="line">客户端 -&gt;&gt; 服务器</span><br><span class="line">客户端 -\ 服务器</span><br><span class="line">客户端 \\- 服务器</span><br><span class="line">客户端 //-- 服务器</span><br><span class="line">客户端 -&gt;o 服务器</span><br><span class="line">客户端 o\\-- 服务器</span><br><span class="line">客户端 &lt;-&gt; 服务器</span><br><span class="line">客户端 &lt;-&gt;o 服务器</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="六、箭头给自己发消息"><a href="#六、箭头给自己发消息" class="headerlink" title="六、箭头给自己发消息"></a>六、箭头给自己发消息</h4><p>参与者可以给自己发消息</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">' 若消息很长, 可以使用 "\n" 换行.</span><br><span class="line">' 消息默认是或对齐.</span><br><span class="line">' 参与者名称则是默认中间对齐.</span><br><span class="line">服务器 -&gt; 服务器: 若消息很长, 可以使用 "\\n" 换行 \n 消息默认是或对齐 \n 参与者名称则是默认中间对齐</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/017/images/6.svg" alt="给自己发消息"></p>
<h4 id="七、消息自动编号"><a href="#七、消息自动编号" class="headerlink" title="七、消息自动编号"></a>七、消息自动编号</h4><ul>
<li><code>autonumber</code> 从 1 开始对消息自动编号</li>
<li><code>autonumber START</code>从 START 开始对消息自动编号</li>
<li><code>autonumber START INCREMENT</code>从 START 开始，按 增量 INCREMENT 对消息自动编号</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">autonumber</span><br><span class="line">客户端 -&gt; 服务器 : 第一次请求 [自动编号]</span><br><span class="line">客户端 &lt;-- 服务器 : 第一次响应 [自动编号]</span><br><span class="line"></span><br><span class="line">autonumber 15</span><br><span class="line">客户端 -&gt; 服务器 : 第二次请求 [从编号15开始, 自动编号]</span><br><span class="line">客户端 &lt;-- 服务器 : 第二次响应 [从编号15开始, 自动编号]</span><br><span class="line"></span><br><span class="line">autonumber 40 10</span><br><span class="line">客户端 -&gt; 服务器 : 第一次请求 [从编号40开始, 以 10 为单位自动编号]</span><br><span class="line">客户端 &lt;-- 服务器 : 第二次响应 [从编号40开始, 以 10 为单位自动编号]</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>
<h4 id="八、自定义消息编号样式"><a href="#八、自定义消息编号样式" class="headerlink" title="八、自定义消息编号样式"></a>八、自定义消息编号样式</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">autonumber "&lt;b&gt;[000]"</span><br><span class="line">客户端 -&gt; 服务器 : 证请求 [编号带中括号及加粗样式]</span><br><span class="line">客户端 &lt;-- 服务器 : 验证响应 [编号带中括号及加粗样式]</span><br><span class="line"></span><br><span class="line">autonumber 15 "&lt;b&gt;(&lt;u&gt;##&lt;/u&gt;)"</span><br><span class="line">客户端 -&gt; 服务器 : 验证请求 [编号带括号及下划线样式]</span><br><span class="line">客户端 &lt;-- 服务器 : 验证响应 [编号带括号及下划线样式]</span><br><span class="line"></span><br><span class="line">autonumber 40 10 "&lt;font color=red&gt;&lt;b&gt;消息编号 0 "</span><br><span class="line">客户端 -&gt; 服务器 : 验证请求 [编号带红色及加粗样式]</span><br><span class="line">客户端 &lt;-- 服务器 : 验证响应 [编号带红色及加粗样式]</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="九、停止消息自动编号"><a href="#九、停止消息自动编号" class="headerlink" title="九、停止消息自动编号"></a>九、停止消息自动编号</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">autonumber 10 10 "&lt;b&gt;[000]"</span><br><span class="line">客户端 -&gt; 服务器 : 验证请求</span><br><span class="line">客户端 &lt;-- 服务器 : 验证响应</span><br><span class="line"></span><br><span class="line">autonumber stop</span><br><span class="line"></span><br><span class="line">客户端 -&gt; 服务器 : 停止自动编号后的消息</span><br><span class="line"></span><br><span class="line">autonumber resume "&lt;font color=red&gt;&lt;b&gt;消息编号 0 "</span><br><span class="line"></span><br><span class="line">客户端 -&gt; 服务器 : 另一个验证请求</span><br><span class="line">客户端 &lt;-- 服务器 : 另一个验证响应</span><br><span class="line"></span><br><span class="line">autonumber stop</span><br><span class="line"></span><br><span class="line">客户端 -&gt; 服务器 : 停止自动编号后的消息</span><br><span class="line"></span><br><span class="line">autonumber resume 1 "&lt;font color=blue&gt;&lt;b&gt;消息编号 0 "</span><br><span class="line"></span><br><span class="line">客户端 -&gt; 服务器 : 另一个验证请求</span><br><span class="line">客户端 &lt;-- 服务器 : 另一个验证响应</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="十、消息分组"><a href="#十、消息分组" class="headerlink" title="十、消息分组"></a>十、消息分组</h4><p>有时候可能需要对消息进行分组，那么可以使用下面的关键词来实现：</p>
<ul>
<li>alt/else</li>
<li>opt</li>
<li>loop</li>
<li>par</li>
<li>break</li>
<li>critical</li>
<li>group, 这个关键词后面的文字会作为组名显示在图形上</li>
</ul>
<p>上面的关键词后可以添加一些文本用来显示在头部（注：group 除外，因 为它后面的文本用来显示在组名称的位置）。<br>在组嵌套组的结构里可以用关 键词<code>end</code>来关闭组或者说是表示一个组符号的结束符（类似<code>if/endif</code>）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">客户端 -&gt; 服务器 : 验证请求</span><br><span class="line">alt 验证成功</span><br><span class="line">    客户端 -&gt; 服务器 : 验证响应</span><br><span class="line"></span><br><span class="line">else 验证失败 ：第一种失败情况</span><br><span class="line">    客户端 -&gt; 服务器 : 验证失败</span><br><span class="line">    group 自定义的分组情况</span><br><span class="line">        客户端 -&gt; 日志服务 : 开始记录日志</span><br><span class="line">    loop 循环 1000 次</span><br><span class="line">        客户端 -&gt; 服务器 : DNS 尝试</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">客户端 -&gt; 日志服务 : 结束日志记录</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">else 验证失败：第二种失败情况</span><br><span class="line">    客户端 -&gt; 服务器 : 要求客户端重新请求</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="十一、消息注解"><a href="#十一、消息注解" class="headerlink" title="十一、消息注解"></a>十一、消息注解</h4><p>我们可能经常会在消息的左边或右边使用注解，要添加注解，只要使用 note left 或 note right 关键词就可以了。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">客户端-&gt;服务器 : 请求</span><br><span class="line">note left: 这是左侧注解</span><br><span class="line">服务器 --&gt;客户端 : 响应</span><br><span class="line">note right: 这是右侧注解</span><br><span class="line">服务器 -&gt;服务器  : 业务流程处理</span><br><span class="line">note left</span><br><span class="line">注解</span><br><span class="line">也可以多行编写</span><br><span class="line">只需要使用 note 和 end note 即可</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="十二、其他注解方式"><a href="#十二、其他注解方式" class="headerlink" title="十二、其他注解方式"></a>十二、其他注解方式</h4><p>通过使用关键词 <code>note left of</code> ， <code>note right of</code> 或 <code>note over</code> ， 我们还可以把注解放置在与之相关的参与者的左边或右边，或下方。</p>
<p>通过改变注解的<a href="http://www.w3school.com.cn/html/html_colornames.asp">背景色</a>，我们还可以高亮一个注解文本块。</p>
<p>如果要使用多行注解，可以使用关键词 <code>end note</code> 来表示注解的结束。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">participant 客户端</span><br><span class="line">participant 服务器</span><br><span class="line"></span><br><span class="line">note left of 客户端 #aqua</span><br><span class="line">    这是相对客户端模块左侧的注解</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">note right of 客户端: 这是相对客户端模块右侧的注解</span><br><span class="line"></span><br><span class="line">note over 客户端: 这是相对客户端模块中间的注解</span><br><span class="line"></span><br><span class="line">note over 客户端, 服务器 #FFAAAA: 这是相对\n 服务器和客户端之间的注解</span><br><span class="line"></span><br><span class="line">note over 客户端, 服务器</span><br><span class="line">    这是换行的注解</span><br><span class="line">    使用 note 和 end note 组合</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h4 id="十三、最佳样式"><a href="#十三、最佳样式" class="headerlink" title="十三、最佳样式"></a>十三、最佳样式</h4><p>默认样式颜色为黄色，组件块是上下对应的，这会产生更多的视觉噪音，因此去掉底部的重复并将颜色改为素色为好：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">skinparam sequenceMessageAlign center</span><br><span class="line">skinparam sequenceArrowFontSize 11</span><br><span class="line">skinparam noteFontSize 11</span><br><span class="line">skinparam monochrome true</span><br><span class="line">skinparam lifelinestrategy solid</span><br><span class="line">autonumber "&lt;b&gt;[00]"</span><br><span class="line"></span><br><span class="line">actor 角色</span><br><span class="line">boundary 分界</span><br><span class="line">control 控制器</span><br><span class="line">entity 数据对象</span><br><span class="line">database 数据库</span><br><span class="line">collections 集合</span><br><span class="line">角色 -&gt; 分界 : 发送到分界</span><br><span class="line">角色 -&gt; 控制器 : 发送到控制器</span><br><span class="line">角色 -&gt; 数据对象 : 发送到数据对象</span><br><span class="line">角色 -&gt; 数据库 : 发送到数据库</span><br><span class="line">角色 -&gt; 集合 : 发送到集合</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>


<p>参考资料：</p>
<p><a href="PlantUML_Language_Reference_Guide.pdf">官方指南英文版</a></p>
<p><a href="http://plantuml.com/sequence-diagram">官网</a></p>
<p><a href="http://www.plantuml.com/plantuml/uml">官网在线制作</a></p>
<p><a href="https://blog.csdn.net/ding_yingzi/article/details/80317111">plantuml 之序列图(一)</a></p>
<p><a href="http://archive.3zso.com/archives/plantuml-quickstart.html#sec-5-1">使用Emacs敲出UML，PlantUML快速指南</a></p>
<p><a href="https://www.jianshu.com/p/e92a52770832">使用 Sublime + PlantUML 高效地画图</a></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>PlantUML</tag>
      </tags>
  </entry>
  <entry>
    <title>人生苦短，转行程序员要趁早(上)</title>
    <url>/2018/06/17/018/</url>
    <content><![CDATA[<h4 id="把生命浪费在美好的事物上"><a href="#把生命浪费在美好的事物上" class="headerlink" title="把生命浪费在美好的事物上"></a>把生命浪费在美好的事物上</h4><p>时间管理理论中的一个重要概念：四象限法则，优先处理完重要且紧急的事情之后，再重点地把主要精力和时间集中地放在处理那些重要但不紧急的工作上，这样可以做到未雨绸缪，防患于未然。</p>
<p><img src="https://image.woodwhales.cn/018/images/1.png" alt="四象限法则"></p>
<p>时间管理四象限法则理论备受追捧，它很好的诠释了如何权衡在资源有限情况下的获得最大收益，世间万物都是基于本事物生命周期之内，有着自己的资源瓶颈，即使作为高智能生物并无限探索欲望能力的人类也无法逃脱客观限制，尤其是时间资源，如何把有限生命活得更有意义，即如何有效地利用有限资源完成任务并实现目标，让自己发光发亮成为生命之要事。</p>
<p>第一次看到这个理论是在高二，无意间瞥见班长把四象限法则图文，一笔一画地从杂志上抄在纸条上，并小心翼翼地夹在书里。很显然班长觉得这个理论很值得收藏，当时的我对此嗤之以鼻，轻浮地认为：这碗鸡汤，本人在中学时候就知道了，至于当个宝嘛。然而，有句话说叫出来混迟早是要还的，现在的我再也不敢轻敌任何学术理论了，因为「 <strong>越看起来简单简洁的理论，越是让人不起眼，但其作用发挥出来越是惊人</strong> 」，最著名的莫过于爱因斯坦质能方程。</p>
<p>判断事情的重要程度因人而异，一件事情被完成之后，能让自己感到生命的美好，那么它就会变得很重要，再利用四象限法则管理分配自己的精力，就需要把生命浪费在美好的事物上。</p>
<h4 id="美好驱动人生"><a href="#美好驱动人生" class="headerlink" title="美好驱动人生"></a>美好驱动人生</h4><p>当要反感一个事物的时候，不要直接说它如何令人不爽，而要反说其他事物如何令人美好。个体之间定义事物的美好程度不同，聚焦美好事物的选择也就不同，放弃一方而追求另一方的理由，可以说成被另一方的美好所吸引选择，也可以说成被一方的不美好而放弃，我更愿意选择前者这种美好的说法，并且一直是这样做着。</p>
<p>人生在世，都是在倒计时，活着的时候，不断追求、时刻聚焦美好，是件令人愉悦的事情，比如编程。</p>
<h4 id="自以为的美好"><a href="#自以为的美好" class="headerlink" title="自以为的美好"></a>自以为的美好</h4><p>大一下学期有一门数据库必修课程，虽然是必修课程，但是由于和本专业关系不大，加上诸多生涩难懂的概念，整个课程学完给我一种云里雾里的感觉，直到临近期末，学习这门课程的实习训练，为期一周，老师要求小组组队合作完成一个数据库管理系统。当看到张老师细致地讲演系统数据的增删改查功能时，我的眼里冒着绿光，兴奋地发现学这门课程，原来可以让计算机完成这么厉害的事情！</p>
<p>揣着好奇兴奋的心情，从图书馆借了本项目实战书，迫于强迫症和好强心，看到书上描述的系统功能强大实用，于是心中暗下决心，我也要做个类似的，于是模仿着书上的讲解开始了人生中的第一个程序，白天帮助同学们解决问题，晚上自己在不停“模仿”，看着自己一点点实现的功能浮出水面，心里越加亢奋，以至于从晚饭开始鼓捣电脑到天亮都没有一丝困意，那时还很流行第一季中国好声音，张伟翻唱过一首歌《三天三夜》，对五音不全的我来说，只会反复哼唱这首歌的第一句「一点都不会累~」，真的是一点都不会累，整个实训过得那叫一个酸爽充实。</p>
<p>当时的电脑里还安装着叫迅雷音影的视频播放器，通过系统设置可以去掉一些广告信息，但是始终无法完全阻止可恶的弹窗，强烈认为没有经过用户同意就硬推广告，不做播放器该做的事情，这完全属于款流氓软件。由于实习项目的“洗礼”，发现小白也可以设计实现一个软件应该长成什么样子，于是心想自己如果独立开发一个干干净净的播放器，并分享给大伙使用，这事该多么牛X。但是苦于自己没有基础，不知从哪里着手开干。</p>
<h4 id="多嘴的一个问"><a href="#多嘴的一个问" class="headerlink" title="多嘴的一个问"></a>多嘴的一个问</h4><p>作为课代表，来到张老师办公室，把实习报告在桌上摞齐后，本可以转身就走，见老师还屏幕前忙活着，本不想打扰，结果心一狠，还是多嘴问了句最近憋在心里的问题，如果想学编程做个软件，该看些什么书比较好。老师见我在实习期间的积极表现，停顿了一下：你是零基础，真感兴趣想学的话，最好有个老师能带着你。我一机灵：老师您不就可以带我嘛。老师轻轻摇头地表示没时间：这样，我到时候给你引荐位老师，让他带着你。我连忙答谢，寒暄一番就回去了。</p>
<p>那个傍晚，夕阳斜照，作为非科班生，原本以为这只是一多嘴的问题，老师并不会放在心上，因为计算机基础知识只是我们专业的附属课程，我自己都没想过可以接触编程并把这个当做日后工作一项技能来学，只是单纯感兴趣的一问，然而老师放在心上，因而这多嘴的一个问正向地影响了我的生命轨迹。</p>
<h4 id="发现编程之美"><a href="#发现编程之美" class="headerlink" title="发现编程之美"></a>发现编程之美</h4><p>不到一星期，张老师突然来电：“现在忙不，如果不忙，来我这，给你推荐了一位老师，可以跟着老师后面完成编程项目…”。电话这头的我兴奋不已，连忙收拾书包，背着笔记本，从宿舍飞奔到教学楼，气喘喘地来到指定的办公室门前，整理好气息，怯怯地敲门进去了。</p>
<p>在带我入编程之门的候老师面前，结结巴巴地表示自己是零基础，心里没有底气，您确定我可以在您的指导下完成项目吗，候老师不在意地表示：“没关系，只要有兴趣就好，直接跟我上手做项目就行，不需要死板的从头开始学习，不过你现在还是得自学点基础知识才行…”。在老师粗略地讲解什么是网页编程之后，简单地演示了一下，看得我是倍感压力（完全不懂，一脸懵逼），老师见状，就翻出了桌上的一本网页编程基础教程书，安慰鼓励我先自己看看，把里面的例子都弄懂之后再来。</p>
<p>这本书很薄，序言写着适合零基础入门，但是作为非科班出身的我来说，这里面讲的任何知识点都是完全陌生的概念，根本就不适合纯小白入门，我连一个 html 的词义解释都需要反复理解半天，有种从入门到放弃的感觉。为了不辜负候老师的期望和自己的初心，当时的自己不会利用网络找学习资料辅助自学，完全仅凭这本不适合小白的入门书在啃，心中无数个对作者胡写一通的骂娘和想放弃的心，但是还是一字一句地阅读并照着书上描述的步骤亲手实现 demo，然而比较神奇的事情发生了，每一个成功实现的功能都像是一针兴奋剂，刺激着原本想放弃的心，通过这一点点兴奋刺激，愈加发现，自己可以通过编程去控制电脑去设计完成自己的想法，每一处细节都是由自己双手亲自精准控制，成就感悠然而生，编程这个真的是令人精神抖擞，因此整个学习过程中，继续学习下去的热情一直没有减少。</p>
<p>回想起来，当时能够完整地看完网页编程基础知识，根本原因在于我有一台个人电脑，遇到不懂的概念可以及时快速地上机实操，每一个成功演示的功能都是一次惊喜发现，每一个兴奋刺激累积下来就使得学习过程变得很有趣味，并且学习时间越长越加发现，原来编程是一种工具，可以帮助自己实现自己想要的想法，让生活变得更美。</p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>转行</tag>
      </tags>
  </entry>
  <entry>
    <title>人生苦短，转行程序员要趁早(中)</title>
    <url>/2018/08/13/019/</url>
    <content><![CDATA[<blockquote>
<p>最近不少朋友表示对现在的自己很不满意，尤其是工作前景和收入上来看，感觉再这样持续下去，一辈子就真的废掉了。得知我已经成功转行做了程序员，于是想了解一下做程序员感觉如何，自己也打算转行做一枚程序员。</p>
</blockquote>
<p>在和朋友们交流的过程中，当他们吐嘈自己的现状和困惑时，不禁想起曾经的自己，也遇到过同样的焦虑迷茫。在和朋友们交流之后，我也在反思自己在交流过程中表达的想法观点是不是真的能对自己和别人有启发，因为我也曾渴望有位过来人能可以点醒一下自己。</p>
<h4 id="生命不息，造粪不止。"><a href="#生命不息，造粪不止。" class="headerlink" title="生命不息，造粪不止。"></a>生命不息，造粪不止。</h4><p>父母们没有经过我们自己的同意，强行一波，将我们带他们的家庭，于是在我们咕咕坠地的那一刻起，我们的成长就和这个家庭绑定在了一起，他们的性格人品和教育思想都会潜移默化地影响着我们的成长，未成年之前我们没有完全民事行为能力，他们是我们的唯一监护人，承担着我们的一切社会风险，吃喝拉撒均由他们来支持。</p>
<p>因为他们深知，以自己的能力是教育不了我们更多的科学知识，也给予不了我们更多的友谊之乐，我们在接受科学知识教育的同时，也在慢慢形成自己的世界观和人生观。于是他们连哄带骗地把哭着鼻子不去学校的我们送去了幼儿园，从此我们走上了漫长的学生（学生 = 学习 + 生活）生涯。</p>
<p>青春期的我们，性荷尔蒙的肆意分泌使得我们在生理上显得更加成熟，并渐渐认为自己已经有了独立思考和做主的能力，他们可以不需要再把自己当作小孩子养育了，从法律上来说，我们已经快有完全民事行为能力了，也可以自己承担一切社会风险了，然而，此刻的吃喝拉撒还是由他们来支持。</p>
<p>已经过了叛逆期的我们，此时的我们绝大多数都已经上了高中，我们开始知道上高中完了要高考，高考完了可以上大学。在父母、老师及亲朋好友们连哄带骗地描绘大学的自由美好，我们无时无刻不在用意淫上大学之后的生活来支撑坚持下去的信念，每天写着写不完的作业，做着做不完的卷子，我们风雨兼程、挑灯夜战，无时无刻不想逃离到更美好更加可以让“自己做主”的地方。</p>
<p>此刻，人生第一次有了点点主动控制权，可以挑选现在开心和未来再开心。</p>
<p>在高考结束，准备选择志愿的时候，我们来到第一个人生路口，握着报考指南，翻来覆去的权衡，在名字好听又好看的院校和霸气侧漏的专业名称之间左右对比、谨慎选择，担心自己“一失足成，成千古恨生”。逼到份上，不管的恨都得忍着接受。</p>
<p>有些人拎着行李进了曾经意淫的大学，有些人也背着行李进了谨慎选择的院校，有些人也驼着行李闯荡社会去了。</p>
<p>曾经在同屋檐下一起意淫、奋斗的小伙伴们，各自飞翔，从此相望于江湖，即便多年之后再聚，我还是我，他还是他，即便我过得一贫如洗，我依旧在这个世界的某个角落，他即便过得再飞黄腾达，也依旧在世界的另一个角落。</p>
<p>现在长大了，有了更多的想法，也产生了更多的梦想，但是无法直接可达，所以我们开始烦恼，烦恼于自己无法改变现状，并对自己现在极其不满意。但是不满归不满，时间总在向前走，持续的烦恼让深知不对现状做出改变，如此反复不变，十年后的今天，不是未来，还是今天。</p>
<p>越是烦恼，越是焦虑。</p>
<p>焦虑归焦虑，即便你我活得千差万别，我活得像一条无处找安身之地的流浪狗，你活成了精致潇洒的人生赢家，我们的肉身依旧苟活于世，都是大自然中一种叫人类的物种，总要三餐觅食，总会造出同营养价值的有机肥料。</p>
<h4 id="造粪之外，还能干嘛？"><a href="#造粪之外，还能干嘛？" class="headerlink" title="造粪之外，还能干嘛？"></a>造粪之外，还能干嘛？</h4><p>我们作为人类物种，区别于其他生物物种，多了一种特殊的能力，那就是智能。</p>
<p>最接近人类基因的大猩猩，它们天生会捡起地上的树枝并折断成自己想要的长度，插进蚂蚁洞里捉蚂蚁吃，而人更高级，有着天生的智力优势。我们可以找到长度粗细合适的树枝做成手柄，找到坚硬扁平合适的石头磨成铲子，再使用藤条把两者组合在一起，制作出一把铲子。</p>
<p>人类一切发明归根结底就是在自我满足，即便某人创造出对没有任何实际价值的东西，在这个创造的过程中也是自己在满足自己的创造欲望，享受身体中产生的多巴胺。因此作为人类除产肥之外，还可以利用智能优势，主动“搞事情”以达到生理或心理上的自我满足感，所以满足私欲并没有什么不好。</p>
<p>沃纳·冯·布劳恩小时候就喜欢在街头看别人开着自制的”火箭四轮车”在横冲直撞，这种前所未有的快乐感和满足感促使他对火箭的研究产生了兴趣，因研究如何把导弹升上天空带来源源不断的愉悦感，使他不断深入其中，年纪轻轻就被人称赞为真正的科学家，成功帮助希特勒制造出了威震八方的 V-2 导弹，使世界格局变得更加混乱。</p>
<p>在这期间，效力纳粹的科学家也不乏其他领域的世界级佼佼者，他们不是战争狂，而是选择了给他们研究探索的土壤，研究乐趣大于纳粹邪恶的痛恨。</p>
<p>当纳粹完全战败时，以美国为首的战胜国，要挟这些科学家来本国效力，如果自愿帮助美国继续研究探索，除本人享受国家给予的顶尖研究资源和环境之外，还可以解决一家老小的住房和户口问题，如果不答应，就视为他们是纳粹共犯，必须受到国际法律制裁。</p>
<p>见到如此诱人的“诱惑”，科学家们当然是选择投入大美帝国的怀抱，肆无忌惮地享受着研究资源以满足自我愉悦感，可以马后炮地认为，这种私欲的满足促进了世界科技文明进步。</p>
<p>回归本性，做什么可以让自己快乐，就去干什么。</p>
<h4 id="挣大钱，就特别愉悦？"><a href="#挣大钱，就特别愉悦？" class="headerlink" title="挣大钱，就特别愉悦？"></a>挣大钱，就特别愉悦？</h4><p>产生愉悦感的事情莫过于挣了大钱，有着花不完的钱，物质资源拥有感变强，少了对未来一贫如洗的焦虑感，于实现了“财务自由”，也变得“于众不同”，从此称为别人眼中的赢家。问题在于，谁都知道拥有很多财富的美好，可怎么实现呢？</p>
<p><strong>传说一</strong></p>
<p>互联网行业兴起有一段时间了，程序员需求量还是没减多少，薪资水平还是相对较高，再对比自己现在所处的行业和位置，人家某程序员干一个月能顶我们干两个月，同样的时间，人家做程序员的实现净积累十万要用一年，而以自己现在的水平，到达那个目标的年限恐怕是个未知数。</p>
<p>上面这段传说，假设一点没错，导致的现象就是，站在圈内的吃得正香，圈外的人看得眼馋，跃跃欲试。但似乎哪里不对劲，薪资高低真的和职位名称有绝对相关？</p>
<p>如果正相关，那是不是只要打着是一枚程序员的旗号来面试，所有企业老板们的脑子都瓦塌似的，听着来者口若悬河地描绘自己如何熟练地某某技术，老板见闻眼睛一亮，立马开高薪纳才，也就是有了上面的“程序员高薪资”。</p>
<p>经济学常识里人力资源是商品，是资源，可以等价交易，高薪不应该是创造价值高低决定吗，谁说干程序员就高薪资，前景发展好的，这不是在故意抬举这个职业吗。</p>
<p><strong>传说二</strong></p>
<p>听说某某曾经是屌丝一个，某年进培训机构呆了五个月，出来就月薪过万了，从富裕起来。</p>
<p>上面这段传说，可以不算作传说，毕竟人家真的拿了高薪，真的有那个商品经济价值。但为啥曾经被众人看不起的屌丝逆袭成功了呢？</p>
<p>或许是因为人家去的是某知名培训机构，老师讲得好呀，学生们学习氛围好呀，就好比名校易出状元一样。加上人家学的就是编程，完全从零基础开始，半年后成功转行做了程序员。</p>
<p>相比自己，比那位曾经的屌丝状态好不少呢，于是在传说的鼓舞下，渐渐开始心动了，犹豫自己是不是也可以去个知名培训机构，闭关修炼半年，出来也是条好汉，拿到高薪成功逆袭，正好大大地满足了自己。</p>
<p><strong>传说三</strong></p>
<p>在一些论坛或者知乎上可以看见一些小伙伴，分享或吐嘈了自己在培训机构的整体感受，他们普遍认为，培训机构毕是的盈利机构，只要报名交了学费或者贷款上学，你学不学与它无关，它会按照教学大纲走一遍，学不学得到得看自己。</p>
<p>这个传说传得很中肯，但和前两个传说相比，前者们更具有故事感和诱惑力，因为它的魅惑力可以让心如止水变成心情漪涟，对未来严重焦虑和恐慌患者听闻之后更加惶恐不安，心中隐隐听到一种声音：是时候转行程序员了，赌一把，没准真的逆袭成功了，那不就赚大发了。</p>
<p>抛硬币看正反面，前五次都是正，第六次一定是正或反吗？</p>
<p>每想起在大学的自己，每每走进图书馆的自然科学阅览室，望着书架上琳琅满目的书籍，站在原地开始意淫学会 PS 可以如何如何，学视频后期如何如何，学会 UI 设计如何如何，学会音频制作如何如何，结果什么都没学成。</p>
<p>生命有限，停止意淫，把生命浪费在使自己开心的事情上，先做自己感兴趣和自己开心的事。</p>
<p><strong>活着，开心就好。</strong></p>
<p>有人或许反问，你唠了那么废话，关键是自己现在对啥都不感兴趣，这怎么办呢？我浅薄地认为，对啥都不感兴趣的人是不会看这段文字，因为完整看到本段的，起码是对本文有点阅读下去的兴趣，所以，不如尝试做点让自己真的开心的事？</p>
<div class="note info">
本文还有个副标题
人生苦短，程序员转行要趁早。
</div>]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>转行</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计中国峰会2018</title>
    <url>/2019/01/22/020/</url>
    <content><![CDATA[<blockquote>
<p>使用视频播放器：<a href="https://mp.weixin.qq.com/s/odVBTkMlCvhjUKNW3krjNw">Pot Player 视频播放器</a>，<code>Ctrl+U</code>打开链接即可播放。</p>
</blockquote>
<h3 id="TRACK1-领域驱动设计与企业应用架构"><a href="#TRACK1-领域驱动设计与企业应用架构" class="headerlink" title="TRACK1 领域驱动设计与企业应用架构"></a>TRACK1 领域驱动设计与企业应用架构</h3><h4 id="1-盒马核心系统架构演进"><a href="#1-盒马核心系统架构演进" class="headerlink" title="1. 盒马核心系统架构演进"></a>1. 盒马核心系统架构演进</h4><p>张群辉</p>
<p>阿里盒马架构总监</p>
<p>领域驱动设计国内最早的一批实践者 15 + 年技术及管理实战经验，前阿里基础机构事业部工程效率总监，长期一线指导大型复杂系统的架构设计，DevOps、微服务架构及领域驱动设计国内最早的一批实践者。崇尚实践出真知，一直奋斗在技术一线。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp2fzke2tde4dp/mda-imcp2fzke2tde4dp.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp2fzke2tde4dp/mda-imcp2fzke2tde4dp.m3u8</a></p>
<h4 id="2-在一个实际复杂业务中落地DDD方法与相关架构"><a href="#2-在一个实际复杂业务中落地DDD方法与相关架构" class="headerlink" title="2. 在一个实际复杂业务中落地DDD方法与相关架构"></a>2. 在一个实际复杂业务中落地DDD方法与相关架构</h4><p>曹剑</p>
<p>四川好医生药业集团CTO</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp4c2uwe61yxzg/mda-imcp4c2uwe61yxzg.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp4c2uwe61yxzg/mda-imcp4c2uwe61yxzg.m3u8</a></p>
<h4 id="3-用状态机封装领域逻辑"><a href="#3-用状态机封装领域逻辑" class="headerlink" title="3. 用状态机封装领域逻辑"></a>3. 用状态机封装领域逻辑</h4><p>潘加宇</p>
<p>UMLChina 首席专家&amp;创始人</p>
<p>UMLChina创始人，潜心研究需求和设计技能。2002年开始对外提供UML需求和设计的技术指导和训练服务。到现在为止，已经上门为超过260家的组织提供服务，覆盖了国内各个领域的领袖企业，包括通信、企业管理、电子商务、房地产、网络游戏、地理信息、物流、数码设备、医疗设备、工业控制…..等领域。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp4whpze2prmmz/mda-imcp4whpze2prmmz.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp4whpze2prmmz/mda-imcp4whpze2prmmz.m3u8</a></p>
<h4 id="4-当我们在谈论业务架构时，我们到底在谈论什么"><a href="#4-当我们在谈论业务架构时，我们到底在谈论什么" class="headerlink" title="4. 当我们在谈论业务架构时，我们到底在谈论什么"></a>4. 当我们在谈论业务架构时，我们到底在谈论什么</h4><p>亢江妹</p>
<p>ThoughtWorks首席业务分析师</p>
<p>中国区业务分析实践负责人 在敏捷/精益产品需求分析、大企业需求管理、行业研究等方面，有丰富的实战和教练经验；她也是业务分析师(IIBA)、产品经理的活跃参与者，是DnA(Design and Analysis)社区、ThoughtWorks中国行业研究社区的发起人，也是ThoughtWorks商业洞见的主编。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnuy9dsj93enst/mda-imcnuy9dsj93enst.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnuy9dsj93enst/mda-imcnuy9dsj93enst.m3u8</a></p>
<h4 id="5-可视化的遗留系统微服务改造"><a href="#5-可视化的遗留系统微服务改造" class="headerlink" title="5. 可视化的遗留系统微服务改造"></a>5. 可视化的遗留系统微服务改造</h4><p>毛超</p>
<p>ThoughtWorks 工程师、专注遗留系统改造、微服务相关技术</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnxyh50hxazpcg/mda-imcnxyh50hxazpcg.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnxyh50hxazpcg/mda-imcnxyh50hxazpcg.m3u8</a></p>
<h3 id="TRACK2-领域驱动的业务中台"><a href="#TRACK2-领域驱动的业务中台" class="headerlink" title="TRACK2 领域驱动的业务中台"></a>TRACK2 领域驱动的业务中台</h3><h4 id="1-当我们谈中台时我们在谈些什么？"><a href="#1-当我们谈中台时我们在谈些什么？" class="headerlink" title="1. 当我们谈中台时我们在谈些什么？"></a>1. 当我们谈中台时我们在谈些什么？</h4><p>王健</p>
<p>ThoughtWorks首席咨询师</p>
<p>一直从事国内外大型企业级软件的设计与开发，时刻保持着对技术的热爱，享受着编码的快乐，热衷于技术分享。目前专注于为服务架构，系统质量保障和持续交付相关领域的学习与分享。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnt08v3ga8hipv/mda-imcnt08v3ga8hipv.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnt08v3ga8hipv/mda-imcnt08v3ga8hipv.m3u8</a></p>
<h4 id="2-演进式架构的平台化落地"><a href="#2-演进式架构的平台化落地" class="headerlink" title="2. 演进式架构的平台化落地"></a>2. 演进式架构的平台化落地</h4><p>姚安峰</p>
<p>ThoughtWorks资深精益敏捷顾问</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnwi8h17gxbzuv/mda-imcnwi8h17gxbzuv.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnwi8h17gxbzuv/mda-imcnwi8h17gxbzuv.m3u8</a></p>
<h3 id="TRACK3-领域统一语言的实践模式"><a href="#TRACK3-领域统一语言的实践模式" class="headerlink" title="TRACK3 领域统一语言的实践模式"></a>TRACK3 领域统一语言的实践模式</h3><h4 id="1-领域建模的易与难"><a href="#1-领域建模的易与难" class="headerlink" title="1. 领域建模的易与难"></a>1. 领域建模的易与难</h4><p>王鹏</p>
<p>华为公司 LS云计算培训方案架构师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imqk8qnrx6t2hifa/mda-imqk8qnrx6t2hifa.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imqk8qnrx6t2hifa/mda-imqk8qnrx6t2hifa.m3u8</a></p>
<h4 id="2-如何让DDD落地"><a href="#2-如何让DDD落地" class="headerlink" title="2. 如何让DDD落地"></a>2. 如何让DDD落地</h4><p>和坚</p>
<p>ThoughtWorks高级咨询师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp0ppb8j04i05k/mda-imcp0ppb8j04i05k.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp0ppb8j04i05k/mda-imcp0ppb8j04i05k.m3u8</a></p>
<h4 id="3-领域模型与形式化验证技术"><a href="#3-领域模型与形式化验证技术" class="headerlink" title="3. 领域模型与形式化验证技术"></a>3. 领域模型与形式化验证技术</h4><p>李凯航</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnwym2ufz5cex3/mda-imcnwym2ufz5cex3.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnwym2ufz5cex3/mda-imcnwym2ufz5cex3.m3u8</a></p>
<h4 id="4-系统分层模型适配实践"><a href="#4-系统分层模型适配实践" class="headerlink" title="4. 系统分层模型适配实践"></a>4. 系统分层模型适配实践</h4><p> 吴雪峰</p>
<p>ThoughtWorks软件架构师</p>
<p>主要负责敏捷软件开发与软件架构设计。他具有10+年软件架构设计经验，从事于分布式系统、电子商务、医疗、电信行业的软件开发、架构设计及敏捷实践。擅长Java/Scala技术，DDD、微服务架构、Reactive分布式软件架构、DevOps以及精益实践。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp34g5xy8tz6k8/mda-imcp34g5xy8tz6k8.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp34g5xy8tz6k8/mda-imcp34g5xy8tz6k8.m3u8</a></p>
<h3 id="TRACK4-领域统设计与架构师"><a href="#TRACK4-领域统设计与架构师" class="headerlink" title="TRACK4 领域统设计与架构师"></a>TRACK4 领域统设计与架构师</h3><h4 id="1-基于DDD的领域建模中的模版和工具实践"><a href="#1-基于DDD的领域建模中的模版和工具实践" class="headerlink" title="1. 基于DDD的领域建模中的模版和工具实践"></a>1. 基于DDD的领域建模中的模版和工具实践</h4><p>王海文</p>
<p>用友网络科技股份有限公司高级技术架构师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnsmrb9xutkzfw/mda-imcnsmrb9xutkzfw.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnsmrb9xutkzfw/mda-imcnsmrb9xutkzfw.m3u8</a></p>
<h4 id="2-复杂业务场景下的业务架构梳理到技术架构设计-UX与架构师的完美结对"><a href="#2-复杂业务场景下的业务架构梳理到技术架构设计-UX与架构师的完美结对" class="headerlink" title="2. 复杂业务场景下的业务架构梳理到技术架构设计 - UX与架构师的完美结对"></a>2. 复杂业务场景下的业务架构梳理到技术架构设计 - UX与架构师的完美结对</h4><p>季炜</p>
<p>ThoughtWorks高级咨询师</p>
<p>朱傲</p>
<p>戴姆勒大中华区高级架构师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnugm94qm2h7qu/mda-imcnugm94qm2h7qu.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnugm94qm2h7qu/mda-imcnugm94qm2h7qu.m3u8</a></p>
<h4 id="3-DDD实践中的那些坑"><a href="#3-DDD实践中的那些坑" class="headerlink" title="3. DDD实践中的那些坑"></a>3. DDD实践中的那些坑</h4><p>王立</p>
<p>厦门云雾科技有限公司创始人/总经理</p>
<p>前阿里资深工程师，国内最早一批实践和推广DDD的践行者，建立了一套适用于DDD的敏捷开发过程，长期聚焦于领域分析、彩色UML建模，擅长复杂业务的模型提炼与架构设计，主张在聚合的实现在可以采用微单体时就尽量不要采用微服务，现任厦门云雾科技有限公司创始人/总经理。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnzedq0t27x236/mda-imcnzedq0t27x236.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnzedq0t27x236/mda-imcnzedq0t27x236.m3u8</a></p>
<h4 id="4-金融支付系统的改造之路"><a href="#4-金融支付系统的改造之路" class="headerlink" title="4. 金融支付系统的改造之路"></a>4. 金融支付系统的改造之路</h4><p>金明</p>
<p>Video++极链科技集团创始人/CEO</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp1dy2wa8irznt/mda-imcp1dy2wa8irznt.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp1dy2wa8irznt/mda-imcp1dy2wa8irznt.m3u8</a></p>
<h3 id="TRACK5-领域驱动设计与演进式架构"><a href="#TRACK5-领域驱动设计与演进式架构" class="headerlink" title="TRACK5 领域驱动设计与演进式架构"></a>TRACK5 领域驱动设计与演进式架构</h3><h4 id="1-DDD在旅游电商架构演进中的实践"><a href="#1-DDD在旅游电商架构演进中的实践" class="headerlink" title="1. DDD在旅游电商架构演进中的实践"></a>1. DDD在旅游电商架构演进中的实践</h4><p>徐泼</p>
<p>美团酒旅研发中心高级技术专家</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnvwik58npernt/mda-imcnvwik58npernt.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnvwik58npernt/mda-imcnvwik58npernt.m3u8</a></p>
<h4 id="2-领域驱动架构透析与架构解耦"><a href="#2-领域驱动架构透析与架构解耦" class="headerlink" title="2. 领域驱动架构透析与架构解耦"></a>2. 领域驱动架构透析与架构解耦</h4><p>张逸</p>
<p>民航成都信息技术总监</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnyaici9v4mz3j/mda-imcnyaici9v4mz3j.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnyaici9v4mz3j/mda-imcnyaici9v4mz3j.m3u8</a></p>
<h4 id="3-化繁为简–DDD驱动复杂业务软件架构的演进"><a href="#3-化繁为简–DDD驱动复杂业务软件架构的演进" class="headerlink" title="3. 化繁为简–DDD驱动复杂业务软件架构的演进"></a>3. 化繁为简–DDD驱动复杂业务软件架构的演进</h4><p>白彦磊</p>
<p>广联达科技股份有限公司技术架构部经理</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp0e9mfgjp62x7/mda-imcp0e9mfgjp62x7.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp0e9mfgjp62x7/mda-imcp0e9mfgjp62x7.m3u8</a></p>
<h4 id="4-端口和适配器架构：DDD好帮手"><a href="#4-端口和适配器架构：DDD好帮手" class="headerlink" title="4. 端口和适配器架构：DDD好帮手"></a>4. 端口和适配器架构：DDD好帮手</h4><p>周宇刚</p>
<p>ThoughtWorks高级咨询师</p>
<p>ThoughtWorks高级咨询师，DDD实践家 10年企业级应用开发经验，主要负责软件交付和持续交付咨询。从09年开始关注领域驱动设计，是Stack Overflow DDD标签 All Time Top Answerer 之一，曾在多个行业领域中实战过DDD。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnxkq5rnuu777y/mda-imcnxkq5rnuu777y.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnxkq5rnuu777y/mda-imcnxkq5rnuu777y.m3u8</a></p>
<h4 id="5-DDD促进传统架构微服务转型"><a href="#5-DDD促进传统架构微服务转型" class="headerlink" title="5. DDD促进传统架构微服务转型"></a>5. DDD促进传统架构微服务转型</h4><p>范钢</p>
<p>航天信息金税本部首席架构师</p>
<p>航天信息股份有限公司首席架构师，《大话重构》作者，哈工大软件工程硕士，软件架构及重构的客座讲师。从需求分析、软件开发到项目管理、架构设计都有丰富的从业经验。大型遗留系统改造专业户，长期关注大型业务系统的品质保证、防止腐化以及技术改造等困扰软件企业的问题，进而提出了许多实用而有效的解决方案，在遗留系统优化与改造方面有丰富的经验。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnzzecrtsjtgar/mda-imcnzzecrtsjtgar.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnzzecrtsjtgar/mda-imcnzzecrtsjtgar.m3u8</a></p>
<h3 id="TRACK6-领域驱动与反应式架构"><a href="#TRACK6-领域驱动与反应式架构" class="headerlink" title="TRACK6 领域驱动与反应式架构"></a>TRACK6 领域驱动与反应式架构</h3><h4 id="1-基于-FP-的-DDD-实践"><a href="#1-基于-FP-的-DDD-实践" class="headerlink" title="1. 基于 FP 的 DDD 实践"></a>1. 基于 FP 的 DDD 实践</h4><p>张晓龙</p>
<p>中兴通讯虚拟化架构师</p>
<p>2008年毕业于哈尔滨工程大学计算机应用专业，爱好编程，业余时间喜欢写一些技术类文章。2008年就职于ZTE，参与过大型通信软件的开发，擅长TDD和重构等XP实践。近年来参与虚拟化产品的研发，同时负责提升全员的DDD能力，从DDD导入到DDD训练营，不断的给学员传递DDD的思想和实践技能，目前DDD已在多个团队有效落地，并得到大家的一致认可。除过程序员，个人在组织中还有一些其它标签，比如架构师、咨询师和技术教练等。个人的简书地址：<a href="http://www.jianshu.com/u/1381dc29fed9">http://www.jianshu.com/u/1381dc29fed9</a>。</p>
<p>熟练掌握C++/Golang/Python/Java等编程语言，这一年主要使用的编程语言是Golang，同时Golang也成了DDD落地的主要语言。这一年在简书上也写了多篇与DDD相关的技术文章，比如《软件设计的演变过程》，《Golang事务模型》，《DDD分层架构的三种模式》，《Implement Domain Object in Golang》，《FizzBuzzWhizz in Python from OO and FP》。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnvki9wv6qcezu/mda-imcnvki9wv6qcezu.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnvki9wv6qcezu/mda-imcnvki9wv6qcezu.m3u8</a></p>
<h4 id="2-淘宝应用架构升级——反应式架构的探索与实践"><a href="#2-淘宝应用架构升级——反应式架构的探索与实践" class="headerlink" title="2. 淘宝应用架构升级——反应式架构的探索与实践"></a>2. 淘宝应用架构升级——反应式架构的探索与实践</h4><p>许泽彬</p>
<p>阿里巴巴淘宝技术专家</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnyvvf7666vxh7/mda-imcnyvvf7666vxh7.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnyvvf7666vxh7/mda-imcnyvvf7666vxh7.m3u8</a></p>
<h4 id="2-Every-Entity-as-A-Microservice"><a href="#2-Every-Entity-as-A-Microservice" class="headerlink" title="2. Every Entity as A Microservice"></a>2. Every Entity as A Microservice</h4><p>陶文</p>
<p>滴滴出行平台技术部首席架构师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnu2patj7nwe7z/mda-imcnu2patj7nwe7z.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnu2patj7nwe7z/mda-imcnu2patj7nwe7z.m3u8</a></p>
<h4 id="3-从微服务到-FaaS"><a href="#3-从微服务到-FaaS" class="headerlink" title="3. 从微服务到 FaaS"></a>3. 从微服务到 FaaS</h4><p>许晓斌</p>
<p>阿里巴巴-AliExpress高级技术专家</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp3dqu9gwxz3uk/mda-imcp3dqu9gwxz3uk.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp3dqu9gwxz3uk/mda-imcp3dqu9gwxz3uk.m3u8</a></p>
<h4 id="4-物联网平台的反应式设计"><a href="#4-物联网平台的反应式设计" class="headerlink" title="4. 物联网平台的反应式设计"></a>4. 物联网平台的反应式设计</h4><p>唐成</p>
<p>ThoughtWorks IoT首席咨询师</p>
<p>ThoughtWorks中国区loT团队的技术专家，曾先后为国内外航空产业。汽车制造、电器制造等领域的领军企业提供软硬件架构咨询、大型遗留系统重构规划、微服务架构转型规划、软硬件系统交付等服务。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp106wczcqn9i4/mda-imcp106wczcqn9i4.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp106wczcqn9i4/mda-imcp106wczcqn9i4.m3u8</a></p>
<h3 id="OTHER"><a href="#OTHER" class="headerlink" title="OTHER"></a>OTHER</h3><h4 id="1-微服务的容器化实践"><a href="#1-微服务的容器化实践" class="headerlink" title="1. 微服务的容器化实践"></a>1. 微服务的容器化实践</h4><p>邢海涛</p>
<p>灵雀云 微服务首席专家</p>
<p>计算机应用硕士(英国)，灵雀云微服务首席专家，近20年软件开发经验，8年亚马逊高级软件工程师。个人专注PaaS应用和分布式系统架构设计。</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnthqs324ai79y/mda-imcnthqs324ai79y.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcnthqs324ai79y/mda-imcnthqs324ai79y.m3u8</a></p>
<h4 id="2-Complex-Adaptive-Systems"><a href="#2-Complex-Adaptive-Systems" class="headerlink" title="2. Complex Adaptive Systems"></a>2. Complex Adaptive Systems</h4><p>Dave Snowden</p>
<p>Cognitive Edge管理咨询公司 创始人兼首席科学官</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp1zupqgrc52e5/mda-imcp1zupqgrc52e5.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp1zupqgrc52e5/mda-imcp1zupqgrc52e5.m3u8</a></p>
<h4 id="3-Readable-Code-Laura-Savino"><a href="#3-Readable-Code-Laura-Savino" class="headerlink" title="3. Readable Code-Laura Savino"></a>3. Readable Code-Laura Savino</h4><p>Laura Savino</p>
<p>DDD Europe 主要讲师之一</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp3xy24ggcm42y/mda-imcp3xy24ggcm42y.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcp3xy24ggcm42y/mda-imcp3xy24ggcm42y.m3u8</a></p>
<h4 id="4-Beyond-Uncertainty-Design-from-Domain-Perspective"><a href="#4-Beyond-Uncertainty-Design-from-Domain-Perspective" class="headerlink" title="4. Beyond Uncertainty, Design from Domain Perspective"></a>4. Beyond Uncertainty, Design from Domain Perspective</h4><p>王威</p>
<p>DDD China 联合发起人、ThoughtWorks资深架构师</p>
<p><a href="http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcntnep3xr4hbmq/mda-imcntnep3xr4hbmq.m3u8">http://ik4pfm2ryuf70bxxd8f.exp.bcevod.com/mda-imcntnep3xr4hbmq/mda-imcntnep3xr4hbmq.m3u8</a></p>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful API 最佳实践</title>
    <url>/2019/01/27/021/</url>
    <content><![CDATA[<blockquote>
<p>前后端分离和微服务成为现代软件开发的大趋势下，API设计也应该变得越来越规范和高效。</p>
</blockquote>
<h4 id="1-RESTful"><a href="#1-RESTful" class="headerlink" title="1. RESTful"></a>1. RESTful</h4><p>REST（英文：Representational State Transfer，简称REST），RESTful是一种对基于HTTP的应用设计风格，<strong>只是提供了一组设计原则和约束条件，而不是一种标准。</strong></p>
<p>从本质上理解RESTful，它其实是尽可能复用HTTP特性来规范软件设计，甚至提高传输效率。HTTP包处于网络应用层，因此HTTP包为平台无关的字符串表示，如果尽可能的使用HTTP的包特征而不是大量在body定义自己的规则，可以用更简洁、清晰、高效的方式实现同样的需求。</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>资源访问路径</th>
<th>数据操作说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/users/</td>
<td>获取所有用户数据</td>
</tr>
<tr>
<td>GET</td>
<td>/users/1</td>
<td>获取id=1的用户数据</td>
</tr>
<tr>
<td>POST</td>
<td>/users</td>
<td>新增一条用户数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>/users/1</td>
<td>删除id=1的用户数据</td>
</tr>
</tbody></table>
<p>RESTful的本质是基于HTTP协议对资源的增删改查操作做出定义。</p>
<h5 id="1-1-几个典型的RESTful-API场景："><a href="#1-1-几个典型的RESTful-API场景：" class="headerlink" title="1.1 几个典型的RESTful API场景："></a>1.1 几个典型的RESTful API场景：</h5><table>
<thead>
<tr>
<th>功能</th>
<th align="right">URL</th>
<th align="right">HTTP Method</th>
</tr>
</thead>
<tbody><tr>
<td>获取一组数据列表</td>
<td align="right">/base-path/records</td>
<td align="right">GET</td>
</tr>
<tr>
<td>根据ID获取某个数据</td>
<td align="right">/base-path/records/{recordID}</td>
<td align="right">GET</td>
</tr>
<tr>
<td>新建数据</td>
<td align="right">/base-path/records</td>
<td align="right">POST</td>
</tr>
<tr>
<td>完整地更新数据</td>
<td align="right">/base-path/records/{recordID}</td>
<td align="right">PUT</td>
</tr>
<tr>
<td>部分更新数据</td>
<td align="right">/base-path/records/{recordID}</td>
<td align="right">PATCH</td>
</tr>
<tr>
<td>删除</td>
<td align="right">/base-path/records/{recordID}</td>
<td align="right">DELETE</td>
</tr>
<tr>
<td>夸域访问预请求</td>
<td align="right">/base-path/records/{recordID}</td>
<td align="right">OPTION</td>
</tr>
</tbody></table>
<p>虽然HTTP协议定义了其他的Method，但是就普通场景来说，用好上面的几项已经足够了。</p>
<p>RESTful的几个注意点：</p>
<ul>
<li><p>URL只是表达被操作的资源位置，因此不应该使用动词，且注意单复数区分</p>
</li>
<li><p>除了POST和DELETE之外，其他的操作需要冥等的，例如对数据多次更新应该返回同样的内容</p>
</li>
<li><p>设计风格没有对错之分，RESTful一种设计风格，与此对应的还有RPC甚至自定义的风格</p>
</li>
<li><p>RESTful和语言、传输格式无关</p>
</li>
<li><p>无状态，HTTP设计本来就是没有状态的，之所以看起来有状态因为我们浏览器使用了Cookies，每次请求都会把Session ID（可以看做身份标识）传递到headers中。关于RESTful风格下怎么做用户身份认证我们会在后面讲到。</p>
</li>
<li><p>RESTful没有定义body中内容传输的格式，有另外的规范来描述怎么设计body的数据结构，网络上有些文章对RESTful的范围理解有差异</p>
</li>
</ul>
<h5 id="1-2-避免多级-URL"><a href="#1-2-避免多级-URL" class="headerlink" title="1.2 避免多级 URL"></a>1.2 避免多级 URL</h5><p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /authors/12/categories/2</span><br></pre></td></tr></tbody></table></figure>

<p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /authors/12?categories=2</span><br></pre></td></tr></tbody></table></figure>

<p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /articles/published</span><br></pre></td></tr></tbody></table></figure>

<p>查询字符串的写法明显更好。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /articles?published=true</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-JSON-API"><a href="#2-JSON-API" class="headerlink" title="2. JSON API"></a>2. JSON API</h4><p>因为RESTful风格仅仅规定了URL和HTTP Method的使用，并没有定义body中数据格式的。我们怎么定义请求或者返回对象的结构，以及该如何针对不同的情况返回不同的HTTP 状态码？</p>
<p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。因此，服务器回应的 HTTP 头的Content-Type属性要设为application/json。</p>
<h5 id="2-1-MIME-类型"><a href="#2-1-MIME-类型" class="headerlink" title="2.1 MIME 类型"></a>2.1 MIME 类型</h5><p>JSON API数据格式已经被IANA机构接受了注册，因此必须使用application/vnd.api+json类型。因此，客户端请求时，必须要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></tbody></table></figure>

<h5 id="2-2-JSON文档结构"><a href="#2-2-JSON文档结构" class="headerlink" title="2.2 JSON文档结构"></a>2.2 JSON文档结构</h5><p>在顶级节点使用data、errors、meta，来描述数据、错误信息、元信息。</p>
<blockquote>
<p>注意：data和errors应该互斥，不能再一个文档中同时存在，meta在项目实际上用的很少，只有特别情况才需要用到，比如返回服务器的一些信息。</p>
</blockquote>
<h5 id="2-3-data属性"><a href="#2-3-data属性" class="headerlink" title="2.3 data属性"></a>2.3 data属性</h5><p>一个典型的data的对象格式，我们的有效信息一般都放在attributes中。</p>
<p><img src="https://image.woodwhales.cn/021/images/1.png" alt="data属性"></p>
<ul>
<li><p>id显而易见为唯一标识，可以为数字也可以为hash字符串，取决于后端实现</p>
</li>
<li><p>type 描述数据的类型，可以对应为数据模型的类名</p>
</li>
<li><p>attributes 代表资源的具体数据</p>
</li>
<li><p>relationships、links为可选属性，用来放置关联数据和资源地址等数据</p>
</li>
</ul>
<h5 id="2-4-errors属性"><a href="#2-4-errors属性" class="headerlink" title="2.4 errors属性"></a>2.4 errors属性</h5><p>这里的errors和data有一点不同，一般来说返回值中errors作为列表存在，因为针对每个资源可能出现多个错误信息。最典型的例子为，我们请求的对象中某些字段不符合验证要求，这里需要返回验证信息，但是HTTP状态码会使用一个通用的401，然后把具体的验证信息在errors给出来。</p>
<p><img src="https://image.woodwhales.cn/021/images/2.png" alt="errors属性"></p>
<p>在title字段中给出错误信息，如果我们在本地或者开发环境想打出更多的调试堆栈信息，我们可以增加一个detail字段让调试更加方便。需要注意的一点是，我们应该在生产环境屏蔽部分敏感信息，detail字段最好在生产环境不可见。</p>
<h4 id="3-常用的返回码"><a href="#3-常用的返回码" class="headerlink" title="3 常用的返回码"></a>3 常用的返回码</h4><ul>
<li>不要发生了错误但给2xx响应，客户端可能会缓存成功的http请求；</li>
<li>正确设置http状态码，不要自定义；</li>
<li>Response body 提供 1) 错误的代码（日志/问题追查）；2) 错误的描述文本（展示给用户）。</li>
</ul>
<p>常用的http状态码及使用场景：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>200 ok</td>
<td>请求成功</td>
</tr>
<tr>
<td>201 created</td>
<td>POST创建资源返回成功的标志</td>
</tr>
<tr>
<td>400 bad request</td>
<td>常用在参数校验</td>
</tr>
<tr>
<td>401 unauthorized</td>
<td>未经验证的用户，常见于未登录。如果经过验证后依然没权限，应该 403（即 authentication 和 authorization 的区别）。</td>
</tr>
<tr>
<td>403 forbidden</td>
<td>无权限</td>
</tr>
<tr>
<td>404 not found</td>
<td>资源不存在</td>
</tr>
<tr>
<td>500 internal server error</td>
<td>非业务类异常</td>
</tr>
<tr>
<td>503 service unavaliable</td>
<td>由容器抛出，自己的代码不要抛这个异常</td>
</tr>
</tbody></table>
<p>参考文献：</p>
<p><a href="https://zhuanlan.zhihu.com/p/54976216">细说API - 重新认识RESTful</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">RESTful API 最佳实践</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></p>
<p><a href="https://novoland.github.io/%E8%AE%BE%E8%AE%A1/2015/08/17/Restful%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83.html">Restful API 的设计规范</a></p>
<p><a href="https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md">微软API指南</a></p>
]]></content>
      <categories>
        <category>软件架构</category>
      </categories>
      <tags>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高并发编程 | 学习笔记（一）</title>
    <url>/2019/01/28/022/</url>
    <content><![CDATA[<h4 id="1-多线程基础回顾"><a href="#1-多线程基础回顾" class="headerlink" title="1. 多线程基础回顾"></a>1. 多线程基础回顾</h4><h5 id="1-1-synchronized关键字"><a href="#1-1-synchronized关键字" class="headerlink" title="1.1 synchronized关键字"></a>1.1 synchronized关键字</h5><p>为了防止并发编程引发的数据共享问题，最常见引用的锁机制就是利用<code>synchronized关键字</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">synchronized</span>(o) { <span class="comment">// 任何线程要执行下面的代码，必须先拿到 o 的锁</span></span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中<code>synchronized</code>关键字锁住的是堆内存中的<code>Object o</code>对象，而不是<code>引用 o</code>。</p>
<h5 id="1-2-synchronized关键字对当前类对象加锁"><a href="#1-2-synchronized关键字对当前类对象加锁" class="headerlink" title="1.2 synchronized关键字对当前类对象加锁"></a>1.2 synchronized关键字对当前类对象加锁</h5><p>如上小节所示，每次锁对象的时候，都 new 一个要锁的对象，未免太麻烦，不如锁一个现成的对象：<code>this</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="built_in">this</span>) { <span class="comment">// 任何线程要执行下面的代码，必须先拿到this的锁</span></span><br><span class="line">			count--;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码与下面代码等同：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> { <span class="comment">// 等同于在方法的代码执行时要synchronized(this)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-3-synchronized-锁住静态方法的时候"><a href="#1-3-synchronized-锁住静态方法的时候" class="headerlink" title="1.3 synchronized 锁住静态方法的时候"></a>1.3 synchronized 锁住静态方法的时候</h5><p>当有<code>static</code>存在的时候，<code>synchronized</code>关键字锁住的是静态类的 .class 类对象（java.lang.Class 类）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized关键字</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> { <span class="comment">//这里等同于synchronized(org.woodwhales.T.class)</span></span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mm</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">synchronized</span>(T.class) { <span class="comment">//考虑一下这里写synchronized(this)是否可以？</span></span><br><span class="line">			count --;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-5-synchronized关键字解决线程重入问题"><a href="#1-5-synchronized关键字解决线程重入问题" class="headerlink" title="1.5 synchronized关键字解决线程重入问题"></a>1.5 <code>synchronized</code>关键字解决线程重入问题</h5><p>下面代码中，如果类 T 的 run() 方法没有 synchronized 锁机制保护方法体里的代码，那么会出现线程重入的问题而导致的数据不一致问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> { </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) {</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出奇怪的结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">THREAD0</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="type">THREAD3</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="type">THREAD2</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="type">THREAD1</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="type">THREAD4</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>从上述示例可知：synchronized 代码块中的数据操作是原子操作，原子操作在多线程操作数据资源中是不可分割的，因为当某个线程得到锁的时候，其他无法获取到这把锁，而需要等待获得锁，获得的前提条件是：已获得锁的线程执行完锁代码块中的资源操作之后释放掉锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比上面一个小程序，分析一下这个程序的输出</span></span><br><span class="line"><span class="comment"> * T 对象的 run() 方法使用了同步锁，因此不会出现多线程同步问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> { </span><br><span class="line">		count--;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) {</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(t, <span class="string">"THREAD"</span> + i).start();</span><br><span class="line">		}</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果始终是：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">THREAD0</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span></span><br><span class="line"><span class="type">THREAD1</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="type">THREAD3</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">7</span></span><br><span class="line"><span class="type">THREAD2</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="type">THREAD4</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-6-同步方法和非同步方法可以同时被多线程调用"><a href="#1-6-同步方法和非同步方法可以同时被多线程调用" class="headerlink" title="1.6 同步方法和非同步方法可以同时被多线程调用"></a>1.6 同步方法和非同步方法可以同时被多线程调用</h5><p>下面示例中：m1() 方法是同步方法，m2() 方法是非同步方法，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步和非同步方法是否可以同时调用？</span></span><br><span class="line"><span class="comment"> * 可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> { </span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 start..."</span>);</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m1 end"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" m2 "</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*new Thread(()-&gt;t.m1(), "t1").start();</span></span><br><span class="line"><span class="comment">		new Thread(()-&gt;t.m2(), "t2").start();*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m1, <span class="string">"t1"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m2, <span class="string">"t2"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 上面代码在 JDK1.8 中等同于下面代码</span></span><br><span class="line"><span class="comment">		new Thread(new Runnable() {</span></span><br><span class="line"><span class="comment">			@Override</span></span><br><span class="line"><span class="comment">			public void run() {</span></span><br><span class="line"><span class="comment">				t.m1();</span></span><br><span class="line"><span class="comment">			}</span></span><br><span class="line"><span class="comment">		});</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行结果：m1 打印的过程之中， m2 也打印了出来，因此可以得出结论，m1() 方法被线程运行的时候，其他的非同步方法可以被其他线程调用运行，也就是 synchronized 方法块在执行的过程中，非 synchronized 方法是可以被执行的。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">t1 m1 start...</span><br><span class="line">t2 m2 </span><br><span class="line">t1 m1 end</span><br></pre></td></tr></tbody></table></figure>





]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java高并发编程 | 学习笔记（二）</title>
    <url>/2019/02/14/023/</url>
    <content><![CDATA[<h5 id="1-7-写方法和读方法的加锁选择问题"><a href="#1-7-写方法和读方法的加锁选择问题" class="headerlink" title="1.7 写方法和读方法的加锁选择问题"></a>1.7 写方法和读方法的加锁选择问题</h5><p>下面代码中：存在一个 Account 对象（属性有名称和余额），下面代码中存在的注释暂时忽略不计：set() 方法是同步的，getBalance() 方法不是同步的。</p>
<p>main方法启动的时候，先启动了个线程，设置账户名和余额，主线程会两次读取账户余额，可能看到的设置余额和读取余额是一致的，但是当 Account 类的 run() 方法中增加线程睡眠，以增大线程阻塞问题，就会出现设置账户名称之后，还没设置账户余额的时候，其他线程就读取到了账户余额，因此导致脏读的问题，在金融业务中，脏读很有必要避免的。</p>
<p>避免线程脏读问题就需要对读操作也进行加锁。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对业务写方法加锁</span></span><br><span class="line"><span class="comment"> * 对业务读方法不加锁</span></span><br><span class="line"><span class="comment"> * 容易产生脏读问题（dirtyRead）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> {</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">double</span> balance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name, <span class="type">double</span> balance)</span> {</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		try {</span></span><br><span class="line"><span class="comment">			Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">		} catch (InterruptedException e) {</span></span><br><span class="line"><span class="comment">			e.printStackTrace();</span></span><br><span class="line"><span class="comment">		}</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">this</span>.balance = balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">(String name)</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">Account</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;a.set(<span class="string">"zhangsan"</span>, <span class="number">100.0</span>)).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		System.out.println(a.getBalance(<span class="string">"zhangsan"</span>));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-8-synchronized-是重入锁"><a href="#1-8-synchronized-是重入锁" class="headerlink" title="1.8 synchronized 是重入锁"></a>1.8 synchronized 是重入锁</h5><p>下面代码中：m1() 和 m2() 方法都加了 synchronized 锁，两个锁的对象都是<code>this</code>，那么当一个线程已经运行 m1() 方法之时，在 m1() 方法中调用了 m2() 方法，且这个 m2() 方法也是加了锁的，是否可以调用这个 m2() 方法运行，答案是可以的，synchronized 会有计数器进行计数，表示重入了几次。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment"> * 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"m1 start"</span>);</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		m2();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在子类和父类之间，也是可以 synchronized 重入。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.</span></span><br><span class="line"><span class="comment"> * 也就是说synchronized获得的锁是可重入的</span></span><br><span class="line"><span class="comment"> * 这里是继承中有可能发生的情形，子类调用父类的同步方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> yxxy.c_010;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"m end"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">TT</span>().m();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span> <span class="keyword">extends</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"child m start"</span>);</span><br><span class="line">		<span class="built_in">super</span>.m();</span><br><span class="line">		System.out.println(<span class="string">"child m end"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1-9-synchronized遇到抛出异常的时候会释放锁"><a href="#1-9-synchronized遇到抛出异常的时候会释放锁" class="headerlink" title="1.9 synchronized遇到抛出异常的时候会释放锁"></a>1.9 synchronized遇到抛出异常的时候会释放锁</h5><p>程序在执行过程中，如果出现异常，默认情况锁会被释放，所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。代码中，当 count 子增到 5 的时候会因为算术计算异常导致锁被释放，那么当前线程只执行了一半操作，另一半未操作的资源会被其他线程抢去操作，造成线程同步问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序在执行过程中，如果出现异常，默认情况锁会被释放</span></span><br><span class="line"><span class="comment"> * 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。</span></span><br><span class="line"><span class="comment"> * 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，</span></span><br><span class="line"><span class="comment"> * 在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。</span></span><br><span class="line"><span class="comment"> * 因此要非常小心的处理同步业务逻辑中的异常</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" start"</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">			count ++;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" count = "</span> + count);</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="number">5</span>) {</span><br><span class="line">				<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//此处抛出异常，锁将被释放，要想不被释放，可以在这里进行catch，然后让循环继续</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">				t.m();</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">		};</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">"t1"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">"t2"</span>).start();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-10-volatile-保证线程的可见性"><a href="#1-10-volatile-保证线程的可见性" class="headerlink" title="1.10 volatile 保证线程的可见性"></a>1.10 volatile 保证线程的可见性</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile 关键字，使一个变量在多个线程间可见</span></span><br><span class="line"><span class="comment"> * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</span></span><br><span class="line"><span class="comment"> * 使用volatile关键字，会让所有线程都会读到变量的修改值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在下面的代码中，running是存在于堆内存的t对象中</span></span><br><span class="line"><span class="comment"> * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去</span></span><br><span class="line"><span class="comment"> * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用volatile，将会强制所有线程都去堆内存中读取running的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以阅读这篇文章进行更深入的理解</span></span><br><span class="line"><span class="comment"> * http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="comment">/*volatile*/</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">		<span class="keyword">while</span>(running) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			try {</span></span><br><span class="line"><span class="comment">				TimeUnit.MILLISECONDS.sleep(10);</span></span><br><span class="line"><span class="comment">			} catch (InterruptedException e) {</span></span><br><span class="line"><span class="comment">				e.printStackTrace();</span></span><br><span class="line"><span class="comment">			}*/</span></span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"m end!"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		t.running = <span class="literal">false</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：volatile 并不能保证原子性</strong></p>
<p>十个线程在自增的时候，当自增完了就会刷新到主内存，当其他线程要拿的时候会更新，但是拿完之后，刚要自增操作的时候，CPU 资源被其他线程抢占，因此别的线程都自增成很大的数值，而此线程再抢到 CPU 资源执行自增的时候，还是之前的小数值自增，因此下面代码中的每个线程自增一万，十个线程执行之后，最终的 count 应该是十万，当时结果很差强人意。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span></span><br><span class="line"><span class="comment"> * 运行下面的程序，并分析结果</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) count++;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		</span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) {</span><br><span class="line">			threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m, <span class="string">"thread-"</span>+i));</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;o.start());</span><br><span class="line">		</span><br><span class="line">		threads.forEach((o)-&gt;{</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				o.join();</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line">		</span><br><span class="line">		System.out.println(t.count);	</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用带有原子性操作的对象，下面代码中的 AtomicInteger在自增时候就是原子操作，因此可以保证一致性问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决同样的问题的更高效的方法，使用AtomXXX类</span></span><br><span class="line"><span class="comment"> * AtomXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	<span class="comment">/*volatile*/</span> <span class="comment">//int count = 0;</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/*synchronized*/</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> { </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">			<span class="comment">//if count.get() &lt; 1000</span></span><br><span class="line">			count.incrementAndGet(); <span class="comment">//count++</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line"></span><br><span class="line">		List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">			threads.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m, <span class="string">"thread-"</span> + i));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		threads.forEach((o) -&gt; o.start());</span><br><span class="line"></span><br><span class="line">		threads.forEach((o) -&gt; {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				o.join();</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line"></span><br><span class="line">		System.out.println(t.count);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="1-11-synchronized-优化（粗细锁）"><a href="#1-11-synchronized-优化（粗细锁）" class="headerlink" title="1.11 synchronized 优化（粗细锁）"></a>1.11 synchronized 优化（粗细锁）</h5><p>下面代码中，由于 synchronized 锁的范围不同，会导致程序执行效率的不同，越精细的锁越高效。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized优化</span></span><br><span class="line"><span class="comment"> * 同步代码块中的语句越少越好</span></span><br><span class="line"><span class="comment"> * 比较m1和m2</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> {</span><br><span class="line">		<span class="comment">//do sth need not sync</span></span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">		count ++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//do sth need not sync</span></span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> {</span><br><span class="line">		<span class="comment">//do sth need not sync</span></span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//业务逻辑中只有下面这句需要sync，这时不应该给整个方法上锁</span></span><br><span class="line">		<span class="comment">//采用细粒度的锁，可以使线程争用时间变短，从而提高效率</span></span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="built_in">this</span>) {</span><br><span class="line">			count ++;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//do sth need not sync</span></span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="1-12-到底锁的是什么（锁定堆中的对象）"><a href="#1-12-到底锁的是什么（锁定堆中的对象）" class="headerlink" title="1.12 到底锁的是什么（锁定堆中的对象）"></a>1.12 到底锁的是什么（锁定堆中的对象）</h5><p>下面代码中，m() 方法是一个死循环，当第一个线程拿到锁的时候，按理来说，一定是不会释放锁的，因为这个线程就是个无限死循环执行代码，而当锁对象发生改变，会造成锁定要锁的对象被释放掉了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁定某对象o，如果o的属性发生改变，不影响锁的使用</span></span><br><span class="line"><span class="comment"> * 但是如果o变成另外一个对象，则锁定的对象发生改变</span></span><br><span class="line"><span class="comment"> * 应该避免将锁定对象的引用变成另外的对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">synchronized</span>(o) {</span><br><span class="line">			<span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">					TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">				} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				}</span><br><span class="line">				System.out.println(Thread.currentThread().getName());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">		<span class="comment">//启动第一个线程</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//创建第二个线程</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t::m, <span class="string">"t2"</span>);</span><br><span class="line">		</span><br><span class="line">		t.o = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span></span><br><span class="line">		</span><br><span class="line">		t2.start();	</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger入门教程</title>
    <url>/2019/03/06/024/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Swagger 能成为最受欢迎的 RESTful APIs 文档生成工具之一，有以下几个原因：</p>
<ul>
<li>Swagger 可以生成一个具有互动性的 API 控制台，开发者可以用来快速学习和尝试 API。</li>
<li>Swagger 可以生成客户端 SDK 代码用于各种不同的平台上的实现。</li>
<li>Swagger 文件可以在许多不同的平台上从代码注释中自动生成。</li>
<li>Swagger 有一个强大的社区，里面有许多强悍的贡献者。</li>
</ul>
<p>Swagger 文档提供了一个方法，使我们可以用指定的 JSON 或者 YAML 摘要来描述你的 API，包括了比如 names、order 等 API 信息。</p>
<blockquote>
<p>用 Swagger 文件生成互动的 API 文档是最精简的，它展示了资源、参数、请求、响应。但是它不会提供你的API如何工作的其他任何一个细节。</p>
</blockquote>
<h4 id="一、maven-工程依赖"><a href="#一、maven-工程依赖" class="headerlink" title="一、maven 工程依赖"></a>一、maven 工程依赖</h4><p>引入 jar 文件：springfox-swagger2、springfox-swagger-ui</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="二、swagger-全局配置"><a href="#二、swagger-全局配置" class="headerlink" title="二、swagger 全局配置"></a>二、swagger 全局配置</h4><p>2.1 创建 config 目录，新建 swagger 的配置文件 swaggerConfig.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhales.king.controller"})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> {</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Docket <span class="title function_">customDocket</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">"woodwhale"</span>, <span class="string">"http://127.0.0.1/"</span>, <span class="string">"woodwhales.github.io"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">				.title(<span class="string">"swagger入门教程"</span>)</span><br><span class="line">				.contact(contact)</span><br><span class="line">				.description(<span class="string">"这里是 RESTful API 描述"</span>)</span><br><span class="line">				.version(<span class="string">"1.0.1"</span>).build();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2.2 在 config 目录中，继续创建 WebMvcConfig.java 配置文件，将 swagger-ui 页面注入到 spring 中</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> {</span><br><span class="line">		registry.addResourceHandler(<span class="string">"swagger-ui.html"</span>)</span><br><span class="line">		.addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>);</span><br><span class="line">		</span><br><span class="line">		registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">		.addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上配置的资源是在<code>springfox-swagger-ui.jar</code> jar 文件中，这个 jar 包只有 META-INF 目录。</p>
<h4 id="三、编写-RESTful-接口"><a href="#三、编写-RESTful-接口" class="headerlink" title="三、编写 RESTful 接口"></a>三、编写 RESTful 接口</h4><p>编写 controller 代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping("/users")</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(value = "用户模块", description = "用户模块的接口")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> {</span><br><span class="line">		users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">"Tom"</span>, <span class="number">12</span>));</span><br><span class="line">		users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">"Tina"</span>, <span class="number">11</span>));</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@ApiOperation(value = "获取用户列表", notes = "获取所有用户的列表")</span></span><br><span class="line">	<span class="meta">@GetMapping("/")</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">users</span><span class="params">()</span> {</span><br><span class="line">		Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		map.put(<span class="string">"users"</span>, users);</span><br><span class="line">		<span class="keyword">return</span> map;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@ApiOperation(value = "用户详情", notes = "根据id获取用户")</span></span><br><span class="line">	<span class="meta">@ApiImplicitParam(value = "用户的id", paramType = "path")</span></span><br><span class="line">	<span class="meta">@GetMapping("/{id}")</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable("id")</span> <span class="type">int</span> id)</span> {</span><br><span class="line">		<span class="keyword">return</span> users.get(id);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@ApiOperation(value = "创建用户", notes = "新增用户")</span></span><br><span class="line">	<span class="meta">@ApiImplicitParam(value = "用户对象", paramType = "query")</span></span><br><span class="line">	<span class="meta">@PostMapping("/")</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> {</span><br><span class="line">		<span class="keyword">return</span> users.add(user);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 application.yml 中配置 web 端口：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  address: 127.0.0.1</span><br><span class="line">  port: 80</span><br></pre></td></tr></tbody></table></figure>

<p>访问：<a href="http://127.0.0.1/swagger-ui.html">http://127.0.0.1:80/swagger-ui.html</a></p>
<p><img src="https://image.woodwhales.cn/024/images/swagger01.png" alt="访问swagger-ui"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis Plus 学习笔记</title>
    <url>/2019/03/28/025/</url>
    <content><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="TableName"><a href="#TableName" class="headerlink" title="@TableName"></a>@TableName</h4><p>表名注解，当数据库中的表名和实体类名之间不能完全匹配时，需要使用这个注解进行绑定。</p>
<p>如：数据库表中的数据库表名为<code>t_student</code>，而实体类的类名为：<code>Student</code>，则需要在该类上增加注解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(value = "t_student"）</span></span><br><span class="line"><span class="meta">public class Student {</span></span><br><span class="line"><span class="meta">	private Long stuId;   </span></span><br><span class="line"><span class="meta">}</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="全局设置数据库表前缀"><a href="#全局设置数据库表前缀" class="headerlink" title="全局设置数据库表前缀"></a>全局设置数据库表前缀</h5><p>当数据库表中的所有表名前有前缀时，需要每次指定<code>@TableName</code>注解，很麻烦，需要使用全局配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">global-config:</span> </span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">"t_"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a>@TableId</h4><p>主键注解，当数据库中的主键和实体类中主键属性不同时，使用这个注解进行绑定。<br>如：数据库表中的主键是<code>id</code>，而实体类中的属性值是<code>stuId</code>，那么就在实体类主键属性上加上注解</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line">    <span class="meta">@TableId(value = "id")</span></span><br><span class="line">	<span class="keyword">private</span> Long stuId;   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="IdType"><a href="#IdType" class="headerlink" title="IdType"></a>IdType</h5><p><code>@TableId</code>注解还有一个属性配置是主键的主键类型，具体可选值如下，默认值为：<strong>IdType.NONE</strong></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AUTO</td>
<td align="center">数据库自增</td>
</tr>
<tr>
<td align="center">INPUT</td>
<td align="center">自行输入</td>
</tr>
<tr>
<td align="center">ID_WORKER</td>
<td align="center">分布式全局唯一ID 长整型类型</td>
</tr>
<tr>
<td align="center">UUID</td>
<td align="center">32位UUID字符串</td>
</tr>
<tr>
<td align="center">NONE</td>
<td align="center">无状态（<strong>默认</strong>）</td>
</tr>
<tr>
<td align="center">ID_WORKER_STR</td>
<td align="center">分布式全局唯一ID 字符串类型</td>
</tr>
</tbody></table>
<h5 id="全局设置设置注解策略"><a href="#全局设置设置注解策略" class="headerlink" title="全局设置设置注解策略"></a>全局设置设置注解策略</h5><p>设置主键策略，默认值：<strong>ID_WORKER</strong></p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">global-config:</span> </span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">AUTO</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="全局设置驼峰功能"><a href="#全局设置驼峰功能" class="headerlink" title="全局设置驼峰功能"></a>全局设置驼峰功能</h5><p>mybatisPlus 有一个全局的配置策略，可以实现数据库表中的列名字段是下划线分割，自动对应实体类中驼峰名：</p>
<p>如：数据库中的<code>stu_address</code>字段与实体类中的<code>stuAddress</code>属性字段相对应。</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-underline:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 表名、是否使用下划线命名（默认 true:默认数据库表下划线命名）</span></span><br></pre></td></tr></tbody></table></figure>

<p>在 Springboot 中，可以通过设置<code>map-underscore-to-camel-case</code>属性为 true 来开启驼峰功能。因此 mybatisPlus 也继承了这种配置，默认为 <strong>true</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h4><h5 id="value"><a href="#value" class="headerlink" title="value"></a>value</h5><p>当显示配置的时候，则按设置的值为准。</p>
<h5 id="exist"><a href="#exist" class="headerlink" title="exist"></a>exist</h5><p>标识该字段是数据库表字段，当实体类中有属性字段不在数据库表中的时候，就需要在数据库操作时忽略这些字段，因此可以配置<code>exist=false</code>属性配置，如果不配置，默认为：<strong>true</strong></p>
<h3 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h3><p>BaseMapper 接口是专门用来进行通用增删改查的接口，通过指定泛型可以对数据实体对象进行通用的CIUD操作，大致可以分为四类：</p>
<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p><code>int insert(T entity)</code></p>
<p>insert 方法会将实体对象中的非空属性值映射到数据库，进行插入操作，也就是说有多少非空属性，执行的SQL语句中才插入多少，和 mybatis 中的 insertSeletive 一样，有值才操作。</p>
<p><strong>亮点</strong>：</p>
<p>插入成功默认返回主键，mybatis Plus 插入数据之后，实体类中的主键会返回给实体类，相比 mybatis 原生的默认不返回要很多繁琐的配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"stuId"</span> <span class="attr">parameterType</span>=<span class="string">"org.woodwhales.king.Student"</span>&gt;</span></span><br><span class="line">    insert into student(userName, password, comment)</span><br><span class="line">    values(#{userName}, #{password}, #{comment})</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>其中：<code>keyProperty</code>中配置的是实体类中的属性字段，用来接收数据库表返回的主键值。</p>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><h5 id="根据主键更新"><a href="#根据主键更新" class="headerlink" title="根据主键更新"></a>根据主键更新</h5><p><code>int updateById(T entity)</code></p>
<h5 id="带条件的更新"><a href="#带条件的更新" class="headerlink" title="带条件的更新"></a>带条件的更新</h5><p><code>int update(T entity, Wrapper&lt;T&gt; updateWrapper)</code></p>
<p>如：更新姓名为<code>Tom</code>且年龄为 28 的学生数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Student&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Student&gt;().lambda()</span><br><span class="line">                                                            .eq(Student::getName, <span class="string">"Tom"</span>)</span><br><span class="line">                                                            .eq(Student::getAge, <span class="number">28</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()</span><br><span class="line">            .name(<span class="string">"woodwhales"</span>)</span><br><span class="line">            .age(<span class="number">20</span>)</span><br><span class="line">            .email(<span class="string">"woodwhales@woodwhales.com"</span>).build();</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> studentMapper.update(student, lambdaQueryWrapper);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>SQL脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt; Preparing: UPDATE student SET name=?, age=?, email=? WHERE name = ? AND age = ? </span><br><span class="line">==&gt; Parameters: woodwhales(String), 20(Integer), woodwhales@woodwhales.com(String), Tom(String), 28(Integer)</span><br><span class="line">&lt;== Updates: 1</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>EntityWapper</p>
<p>注意：条件构造器中使用的是数据列名，而不是实体类对象属性。</p>
<h4 id="分页查询（带条件）"><a href="#分页查询（带条件）" class="headerlink" title="分页查询（带条件）"></a>分页查询（带条件）</h4><p>对于条件构造器的编写，可以使用最原始写法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;();</span><br><span class="line">    queryWrapper.eq(“stu_name”, <span class="string">"Tom"</span>);</span><br><span class="line">    queryWrapper.like(<span class="string">"email"</span>, <span class="string">"woodwhale"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>也可以使用<code>QueryWrapper&lt;User&gt;().lambda()</code>这样类似于 JDK1.8 的<code>lambda表达式</code>编写条件构造器，下文中均采用此写法。</p>
<p>例：查询数据库中 student 表（<code>Student</code> 实体类）中的所有姓名为<code>Tom</code>且年龄在10-20 岁之间的分页数据，当前页为 1，每页显示数为 2</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">IPage&lt;Student&gt; pager = studentMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;Student&gt;(<span class="number">1</span>, <span class="number">2</span>), </span><br><span class="line">        		<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">				.eq(Student::getName, <span class="string">"Tom"</span>)</span><br><span class="line">				.between(Student::getAge, <span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">				</span><br><span class="line">	List&lt;Student&gt; studentList = pager.getRecords();</span><br><span class="line">	studentList.forEach(System.out::println);</span><br><span class="line">	System.out.println(<span class="string">"total: "</span> + pager.getTotal());</span><br><span class="line">    System.out.println(<span class="string">"pages: "</span> + pager.getPages());</span><br><span class="line">    System.out.println(<span class="string">"size: "</span> + pager.getSize());</span><br></pre></td></tr></tbody></table></figure>

<p><strong>SQL脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt; Preparing: SELECT id,name,age,email FROM student WHERE name = ? AND age BETWEEN ? AND ? LIMIT ?,? </span><br><span class="line">==&gt; Parameters: Tom(String), 10(Integer), 20(Integer), 0(Long), 1(Long)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意</strong>：上面代码查询出来的对象<code>pager</code>中的<code>total</code>和<code>pages</code>总是为 0 ，解决办法：编写一个配置类，自定义一个分页插件<code>PaginationInterceptor</code>配置到 spring 中即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">PaginationInterceptor</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">        page.setDialectType(DbType.MYSQL.getDb()); <span class="comment">// 设置数据库方言</span></span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中：只需要返回<code>new PaginationInterceptor()</code>即可使得<code>selectPage</code>返回对象中有数据总记录数。</p>
<h4 id="带条件的查询-并且"><a href="#带条件的查询-并且" class="headerlink" title="带条件的查询-并且"></a>带条件的查询-并且</h4><p>查询数据库中 student 表（<code>Student</code> 实体类）中的所有邮箱名字含有<code>woodwhale</code>且年龄在10-20 岁之间的所有数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = studentMapper.selectList(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Student&gt;()</span><br><span class="line">							.lambda()</span><br><span class="line">							.like(Student::getEmail, <span class="string">"woodwhale"</span>)</span><br><span class="line">							.between(Student::getAge, <span class="number">10</span>, <span class="number">20</span>));</span><br></pre></td></tr></tbody></table></figure>

<p><strong>SQL脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt; Preparing: SELECT id,name,age,email FROM student WHERE email LIKE ? AND age BETWEEN ? AND ? </span><br><span class="line">==&gt; Parameters: %woodwhale%(String), 10(Integer), 20(Integer)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="带条件的查询-或者"><a href="#带条件的查询-或者" class="headerlink" title="带条件的查询-或者"></a>带条件的查询-或者</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">IPage&lt;Student&gt; pager = studentMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;Student&gt;(<span class="number">1</span>, <span class="number">2</span>), </span><br><span class="line">													<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;Student&gt;().lambda()</span><br><span class="line">														.eq(Student::getName, <span class="string">"Tom"</span>)</span><br><span class="line">														.between(Student::getAge, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">														.or()</span><br><span class="line">														.like(Student::getEmail, <span class="string">"woodwhale"</span>));</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意</strong>：<code>or()</code>中可以传参一个布尔表达式，当条件为<code>false</code>时，或者作用失效，后面的条件会与前面的条件形成并且的关系。引用官方的解释：</p>
<blockquote>
<p>主动调用<code>or</code>表示紧接着下一个<strong>方法</strong>不是用<code>and</code>连接！（不调用<code>or</code>则默认为使用<code>and</code>连接）</p>
</blockquote>
<p><strong>SQL脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT COUNT(1) FROM student WHERE name = ? AND age BETWEEN ? AND ? OR email LIKE ? </span><br><span class="line">==&gt; Parameters: Tom(String), 10(Integer), 20(Integer), %woodwhale%(String)</span><br><span class="line">==&gt; Preparing: SELECT id,name,age,email FROM student WHERE name = ? AND age BETWEEN ? AND ? OR email LIKE ? limit ? </span><br><span class="line">==&gt; Parameters: Tom(String), 10(Integer), 20(Integer), %woodwhale%(String), 1(Long)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查询结果排序"><a href="#查询结果排序" class="headerlink" title="查询结果排序"></a>查询结果排序</h4><p><code>orderBy(boolean condition, boolean isAsc, R... columns)</code></p>
<p>对查询的结果进行降序排列（<code>isAsc</code> 设置成了<code>false</code>）</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Student&gt; studentList = userMapper.selectList(Wrappers.&lt;Student&gt;query().orderBy(<span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"age"</span>));</span><br><span class="line">studentList.forEach(System.out::println);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>SQL 脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt; Preparing: SELECT id,name,age,email FROM student ORDER BY age DESC </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;== Total: 8</span><br></pre></td></tr></tbody></table></figure>

<p>mybatis Plus 提供了更加便捷的方法：</p>
<p>降序排序</p>
<p><code>orderByDesc(R column)</code></p>
<p><code>orderByDesc(R... columns)</code></p>
<p><code>orderByDesc(boolean condition, R... columns)</code></p>
<p>升序排序</p>
<p><code>orderByAsc(R column)</code></p>
<p><code>orderByAsc(R... columns)</code></p>
<p><code>orderByAsc(boolean condition, R... columns)</code></p>
<h3 id="领域模式"><a href="#领域模式" class="headerlink" title="领域模式"></a>领域模式</h3><p><code>ActiveRecord</code></p>
<p>必须存在对应的<code>原始mapper</code>并继承<code>baseMapper</code>并且可以使用的前提下，才能使用此 AR 模式。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>实体类对象继承 <code>Model</code>抽象类即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Model</span>&lt;Student&gt;{</span><br><span class="line">	<span class="meta">@TableId(type=IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对数据的增删改查操作，直接操作自己即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder().id(<span class="literal">null</span>).name(<span class="string">"adc"</span>).age(<span class="number">20</span>).email(<span class="string">"ss@q.com"</span>).build();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">insert</span> <span class="operator">=</span> student.insert();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>领域模式下查询主键的方法，有参数传入时以传入为准，无参数时以对象为准。当对象没有主键时，会报<code>com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: selectById primaryKey is null.</code>异常，删除主键的方法同理，另外删除逻辑上不存在的数据也是返回成功。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder().id(<span class="number">5L</span>).build();</span><br><span class="line"><span class="type">Student</span> <span class="variable">result</span> <span class="operator">=</span> student.selectById(<span class="number">6L</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>SQL脚本执行日志</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">==&gt; Preparing: SELECT id,name,age,email FROM student WHERE id=? </span><br><span class="line">==&gt; Parameters: 6(Long)</span><br><span class="line">&lt;== Total: 1</span><br></pre></td></tr></tbody></table></figure>

<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>分页返回的数据对象是<code>IPage</code>，从<code>IPage</code>可以获取相应的总记录数，记录，当前页，每页数。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，MyBatis-Plus 的代码生成器比 Mybatis 原生的代码生成器强大的地方在于，能够快速生成通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<p>以下代码生成器中开启了<code>lombok</code>，<code>sprigboot-web</code>，<code>swagger2</code>，<code>freemarker</code>，因此需要添加依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- lombok  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring-boot-web  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis-plus  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- druid  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis-plus-generator  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- freemarker  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- swagger2  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- swagger-ui  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringPool;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.InjectionConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.FileOutConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.TemplateConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableInfo;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generator</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="comment">// 代码生成器</span></span><br><span class="line">		<span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 全局配置</span></span><br><span class="line">		<span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line">		gc.setActiveRecord(<span class="literal">true</span>); <span class="comment">// 开启领域模式</span></span><br><span class="line">		gc.setIdType(IdType.AUTO);</span><br><span class="line">		gc.setServiceName(<span class="string">"%sService"</span>); <span class="comment">// 各层文件名称方式，例如： %sAction 生成 UserAction</span></span><br><span class="line">		gc.setOutputDir(projectPath + <span class="string">"/src/main/java"</span>); <span class="comment">// 生成文件的输出目录【默认 D 盘根目录】</span></span><br><span class="line">		gc.setAuthor(<span class="string">"woodwhales"</span>); <span class="comment">// [开发者]</span></span><br><span class="line">		gc.setFileOverride(<span class="literal">true</span>); <span class="comment">// 开启文件覆盖</span></span><br><span class="line">		gc.setOpen(<span class="literal">false</span>); <span class="comment">// 是否打开输出目录</span></span><br><span class="line">		gc.setSwagger2(<span class="literal">true</span>); <span class="comment">// 开启 swagger2 模式</span></span><br><span class="line">		gc.setBaseResultMap(<span class="literal">true</span>); <span class="comment">// 开启 BaseResultMap</span></span><br><span class="line">		gc.setBaseColumnList(<span class="literal">true</span>); <span class="comment">// 开启 baseColumnList</span></span><br><span class="line">		mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 数据源配置</span></span><br><span class="line">		<span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">		dsc.setUrl(<span class="string">"jdbc:mysql://localhost:3306/mytest?useUnicode=true&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC"</span>);</span><br><span class="line">		dsc.setDriverName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>); <span class="comment">// 注意：mysql 5.7 之后的驱动是com.mysql.cj.jdbc.Driver</span></span><br><span class="line">		dsc.setDbType(DbType.MYSQL);</span><br><span class="line">		dsc.setUsername(<span class="string">"root"</span>);</span><br><span class="line">		dsc.setPassword(<span class="string">"root"</span>);</span><br><span class="line">		mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 包配置</span></span><br><span class="line">		<span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">		pc.setParent(<span class="string">"org.woodwahles"</span>); <span class="comment">// [实体类所在模块的父模块名]</span></span><br><span class="line">		pc.setModuleName(<span class="string">"king"</span>); <span class="comment">// [实体类所在模块名]</span></span><br><span class="line">		pc.setXml(<span class="string">"mapper"</span>); <span class="comment">// 默认包名：mapper.xml</span></span><br><span class="line">		mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 自定义配置</span></span><br><span class="line">		<span class="type">InjectionConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InjectionConfig</span>() {</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMap</span><span class="params">()</span> {</span><br><span class="line">				<span class="comment">// to do nothing</span></span><br><span class="line">			}</span><br><span class="line">		};</span><br><span class="line">		List&lt;FileOutConfig&gt; focList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		focList.add(<span class="keyword">new</span> <span class="title class_">FileOutConfig</span>(<span class="string">"/templates/mapper.xml.ftl"</span>) {</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> String <span class="title function_">outputFile</span><span class="params">(TableInfo tableInfo)</span> {</span><br><span class="line">				<span class="comment">// 自定义mapper文件名称</span></span><br><span class="line">				<span class="keyword">return</span> projectPath + <span class="string">"/src/main/resources/mapper/"</span> + pc.getModuleName() + <span class="string">"/"</span></span><br><span class="line">						+ tableInfo.getEntityName() + <span class="string">"Mapper"</span> + StringPool.DOT_XML;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		});</span><br><span class="line">		cfg.setFileOutConfigList(focList);</span><br><span class="line">		mpg.setCfg(cfg);</span><br><span class="line">		mpg.setTemplate(<span class="keyword">new</span> <span class="title class_">TemplateConfig</span>().setXml(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 策略配置</span></span><br><span class="line">		<span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">		strategy.setNaming(NamingStrategy.underline_to_camel); <span class="comment">// 下划线转驼峰命名</span></span><br><span class="line">		strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">		strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">		strategy.setInclude(<span class="string">"student"</span>); <span class="comment">// [表名]</span></span><br><span class="line">		strategy.setSuperEntityColumns(<span class="string">"id"</span>);</span><br><span class="line">		strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">		<span class="comment">// strategy.setTablePrefix(pc.getModuleName() + "_"); // 数据库表名前缀</span></span><br><span class="line">		mpg.setStrategy(strategy);</span><br><span class="line">		<span class="comment">// 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！</span></span><br><span class="line">		mpg.setTemplateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>());</span><br><span class="line">		mpg.execute();</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生成的项目结构如下：</p>
<p><img src="https://image.woodwhales.cn/025/images/1.png" alt="代码生成器生成的项目结构"></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="攻击-SQL-阻断解析器"><a href="#攻击-SQL-阻断解析器" class="headerlink" title="攻击 SQL 阻断解析器"></a>攻击 SQL 阻断解析器</h4><p>作用！阻止恶意的全表更新删除</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">PaginationInterceptor</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">        page.setDialectType(DbType.MYSQL.getDb()); <span class="comment">// 设置数据库方言</span></span><br><span class="line">        </span><br><span class="line">        List&lt;ISqlParser&gt; sqlParserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 攻击 SQL 阻断解析器、加入解析链</span></span><br><span class="line">        sqlParserList.add(<span class="keyword">new</span> <span class="title class_">BlockAttackSqlParser</span>());</span><br><span class="line">        page.setSqlParserList(sqlParserList);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h4><p>该插件只用于开发环境，不建议生产环境使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  性能分析插件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile({"dev","test"})</span> <span class="comment">// 设置 dev test 环境开启</span></span><br><span class="line">    <span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>();</span><br><span class="line">        <span class="comment">// maxTime 指的是 SQL 执行最大时长，超过自动停止运行，有助于发现问题。</span></span><br><span class="line">        performanceInterceptor.setMaxTime(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// SQL 是否格式化</span></span><br><span class="line">        performanceInterceptor.setFormat(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="乐观锁插件"><a href="#乐观锁插件" class="headerlink" title="乐观锁插件"></a>乐观锁插件</h4><p>目的：当要更新一条记录的时候，希望这条记录没有被别人更新</p>
<p>乐观锁的实现思路：</p>
<ul>
<li>取出记录时，获取当前<code>version</code></li>
<li>更新时，带上这个<code>version</code></li>
<li>执行更新时， set version = newVersion where version = oldVersion</li>
<li>如果<code>version</code>不对，就更新失败</li>
</ul>
<p>插件使用步骤：</p>
<ol>
<li>将插件注入spring 框架：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>使用注解<code>@Version</code>注解实体字段（必要步骤）</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>特别说明</strong>：</p>
<ul>
<li>支持的数据类型只有:<code>int</code>，<code>Integer</code>，<code>long</code>，<code>Long</code>，<code>Date</code>，<code>Timestamp</code>，<code>LocalDateTime</code></li>
<li>整数类型下 <code>newVersion = oldVersion + 1</code></li>
<li><code>newVersion</code> 会回写到 <code>entity</code> 中</li>
<li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li>
<li>在<code>update(entity, wrapper)</code>方法下, wrapper不能复用！</li>
</ul>
<h4 id="逻辑删除插件"><a href="#逻辑删除插件" class="headerlink" title="逻辑删除插件"></a>逻辑删除插件</h4><p>首先指定逻辑删除字段在数据库表中的取值：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></tbody></table></figure>

<p>将插件注入spring中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.injector.ISqlInjector;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfiguration</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实体类字段上加上<code>@TableLogic</code>注解</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></tbody></table></figure>

<p>使用 Mybatis-Plus 自带方法删除和查找都会附带逻辑删除功能（自己写的<code>xml</code>不会）</p>
<h3 id="MybatisX插件（IDEA插件）"><a href="#MybatisX插件（IDEA插件）" class="headerlink" title="MybatisX插件（IDEA插件）"></a>MybatisX插件（IDEA插件）</h3><p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p>
<p>安装方法：打开 IDEA，进入 File -&gt; Settings -&gt; Plugins -&gt; Browse Repositories，输入 <code>mybatisx</code> 搜索并安装。</p>
<p>插件功能：Java 与 XML 调回跳转，Mapper 方法自动生成 XML。</p>
<p>插件源码：<a href="https://gitee.com/baomidou/MybatisX%E3%80%82">https://gitee.com/baomidou/MybatisX。</a></p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis Plus</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Spring Security 学习笔记（一）自定义基本使用及个性化登录配置</title>
    <url>/2019/04/12/026/</url>
    <content><![CDATA[<p><a href="https://spring.io/projects/spring-security#learn">官方文档参考</a>，<a href="https://springcloud.cc/spring-security.html">5.1.2 中文参考文档</a>，<a href="https://springcloud.cc/spring-security-zhcn.html">4.1 中文参考文档</a>，<a href="http://www.tianshouzhi.com/api/tutorials/spring_security_4">4.1 官方文档中文翻译与源码解读</a></p>
<p>SpringSecurity 核心功能：</p>
<ul>
<li>认证（你是谁）</li>
<li>授权（你能干什么）</li>
<li>攻击防护（防止伪造身份）</li>
</ul>
<h2 id="简单的开始"><a href="#简单的开始" class="headerlink" title="简单的开始"></a>简单的开始</h2><p>pom 依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.woodwhale.king<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>security-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>security-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>spring-security-demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>编写一个最简单的用户 controller</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/user")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsers</span><span class="params">()</span> {       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Security"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>application.yml 配置IP 和端口</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">org.woodwhale.king:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></tbody></table></figure>

<p>浏览器访问<a href="http://127.0.0.1:8081/user%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A2%AB%E8%87%AA%E5%8A%A8%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E4%BA%86%E7%99%BB%E5%BD%95%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%9A">http://127.0.0.1:8081/user，浏览器被自动重定向到了登录的界面：</a></p>
<p><img src="https://image.woodwhales.cn/026/images/1-%E9%87%8D%E5%AE%9A%E5%90%91.png"></p>
<p>这个<code>/login</code>访问路径在程序中没有任何的显示代码编写，为什么会出现这样的界面呢，当前界面中的UI 都是哪里来的呢？</p>
<p>当然是 <strong>spring-security</strong> 进行了默认控制，从启动日志中，可以看到一串用户名默认为<code>user</code>的默认密码：</p>
<p><img src="https://image.woodwhales.cn/026/images/2-%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81.png"></p>
<p>登录成功之后，可以正常访问服务资源了。</p>
<h3 id="自定义默认用户名和密码"><a href="#自定义默认用户名和密码" class="headerlink" title="自定义默认用户名和密码"></a>自定义默认用户名和密码</h3><p>在配置文件配置用户名和密码：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">"admin"</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">"admin"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="关闭默认的安全访问控制"><a href="#关闭默认的安全访问控制" class="headerlink" title="关闭默认的安全访问控制"></a>关闭默认的安全访问控制</h3><p>旧版的 spring security 关闭默认安全访问控制，只需要在配置文件中关闭即可：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">security.basic.enabled</span> <span class="string">=</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<p>新版本 Spring-Boot2.xx(Spring-security5.x) 的不再提供上述配置了：</p>
<p>方法1： 将 security 包从项目依赖中去除。</p>
<p>方法2：将<code>org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration</code>不注入spring中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration(exclude = {SecurityAutoConfiguration.class})</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityDemoApplication</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(SecurityDemoApplication.class, args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方法3：己实现一个配置类继承自<code>WebSecurityConfigurerAdapter</code>，并重写<code>configure(HttpSecurity http)</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        http.authorizeRequests().antMatchers(<span class="string">"/**"</span>).permitAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置一个userDetailsService Bean</span></span><br><span class="line"><span class="comment">    * 不再生成默认security.user用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.userDetailsService();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong><code>WebSecurityConfigurerAdapter</code>是一个适配器类，所以为了使自定义的配置类见名知义，所以写成了<code>WebSecurityConfig</code>。同时增加了<code>@EnableWebSecurity</code>注解到了 spring security 中。</p>
<h2 id="自定义用户认证"><a href="#自定义用户认证" class="headerlink" title="自定义用户认证"></a>自定义用户认证</h2><h3 id="安全认证配置注意事项"><a href="#安全认证配置注意事项" class="headerlink" title="安全认证配置注意事项"></a>安全认证配置注意事项</h3><p>springsucrity 的自定义用户认证配置的核心均在上述的<code>WebSecurityConfigurerAdapter</code>类中，用户想要个性化的用户认证逻辑，就需要自己写一个自定义的配置类，适配到 spring security 中：</p>
<p>注意：如果配置了两个以上的自定义实现类，那么就会报<code>WebSecurityConfigurers</code>不唯一的错误：<code>java.lang.IllegalStateException: @Order on WebSecurityConfigurers must be unique.</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrowerSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        http.formLogin()               <span class="comment">//  定义当需要提交表单进行用户登录时候，转到的登录页面。</span></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()   <span class="comment">// 定义哪些URL需要被保护、哪些不需要被保护</span></span><br><span class="line">                .anyRequest()          <span class="comment">// 任何请求,登录后可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="自定义用户名和密码"><a href="#自定义用户名和密码" class="headerlink" title="自定义用户名和密码"></a>自定义用户名和密码</h3><h4 id="密码加密注意事项"><a href="#密码加密注意事项" class="headerlink" title="密码加密注意事项"></a>密码加密注意事项</h4><p>将用户名密码设置到内存中，用户登录的时候会校验内存中配置的用户名和密码：</p>
<p>在旧版本的 spring security 中，在上述自定义的<code>BrowerSecurityConfig</code> 中配置如下代码即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    auth.inMemoryAuthentication().withUser(<span class="string">"admin"</span>).password(<span class="string">"admin"</span>).roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是在新版本中，启动运行都没有问题，一旦用户正确登录的时候，会报异常：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"</span><br></pre></td></tr></tbody></table></figure>

<p>因为在 Spring security 5.0 中新增了多种加密方式，也改变了密码的格式。<a href="https://docs.spring.io/spring-security/site/docs/5.1.5.RELEASE/reference/htmlsingle/#pe-dpe-format">官方文档说明：Password Storage Format</a></p>
<p><img src="https://image.woodwhales.cn/026/images/3-%E5%8A%A0%E5%AF%86%E7%B1%BB%E5%9E%8B.png"></p>
<p>上面这段话的意思是，现在新的 Spring Security 中对密码的存储格式是<code>"{id}……"</code>。前面的 <code>id</code> 是加密方式，id 可以是<code>bcrypt</code>、<code>sha256</code>等，后面紧跟着是使用这种加密类型进行加密后的密码。</p>
<p>因此，程序接收到内存或者数据库查询到的密码时，首先查找被<code>{}</code>包括起来的<code>id</code>，以确定后面的密码是被什么加密类型方式进行加密的，如果找不到就认为 id 是 null。这也就是为什么程序会报错：<code>There is no PasswordEncoder mapped for the id "null"</code>。官方文档举的例子中是各种加密方式针对同一密码加密后的存储形式，原始密码都是”password”。</p>
<h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><p>要想我们的项目还能够正常登陆，需要将前端传过来的密码进行某种方式加密，官方推荐的是使用<code>bcrypt</code>加密方式（不用用户使用相同原密码生成的密文是不同的），因此需要在 configure 方法里面指定一下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// auth.inMemoryAuthentication().withUser("admin").password("admin").roles("ADMIN");</span></span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>())</span><br><span class="line">        .withUser(<span class="string">"admin"</span>)</span><br><span class="line">        .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"admin"</span>))</span><br><span class="line">        .roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然还有一种方法，将<code>passwordEncoder</code>配置抽离出来：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="自定义到内存"><a href="#自定义到内存" class="headerlink" title="自定义到内存"></a>自定义到内存</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">        .withUser(<span class="string">"admin"</span>)</span><br><span class="line">        .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"admin"</span>))</span><br><span class="line">        .roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="自定义到代码"><a href="#自定义到代码" class="headerlink" title="自定义到代码"></a>自定义到代码</h4><p>这里还有一种更优雅的方法，实现<code>org.springframework.security.core.userdetails.UserDetailsService</code>接口，重载<code>loadUserByUsername(String username)</code>方法，当用户登录时，会调用<code>UserDetailsService</code>接口的<code>loadUserByUsername()</code>来校验用户的合法性（密码和权限）。</p>
<blockquote>
<p>这种方法为之后结合数据库或者JWT动态校验打下技术可行性基础。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">"ADMIN"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"root"</span>, <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"root"</span>), authorities);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当然，”自定义到内存”中的配置文件中的<code>configure(AuthenticationManagerBuilder auth)</code>配置就不需要再配置一遍了。</p>
<p><strong>注意：</strong>对于返回的<code>UserDetails</code>实现类，可以使用框架自己的 User，也可以自己实现一个 UserDetails 实现类，其中密码和权限都应该从数据库中读取出来，而不是写死在代码里。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>将加密类型抽离出来，实现<code>UserDetailsService</code>接口，将两者注入到<code>AuthenticationManagerBuilder</code>中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        auth.userDetailsService(userDetailsService)</span><br><span class="line">            .passwordEncoder(passwordEncoder());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>UserDetailsService</code>接口实现类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        authorities.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">"ADMIN"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"root"</span>, <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"root"</span>), authorities);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的 User 对象是框架提供的一个用户对象，注意包名是：<code>org.springframework.security.core.userdetails.User</code>，里面的属性中最核心的就是<code>password</code>，<code>username</code>和<code>authorities</code>。</p>
<h3 id="自定义安全认证配置"><a href="#自定义安全认证配置" class="headerlink" title="自定义安全认证配置"></a>自定义安全认证配置</h3><p>配置自定义的登录页面：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    http.formLogin() 								<span class="comment">// 定义当需要用户登录时候，转到的登录页面。</span></span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)	 					<span class="comment">// 设置登录页面</span></span><br><span class="line">        .loginProcessingUrl(<span class="string">"/user/login"</span>) 			<span class="comment">// 自定义的登录接口</span></span><br><span class="line">        .defaultSuccessUrl(<span class="string">"/home"</span>).permitAll()		<span class="comment">// 登录成功之后，默认跳转的页面</span></span><br><span class="line">        .and().authorizeRequests()					<span class="comment">// 定义哪些URL需要被保护、哪些不需要被保护</span></span><br><span class="line">        .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>，<span class="string">"/user/login"</span>).permitAll()		<span class="comment">// 设置所有人都可以访问登录页面</span></span><br><span class="line">        .anyRequest().authenticated() 				<span class="comment">// 任何请求,登录后可以访问</span></span><br><span class="line">        .and().csrf().disable(); 					<span class="comment">// 关闭csrf防护</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上述配置中，可以看出用可以所有访客均可以自由登录<code>/</code>和<code>/index</code>进行资源访问，同时配置了一个登录的接口<code>/lgoin</code>，使用mvc做了视图映射（映射到模板文件目录中的<code>login.html</code>），controller 映射代码太简单就不赘述了，当用户成功登录之后，页面会自动跳转至<code>/home</code>页面。</p>
<p><img src="https://image.woodwhales.cn/026/images/4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6.png"></p>
<blockquote>
<p>上述图片中的配置有点小小缺陷，当去掉<code>.loginProcessUrl()</code>的配置的时候，登录完毕，浏览器会一直重定向，直至报重定向失败。因为登录成功的 url 没有配置成所有人均可以访问，因此造成了死循环的结果。</p>
<p>因此，配置了登录界面就需要配置任意可访问：<code>.antMatchers("/user/login").permitAll()</code></p>
</blockquote>
<p><code>login.html</code>代码：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>自定义登录页面<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/user/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="静态资源忽略配置"><a href="#静态资源忽略配置" class="headerlink" title="静态资源忽略配置"></a>静态资源忽略配置</h3><p>上述配置用户认证过程中，会发现资源文件也被安全框架挡在了外面，因此需要进行安全配置：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/webjars/**/*"</span>, <span class="string">"/**/*.css"</span>, <span class="string">"/**/*.js"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在前端框架的静态资源完全可以通过<code>webjars</code>统一管理，因此注意配置<code>/webjars/**/*</code>。</p>
<h2 id="处理不同类型的请求"><a href="#处理不同类型的请求" class="headerlink" title="处理不同类型的请求"></a>处理不同类型的请求</h2><p>前后端分离的系统中，一般后端仅提供接口 JSON 格式的数据，以供前端自行调用。刚才那样，调用了被保护的接口，直接进行了页面的跳转，在web端还可以接受，但是在 App 端就不行了， 所以我们还需要做进一步的处理。<br>这里做一下简单的思路整理 </p>
<p>这里提供一种思路，核心在于运用安全框架的：<code>RequestCache</code>和<code>RedirectStrategy</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.DefaultRedirectStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.RedirectStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.savedrequest.HttpSessionRequestCache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.savedrequest.RequestCache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.savedrequest.SavedRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrowserSecurityController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原请求信息的缓存及恢复</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RequestCache</span> <span class="variable">requestCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSessionRequestCache</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于重定向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedirectStrategy</span> <span class="variable">redirectStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRedirectStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当需要身份认证的时候，跳转过来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping("/authentication/require")</span></span><br><span class="line">    <span class="meta">@ResponseStatus(code = HttpStatus.UNAUTHORIZED)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">requireAuthenication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">SavedRequest</span> <span class="variable">savedRequest</span> <span class="operator">=</span> requestCache.getRequest(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (savedRequest != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">targetUrl</span> <span class="operator">=</span> savedRequest.getRedirectUrl();</span><br><span class="line">            log.info(<span class="string">"引发跳转的请求是:"</span> + targetUrl);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.endsWithIgnoreCase(targetUrl, <span class="string">".html"</span>)) {</span><br><span class="line">                redirectStrategy.sendRedirect(request, response, <span class="string">"/login.html"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"访问的服务需要身份认证，请引导用户到登录页"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong>这个<code>/authentication/require</code>需要配置到安全认证配置：配置成默认登录界面，并设置成任何人均可以访问，并且这个重定向的页面可以设计成配置，从配置文件中读取。</p>
<h2 id="自定义处理登录成功-失败"><a href="#自定义处理登录成功-失败" class="headerlink" title="自定义处理登录成功/失败"></a>自定义处理登录成功/失败</h2><p>在前后端分离的情况下，我们登录成功了可能需要向前端返回用户的个人信息，而不是直接进行跳转。登录失败也是同样的道理。这里涉及到了 Spring Security 中的两个接口<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code>。自定义这两个接口的实现，并进行相应的配置就可以了。 当然框架是有默认的实现类的，我们可以继承这个实现类再来自定义自己的业务：</p>
<h3 id="成功登录处理类"><a href="#成功登录处理类" class="headerlink" title="成功登录处理类"></a>成功登录处理类</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component("myAuthenctiationSuccessHandler")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenctiationSuccessHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationSuccessHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">            HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"登录成功"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(authentication));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>成功登录之后，通过 response 返回一个 JSON 字符串回去。这个方法中的第三个参数<code>Authentication</code>，它里面包含了登录后的用户信息（UserDetails），Session 的信息，登录信息等。</p>
<p>登录成功之后的响应JSON：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"authorities"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"authority"</span><span class="punctuation">:</span> <span class="string">"ROLE_admin"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"details"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"remoteAddress"</span><span class="punctuation">:</span> <span class="string">"127.0.0.1"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"sessionId"</span><span class="punctuation">:</span> <span class="string">"8BFA4F61A7CEA774C00F616AAE8C307C"</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"authenticated"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"principal"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"password"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"username"</span><span class="punctuation">:</span> <span class="string">"admin"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"authorities"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"authority"</span><span class="punctuation">:</span> <span class="string">"ROLE_admin"</span></span><br><span class="line">            <span class="punctuation">}</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"accountNonExpired"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"accountNonLocked"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"credentialsNonExpired"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"enabled"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"credentials"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"admin"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p> 这里有个细节需要注意：</p>
<p><code>principal</code> 中有个权限数组集合<code>authorities</code>，里面的权限值是：<code>ROLE_admin</code>，而自定义的安全认证配置中配置的是：<code>admin</code>，所以<code>ROLE_</code>前缀是框架自己加的，后期取出权限集合的时候需要注意这个细节，以取决于判断是否有权限是使用字符串的包含关系还是等值关系。</p>
</blockquote>
<h3 id="登录失败处理类"><a href="#登录失败处理类" class="headerlink" title="登录失败处理类"></a>登录失败处理类</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component("myAuthenctiationFailureHandler")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenctiationFailureHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"登录失败"</span>);</span><br><span class="line">        response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(exception.getMessage()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将两个自定义的处理类配置到自定义配置文件中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.woodwhale.king.handler.MyAuthenctiationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.woodwhale.king.handler.MyAuthenctiationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenctiationFailureHandler myAuthenctiationFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenctiationSuccessHandler myAuthenctiationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        http.formLogin() 								<span class="comment">// 定义当需要用户登录时候，转到的登录页面。</span></span><br><span class="line">            .loginPage(<span class="string">"/login"</span>)	 					<span class="comment">// 设置登录页面</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">"/user/login"</span>) 			<span class="comment">// 自定义的登录接口</span></span><br><span class="line">            .successHandler(myAuthenctiationSuccessHandler)</span><br><span class="line">            .failureHandler(myAuthenctiationFailureHandler)</span><br><span class="line">            <span class="comment">//.defaultSuccessUrl("/home").permitAll()		// 登录成功之后，默认跳转的页面</span></span><br><span class="line">            .and().authorizeRequests()					<span class="comment">// 定义哪些URL需要被保护、哪些不需要被保护</span></span><br><span class="line">            .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>).permitAll()		<span class="comment">// 设置所有人都可以访问登录页面</span></span><br><span class="line">            .anyRequest().authenticated() 				<span class="comment">// 任何请求,登录后可以访问</span></span><br><span class="line">            .and().csrf().disable(); 					<span class="comment">// 关闭csrf防护</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            .passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>()).withUser(<span class="string">"admin"</span>)</span><br><span class="line">            .password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"admin"</span>))</span><br><span class="line">            .roles(<span class="string">"admin"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：<code>defaultSuccessUrl</code>不需要再配置了，实测如果配置了，成功登录的 handler 就不起作用了。</p>
<p><strong>小结</strong></p>
<p>可以看出，通过自定义的登录成功或者失败类，进行登录响应控制，可以设计一个配置，以灵活适配响应返回的是页面还是 JSON 数据。</p>
<h2 id="结合thymeleaf"><a href="#结合thymeleaf" class="headerlink" title="结合thymeleaf"></a>结合thymeleaf</h2><p>在前端使用了<code>Thymeleaf</code>进行渲染，特使是结合<code>Spring Security</code>在前端获取用户信息</p>
<p>依赖添加：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-springsecurity5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong></p>
<p>因为本项目使用了spring boot 自动管理版本号，所以引入的一定是完全匹配的，如果是旧的 spring security 版本需要手动引入对应的版本。</p>
<p>引用官方版本引用说明：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">thymeleaf-extras-springsecurity3 <span class="keyword">for</span> integration with Spring Security <span class="number">3.</span>x</span><br><span class="line">thymeleaf-extras-springsecurity4 <span class="keyword">for</span> integration with Spring Security <span class="number">4.</span>x</span><br><span class="line">thymeleaf-extras-springsecurity5 <span class="keyword">for</span> integration with Spring Security <span class="number">5.</span>x</span><br></pre></td></tr></tbody></table></figure>

<p>具体语法可查看：<br><a href="https://github.com/thymeleaf/thymeleaf-extras-springsecurity">https://github.com/thymeleaf/thymeleaf-extras-springsecurity</a></p>
<h3 id="常用的语法标签"><a href="#常用的语法标签" class="headerlink" title="常用的语法标签"></a>常用的语法标签</h3><p>这里为了表述方便，引用了上小节中的”自定义处理登录成功/失败”的成功响应JSON数据：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"authorities"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"authority"</span><span class="punctuation">:</span> <span class="string">"ROLE_admin"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"details"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"remoteAddress"</span><span class="punctuation">:</span> <span class="string">"127.0.0.1"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"sessionId"</span><span class="punctuation">:</span> <span class="string">"8BFA4F61A7CEA774C00F616AAE8C307C"</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"authenticated"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"principal"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"password"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"username"</span><span class="punctuation">:</span> <span class="string">"admin"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"authorities"</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">{</span></span><br><span class="line">                <span class="attr">"authority"</span><span class="punctuation">:</span> <span class="string">"ROLE_admin"</span></span><br><span class="line">            <span class="punctuation">}</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"accountNonExpired"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"accountNonLocked"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"credentialsNonExpired"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"enabled"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"credentials"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"admin"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>sec:authorize="isAuthenticated()</code>：判断是否有认证通过</p>
<p><code>sec:authorize="hasRole('ROLE_ADMIN')"</code>判断是否有<code>ROLE_ADMIN</code>权限</p>
<p><strong>注意：</strong>上述的<code>hasRole()</code>标签使用能成功的前提是：自定义用户的权限字符集必须是以<code>ROLE_</code>为前缀的，否则解析不到，即自定义的<code>UserDetailsService</code> 实现类的返回用户的权限数组列表的权限字段必须是<code>ROLE_***</code>，同时在 html 页面中注意引入对应的<code>xmlns</code>，本例这里引用了：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:sec</span>=<span class="string">"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>sec:authentication="principal.authorities"</code>：得到该用户的所有权限列表</p>
<p><code>sec:authentication="principal.username"</code>：得到该用户的用户名</p>
<p>当然也可以获取更多的信息，只要<code>UserDetailsService</code>实现类中返回的用户中携带有的信息均可以获取。</p>
<h2 id="常见异常类"><a href="#常见异常类" class="headerlink" title="常见异常类"></a>常见异常类</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">AuthenticationException        常用的的子类：(会被底层换掉，不推荐使用)</span><br><span class="line">UsernameNotFoundException      用户找不到</span><br><span class="line">BadCredentialsException        坏的凭据</span><br><span class="line">AccountStatusException         用户状态异常它包含如下子类：（推荐使用）</span><br><span class="line">AccountExpiredException        账户过期</span><br><span class="line">LockedException                账户锁定</span><br><span class="line">DisabledException              账户不可用</span><br><span class="line">CredentialsExpiredException    证书过期</span><br></pre></td></tr></tbody></table></figure>

<p>参考资料：</p>
<p><a href="https://blog.csdn.net/u013435893/article/details/79596628">https://blog.csdn.net/u013435893/article/details/79596628</a></p>
<p><a href="https://blog.csdn.net/canon_in_d_major/article/details/79675033">https://blog.csdn.net/canon_in_d_major/article/details/79675033</a></p>
<p><a href="https://juejin.im/post/5c46a49e51882528735ef2d9">https://juejin.im/post/5c46a49e51882528735ef2d9</a></p>
<p><a href="https://www.jianshu.com/p/6307c89fe3fa/">https://www.jianshu.com/p/6307c89fe3fa/</a></p>
<p><a href="https://mp.weixin.qq.com/s/NKhwU6qKKU0Q0diA0hg13Q">https://mp.weixin.qq.com/s/NKhwU6qKKU0Q0diA0hg13Q</a></p>
<p><a href="https://mp.weixin.qq.com/s/sMi1__Rw_s75YDaIdmTWKw">https://mp.weixin.qq.com/s/sMi1__Rw_s75YDaIdmTWKw</a></p>
<p><a href="https://blog.csdn.net/smd2575624555/article/details/82759863">https://blog.csdn.net/smd2575624555/article/details/82759863</a></p>
<p><a href="https://www.cnblogs.com/yyxxn/p/8808851.html">https://www.cnblogs.com/yyxxn/p/8808851.html</a></p>
<p><a href="https://blog.csdn.net/coder_py/article/details/80330868">https://blog.csdn.net/coder_py/article/details/80330868</a></p>
<p>参考项目源码：</p>
<p><a href="https://github.com/whyalwaysmea/Spring-Security">https://github.com/whyalwaysmea/Spring-Security</a></p>
<p><a href="https://github.com/oycyqr/SpringSecurity">https://github.com/oycyqr/SpringSecurity</a></p>
<p><a href="https://github.com/chengjiansheng/cjs-springsecurity-example">https://github.com/chengjiansheng/cjs-springsecurity-example</a></p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Spring Security 学习笔记（二）安全认证流程源码详解</title>
    <url>/2019/04/12/027/</url>
    <content><![CDATA[<h2 id="用户认证流程"><a href="#用户认证流程" class="headerlink" title="用户认证流程"></a>用户认证流程</h2><h3 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h3><p>我们直接来看<code>UsernamePasswordAuthenticationFilter</code>类，</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span></span><br><span class="line">		<span class="title class_">AbstractAuthenticationProcessingFilter</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">        <span class="comment">// 判断是否是 POST 请求</span></span><br><span class="line">        <span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line">                <span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取请求中的用户，密码。</span></span><br><span class="line">        <span class="comment">// 就是最简单的：request.getParameter(xxx)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span>) {</span><br><span class="line">            username = <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span>) {</span><br><span class="line">            password = <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        username = username.trim();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成 authRequest，本质就是个 usernamePasswordAuthenticationToken</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">            username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 request 请求也一同塞进 token 里</span></span><br><span class="line">        <span class="comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">        setDetails(request, authRequest);</span><br><span class="line">        <span class="comment">// 将 authRequest 塞进 AuthenticationManager并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>attemptAuthentication()</code>方法中：主要是先进行请求判断并获取<code>username</code>和<code>password</code>的值，然后再生成一个<code>UsernamePasswordAuthenticationToken</code>对象，将这个对象塞进<code>AuthenticationManager</code>对象并返回，注意：<strong>此时的<code>authRequest</code>的权限是没有任何值的</strong>。</p>
<h4 id="UsernamePasswordAuthenticationToken"><a href="#UsernamePasswordAuthenticationToken" class="headerlink" title="UsernamePasswordAuthenticationToken"></a>UsernamePasswordAuthenticationToken</h4><p>不过我们可以先看看<code>UsernamePasswordAuthenticationToken</code>的构造方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> {</span><br><span class="line">    <span class="built_in">super</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.principal = principal;</span><br><span class="line">    <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">    setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其实<code>UsernamePasswordAuthenticationToken</code>是继承于<code>Authentication</code>，该对象在学习笔记一中的中”自定义处理登录成功/失败”章节里的自定义登录成功里有提到过，它是处理登录成功回调方法中的一个参数，里面包含了用户信息、请求信息等参数。</p>
<p><img src="https://image.woodwhales.cn/027/images/5-%E7%BB%A7%E6%89%BF%E5%9B%BE.png"></p>
<p>来一张继承关系图，对其有个大概的认识，注意到<code>Authentication</code>继承了<code>Principal</code>。</p>
<h4 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h4><p><code>AuthenticationManager</code>是一个接口，它的所有实现类如图：</p>
<p><img src="https://image.woodwhales.cn/027/images/6-AuthentivationManager%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"></p>
<p> 其中一个十分核心的类就是：<code>ProviderManager</code>，在<code>attemptAuthentication()</code>方法最后返回的就是这个类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br></pre></td></tr></tbody></table></figure>

<p>进入<code>authenticate()</code>方法查看具体做了什么：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">			<span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">parentException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) {</span><br><span class="line">        <span class="comment">// 1.判断是否有provider支持该Authentication</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest)) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) {</span><br><span class="line">            logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">                         + provider.getClass().getName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 2. 真正的逻辑判断</span></span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) {</span><br><span class="line">                copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (AccountStatusException e) {</span><br><span class="line">           ……</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里首先通过 provider 判断是否支持当前传入进来的<code>Authentication</code>，目前我们使用的是<code>UsernamePasswordAuthenticationToken</code>，因为除了帐号密码登录的方式，还会有其他的方式，比如<code>JwtAuthenticationToken</code>。</p>
<p>从整体来看<code>Authentication</code> 的实现类如图：</p>
<p><img src="https://image.woodwhales.cn/027/images/7-Authentication%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"></p>
<p><a href="https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/api/index.html?overview-summary.html">官方 API 文档</a>列出了所有的子类</p>
<p><img src="https://image.woodwhales.cn/027/images/8-Authentication%E5%AD%90%E7%B1%BB.png"></p>
<p>从整体来看<code>AuthenticationProvider</code>的实现类如图：</p>
<p><img src="https://image.woodwhales.cn/027/images/9-AuthenticationProvider%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"></p>
<p><a href="https://docs.spring.io/spring-security/site/docs/5.2.0.BUILD-SNAPSHOT/api/index.html?overview-summary.html">官方 API 文档</a>列出了所有的子类</p>
<p><img src="https://image.woodwhales.cn/027/images/10-AuthenticationProvider%E5%AD%90%E7%B1%BB.png"></p>
<p>根据我们目前所使用的<code>UsernamePasswordAuthenticationToken</code>，provider 对应的是<code>AbstractUserDetailsAuthenticationProvider</code>抽象类的子类<code>DaoAuthenticationProvider</code>，其<code>authenticate()</code>属于抽象类本身的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">			<span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">    Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,</span><br><span class="line">                        () -&gt; messages.getMessage(</span><br><span class="line">                            <span class="string">"AbstractUserDetailsAuthenticationProvider.onlySupports"</span>,</span><br><span class="line">                            <span class="string">"Only UsernamePasswordAuthenticationToken is supported"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine username</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (authentication.getPrincipal() == <span class="literal">null</span>) ? <span class="string">"NONE_PROVIDED"</span></span><br><span class="line">        : authentication.getName();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 1.从缓存中获取 UserDetails</span></span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 2.缓存获取不到，就去接口实现类中获取</span></span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                                (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (UsernameNotFoundException notFound) {</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Assert.notNull(user,</span><br><span class="line">                       <span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 3.用户信息预检查（用户是否密码过期，用户信息被删除等）</span></span><br><span class="line">        preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="comment">// 4.附加的检查（密码检查：匹配用户的密码和服务器中的用户密码是否一致）</span></span><br><span class="line">        additionalAuthenticationChecks(user,</span><br><span class="line">                                       (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (AuthenticationException exception) {</span><br><span class="line">        <span class="keyword">if</span> (cacheWasUsed) {</span><br><span class="line">            <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">            <span class="comment">// we're using latest data (i.e. not from the cache)</span></span><br><span class="line">            cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">            user = retrieveUser(username,</span><br><span class="line">                                (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            preAuthenticationChecks.check(user);</span><br><span class="line">            additionalAuthenticationChecks(user,</span><br><span class="line">                                           (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.最后的检查</span></span><br><span class="line">    postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.返回真正的经过认证的Authentication </span></span><br><span class="line">    <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong><code>retrieveUser()</code>的具体方法实现是由<code>DaoAuthenticationProvider</code>类完成的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title class_">AbstractUserDetailsAuthenticationProvider</span> {	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username,</span></span><br><span class="line"><span class="params">            UsernamePasswordAuthenticationToken authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">        prepareTimingAttackProtection();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取用户信息</span></span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(</span><br><span class="line">                        <span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (UsernameNotFoundException ex) {</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同时<code>createSuccessAuthentication()</code>的方法也是由<code>DaoAuthenticationProvider</code>类来完成的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 子类拿 user 对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal,</span></span><br><span class="line"><span class="params">                                                     Authentication authentication, UserDetails user)</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">upgradeEncoding</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsPasswordService != <span class="literal">null</span></span><br><span class="line">        &amp;&amp; <span class="built_in">this</span>.passwordEncoder.upgradeEncoding(user.getPassword());</span><br><span class="line">    <span class="keyword">if</span> (upgradeEncoding) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">newPassword</span> <span class="operator">=</span> <span class="built_in">this</span>.passwordEncoder.encode(presentedPassword);</span><br><span class="line">        user = <span class="built_in">this</span>.userDetailsPasswordService.updatePassword(user, newPassword);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 调用父类的方法完成 Authentication 的创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.createSuccessAuthentication(principal, authentication, user);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建已认证的 Authentication</span></span><br><span class="line"><span class="keyword">protected</span> Authentication <span class="title function_">createSuccessAuthentication</span><span class="params">(Object principal,</span></span><br><span class="line"><span class="params">			Authentication authentication, UserDetails user)</span> {</span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">        principal, authentication.getCredentials(),</span><br><span class="line">        authoritiesMapper.mapAuthorities(user.getAuthorities()));</span><br><span class="line">    result.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>小结：<code>authenticate()</code>的认证逻辑</p>
<ol>
<li>去调用自己实现的<code>UserDetailsService</code>，返回<code>UserDetails</code></li>
<li>对 UserDetails 的信息进行校验，主要是帐号是否被冻结，是否过期等</li>
<li>对密码进行检查，这里调用了<code>PasswordEncoder</code>，检查 UserDetails 是否可用。</li>
<li>返回经过认证的<code>Authentication</code></li>
</ol>
<blockquote>
<p>编码技巧提示：这里在认证之前使用了<code>Assert.isInstanceOf()</code>进行断言校验，方法内部也不断用了<code>Assert.notNull()</code>，这种编码非常的灵巧，省去了后续的类型判断。</p>
</blockquote>
<p>这里的两次对<code>UserDetails</code>的检查，主要就是通过它的四个返回 boolean 类型的方法（<code>isAccountNonExpired()</code>，<code>isAccountNonLocked()</code>，<code>isCredentialsNonExpired()</code>，<code>isEnabled()</code>）。</p>
<p>经过信息的校验之后，通过<code>UsernamePasswordAuthenticationToken</code>的全参构造方法，返回了一个已经过认证的<code>Authentication</code>。</p>
<p>拿到经过认证的<code>Authentication</code>之后，至此<code>UsernamePasswordAuthenticationFilter</code>的过滤步骤就完全结束了，之后就会进入<code>BasicAuthenticationFilter</code>，具体来说就是去调用<code>successHandler</code>。或者未通过认证，去调用<code>failureHandler</code>。</p>
<h2 id="已认证数据共享"><a href="#已认证数据共享" class="headerlink" title="已认证数据共享"></a>已认证数据共享</h2><p>完成了用户认证处理流程之后，我们思考一下是如何在多个请求之间共享这个认证结果的呢？因为没有做关于这方面的配置，所以可以联想到默认的方式应该是在session中存入了认证结果。思考：那么是什么时候存放入session中的呢？</p>
<p>认证流程完毕之后，再看是谁调用的它，发现是<code>AbstractAuthenticationProcessingFilter</code>的<code>doFilter()</code>进行调用的，这是<code>AbstractAuthenticationProcessingFilter</code>继承关系结构图：</p>
<p><img src="https://image.woodwhales.cn/027/images/11-filter.png"></p>
<p>当认证成功之后会调用<code>successfulAuthentication(request, response, chain, authResult)</code>，该方法中，不仅调用了<code>successHandler</code>，还有一行比较重要的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span></span><br><span class="line">		<span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span>, MessageSourceAware {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="comment">// 调用了 UsernamePasswordAuthenticationFilter</span></span><br><span class="line">        authResult = attemptAuthentication(request, response);</span><br><span class="line">        </span><br><span class="line">        ……</span><br><span class="line">        <span class="comment">// 调用方法，目的是保存到session   </span></span><br><span class="line">        successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将成功认证的用户信息保存到session</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Authentication success. Updating SecurityContextHolder to contain: "</span></span><br><span class="line">                         + authResult);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到 SecurityContextHolder 的静态属性 SecurityContextHolderStrategy 里， 非常重要的代码</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">        rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fire event</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) {</span><br><span class="line">            eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">                authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecurityContextHolder类中存着 静态属性：SecurityContextHolderStrategy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> {</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SecurityContextHolderStrategy strategy;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> {</span><br><span class="line">        strategy.setContext(context);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>SecurityContextHolderStrategy</code>接口的所有实现类：</p>
<p><img src="https://image.woodwhales.cn/027/images/12-securityContext.png"></p>
<p>非常显眼的看出：<code>ThreadLocalSecurityContextHolderStrategy</code>类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">SecurityContextHolderStrategy</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SecurityContext&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> {</span><br><span class="line">        Assert.notNull(context, <span class="string">"Only non-null SecurityContext instances are permitted"</span>);</span><br><span class="line">        <span class="comment">// 将已认证的用户对象保存到 ThreadLocal&lt;SecurityContext&gt; 中</span></span><br><span class="line">        contextHolder.set(context);</span><br><span class="line">    }</span><br><span class="line">    ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：<code>SecurityContext</code>类的<code>equals()</code>和<code>hashCode()</code>方法已经重写了，用来保证了authentication的唯一性。</p>
</blockquote>
<p>身份认证成功后，最后在<code>UsernamePasswordAuthenticationFilter</code>返回后会进入一个<code>AbstractAuthenticationProcessingFilter</code>类中调用<code>successfulAuthentication()</code>方法，这个方法最后会返回我们自己定义的登录成功处理器<code>handler</code>。</p>
<p>在返回之前，它会调用<code>SecurityContext</code>，最后将认证的结果放入<code>SecurityContextHolder</code>中，SecurityContext 类很简单，重写了<code>equals()</code> 方法和<code>hashCode()</code>方法，保证了authentication的唯一性。</p>
<p>从代码可以看出：<code>SecurityContextHolder</code>类实际上是对<code>ThreadLocal</code>的一个封装，可以在不同方法之间进行通信，可以简单理解为线程级别的一个全局变量。</p>
<p>因此，可以在同一个线程中的不同方法中获取到认证信息。最后会被<code>SecurityContextPersistenceFilter</code>过滤器使用，这个过滤器的作用是：</p>
<p>当一个请求来的时候，它会将 session 中的值传入到该线程中，当请求返回的时候，它会判断该请求线程是否有 <code>SecurityContext</code>，如果有它会将其放入到 session 中，因此保证了请求结果可以在不同的请求之间共享。 </p>
<h2 id="用户认证流程总结"><a href="#用户认证流程总结" class="headerlink" title="用户认证流程总结"></a>用户认证流程总结</h2><p>引用徐靖峰在个人博客<a href="https://www.cnkirito.moe/spring-security-1/">Spring Security(一)–Architecture Overview</a>中的概括性总结，非常的到位：</p>
<ol>
<li>用户名和密码被过滤器获取到，封装成<code>Authentication</code>，通常情况下是<code>UsernamePasswordAuthenticationToken</code>这个实现类。</li>
<li><code>AuthenticationManager</code> 身份管理器负责验证这个<code>Authentication</code>。</li>
<li>认证成功后，<code>AuthenticationManager</code>身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除）<code>Authentication</code>实例。</li>
<li><code>SecurityContextHolder</code>安全上下文容器将第3步填充了信息的<code>Authentication</code>，通过<code>SecurityContextHolder.getContext().setAuthentication(…)</code>方法，设置到其中。</li>
</ol>
<p>高度概括起来本章节所有用的核心认证相关接口：<code>SecurityContextHolder</code>是</p>
<p>身份信息的存放容器，<code>Authentication</code>是身份信息的抽象，<code>AuthenticationManager</code>是身份认证器，一般常用的是用户名+密码的身份认证器，还有其它认证器，如邮箱+密码、手机号码+密码等。</p>
<p>再引用一张十分流行的流程图来表示用户的认证过程：</p>
<p><img src="https://image.woodwhales.cn/027/images/13-%E7%94%A8%E6%88%B7%E8%AE%A4%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="架构概览图"><a href="#架构概览图" class="headerlink" title="架构概览图"></a>架构概览图</h2><p>为了更加形象的理解，在徐靖峰大佬的经典架构图之上，根据自己的理解，做了更多的细化和调整：</p>
<p><img src="https://image.woodwhales.cn/027/images/16-%E6%A0%B8%E5%BF%83%E8%AE%A4%E8%AF%81%E6%8E%A5%E5%8F%A3%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE.png"></p>
<h2 id="获取认证用户信息"><a href="#获取认证用户信息" class="headerlink" title="获取认证用户信息"></a>获取认证用户信息</h2><p>如果我们需要获取用的校验过的所有信息，该如何获取呢？上面我们知道了会将校验结果放入 session 中，因此，我们可以通过 session 获取：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping("/me1")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getMeDetail</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping("/me2")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getMeDetail</span><span class="params">(Authentication authentication)</span>{</span><br><span class="line">    <span class="keyword">return</span> authentication;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在登录成功之后，上面有两种方式来获取，访问上面的请求，就会获取用户全部的校验信息，包括ip地址等信息。 </p>
<p><img src="https://image.woodwhales.cn/027/images/14-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96.png"></p>
<p>如果我们只想获取用户名和密码以及它的权限，不需要ip地址等太多的信息可以使用下面的方式来获取信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping("/me3")</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getMeDetail</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> UserDetails userDetails)</span>{</span><br><span class="line">    <span class="keyword">return</span> userDetails;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/027/images/15-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%AE%80%E5%8D%95%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96.png"></p>
<p>参考资料：</p>
<p><a href="https://www.cnkirito.moe/spring-security-1/">https://www.cnkirito.moe/spring-security-1/</a></p>
<p><a href="https://blog.csdn.net/u013435893/article/details/79605239">https://blog.csdn.net/u013435893/article/details/79605239</a></p>
<p><a href="https://blog.csdn.net/qq_37142346/article/details/80032336">https://blog.csdn.net/qq_37142346/article/details/80032336</a></p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Spring Security 学习笔记（三）实现图片验证码认证</title>
    <url>/2019/04/12/028/</url>
    <content><![CDATA[<h2 id="整体实现逻辑"><a href="#整体实现逻辑" class="headerlink" title="整体实现逻辑"></a>整体实现逻辑</h2><ol>
<li><p>前端在登录页面时，自动从后台获取最新的验证码图片</p>
</li>
<li><p>服务器接收获取生成验证码请求，生成验证码和对应的图片，图片响应回前端，验证码保存一份到服务器的 session 中</p>
</li>
<li><p>前端用户登录时携带当前验证码</p>
</li>
<li><p>服务器校验验证码是否合法（验证码存在并未过期），继续后续的用户名和密码校验逻辑</p>
</li>
</ol>
<p>通过一个时序图来表述如下图，图中细化了一下各个控制器和过滤器之间的功能职责，还不是很正规，只为了更好表达上述的流程描述，所以读者们将就一下：</p>
<p><img src="https://image.woodwhales.cn/028/images/16-%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A0%A1%E9%AA%8C%E9%80%BB%E8%BE%91.png"></p>
<p>时序图 plantUML 代码</p>
<blockquote>
<p>plantUML 的使用教程请移步至之前发布过的文章：<a href="https://woodwhales.github.io/2019/01/13/017/">PlantUML 语法之时序图</a></p>
</blockquote>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">skinparam sequenceMessageAlign center</span><br><span class="line">skinparam sequenceArrowFontSize 11</span><br><span class="line">skinparam noteFontSize 11</span><br><span class="line">skinparam monochrome true</span><br><span class="line">skinparam lifelinestrategy solid </span><br><span class="line"></span><br><span class="line">autonumber "&lt;b&gt;[000]"</span><br><span class="line">participant browser as ui</span><br><span class="line">participant imageCodeController as ic</span><br><span class="line">participant UserController as uc</span><br><span class="line">database sessionStorage as session</span><br><span class="line">participant CodeAuthenticationFilter as cf</span><br><span class="line">participant "UsernamePasswordAuthenticationFilter" as uf</span><br><span class="line"></span><br><span class="line">ui -&gt; ic: 登录请求</span><br><span class="line">ic -&gt; ic: 生成验证码</span><br><span class="line">ic -&gt; session: 保存验证码信息</span><br><span class="line">ic --&gt; ui: 验证码图片</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">autonumber "&lt;b&gt;[000]"</span><br><span class="line">ui -&gt; cf: 帐号登录</span><br><span class="line">cf -&gt; session: 获取验证码</span><br><span class="line">session --&gt; cf: 验证码</span><br><span class="line">cf -&gt; cf: 校验请求验证码合法性</span><br><span class="line">cf -&gt; uf: 用户认证的后续操作</span><br><span class="line"></span><br><span class="line">uf --&gt; uc: 返回认证结果</span><br><span class="line">uc --&gt; ui: 用户登录成功</span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<p>将上述的逻辑进行任务拆分：随机验证码和图片生成，生成验证码请求<code>Controller</code>，session存储器就临时使用<code>spring-social-web</code>包中的<code>SessionStrategy</code>来存储，验证码过滤器，配置过滤器到<code>spring scuerity</code></p>
<p>过滤器中的用户密码验证过滤器之前。</p>
<h2 id="前端控制器-生成验证码"><a href="#前端控制器-生成验证码" class="headerlink" title="前端控制器+生成验证码"></a>前端控制器+生成验证码</h2><h3 id="服务器-session-容器"><a href="#服务器-session-容器" class="headerlink" title="服务器 session 容器"></a>服务器 session 容器</h3><p>采用小步快走的开发模式，前端控制器和生成验证码的代码都写在一起，后期再进行代码重构， 这里主要引用了<code>spring-social-web</code>依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.social<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-social-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个包里面有个很小巧的<code>session</code>管理工具：<code>SessionStrategy</code></p>
<p>考虑到这个 session 在验证码过滤器中还得使用，所以自定义了一个配置，直接注入到了spring中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.social.connect.web.HttpSessionSessionStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.social.connect.web.SessionStrategy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean("sessionStrategy")</span></span><br><span class="line">    <span class="keyword">public</span> SessionStrategy <span class="title function_">registBean</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SessionStrategy</span> <span class="variable">sessionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpSessionSessionStrategy</span>();</span><br><span class="line">        <span class="keyword">return</span> sessionStrategy;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，在 Controller 层直接通过<code>@Autowired</code>引用即可。</p>
<h3 id="图片验证码容器"><a href="#图片验证码容器" class="headerlink" title="图片验证码容器"></a>图片验证码容器</h3><p>图片验证码对象需要至少三个属性：图片，验证码，过期时间。</p>
<blockquote>
<p>后期可能还有其他的验证形式，但是其中公共的部分：验证码和过期时间是可以抽象出来，这里为了演示不做重构。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageCode</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> BufferedImage image;</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageCode</span><span class="params">(BufferedImage image, String code, <span class="type">int</span> expireIn)</span> {</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.image = image;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireIn);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpried</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().isAfter(getExpireTime());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="公共常量"><a href="#公共常量" class="headerlink" title="公共常量"></a>公共常量</h3><p>在图片生成代码中，图片的尺寸，验证码的随机随机数长度和过期时间，都设计在了静态常量类中，当然也可以做成配置文件。验证码的 session 的唯一标识也做成了公共的，以便在验证码过滤器中进行校验时使用：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConstants</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">"SESSION_KEY_IMAGE_CODE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片宽度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WIDTH</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HEIGHT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证码的位数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RANDOM_SIZE</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证码过期秒数	</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPIRE_SECOND</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>生成验证码请求<code>Controller</code>源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.EXPIRE_SECOND;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.HEIGHT;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.RANDOM_SIZE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.SESSION_KEY;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.WIDTH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.social.connect.web.SessionStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.ServletRequestUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.woodwhale.king.model.ImageCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionStrategy sessionStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/code/image")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">ImageCode</span> <span class="variable">imageCode</span> <span class="operator">=</span> generate(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request));</span><br><span class="line">        sessionStrategy.setAttribute(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), SESSION_KEY, imageCode);</span><br><span class="line">        ImageIO.write(imageCode.getImage(), <span class="string">"JPEG"</span>, response.getOutputStream());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成图形验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ImageCode <span class="title function_">generate</span><span class="params">(ServletWebRequest request)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> ServletRequestUtils.getIntParameter(request.getRequest(), <span class="string">"width"</span>, WIDTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> ServletRequestUtils.getIntParameter(request.getRequest(), <span class="string">"height"</span>, HEIGHT);</span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">        <span class="type">Graphics</span> <span class="variable">g</span> <span class="operator">=</span> image.getGraphics();</span><br><span class="line"></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        g.setColor(getRandColor(<span class="number">200</span>, <span class="number">250</span>));</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">"Times New Roman"</span>, Font.ITALIC, <span class="number">20</span>));</span><br><span class="line">        g.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">155</span>; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> random.nextInt(width);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> random.nextInt(height);</span><br><span class="line">            <span class="type">int</span> <span class="variable">xl</span> <span class="operator">=</span> random.nextInt(<span class="number">12</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">yl</span> <span class="operator">=</span> random.nextInt(<span class="number">12</span>);</span><br><span class="line">            g.drawLine(x, y, x + xl, y + yl);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sRand</span> <span class="operator">=</span> <span class="string">""</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> ServletRequestUtils.getIntParameter(request.getRequest(), <span class="string">"length"</span>, RANDOM_SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">rand</span> <span class="operator">=</span> String.valueOf(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            sRand += rand;</span><br><span class="line">            g.setColor(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>)));</span><br><span class="line">            g.drawString(rand, <span class="number">13</span> * i + <span class="number">6</span>, <span class="number">16</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        g.dispose();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImageCode</span>(image, sRand, EXPIRE_SECOND);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成随机背景条纹</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Color <span class="title function_">getRandColor</span><span class="params">(<span class="type">int</span> fc, <span class="type">int</span> bc)</span> {</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) {</span><br><span class="line">            fc = <span class="number">255</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) {</span><br><span class="line">            bc = <span class="number">255</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Color</span>(r, g, b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了提升代码的可扩展性，随机验证码的生成方法<code>generate()</code>的方法最好是抽成接口，后期可能还有短信验证码，三方登录的验证码，这里仅做演示。上述验证码图片效果：</p>
<p><img src="https://image.woodwhales.cn/028/images/17-%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81.png"></p>
<h2 id="验证码过滤器"><a href="#验证码过滤器" class="headerlink" title="验证码过滤器"></a>验证码过滤器</h2><p><code>SpringSecurity </code>是通过过滤器链来进行校验的，我们想要验证图形验证码，所以可以在认证流程之前，也就是<code>UsernamePasswordAuthenticationFilter</code>之前进行校验。 </p>
<p>那么自定义的验证码过滤器也需要实现<code>j2EE</code>的过滤器接口，同时验证方法<code>validate()</code>只做了内部方法抽象，后期可以做成可扩展的抽象接口，这个<code>void</code>方法可能会抛出异常，这里的异常设计成了<code>spring security</code>框架的<code>AuthenticationException</code>高级抽象异常的子类，为了就是保证和安全认证的异常同步，后期使用同一个失败处理器抓取<code>AuthenticationException</code>类型的异常即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">AuthenticationException</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span> {</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而上述异常的接收者就是<a href="http://#">springboot + spring security 学习笔记（一）自定义基本使用及个性化登录配置</a>里提到的自定义认证失败处理器。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.woodwhale.king.commons.MyConstants.SESSION_KEY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.social.connect.web.SessionStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.ServletRequestBindingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.ServletRequestUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;</span><br><span class="line"><span class="keyword">import</span> org.woodwhale.king.MyException;</span><br><span class="line"><span class="keyword">import</span> org.woodwhale.king.model.ImageCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component("validateCodeFilter")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码校验失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionStrategy sessionStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 必须是登录的post请求才能进行验证，其他的直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.equals(<span class="string">"/user/login"</span>, request.getRequestURI()) &amp;&amp; StringUtils.equalsIgnoreCase(request.getMethod(), <span class="string">"post"</span>)) {</span><br><span class="line">            log.info(<span class="string">"request : {}"</span>, request.getRequestURI());</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 1. 进行验证码的校验</span></span><br><span class="line">                validate(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request));</span><br><span class="line">            } <span class="keyword">catch</span> (AuthenticationException e) {</span><br><span class="line">                <span class="comment">// 2. 捕获步骤1中校验出现异常，交给失败处理类进行进行处理</span></span><br><span class="line">                authenticationFailureHandler.onAuthenticationFailure(request, response, e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 校验通过，就放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(ServletWebRequest request)</span> <span class="keyword">throws</span> ServletRequestBindingException {</span><br><span class="line">        <span class="comment">// 1. 获取请求中的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">codeInRequest</span> <span class="operator">=</span> ServletRequestUtils.getStringParameter(request.getRequest(), <span class="string">"imageCode"</span>);</span><br><span class="line">        <span class="comment">// 2. 校验空值情况</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(codeInRequest)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"验证码不能为空"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 获取服务器session池中的验证码</span></span><br><span class="line">        <span class="type">ImageCode</span> <span class="variable">codeInSession</span> <span class="operator">=</span> (ImageCode) sessionStrategy.getAttribute(request, SESSION_KEY);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(codeInSession)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"验证码不存在"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 校验服务器session池中的验证码是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(codeInSession.isExpried()) {</span><br><span class="line">            sessionStrategy.removeAttribute(request, SESSION_KEY);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"验证码过期了"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 请求验证码校验</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">"验证码不匹配"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 移除已完成校验的验证码</span></span><br><span class="line">        sessionStrategy.removeAttribute(request, SESSION_KEY);</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>细节注意：这个过滤器继承了<code>OncePerRequestFilter</code>，目的在于接受 spring 的管理，它能保证我们的过滤器在一次请求中只被调用一次。</p>
<h2 id="验证码过滤器配置"><a href="#验证码过滤器配置" class="headerlink" title="验证码过滤器配置"></a>验证码过滤器配置</h2><p>验证码的过滤应该在用户认证过滤之前，所以需要配置在<code>UsernamePasswordAuthenticationFilter</code>过滤器之前，自定义的<code>ValidateCodeFilter</code>过滤器由于配置了<code>@Component("validateCodeFilter")</code>，所以已经注入到了 spring 中，安全认证配置中直接<code>@Autowired</code>引用即可。</p>
<blockquote>
<p><strong>注意：</strong>因为在验证码Controller 中设置了这个<code>/code/image</code>请求路径，因此要做不需验证配置，将其加入到<code>.antMatchers()</code>中。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidateCodeFilter validateCodeFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 将自定义的验证码过滤器放置在 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) </span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="string">"/login"</span>)	 					<span class="comment">// 设置登录页面</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">"/user/login"</span>) 			<span class="comment">// 自定义的登录接口</span></span><br><span class="line">            .successHandler(myAuthenctiationSuccessHandler)</span><br><span class="line">            .failureHandler(myAuthenctiationFailureHandler)</span><br><span class="line">            .defaultSuccessUrl(<span class="string">"/home"</span>).permitAll()		<span class="comment">// 登录成功之后，默认跳转的页面</span></span><br><span class="line">            .and().authorizeRequests()					<span class="comment">// 定义哪些URL需要被保护、哪些不需要被保护</span></span><br><span class="line">            .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>, <span class="string">"/user/login"</span>, <span class="string">"/code/image"</span>).permitAll() <span class="comment">// 设置所有人都可以访问登录页面</span></span><br><span class="line">            .anyRequest().authenticated() 				<span class="comment">// 任何请求,登录后可以访问</span></span><br><span class="line">            .and().csrf().disable(); 					<span class="comment">// 关闭csrf防护</span></span><br><span class="line">            </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>到此，整个图片验证码的安全认证流程设计就结束了，可以再回头看看笔者最开始画的时序图，感觉还是非常不专业规范的，这里辅助说明的草稿，如笔者有设计更好的时序图，欢迎交流。</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Spring Security 学习笔记（四）记住我功能实现</title>
    <url>/2019/04/12/029/</url>
    <content><![CDATA[<h2 id="记住我功能的基本原理"><a href="#记住我功能的基本原理" class="headerlink" title="记住我功能的基本原理"></a>记住我功能的基本原理</h2><p>当用户登录发起认证请求时，会通过<code>UsernamePasswordAuthenticationFilter</code>进行用户认证，认证成功之后，SpringSecurity 调用前期配置好的记住我功能，实际是调用了<code>RememberMeService</code>接口，其接口的实现类会将用户的信息生成<code>Token</code>并将它写入 response 的<code>Cookie</code>中，在写入的同时，内部的<code>TokenRepositoryTokenRepository</code>会将这份<code>Token</code>再存入数据库一份。</p>
<p>当用户再次访问服务器资源的时候，首先会经过<code>RememberMeAuthenticationFiler</code>过滤器，在这个过滤器里面会读取当前请求中携带的 Cookie，这里存着上次服务器保存 的<code>Token</code>，然后去数据库中查找是否有相应的 Token，如果有，则再通过<code>UserDetailsService</code>获取用户的信息。</p>
<p><img src="https://image.woodwhales.cn/029/images/19-%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8E%9F%E7%90%86.png"></p>
<h3 id="记住我功能的过滤器"><a href="#记住我功能的过滤器" class="headerlink" title="记住我功能的过滤器"></a>记住我功能的过滤器</h3><p>从图中可以得知记住我的过滤器在过滤链的中部，注意是在<code>UsernamePasswordAuthenticationFilter</code>之后。</p>
<p><img src="https://image.woodwhales.cn/029/images/20-%E8%AE%B0%E4%BD%8F%E6%88%91%E7%9A%84%E8%BF%87%E6%BB%A4%E9%93%BE.png"></p>
<h2 id="前端页面checkbox设置"><a href="#前端页面checkbox设置" class="headerlink" title="前端页面checkbox设置"></a>前端页面checkbox设置</h2><p>在 html 中增加记住我复选框checkbox控件，注意其中复选框的<code>name</code> 一定必须为<code>remember-me</code></p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="配置cookie存储数据库源"><a href="#配置cookie存储数据库源" class="headerlink" title="配置cookie存储数据库源"></a>配置cookie存储数据库源</h2><p>本例中使用了 springboot 管理的数据库源，所以注意要配置<code>spring-boot-starter-jdbc</code>的依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果不配置会报编译异常：</p>
<figure class="highlight txt"><table><tbody><tr><td class="code"><pre><span class="line">The type org.springframework.jdbc.core.support.JdbcDaoSupport cannot be resolved. It is indirectly referenced from required .class files</span><br></pre></td></tr></tbody></table></figure>

<p>记住我的安全认证配置：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 将自定义的验证码过滤器放置在 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) </span><br><span class="line">            .formLogin()</span><br><span class="line">                .loginPage(<span class="string">"/login"</span>)	 					<span class="comment">// 设置登录页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">"/user/login"</span>) 			<span class="comment">// 自定义的登录接口</span></span><br><span class="line">                .successHandler(myAuthenctiationSuccessHandler)</span><br><span class="line">                .failureHandler(myAuthenctiationFailureHandler)</span><br><span class="line">                .defaultSuccessUrl(<span class="string">"/home"</span>).permitAll()		<span class="comment">// 登录成功之后，默认跳转的页面</span></span><br><span class="line">                .and().authorizeRequests()					<span class="comment">// 定义哪些URL需要被保护、哪些不需要被保护</span></span><br><span class="line">                .antMatchers(<span class="string">"/"</span>, <span class="string">"/index"</span>, <span class="string">"/user/login"</span>, <span class="string">"/code/image"</span>).permitAll() <span class="comment">// 设置所有人都可以访问登录页面</span></span><br><span class="line">                .anyRequest().authenticated() 				<span class="comment">// 任何请求,登录后可以访问</span></span><br><span class="line">                .and().csrf().disable() 					<span class="comment">// 关闭csrf防护</span></span><br><span class="line">            .rememberMe()                                   <span class="comment">// 记住我配置</span></span><br><span class="line">                .tokenRepository(persistentTokenRepository())  <span class="comment">// 配置数据库源</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">3600</span>)</span><br><span class="line">                .userDetailsService(userDetailsService);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">persistentTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        <span class="comment">// 将 DataSource 设置到 PersistentTokenRepository</span></span><br><span class="line">        persistentTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 第一次启动的时候自动建表（可以不用这句话，自己手动建表，源码中有语句的）</span></span><br><span class="line">        <span class="comment">// persistentTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">        <span class="keyword">return</span> persistentTokenRepository;</span><br><span class="line">    }</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<p>注意：在数据库源配置之前，建议手动在数据库中新增一张保存的<code>cookie</code>表，其数据库脚本在<code>JdbcTokenRepositoryImpl</code>的静态属性中配置了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTokenRepositoryImpl</span> <span class="keyword">extends</span> <span class="title class_">JdbcDaoSupport</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">PersistentTokenRepository</span> {</span><br><span class="line">	<span class="comment">/** Default SQL for creating the database table to store the tokens */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CREATE_TABLE_SQL</span> <span class="operator">=</span> <span class="string">"create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, "</span></span><br><span class="line">            + <span class="string">"token varchar(64) not null, last_used timestamp not null)"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此可以事先执行以下sql 脚本创建表：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> persistent_logins (username <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>, series <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">primary</span> key, token <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">not</span> <span class="keyword">null</span>, last_used <span class="type">timestamp</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>当然，<code>JdbcTokenRepositoryImpl</code>自身还有一个<code>setCreateTableOnStartup()</code>方法进行开启自动建表操作，但是不建议使用。</p>
<p>当成功登录之后，<code>RememberMeService</code>会将成功登录请求的<code>cookie</code>存储到配置的数据库中：</p>
<p><img src="https://image.woodwhales.cn/029/images/18-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E5%AD%98cookie.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="首次请求"><a href="#首次请求" class="headerlink" title="首次请求"></a>首次请求</h3><p>首先进入到<code>AbstractAuthenticationProcessingFilter</code>过滤器中的<code>doFilter()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            authResult = attemptAuthentication(request, response);</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) {</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中当用户认证成功之后，会进入<code>successfulAuthentication()</code>方法，在用户信息被保存在了<code>SecurityContextHolder</code>之后，其中就调用了<code>rememberMeServices.loginSuccess()</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">			HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用记住我服务接口的登录成功方法</span></span><br><span class="line">    rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fire event</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.eventPublisher != <span class="literal">null</span>) {</span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">InteractiveAuthenticationSuccessEvent</span>(</span><br><span class="line">            authResult, <span class="built_in">this</span>.getClass()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在这个<code>RememberMeServices</code>有个抽象实现类，在抽象实现类<code>loginSuccess()</code>方法中进行了记住我功能判断，为什么前端的复选框控件的 name 必须为<code>remember-me</code>，原因就在此：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRememberMeServices</span> <span class="keyword">implements</span> <span class="title class_">RememberMeServices</span>,</span><br><span class="line">		InitializingBean, LogoutHandler {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_PARAMETER</span> <span class="operator">=</span> <span class="string">"remember-me"</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">parameter</span> <span class="operator">=</span> DEFAULT_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">loginSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, Authentication successfulAuthentication)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rememberMeRequested(request, parameter)) {</span><br><span class="line">            logger.debug(<span class="string">"Remember-me login not requested."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        onLoginSuccess(request, response, successfulAuthentication);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当识别到记住我功能开启的时候，就会进入<code>onLoginSuccess()</code>方法，其具体的方法实现在<code>PersistentTokenBasedRememberMeServices</code>类中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentTokenBasedRememberMeServices</span> <span class="keyword">extends</span> <span class="title class_">AbstractRememberMeServices</span> {</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLoginSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, Authentication successfulAuthentication)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> successfulAuthentication.getName();</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"Creating new persistent login for user "</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="type">PersistentRememberMeToken</span> <span class="variable">persistentToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersistentRememberMeToken</span>(</span><br><span class="line">                username, generateSeriesData(), generateTokenData(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 保存cookie到数据库</span></span><br><span class="line">            tokenRepository.createNewToken(persistentToken);</span><br><span class="line">            <span class="comment">// 将cookie回写一份到响应中</span></span><br><span class="line">            addCookie(persistentToken, request, response);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            logger.error(<span class="string">"Failed to save persistent token "</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的<code>tokenRepository.createNewToken()</code>和<code>addCookie()</code>就将 cookie 保存到数据库并回显到响应中。</p>
<h3 id="第二次请求"><a href="#第二次请求" class="headerlink" title="第二次请求"></a>第二次请求</h3><p>当第二次请求传到服务器的时候，请求会被<code>RememberMeAuthenticationFilter</code>过滤器进行过滤：过滤器首先判定之前的过滤器都没有认证通过当前用户，也就是<code>SecurityContextHolder</code>中没有已经认证的信息，所以会调用<code>rememberMeServices.autoLogin()</code>的自动登录接口拿到已通过认证的<code>rememberMeAuth</code>进行用户认证登录：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RememberMeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> <span class="keyword">implements</span></span><br><span class="line">		<span class="title class_">ApplicationEventPublisherAware</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SecurityContextHolder 不存在已经认证的 authentication，表示前面的过滤器没有做过任何身份认证</span></span><br><span class="line">        <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 调用自动登录接口</span></span><br><span class="line">            <span class="type">Authentication</span> <span class="variable">rememberMeAuth</span> <span class="operator">=</span> rememberMeServices.autoLogin(request,</span><br><span class="line">                    response);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rememberMeAuth != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// Attempt authenticaton via AuthenticationManager</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    rememberMeAuth = authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Store to SecurityContextHolder</span></span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);</span><br><span class="line">                    </span><br><span class="line">                    onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line"></span><br><span class="line">                    ……</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (AuthenticationException authenticationException) {</span><br><span class="line">                    ……</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">                logger.debug(<span class="string">"SecurityContextHolder not populated with remember-me token, as it already contained: '"</span></span><br><span class="line">                        + SecurityContextHolder.getContext().getAuthentication() + <span class="string">"'"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个自动登录的接口，又由其抽象实现类进行实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRememberMeServices</span> <span class="keyword">implements</span> <span class="title class_">RememberMeServices</span>,</span><br><span class="line">		InitializingBean, LogoutHandler {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Authentication <span class="title function_">autoLogin</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response)</span> {</span><br><span class="line">        <span class="comment">// 从请求中获取cookie</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rememberMeCookie</span> <span class="operator">=</span> extractRememberMeCookie(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rememberMeCookie == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"Remember-me cookie detected"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rememberMeCookie.length() == <span class="number">0</span>) {</span><br><span class="line">            logger.debug(<span class="string">"Cookie was empty"</span>);</span><br><span class="line">            cancelCookie(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 解码请求中的cookie</span></span><br><span class="line">            String[] cookieTokens = decodeCookie(rememberMeCookie);</span><br><span class="line">            <span class="comment">// 根据 cookie 找到用户认证</span></span><br><span class="line">            user = processAutoLoginCookie(cookieTokens, request, response);</span><br><span class="line">            userDetailsChecker.check(user);</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">"Remember-me cookie accepted"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> createSuccessfulAuthentication(request, user);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (CookieTheftException cte) {</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cancelCookie(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>processAutoLoginCookie()</code>的具体实现还是由<code>PersistentTokenBasedRememberMeServices</code>来实现，总得来说就是一顿判定当前的<code>cookieTokens</code>是不是在数据库中存在<code>tokenRepository.getTokenForSeries(presentedSeries)</code>，并判断是不是一样的，如果一样，就是把当前请求的新 token 更新保存到数据库，最后通过当前请求token中的用户名调用<code>UserDetailsService.loadUserByUsername()</code>进行用户认证。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentTokenBasedRememberMeServices</span> <span class="keyword">extends</span> <span class="title class_">AbstractRememberMeServices</span> {</span><br><span class="line">    <span class="keyword">protected</span> UserDetails <span class="title function_">processAutoLoginCookie</span><span class="params">(String[] cookieTokens,</span></span><br><span class="line"><span class="params">            HttpServletRequest request, HttpServletResponse response)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cookieTokens.length != <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidCookieException</span>(<span class="string">"Cookie token did not contain "</span> + <span class="number">2</span></span><br><span class="line">                    + <span class="string">" tokens, but contained '"</span> + Arrays.asList(cookieTokens) + <span class="string">"'"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">presentedSeries</span> <span class="operator">=</span> cookieTokens[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">presentedToken</span> <span class="operator">=</span> cookieTokens[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库查询上次保存的token</span></span><br><span class="line">        <span class="type">PersistentRememberMeToken</span> <span class="variable">token</span> <span class="operator">=</span> tokenRepository.getTokenForSeries(presentedSeries);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 查询不到抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RememberMeAuthenticationException</span>(……);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token 不匹配抛出异常</span></span><br><span class="line">        <span class="comment">// We have a match for this user/series combination</span></span><br><span class="line">        <span class="keyword">if</span> (!presentedToken.equals(token.getTokenValue())) {</span><br><span class="line">            <span class="comment">// Token doesn't match series value. Delete all logins for this user and throw</span></span><br><span class="line">            <span class="comment">// an exception to warn them.</span></span><br><span class="line">            tokenRepository.removeUserTokens(token.getUsername());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CookieTheftException</span>(……);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过期判断</span></span><br><span class="line">        <span class="keyword">if</span> (token.getDate().getTime() + getTokenValiditySeconds() * <span class="number">1000L</span> &lt; System.currentTimeMillis()) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RememberMeAuthenticationException</span>(<span class="string">"Remember-me login has expired"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">PersistentRememberMeToken</span> <span class="variable">newToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersistentRememberMeToken</span>(token.getUsername(), token.getSeries(), generateTokenData(), <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(), newToken.getDate());</span><br><span class="line">            addCookie(newToken, request, response);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            ……</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserDetailsService().loadUserByUsername(token.getUsername());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot + Spring Security 学习笔记（五）实现短信验证码+登录功能</title>
    <url>/2019/04/24/030/</url>
    <content><![CDATA[<p>在 Spring Security 中基于表单的认证模式，默认就是密码帐号登录认证，那么对于短信验证码+登录的方式，Spring Security 没有现成的接口可以使用，所以需要自己的封装一个类似的认证过滤器和认证处理器实现短信认证。</p>
<h2 id="短信验证码认证"><a href="#短信验证码认证" class="headerlink" title="短信验证码认证"></a>短信验证码认证</h2><h3 id="验证码对象类设计"><a href="#验证码对象类设计" class="headerlink" title="验证码对象类设计"></a>验证码对象类设计</h3><p>和图片验证码一样，需要自己封装一个验证码对象，用来生成手机验证码并发送给手机。因为图片验证码和手机验证码对象的区别就在于前者多了个图片对象，所以两者共同部分抽象出来可以设计成一个<code>ValidateCode</code>类，这个类里面只存放验证码和过期时间，短信验证码直接使用这个类即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCode</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ValidateCode</span><span class="params">(String code, <span class="type">int</span> expireIn)</span>{</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireIn);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpried</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().isAfter(getExpireTime());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ValidateCode</span><span class="params">(String code, LocalDateTime expireTime)</span> {</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.code = code;</span><br><span class="line">		<span class="built_in">this</span>.expireTime = expireTime;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>图片验证码承继此类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.validate.code.ValidateCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageCode</span> <span class="keyword">extends</span> <span class="title class_">ValidateCode</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BufferedImage image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageCode</span><span class="params">(BufferedImage image, String code, <span class="type">int</span> expireId)</span> {</span><br><span class="line">        <span class="built_in">super</span>(code, LocalDateTime.now().plusSeconds(expireId));</span><br><span class="line">        <span class="built_in">this</span>.image = image;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageCode</span><span class="params">(BufferedImage image, String code, LocalDateTime localDateTime)</span> {</span><br><span class="line">        <span class="built_in">super</span>(code, localDateTime);</span><br><span class="line">        <span class="built_in">this</span>.image = image;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="验证码生成类设计"><a href="#验证码生成类设计" class="headerlink" title="验证码生成类设计"></a>验证码生成类设计</h3><p>由于图片和短信类均可以生成相应的验证码，所以直接设计一个验证码生成接口，具体实现类根据业务进行实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidateCodeGenerator</span> {</span><br><span class="line"></span><br><span class="line">	ValidateCode <span class="title function_">generate</span><span class="params">(ServletWebRequest request)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>这里的传参设计成了<code>ServletWebRequest</code>是能够根据前端请求中的参数进行不同的业务实现</p>
</blockquote>
<p>目前实现累只有图片生成器和验证码生成器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 图片验证码生成器</span></span><br><span class="line"><span class="meta">@Component("imageCodeGenerator")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageCodeGenerator</span> <span class="keyword">implements</span> <span class="title class_">ValidateCodeGenerator</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成图形验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ValidateCode <span class="title function_">generate</span><span class="params">(ServletWebRequest request)</span> {</span><br><span class="line">        </span><br><span class="line">        ……</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImageCode</span>(image, sRand, SecurityConstants.EXPIRE_SECOND);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信验证码生成器</span></span><br><span class="line"><span class="meta">@Component("smsCodeGenerator")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeGenerator</span> <span class="keyword">implements</span> <span class="title class_">ValidateCodeGenerator</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ValidateCode <span class="title function_">generate</span><span class="params">(ServletWebRequest request)</span> {</span><br><span class="line">		<span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomStringUtils.randomNumeric(SecurityConstants.SMS_RANDOM_SIZE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValidateCode</span>(code, SecurityConstants.SMS_EXPIRE_SECOND);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="短信验证码发送接口设计"><a href="#短信验证码发送接口设计" class="headerlink" title="短信验证码发送接口设计"></a>短信验证码发送接口设计</h3><p>短信验证码生成之后，需要设计接口依赖短信服务提供商进行验证码发送，因此至少设计一个统一的接口，供短信服务提供商生成发送短信服务：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsCodeSender</span> {</span><br><span class="line">	<span class="comment">//　至少需要手机号和验证码</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String mobile, String code)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了演示，设计一个虚拟的默认短信发送器，只在日志文件中打印一行log：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 短信发送模拟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSmsCodeSender</span> <span class="keyword">implements</span> <span class="title class_">SmsCodeSender</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String mobile, String code)</span> {</span><br><span class="line">    	log.debug(<span class="string">"send to mobile ：{}, code : {}"</span>, mobile, code);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="短信验证码请求Controller"><a href="#短信验证码请求Controller" class="headerlink" title="短信验证码请求Controller"></a>短信验证码请求Controller</h3><p>所有验证码的请求都在统一的<code>ValidateCodeController</code>里，这里注入了两个验证码生成器<code>ValidateCodeGenerator</code>，后期可以利用 spring 的<strong>依赖查找/搜索</strong>技巧来重构代码，另外所有的请求也是可以做成动态配置，这里临时全部 hardCode 在代码里：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.social.connect.web.SessionStrategy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.ServletRequestBindingException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.ServletRequestUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.ServletWebRequest;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.core.commons.SecurityConstants;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.validate.code.ValidateCode;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.validate.code.ValidateCodeGenerator;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.validate.code.image.ImageCode;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.king.validate.code.sms.DefaultSmsCodeSender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeController</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> SessionStrategy sessionStrategy;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ValidateCodeGenerator imageCodeGenerator;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ValidateCodeGenerator smsCodeGenerator;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DefaultSmsCodeSender defaultSmsCodeSender;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@GetMapping("code/image")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createImageCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">		<span class="type">ImageCode</span> <span class="variable">imageCode</span> <span class="operator">=</span> (ImageCode)imageCodeGenerator.generate(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request));</span><br><span class="line">		sessionStrategy.setAttribute(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), SecurityConstants.SESSION_KEY, imageCode);</span><br><span class="line">		ImageIO.write(imageCode.getImage(), <span class="string">"JPEG"</span>, response.getOutputStream());</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@GetMapping("code/sms")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createSmsCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletRequestBindingException {</span><br><span class="line">		<span class="type">ValidateCode</span> <span class="variable">smsCode</span> <span class="operator">=</span> smsCodeGenerator.generate(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request));</span><br><span class="line">		sessionStrategy.setAttribute(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), SecurityConstants.SESSION_KEY, smsCode);</span><br><span class="line">		<span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> ServletRequestUtils.getStringParameter(request, <span class="string">"mobile"</span>);</span><br><span class="line">		defaultSmsCodeSender.send(mobile, smsCode.getCode());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从上述代码中可以看出图片验证码和短信验证码的生成请求逻辑是相似的：首先调用验证码生成接口生成验证码，然后将验证码放入 session 中，最后将验证码返回给前端或者用户。因此这个套路流程可以抽象成一个模板方法，以增强代码的可维护性和可扩展性。</p>
<p>用一张图来表述重构后的代码结构：</p>
<p><img src="https://image.woodwhales.cn/030/images/spring-security-1.png"></p>
<h3 id="随机验证码过滤器设计"><a href="#随机验证码过滤器设计" class="headerlink" title="随机验证码过滤器设计"></a>随机验证码过滤器设计</h3><p>由于图片和手机都会产生验证码，后期还可以通过邮件发送随机验证码的方式进行随机验证码登录验证，因此将随机验证码的认证可以独立封装在一个随机验证码过滤器中，并且这个过滤器在整个 spring security 过滤器链的最前端（它是第一道认证墙）。</p>
<p>随机验证码过滤器只要继承 spring 框架中的<code>OncePerRequestFilter</code>即可保证这个过滤器在请求来的时候只被调用一次，具体代码实现参见文末源码。</p>
<p>这里重点解释一下如何将随机验证码过滤器配置到 spring security 过滤器认证最前端，需要重写<code>SecurityConfigurerAdapter</code>的<code>configure()</code>方法，并将自定义的过滤器放到<code>AbstractPreAuthenticatedProcessingFilter</code>过滤器之前即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.SecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.DefaultSecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidateCodeSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Filter validateCodeFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="built_in">super</span>.configure(http);</span><br><span class="line">        http.addFilterBefore(validateCodeFilter, AbstractPreAuthenticatedProcessingFilter.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="短信验证码认证-1"><a href="#短信验证码认证-1" class="headerlink" title="短信验证码认证"></a>短信验证码认证</h2><p>在自定义短信登录认证流程之前，建议可以移步到之前的文章：<a href="https://juejin.im/post/5cb3416ee51d456e63760454">SpringBoot + Spring Security 学习笔记（二）安全认证流程源码详解</a>，了解清除用户密码的认证流程才能更容易理解下面这张经典的流程图：</p>
<p><img src="https://image.woodwhales.cn/030/images/spring-security-2.png"></p>
<p>左侧是用户+密码的认证流程，整体的流程就是经过用户名+密码认证过滤器认证，将请求封装成 token 并注入到 AutheticationMananger 中，之后由默认的认证校验器进行校验，在校验的过程中会调用 UserDetailsService 接口进行 token 校验，当校验成功之后，就会将已经认证的 token 放到 SecurityContextHolder 中。</p>
<p>同理，由于短信登录方式只需要使用随机验证码进行校验而不需要密码登录功能，当校验成功之后就认为用户认证成功了，因此需要仿造左侧的流程开发自定义的短信登录认证 token，这个 token 只需要存放手机号即可，在token 校验的过程中，不能使用默认的校验器了，需要自己开发校验当前自定义 token 的校验器，最后将自定义的过滤器和校验器配置到 spring security 框架中即可。</p>
<blockquote>
<p>注意：短信随机验证码的验证过程是在 SmsCodeAuthticationFIlter 之前就已经完成。</p>
</blockquote>
<h3 id="短信登录认证Token"><a href="#短信登录认证Token" class="headerlink" title="短信登录认证Token"></a>短信登录认证Token</h3><p>仿造<code>UsernamePasswordAuthenticationToken</code>设计一个属于短信验证的认证 token 对象，为什么要自定义一个短信验证的 token，spring security 框架不只提供了用户名+密码的验证方式，用户认证是否成功，最终看的就是<code>SecurityContextHolder</code>对象中是否有对应的<code>AuthenticationToken</code>，因此要设计一个认证对象，当认证成功之后，将其设置到<code>SecurityContextHolder</code>即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.SpringSecurityCoreVersion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> SpringSecurityCoreVersion.SERIAL_VERSION_UID;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object mobile)</span> {</span><br><span class="line">		<span class="built_in">super</span>(<span class="literal">null</span>);</span><br><span class="line">		<span class="built_in">this</span>.principal = mobile;</span><br><span class="line">		setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object mobile, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> {</span><br><span class="line">		<span class="built_in">super</span>(authorities);</span><br><span class="line">		<span class="built_in">this</span>.principal = mobile;</span><br><span class="line">		<span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>); <span class="comment">// must use super, as we override</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException {</span><br><span class="line">		<span class="keyword">if</span> (isAuthenticated) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> {</span><br><span class="line">		<span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从<code>AuthenticationToken</code>接口可以看到，现在框架中有我们自己定义短信登录的 token 了：</p>
<p><img src="https://image.woodwhales.cn/030/images/spring-security-3.png"></p>
<h3 id="短信登录认证过滤器"><a href="#短信登录认证过滤器" class="headerlink" title="短信登录认证过滤器"></a>短信登录认证过滤器</h3><p>短信验证码的过滤器设计思路同理，仿造<code>UsernamePasswordAuthenticationFilter</code>过滤器，这里再次提醒，短信随机验证码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationServiceException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.core.constants.SecurityConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求中的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">mobileParameter</span> <span class="operator">=</span> SecurityConstants.DEFAULT_PARAMETER_NAME_MOBILE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">postOnly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, <span class="string">"POST"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">		<span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取请求中的参数值</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> obtainMobile(request);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Objects.isNull(mobile)) {</span><br><span class="line">			mobile = <span class="string">""</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		mobile = mobile.trim();</span><br><span class="line">		</span><br><span class="line">		<span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(mobile);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow subclasses to set the "details" property</span></span><br><span class="line">		setDetails(request, authRequest);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">obtainMobile</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">		<span class="keyword">return</span> request.getParameter(mobileParameter);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setDetails</span><span class="params">(HttpServletRequest request, SmsCodeAuthenticationToken authRequest)</span> {</span><br><span class="line">		authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMobileParameter</span><span class="params">(String mobileParameter)</span> {</span><br><span class="line">		Assert.hasText(mobileParameter, <span class="string">"Mobile parameter must not be empty or null"</span>);</span><br><span class="line">		<span class="built_in">this</span>.mobileParameter = mobileParameter;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPostOnly</span><span class="params">(<span class="type">boolean</span> postOnly)</span> {</span><br><span class="line">		<span class="built_in">this</span>.postOnly = postOnly;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getMobileParameter</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> mobileParameter;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>短信验证码过滤器也成为了<code>AbstractAuthenticationProcessingFilter</code>其中一个子类，后期需要注册到安全配置中，让它成为安全认证过滤链中的一环：</p>
<p><img src="https://image.woodwhales.cn/030/images/spring-security-4.png"></p>
<h3 id="短信登录认证校验器"><a href="#短信登录认证校验器" class="headerlink" title="短信登录认证校验器"></a>短信登录认证校验器</h3><p>短信登录认证校验器的作用就是调用<code>UserDetailsService</code>的<code>loadUserByUsername()</code>方法对 authenticationToken 进行校验，所有校验器的根接口为：<code>AuthenticationProvider</code>，因此自定义的短信登录认证校验器实现这个接口，重写<code>authenticate()</code>即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.InternalAuthenticationServiceException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException {</span><br><span class="line"></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> (SmsCodeAuthenticationToken) authentication;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 {<span class="doctag">@link</span> UserDetailsService}</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> userDetailsService.loadUserByUsername((String)authenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">"无法获取用户信息"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authenticationResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(user, user.getAuthorities());</span><br><span class="line"></span><br><span class="line">        authenticationResult.setDetails(authenticationToken.getDetails());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticationResult;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> {</span><br><span class="line">		<span class="keyword">return</span> SmsCodeAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意，这里使用<code>@Data</code>注解生成 setter 和 getter 方法。</p>
<p><img src="https://image.woodwhales.cn/030/images/spring-security-5.png"></p>
<h3 id="短信登录认证安全配置设计"><a href="#短信登录认证安全配置设计" class="headerlink" title="短信登录认证安全配置设计"></a>短信登录认证安全配置设计</h3><p>设计一个封装好的短信登录认证配置类，以供外部调用者直接调用：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.SecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.DefaultSecurityFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">SecurityConfigurerAdapter</span>&lt;DefaultSecurityFilterChain, HttpSecurity&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">        <span class="type">SmsCodeAuthenticationFilter</span> <span class="variable">smsCodeAuthenticationFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationFilter</span>();</span><br><span class="line">        smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));</span><br><span class="line">        smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(myAuthenticationSuccessHandler);</span><br><span class="line">        smsCodeAuthenticationFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取验证码提供者</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationProvider</span> <span class="variable">smsCodeAuthenticationProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationProvider</span>();</span><br><span class="line">        smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将短信验证码校验器注册到 HttpSecurity， 并将短信验证码过滤器添加在 UsernamePasswordAuthenticationFilter 之前</span></span><br><span class="line">        http.authenticationProvider(smsCodeAuthenticationProvider).addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当外部想要引用这个封装好的配置，只需要在自定义的<code>AbstractChannelSecurityConfig</code>安全认证配置中添加进去即可，注意这个配置对象使用了<code>@Component</code>注解，注册到了spring 中，所以可以直接通过<code>@Autowired</code>引用，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.core.authentication.sms.AbstractChannelSecurityConfig;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.core.authentication.sms.SmsCodeAuthenticationSecurityConfig;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.core.validate.code.config.ValidateCodeSecurityConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrowserSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractChannelSecurityConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidateCodeSecurityConfig validateCodeSecurityConfig;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationSuccessHandler authenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line"></span><br><span class="line">        http.formLogin()</span><br><span class="line">            .loginPage(<span class="string">"/authentication/require"</span>) <span class="comment">// 登录页面回调</span></span><br><span class="line">            .successHandler(authenticationSuccessHandler)<span class="comment">// 认证成功回调</span></span><br><span class="line">            .failureHandler(authenticationFailureHandler)</span><br><span class="line">        </span><br><span class="line">	        <span class="comment">// 以下验证码的校验配置</span></span><br><span class="line">	        .and()</span><br><span class="line">	        .apply(validateCodeSecurityConfig) </span><br><span class="line">	</span><br><span class="line">	        <span class="comment">// 以下短信登录认证的配置</span></span><br><span class="line">	        .and()</span><br><span class="line">	        .apply(smsCodeAuthenticationSecurityConfig)</span><br><span class="line">	            </span><br><span class="line">	        <span class="comment">// 记住我的配置</span></span><br><span class="line">	        .and()</span><br><span class="line">	        .rememberMe()</span><br><span class="line">	        .tokenRepository(persistentTokenRepository())</span><br><span class="line">	        .tokenValiditySeconds(<span class="number">3600</span>) <span class="comment">// 设置记住我的过期时间</span></span><br><span class="line">	        .userDetailsService(userDetailsService)</span><br><span class="line">	        </span><br><span class="line">	        .and()</span><br><span class="line">	        <span class="comment">// 请求做授权配置</span></span><br><span class="line">	        .authorizeRequests() </span><br><span class="line">	        <span class="comment">// 以下请求路径不需要认证</span></span><br><span class="line">	        .antMatchers(<span class="string">"/authentication/require"</span>,</span><br><span class="line">	                <span class="string">"/authentication/mobile"</span>,</span><br><span class="line">	                <span class="string">"/login"</span>,</span><br><span class="line">	                <span class="string">"/code/*"</span>,</span><br><span class="line">	                <span class="string">"/"</span>)</span><br><span class="line">	        .permitAll() </span><br><span class="line">	        .anyRequest() <span class="comment">// 任何请求</span></span><br><span class="line">	        .authenticated() <span class="comment">// 都需要身份认证</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 暂时将防护跨站请求伪造的功能置为不可用</span></span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置TokenRepository</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 初始化记住我的数据库表，建议通过看源码直接创建出来</span></span><br><span class="line">		<span class="comment">// jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的配置中有些代码出现了冗余配置，可以全部封装成抽象模板，完成一些基础的配置。</p>
<p>参考源码：<a href="https://github.com/imooc-java/security">https://github.com/imooc-java/security</a></p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth 2.0 授权认证详解</title>
    <url>/2019/04/30/031/</url>
    <content><![CDATA[<h2 id="一、认识-OAuth-2-0"><a href="#一、认识-OAuth-2-0" class="headerlink" title="一、认识 OAuth 2.0"></a>一、认识 OAuth 2.0</h2><h3 id="1-1-OAuth-2-0-应用场景"><a href="#1-1-OAuth-2-0-应用场景" class="headerlink" title="1.1 OAuth 2.0 应用场景"></a>1.1 OAuth 2.0 应用场景</h3><p>OAuth 2.0 标准目前被广泛应用在第三方登录场景中，以下是虚拟出来的角色，阐述 OAuth2 能帮我们干什么，引用阮一峰这篇<a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a>中的例子：</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。<br>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。<br>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<h3 id="1-2-名词概念"><a href="#1-2-名词概念" class="headerlink" title="1.2 名词概念"></a>1.2 名词概念</h3><p>OAuth 就是为了解决上面这些问题而诞生的。在详解 OAuth 之前，需要明确一些基本的概念，从上面场景中抽象出以下概念。</p>
<p><strong>第三方应用程序</strong></p>
<p><strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p>
<p><strong>HTTP服务提供商</strong></p>
<p><strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p>
<p><strong>资源所有者</strong></p>
<p><strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</p>
<p><strong>用户代理</strong></p>
<p><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
<p><strong>认证服务器</strong></p>
<p><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
<p><strong>资源服务器</strong></p>
<p><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
<p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，从而可以和”服务商提供商”进行互动。</p>
<h2 id="二、OAuth-的授权认证流程"><a href="#二、OAuth-的授权认证流程" class="headerlink" title="二、OAuth 的授权认证流程"></a>二、OAuth 的授权认证流程</h2><h3 id="2-1-认证思路"><a href="#2-1-认证思路" class="headerlink" title="2.1 认证思路"></a>2.1 认证思路</h3><p>OAuth 在”客户端”与”服务提供商”之间，设置了一个 <strong>授权层</strong>（authorization  layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h3 id="2-2-认证流程"><a href="#2-2-认证流程" class="headerlink" title="2.2 认证流程"></a>2.2 认证流程</h3><p>官方 RFC 6749 文件中的 OAuth 2.0 流程图有点晦涩，优化了 一下：</p>
<p><img src="https://image.woodwhales.cn/031/images/oauth-1.png"></p>
<blockquote>
<ol>
<li>用户访问第三方应用程序（简称：客户端）以后，客户端要求用户给予授权。</li>
<li>用户同意给予客户端授权。</li>
<li>客户端使用第 2 步获得的授权，向认证服务器申请令牌。</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li>
<li>客户端使用令牌，向资源服务器申请获取资源。</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ol>
</blockquote>
<p>上述中的第 2 步 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<h2 id="三、四种授权模式"><a href="#三、四种授权模式" class="headerlink" title="三、四种授权模式"></a>三、四种授权模式</h2><p>上一小节可以得出用户对客户端的授权动作是核心，客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式：</p>
<h3 id="3-1-授权码模式（authorization-code）"><a href="#3-1-授权码模式（authorization-code）" class="headerlink" title="3.1 授权码模式（authorization code）"></a>3.1 授权码模式（authorization code）</h3><p>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>
<h3 id="3-2-简化模式（implicit）"><a href="#3-2-简化模式（implicit）" class="headerlink" title="3.2 简化模式（implicit）"></a>3.2 简化模式（implicit）</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</p>
<h3 id="3-3-密码模式（resource-owner-password-credentials）"><a href="#3-3-密码模式（resource-owner-password-credentials）" class="headerlink" title="3.3 密码模式（resource owner password credentials）"></a>3.3 密码模式（resource owner password credentials）</h3><p>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</p>
<h3 id="3-4-客户端模式（client-credentials）"><a href="#3-4-客户端模式（client-credentials）" class="headerlink" title="3.4 客户端模式（client credentials）"></a>3.4 客户端模式（client credentials）</h3><p>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</p>
<h2 id="四、授权码模式详解"><a href="#四、授权码模式详解" class="headerlink" title="四、授权码模式详解"></a>四、授权码模式详解</h2><h3 id="4-1-授权码模式流程"><a href="#4-1-授权码模式流程" class="headerlink" title="4.1 授权码模式流程"></a>4.1 授权码模式流程</h3><p>授权码模式（authorization code）是功能最完整、流程最严密安全的授权模式。它的特点就是通过客户端的 <strong>后台服务器</strong>，与”服务提供商”的认证服务器进行互动。</p>
<p>注意这种方式适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p><img src="https://image.woodwhales.cn/031/images/oauth-2.png"></p>
<p>授权码模式流程如下：</p>
<blockquote>
<ol>
<li>用户访问客户端，客户端将用户导向认证服务器。</li>
<li>用户选择是否给予客户端授权。</li>
<li>假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</li>
<li>客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的 <strong>后台服务器</strong> 上完成的，对用户不可见。</li>
<li>认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</li>
</ol>
</blockquote>
<p>从上述的流程描述可知，只有第 2 步需要用户进行授权操作，之后的流程都是在客户端的后台和认证服务器后台之前进行”静默”操作，对于用户来说是无感知的。</p>
<p>下面是上面这些步骤所需要的参数。</p>
<h3 id="4-2-授权码模式流程的五个步骤"><a href="#4-2-授权码模式流程的五个步骤" class="headerlink" title="4.2 授权码模式流程的五个步骤"></a>4.2 授权码模式流程的五个步骤</h3><h4 id="第-1-步骤"><a href="#第-1-步骤" class="headerlink" title="第 1 步骤"></a>第 1 步骤</h4><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><p>第 1 步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li><code>response_type</code>：表示授权类型，<strong>必选项</strong>，此处的值固定为”code”</li>
<li><code>client_id</code>：表示客户端的ID，<strong>必选项</strong></li>
<li><code>redirect_uri</code>：表示重定向URI，可选项</li>
<li><code>scope</code>：表示申请的权限范围，可选项</li>
<li><code>state</code>：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></tbody></table></figure>

<p>上面 URL 中：</p>
<p><code>response_type</code>参数表示要求返回授权码（<code>code</code>）；</p>
<p><code>client_id</code>参数让 B 网站知道是谁在请求；</p>
<p><code>redirect_uri</code>参数是 B 网站接受或拒绝请求后的跳转网址；</p>
<p><code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<h4 id="第-2-步骤"><a href="#第-2-步骤" class="headerlink" title="第 2 步骤"></a>第 2 步骤</h4><p>第 2 步骤中，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。</p>
<h4 id="第-3-步骤"><a href="#第-3-步骤" class="headerlink" title="第 3 步骤"></a>第 3 步骤</h4><h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h5><p>第 3 步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li><code>code</code>：表示授权码，<strong>必选项</strong>。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li><code>state</code>：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>在第 2 步骤用户表示同意之后，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></tbody></table></figure>

<p>上面 URL 中，<code>code</code>参数就是授权码。</p>
<h4 id="第-4-步骤"><a href="#第-4-步骤" class="headerlink" title="第 4 步骤"></a>第 4 步骤</h4><h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h5><p>第 4 步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li><code>grant_type</code>：表示使用的授权模式，<strong>必选项</strong>，此处的值固定为”authorization_code”。</li>
<li><code>code</code>：表示上一步获得的授权码，<strong>必选项</strong>。</li>
<li><code>redirect_uri</code>：表示重定向URI，<strong>必选项</strong>，且必须与A步骤中的该参数值保持一致。</li>
<li><code>client_id</code>：表示客户端ID，<strong>必选项</strong>。</li>
</ul>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>在第 3 步骤中，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></tbody></table></figure>

<p>上面 URL 中：</p>
<p><code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求）；</p>
<p><code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码；</p>
<p><code>code</code>参数是上一步拿到的授权码；</p>
<p><code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<h4 id="第-5-步骤"><a href="#第-5-步骤" class="headerlink" title="第 5 步骤"></a>第 5 步骤</h4><h5 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h5><p>第 5 步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li><code>access_token</code>：表示访问令牌，必选项。</li>
<li><code>token_type</code>：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li><code>expires_in</code>：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li><code>refresh_token</code>：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li><code>scope</code>：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><p>第 4 步骤中，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">{    </span><br><span class="line">    "access_token":"ACCESS_TOKEN",</span><br><span class="line">    "token_type":"bearer",</span><br><span class="line">    "expires_in":2592000,</span><br><span class="line">    "refresh_token":"REFRESH_TOKEN",</span><br><span class="line">    "scope":"read",</span><br><span class="line">    "uid":100101,</span><br><span class="line">    "info":{...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。注意：HTTP头信息中明确指定不得缓存。</p>
<h2 id="五、令牌（Token）传递方式"><a href="#五、令牌（Token）传递方式" class="headerlink" title="五、令牌（Token）传递方式"></a>五、令牌（Token）传递方式</h2><p>当客户端（第三方应用程序）拿到访问资源服务器的令牌时，便可以使用这个令牌进行资源访问了。</p>
<p>在第三方应用程序拿到<code>access_token</code>后，如何发送给资源服务器这个问题并没有在 RFC6729 文件中定义，而是作为一个单独的 <a href="https://www.rfc-editor.org/rfc/rfc6750.txt">RFC6750</a> 文件中独立定义了。这里做以下简单的介绍，主要有三种方式如下：</p>
<ol>
<li>URI Query Parameter</li>
<li>Authorization Request Header Field</li>
<li>Form-Encoded Body Parameter</li>
</ol>
<h3 id="5-1-请求头参数传递"><a href="#5-1-请求头参数传递" class="headerlink" title="5.1 请求头参数传递"></a>5.1 请求头参数传递</h3><p>Authorization Request Header Field，因为在HTTP应用层协议中，专门有定义一个授权使用的Request Header，所以也可以使用这种方式：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">GET /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Bearer mF_9.B5f-4.1JqM</span><br></pre></td></tr></tbody></table></figure>

<p>其中”Bearer “是固定的在access_token前面的头部信息。</p>
<h3 id="5-2-表单编码传递"><a href="#5-2-表单编码传递" class="headerlink" title="5.2 表单编码传递"></a>5.2 表单编码传递</h3><p>使用 Request Body 这种方式，有一个额外的要求，就是 Request Header 的<code>Content-Type</code>必须是固定的<code>application/x-www-form-urlencoded</code>，此外还有一个限制就是 <strong>不可以使用 GET</strong>  访问，这个好理解，毕竟 GET 请求是不能携带 Request Body 的。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">POST /resource HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">access_token=mF_9.B5f-4.1JqM</span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-3-URI-请求参数传递"><a href="#5-3-URI-请求参数传递" class="headerlink" title="5.3 URI 请求参数传递"></a>5.3 URI 请求参数传递</h3><p>URI Query Parameter，这种使用途径应该是最常见的一种方式，非常简单，比如：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></tbody></table></figure>

<p>在我们请求受保护的资源的 Url 后面追加一个 access_token 的参数即可。另外还有一点要求，就是 Client 需要设置以下 Request Header 的 <strong>Cache-Control:no-store</strong>，用来阻止 access_token 不会被 Web 中间件给 log 下来，属于安全防护方面的一个考虑。</p>
<h3 id="5-4-令牌的刷新"><a href="#5-4-令牌的刷新" class="headerlink" title="5.4 令牌的刷新"></a>5.4 令牌的刷新</h3><p>为了防止客户端使用一个令牌无限次数使用，令牌一般会有过期时间限制，当快要到期时，需要重新获取令牌，如果再重新走授权码的授权流程，对用户体验非常不好，于是 OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></tbody></table></figure>

<p>上面 URL 中：</p>
<p><code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，此处的值固定为<code>refresh_token</code>，必选项；</p>
<p><code>client_id</code>参数和<code>client_secret</code>参数用于确认身份；</p>
<p><code>refresh_token</code>参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<p><strong>注意：</strong> 第三方应用服务器拿到刷新令牌必须存于服务器，通过后台进行重新获取新的令牌，以保障刷新令牌的保密性。</p>
<h2 id="六、OAuth2的安全问题"><a href="#六、OAuth2的安全问题" class="headerlink" title="六、OAuth2的安全问题"></a>六、OAuth2的安全问题</h2><h3 id="6-1-CSRF攻击"><a href="#6-1-CSRF攻击" class="headerlink" title="6.1 CSRF攻击"></a>6.1 CSRF攻击</h3><p>应用程序在早期使用 OAuth2 的时候爆发过不少相关的安全方面的漏洞，其实仔细分析后会发现大都都是没有严格遵循 OAuth2 的安全相关的指导造成的，相关的漏洞事件自行搜索。</p>
<p>其实 OAuth2 在设计之初是已经做了很多安全方面的考虑，并且在 RFC6749 中加入了一些安全方面的规范指导。比如：</p>
<ol>
<li><p>要求 Authorization server 进行有效的客户端验证；</p>
</li>
<li><p>client_serect, access_token, refresh_token, code等敏感信息的安全存储（不得泄露给第三方）、传输通道的安全性（TSL的要求）；</p>
</li>
<li><p>维持 refresh_token 和第三方应用的绑定，刷新失效机制；</p>
</li>
<li><p>维持 Authorization Code 和第三方应用的绑定，这也是state参数为什么是推荐的一点，以防止CSRF攻击；</p>
</li>
<li><p>保证上述各种令牌信息的不可猜测行，以防止被猜测得到；</p>
</li>
</ol>
<p>安全无小事，这方面是要靠各方面（开放平台，第三方开发者）共同防范的。</p>
<h3 id="6-2-攻击流程"><a href="#6-2-攻击流程" class="headerlink" title="6.2 攻击流程"></a>6.2 攻击流程</h3><p>假设有用户张三，攻击者李四，第三方”云冲印”应用（它集成了第三方社交账号登录，并且允许用户将社交账号和”云冲印”中的账号进行绑定），以及 OAuth2 服务提供者 Google。</p>
<p><img src="https://image.woodwhales.cn/031/images/oauth-3.png"></p>
<p><strong>步骤1</strong></p>
<p>攻击者李四登录”云冲印”网站，并且选择绑定自己的 Google 账号</p>
<p><strong>步骤2</strong></p>
<p>“云冲印”网站将李四重定向到 Google，由于他之前已经登录过 Google，所以 Google 直接向他显示是否授权”云冲印”访问的页面。</p>
<p><strong>步骤3</strong></p>
<p>李四在点击”同意授权”之后，截获 Google 服务器返回的含有<code>Authorization code</code>参数的HTTP响应。</p>
<p><strong>步骤4</strong></p>
<p>李四精心构造一个 Web 页面，它会触发”云冲印”网站向 Google 发起令牌申请的请求，而这个请求中的<code>Authorization Code</code>参数正是上一步截获到的 code。</p>
<p><strong>步骤5</strong></p>
<p>李四将这个 Web 页面放到互联网上，等待或者诱骗受害者张三来访问。</p>
<p><strong>步骤6</strong></p>
<p>张三之前登录了”云冲印”网站，只是没有把自己的账号和其他社交账号绑定起来。在张三访问了李四准备的这个 Web 页面，令牌申请流程在张三的浏览器里被顺利触发，”云冲印”网站从 Google 那里获取到<code>access_token</code>，但是这个 token 以及通过它进一步获取到的用户信息却都是攻击者李四的。</p>
<p><strong>步骤7</strong></p>
<p>“云冲印”网站将李四的 Google 账号同张三的”云冲印”账号关联绑定起来，从此以后，李四就可以用自己的 Google 账号通过 OAuth 登录到张三在 “云冲印” 网站中的账号，堂而皇之的冒充张三的身份执行各种操作。</p>
<p>从整体上来看，本次 CSRF 攻击的时序图应该是下面这个样子的：</p>
<p><img src="https://image.woodwhales.cn/031/images/oauth-4.png"></p>
<p>从上图中可以看出，造成 CSRF 攻击漏洞问题的关键点在于，OAuth2 的认证流程是分为好几步来完成的，在上一章节授权码模式流程中的流程图中的第 4步骤中，第三方应用在收到一个 GET 请求时，除了能知道当前用户的 cookie，以及 URL 中的<code>Authorization Code</code>之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。</p>
<p>于是，攻击者就能使用移花接木的手段，提前准备一个含有自己的<code>Authorization Code</code>的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。</p>
<h3 id="6-3-解决方案"><a href="#6-3-解决方案" class="headerlink" title="6.3 解决方案"></a>6.3 解决方案</h3><p>要防止这样的攻击其实很容易，作为第三方应用的开发者，只需在 OAuth 认证过程中加入<code>state</code>参数，并验证它的参数值即可。具体细节如下：</p>
<ul>
<li>在将用户重定向到资源认证服务器授权界面的时候，为当前用户生成一个随机的字符串，并作为<code>state</code>参数加入到URL中，同时存储一份到 session 中。</li>
<li>当第三方应用收到资源服务提供者返回的<code>Authorization Code</code>请求的时候，验证接收到的<code>state</code>参数值。如果是正确合法的请求，那么此时接收到的参数值应该和上一步提到的为该用户生成的<code>state</code>参数值（存于当前用户的 session 中）完全一致，否则就是异常请求。</li>
<li><code>state</code>参数值需要具备下面几个特性： <ul>
<li>不可预测性：足够的随机，使得攻击者难以猜到正确的参数值</li>
<li>关联性：<code>state</code>参数值和当前用户会话（user session）是相互关联的</li>
<li>唯一性：每个用户，甚至每次请求生成的<code>state</code>参数值都是唯一的</li>
<li>时效性：<code>state</code>参数一旦被使用则立即失效</li>
</ul>
</li>
</ul>
<p><code>state</code>参数在 OAuth2 认证过程中不是必选参数，因此在早期第三方应用开发者在集成 OAuth2 认证的时候很容易会忽略它的存在，导致应用易受 CSRF 攻击。所以必须对这个安全问题重视起来。</p>
<p>安全是双方的，需要第三方应用和资源服务提供商均要严格遵守安全规范。如 QQ 互联的 OAuth2 API 中，state 参数是强制必选的参数，授权接口是基于 HTTPS 的加密通道等；作为第三方开发者在使用消费这些服务的时候也应该重视注意安全中存在的漏洞。</p>
<h2 id="七、OAuth2-参考资料及案例"><a href="#七、OAuth2-参考资料及案例" class="headerlink" title="七、OAuth2 参考资料及案例"></a>七、OAuth2 参考资料及案例</h2><h3 id="7-1-参考资料"><a href="#7-1-参考资料" class="headerlink" title="7.1  参考资料"></a>7.1  参考资料</h3><p><a href="https://oauth.net/2/">https://oauth.net/2/</a></p>
<p><a href="https://tools.ietf.org/wg/oauth/draft-ietf-oauth-v2/">Oauth Status Pages</a></p>
<p><a href="https://tools.ietf.org/html/rfc6749">RFC6749 : The OAuth 2.0 Authorization Framework</a></p>
<p><a href="https://github.com/jeansfish/RFC6749.zh-cn">RFC6749中文版</a></p>
<h3 id="7-2-案例"><a href="#7-2-案例" class="headerlink" title="7.2  案例"></a>7.2  案例</h3><p><a href="https://developers.douban.com/wiki/?title=oauth2">豆瓣OAuth2 API（Authorization Code）</a></p>
<p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token">QQ OAuth2 API（Authorization Code）</a></p>
<p><a href="https://developers.douban.com/wiki/?title=browser">豆瓣OAuth2 API（Implicit )</a></p>
<p><a href="http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8implicit_grant%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96access_token">QQ OAuth2 API（Implicit）</a></p>
<p><a href="https://mp.weixin.qq.com/wiki?id=mp1421140183&amp;t=0.2731444596120334">微信公众号获取access_token（Client Credentials Grant）</a></p>
<p><a href="https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E">微博开发文档：授权机制</a></p>
<p>参考博文：</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth 2.0 的四种方式</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0 的一个简单解释</a></p>
<p><a href="https://www.cnblogs.com/linianhui/p/oauth2-authorization.html">OAuth2认证授权</a></p>
<p><a href="https://segmentfault.com/a/1190000010540911">理解OAuth2.0认证与客户端授权码模式详解</a></p>
<p><a href="http://insights.thoughtworkers.org/attack-aim-at-oauth2/">移花接木：针对OAuth2的攻击</a></p>
<p><a href="https://www.dangyaming.com/2017/02/09/oauth2-csrf/">OAuth授权与CSRF攻击</a></p>
<p><a href="http://www.tasfa.cn/index.php/2016/03/26/note_of_oauth/">OAuth研究&amp;学习笔记</a></p>
]]></content>
      <categories>
        <category>OAuth 2.0</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之链表（C语言描述）</title>
    <url>/2019/05/30/032/</url>
    <content><![CDATA[<h2 id="一、基础知识准备"><a href="#一、基础知识准备" class="headerlink" title="一、基础知识准备"></a>一、基础知识准备</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>万事万物在计算机中最终会归为二进制组合数字表示。</p>
<p>然而，对于现实世界的事物与事物关系，不能单纯使用某个数字和另一个数字来表示，就好比，使用年龄这一个维度来表示人类这个事物未免有些不妥。因为人类这个事物会包含很多的属性，比如姓名、年龄、身高、体重等属性，只有这些属性组合在一起才可以构成人类的基本特征。</p>
<p>然而，不同属性的设计会表现出这个事物在现实世界的表现意义，如学号、身份证、所属年级等属性的组合，很具象表示学生这个事物。</p>
<p>再回到第一句话，计算机只能使用数学上纯数字来标识事物，在硬件内存中表示上述复杂的事物结构呢？这就需要引入结构体的概念：</p>
<p>内存是一块连续的可存储空间， 一般最小的存储单位是一个字节（8bit），这里将一个字节的存储单位叫一个格子，那么内存可以表示为连续的格子组成，每一个格子可以表示的最大数值范围是 256（ 2 的 8 次方），比如一个学生的学号是20190909001，那这么大的数字在一个内存格子里放不下，该怎么办呢？</p>
<p>答案很简单，多使用几个格子来表示不就行了对吗，因此，有一块连续的存储空间，可以任意使用，想怎么存就怎么存，那么规定每四个格子表示一个事物，那么这个四个格子可以表示的数字范围是 4G（4个2的8次方相乘），这个 4G 数字单位很眼熟（不就是32位计算机最大的内存限制嘛），这四个格子可以表示的范围（42亿多）完全可以够上述的学号属性使用了，毕竟没有哪所学校会设计学生学号长度超过亿位数。</p>
<h3 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h3><p>在 C 语言中，将这四个内存格子为一个单位的数字数据，其类型成为<code>int</code>，一个内存格子的数字数据类型为<code>char</code>，C 语言中还定义了一些现实世界常用的数字数据类型，这些类型是用来约束整数数据的：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">2 或 4 字节</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">4 字节</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">4 字节</td>
<td align="left">0 到 4,294,967,295</td>
</tr>
</tbody></table>
<p>注意：上表中的数据类型是针对整型数据不用的存储大小（内存格子）会对应不同的数据类型，C 语言中还定义了其他数据的数据类型：枚举类型、void 类型、派生类型。</p>
<h3 id="1-3-结构体"><a href="#1-3-结构体" class="headerlink" title="1.3 结构体"></a>1.3 结构体</h3><p>在第 2 小节中已经阐述了：内存硬件通信的基本单位是字节（8bit），而不同数量字节的组合会形成不同的数据类型，那么单从整型数据类型上映射事物，还是有不足之处：<code>int</code>类型虽然可以存储年龄属性，如果再想存储其他数据属性，就不够用了，人类的中还包括性别、身高、体重等属性，那么就需要更多的数据类型来表示其属性值。</p>
<p>而这些属性之间的关系是密不可分的，都属于人类这个事物的一部分，少了任何一个属性就无法完整表示人类这个事物在现实世界中的真实表现。因此在 C 语言中引出了结构体的概念，程序员可以使用<code>struct</code>关键词来自定义数据类型，它允许在结构体中存储不同类型的数据项。</p>
<p>通俗点讲，就是将 C 语言本身定义的一些数据类型（整数类型，字符串类型）进行组合，形成一段更有现实意义的内存格子，程序员再以这个结构体定义的内存单元格进行数据操作会更符合事物现实规律。</p>
<p>举例：</p>
<p>定义一个学生，有性别和年龄属性：性别可以使用 female 和 male 的单词首字母表示，所用 char 数据类型，年龄使用 int 数据类型，那么使用定义 Student 结构体之后，在程序中就会将 Student 类型的内存以 5 个字节（1 个字节+ 4 个字节）来表示这种数据类型：</p>
<p><img src="https://image.woodwhales.cn/032/images/1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.png"></p>
<h3 id="1-4-typedef"><a href="#1-4-typedef" class="headerlink" title="1.4 typedef"></a>1.4 typedef</h3><p>C 语言提供了 <strong>typedef</strong> 关键字，程序员可以使用它来为数据类型取一个别名。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sutdent</span> {</span></span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">} STUDENT;</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，定义了<code>struct Sutdent</code>数据类型的别名为：<code>STUDENT</code>，在定义语句之后的任意地方都可以使用这个别名来代表<code>struct Sutdent</code>这种数据类型。</p>
<h3 id="1-5-指针"><a href="#1-5-指针" class="headerlink" title="1.5 指针"></a>1.5 指针</h3><p>指针是 C 语言的灵魂，指针就是地址。</p>
<p>第 1 小节描述了内存是一块连续的内存空间，是由一个个 bit 组成，8 个 bit 组成一个字节，它是计算机操作数据的基本单位，因此对于程序来说，一块内存有很多内存单元（8 bit 为一个字节的单元格）。</p>
<p>此时不禁疑惑：计算机如何聪明地知道第一个单元格和其后面的三个单元格联接在一起，是表示<code>int</code>数据类型？它又是怎么知道第一个单元格和后面所有单元都没有联系，它就是孤立的<code>char</code>类型？还有它有时候是怎么知道第一个单元格和后面四个连续在一起是表示<code>Student</code>数据类型呢？</p>
<p>好比，有些租户租了一套房子，这是一家人，还有写租户租了四套连续的房子，这四套连在一起是属于一家。我们可以人为定义 1 个字节用于表示<code>char</code>数据类型，4 个字节表示<code>int</code>数据类型，是如何在连续的单元格中，准确无误地知道哪些单元格连在一起就是某种数据类型，哪些单元格和另一些不与之连续的单元格是一个整体，用来表示某种特殊数据呢？</p>
<p>由于内存的连续存储空间特性，可以将内存单元格进行人为编号， 这个编号的术语就是内存地址，CPU 能够操作内存中的数据就是通过地址总线进行对内存的精准操作，因此计算机只需要记住地址，就能知道其地址上对应的数据是什么。</p>
<p>因此，当定义一个<code>int</code>类型的数据，就是告知CPU，在读取内存的时候，记得在某某编号的位置开始读取内存，读取 4 个字节单元，读出来的数据就是有意义的数据。由此可以得知，数据类型的定义就是用来约束CPU从某个地址逐个字节读取数据，读到第几个字节表示一个有实际意义的函数。</p>
<p>下图表示的是，使用文件编辑器使用<code>UTF-8</code>字符集编码的文本文件，查看该十六进制信息，可以看到字母 a 和 b 占了 1 个字节，回车占了 2 个字节，在 UTF-8 字符集规范中，一个汉字占用 3 个字节，因此”木鲸鱼”这一串字符串占了 9 个字节。</p>
<p><img src="https://image.woodwhales.cn/032/images/3-%E6%8C%87%E9%92%88.png"></p>
<p>那么，在 C 语言中是如何告诉 CPU 地址和当前地址要读取几个字节数据表示一个有意义的数据呢？</p>
<p>答案就是指针变量类型，当定义一个 int 数据类型的数据，使用一个字母 a 来表示它，以便在程序的其他地方可以复用，那么就定义成以下语句：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>；</span><br></pre></td></tr></tbody></table></figure>

<p>当程序执行这句话的时候，就是告知计算机在内存中分配一块 4 个字节的内存单元用来保存 10 这个数值，那么当计算机分配成功，一定是通过地址总线进行内存分配的，因此只要内存分配成功就表示有个唯一的地址空间，从这个地址开始之后的 4 个字节内存空间是表示数字 10 的。</p>
<p>在 C 语言中，会使用某种特定的语法来获取分配成功的变量的地址，即在定义的变量名前面加个<code>&amp;</code>符号，就能得到内存分配成功之后的地址：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">&amp;a <span class="comment">// 使用 &amp;变量名 的语法方式获取地址</span></span><br></pre></td></tr></tbody></table></figure>

<p>因此，为何 C 语言为何引入地址（指针）的概念的目的就出来了，是用来记录数据存在内存的哪个位置，并在后续的时候让 CPU 知道去内存的哪里找数据。</p>
<p>此时有个新的问题，光知道地址，是无法知道数据是什么，因为从已知地址之后的任意字节空间都可以组合成数据，因此指针的概念引入还不够，还需要知道当前地址（指针）之后需要读取多少字节表示一个完整有意义的数据，而这个问题就是<code>指针类型</code>概念引入的目的，指针类型就是在告知计算机，当前地址之后的多少个字节是连续操作读取的，在 C 语言中，使用语法：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">数据类型 *</span><br></pre></td></tr></tbody></table></figure>

<p>因此，定义了上述的<code>&amp;a</code>取出地址之后，需要使用<code>int *</code>的指针类型来修饰。</p>
<p>此时又引出一个问题，当定义了一个地址，怎么知道地址对应的数据是多少，这个在 C 语言中得到很好的处理，只需要在指针变量前面加<code>*</code>符号即可读取到当前地址对应的数据内容了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> * pAge;</span><br><span class="line">    <span class="type">int</span> age= <span class="number">10</span>;</span><br><span class="line">    pAge = &amp;age;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pAge); <span class="comment">// *pAge 等价于变量 age</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也是说，<code>*指针变量</code>的方式是将会读取指针变量所在的地址，并从它的指针类型推导出应该从这个地址的内存单元开始读取几个内存单元。</p>
<p><strong>注意：</strong>指针有别于指针变量，指针是地址，而指针变量是地址（指针）对应的变量的变量。开发者常说的指针是指指针变量，这是种约定俗成的口头表述概念，不是学术上的地址概念。</p>
<h3 id="1-6-动态内存分配"><a href="#1-6-动态内存分配" class="headerlink" title="1.6 动态内存分配"></a>1.6 动态内存分配</h3><p>C 语言中提供了标准的内存管理函数库，库中的函数可以在<code>&lt;stdlib.h&gt;</code>头文件中找到，用来帮助程序员在堆中创建内存：</p>
<p><img src="https://image.woodwhales.cn/032/images/2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0.png"></p>
<p><strong>注意：</strong><code>void *</code>类型表示未确定类型的指针。C、C++ 规定<code>void *</code>类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<p><strong>说明：</strong>堆中的内存是完全由程序员自己来管理何时回收，因此程序员需要时刻小心自己在堆中申请的内存释放的时机，不需要再使用的内存没有及时回收，会产生内存泄漏风险，这是一件很恐怖的事情。</p>
<p>想要申请一块内存，用来存储 int 数据类型的数据，使用如下命令：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pTemp；</span><br><span class="line">pTemp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>想要申请一块内存，用来存储<code>Student</code>数据类型的数据时，使用如下命令：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">PStudent</span>；</span></span><br><span class="line"><span class="class"><span class="title">PStudent</span> =</span> (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br></pre></td></tr></tbody></table></figure>

<p>注意到在申请内存的时候，在<code>malloc()</code>函数中，填写的数值是使用<code>sizeof()</code>函数动态计算要存储数据的数据类型大小，这样使得 C 程序的可移植性更好，因为在不同的系统中，相同的数据类型，可能其所占的内存空间是不一样的。</p>
<h2 id="二、链表之-C-语言描述"><a href="#二、链表之-C-语言描述" class="headerlink" title="二、链表之 C 语言描述"></a>二、链表之 C 语言描述</h2><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p>
<h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。</p>
<p><img src="https://image.woodwhales.cn/032/images/4-%E9%93%BE%E8%A1%A8.png"></p>
<p><em>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接</em></p>
<p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。</p>
<h5 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h5><p>链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。</p>
<h4 id="1-2-设计思路"><a href="#1-2-设计思路" class="headerlink" title="1.2 设计思路"></a>1.2 设计思路</h4><p>链表是由节点进行链接的，那么链表中最小的单元就是节点，因此以链表的节点为一个结构体，其结构体中存放着数据和下一个节点的地址：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>设计好链表的数据节点之后，就需要考虑，节点和节点之间虽然都是使用上一个节点的属性关联着自己的地址，自己关联着下一个节点的地址，那么链表中，谁才是头，谁才是尾：</p>
<ul>
<li>头节点，其数据类型和其他子节点一样</li>
<li>头节点不含有数据data，下一个节点的地址可以指向NULL，也可以指向有效的节点（含有数据的节点）的地址</li>
<li>尾节点，其数据类型和其他子节点一样</li>
<li>尾节点其数据节点中含有数据，但其下一个节点的地址永远是指向NULL</li>
</ul>
<h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">} NODE, *PNODE;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">createList</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sortList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertList</span><span class="params">(PNODE, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteList</span><span class="params">(PNODE, <span class="type">int</span>, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(PNODE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    PNODE pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    pHead = createList();</span><br><span class="line">    traverseList(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试链表长度</span></span><br><span class="line">    <span class="type">int</span> len = lengthList(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表的长度为：%d\n"</span>, len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 测试链表是否为空</span></span><br><span class="line"><span class="comment">    if(isEmpty(pHead)) {</span></span><br><span class="line"><span class="comment">        printf("链表为空\n");</span></span><br><span class="line"><span class="comment">    } else {</span></span><br><span class="line"><span class="comment">        printf("链表不为空\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试排序</span></span><br><span class="line">    <span class="comment">// sortList(pHead);</span></span><br><span class="line">    <span class="comment">// traverseList(pHead);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试插入</span></span><br><span class="line">    <span class="comment">// insertList(pHead, 3, -1);</span></span><br><span class="line">    <span class="comment">// traverseList(pHead);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> post = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>(deleteList(pHead, post, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功，删除第%d个元素为：%d\n"</span>, post, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除失败"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverseList(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PNODE <span class="title function_">createList</span><span class="params">()</span>{</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要生成的链表的结点个数："</span>);</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; len; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第 %d 个结点的值: "</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line"></span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pNew) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;</span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        pTail = pNew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    遍历链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    判断链表是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead-&gt;pNext) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    计算链表的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p) {</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    对链表元素进行排序，使用冒泡排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = lengthList(pHead);</span><br><span class="line">    PNODE p,q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, p=pHead-&gt;pNext; i &lt; len<span class="number">-1</span>; ++i, p=p-&gt;pNext) {</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>, q=p-&gt;pNext;j &lt; len; ++j, q=q-&gt;pNext) {</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data) {</span><br><span class="line">                t = p-&gt;data;</span><br><span class="line">                p-&gt;data = q-&gt;data;</span><br><span class="line">                q-&gt;data = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    链表中插入元素，在第post 个元素位置插入 val 值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertList</span><span class="params">(PNODE pHead, <span class="type">int</span> post, <span class="type">int</span> val)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="comment">// 遍历找第 post-1 的结点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p &amp;&amp; i&lt;post<span class="number">-1</span>) {</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面循环正确的话，此时的 i 一定是：post-1</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;post<span class="number">-1</span> || <span class="literal">NULL</span> == p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    pNew-&gt;pNext = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteList</span><span class="params">(PNODE pHead, <span class="type">int</span> post, <span class="type">int</span> * pVal)</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="comment">// 遍历找第 post-1 的结点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p &amp;&amp; i &lt; post<span class="number">-1</span>) {</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面循环正确的话，此时的 i 一定是：post-1</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;post<span class="number">-1</span> || <span class="literal">NULL</span> == p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE postP = p-&gt;pNext; <span class="comment">// p-&gt;pNext 是第post个元素，需要删除</span></span><br><span class="line">    *pVal = postP-&gt;data;</span><br><span class="line"></span><br><span class="line">    p-&gt;pNext = postP-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    postP = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(postP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参考资料：郝斌 数据结构自学视频</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析消息中间件</title>
    <url>/2019/06/24/033/</url>
    <content><![CDATA[<h2 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a>1.1 什么是消息中间件</h2><p>消息中间件通也被称为消息队列服务器，是当今分布式应用架构中经常采用的技术。</p>
<p>简单来说就是程序与程序之间进行异步通信的一种方式，消息的发送者不用一直等待消息的处理完毕，而是将消息发送给消息中间件就返回了。消息的指定消费者会订阅消息并处理他们。</p>
<p>这有点类似与 RPC（远程过程调用），当然消息中间件的实现与 RPC 规范是息息相关的，因为毕竟他们都是为了解决计算机世界中两个程序之间通信的技术。</p>
<p><strong>消息队列</strong> 已经逐渐成为企业应用系统 <strong>内部通信</strong> 的核心手段。它具有 <strong>低耦合</strong>、<strong>可靠投递</strong>、<strong>广播</strong>、<strong>流量控制</strong>、<strong>最终一致性</strong> 等一系列功能。</p>
<p>当前使用较多的消息队列有 <code>RabbitMQ</code>、<code>RocketMQ</code>、<code>ActiveMQ</code>、<code>Kafka</code>、<code>ZeroMQ</code>、<code>MetaMQ</code>等，而部分数据库，如 <code>Redis</code>、<code>MySQL</code> 以及 <code>phxsql</code> 也可实现消息队列的功能。在当今世界的互联网应用中消息队列中间件基本上成为标配。</p>
<h2 id="1-2-消息中间件的产生背景"><a href="#1-2-消息中间件的产生背景" class="headerlink" title="1.2 消息中间件的产生背景"></a>1.2 消息中间件的产生背景</h2><p>A 系统产生一些特有的数据，并需要将这些数据传递给下面其他系统，让其他系统来继续处理这段数据，最终才能称之为完整的处理一条数据。</p>
<p>由于系统与系统之间是通过业务逻辑来拆分的，所以各自系统都”对外”暴露自己可以服务的接口，别人想用自己的服务就必须调用自己设计的接口（将数据作为参数传进接口里进行接口调用），当然被调用的接口也是可以返回给调用者数据处理之后的结果数据。</p>
<p>所以在一个单体服务应用里，可以到处找到一个服务实现里，调用了其他服务接口，并以此进行数据传输通信。但这里有个现实问题：</p>
<ul>
<li><p>如果下面的 B 系统不提供某种特殊服务了，那么 A 系统在知道的情况下，就需要去掉调用 B 系统服务接口的代码，修改一处还好说，如果有大量的数据服务都对外关闭了，那么 A 系统中代码改动就会很大。</p>
</li>
<li><p>A 系统调用 B 系统的时候，要是不知道 B 系统停用了接口情况下，A 系统如何知道是通信不正常导致的，还是确实是要调用的接口不存在了，还是调用接口服务超时了。</p>
</li>
<li><p>又来了新的 E 系统，其接口也需要用到 A 系统的数据，那么 A 系统又得增加新的代码，调用 E 系统的接口。如果，E 系统就是尝试运营一段时间，发现业务这样拆分不是很好，又要砍掉，那么 A 系统的代码又需要改一次。</p>
</li>
</ul>
<p>因此这样的系统架构对于那种后期业务需求不需要发生系统性变化的场景，已经是最精炼省成本的方案。但是，遇到业务需求频繁变化，系统拆分频繁的情况下，A 系统和其他相关系统接口之间的代码耦合度太高，以至于后期的代码维护成本十分巨大，也不利于架构的伸缩。</p>
<p><img src="https://image.woodwhales.cn/033/images/02.png"></p>
<p>总体用图来表述，就是下面这张看着烦心的变动需求：</p>
<p><img src="https://image.woodwhales.cn/033/images/01.png"></p>
<p>从上图可以看出：</p>
<p>只要有别人需要 A 系统的数据，那么 A 系统业务代码中就要增加调用这些系统的接口，当需求方不需要这些数据的时候，又要去掉该代码。因此代码维护成本很高。</p>
<h2 id="1-3-消息中间件的使用场景"><a href="#1-3-消息中间件的使用场景" class="headerlink" title="1.3 消息中间件的使用场景"></a>1.3 消息中间件的使用场景</h2><h3 id="1-3-1-解耦"><a href="#1-3-1-解耦" class="headerlink" title="1.3.1 解耦"></a>1.3.1 解耦</h3><p>在 A 系统和其他系统之间增加一个处理消息的中间件，这个中间件专门用于接收数据，同时也提供其他订阅了该数据消费的系统来此消费该数据，也是 JMS 规范中的 Pub/Sub（发布/订阅）模型。</p>
<p>A 系统产生了有效数据，随即发给 MQ，即可继续干自己的事情，至于谁来处理这条数据，A 系统无需关心，它只需要一门心思生产有效数据即可。</p>
<p>其他系统想要使用并处理 A 系统的数据，也变得十分简单，只需要去 MQ 中找自己要消费的数据进行消费即可，当不需要A系统数据时，就不去 MQ 消费即可。</p>
<p>这种消息通信方式使得系统之间得到完全解偶，绝对是应对频繁拆分系统问题的优质解决方案。</p>
<p><img src="https://image.woodwhales.cn/033/images/03.png"></p>
<p><strong>面试技巧</strong></p>
<p>消息队列的常见使用场景？</p>
<p>此时需要去考虑一下自己负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 达到解耦。</p>
<h3 id="1-3-2-异步"><a href="#1-3-2-异步" class="headerlink" title="1.3.2 异步"></a>1.3.2 异步</h3><p>在同步调用的系统中，A 系统分别调用了下面三个系统，每个系统都会对数据库进行数据操作，那么整个一次数据的完整流程走下来就是很慢长的数据处理，这是用户无法容忍的响应速度。</p>
<p><img src="https://image.woodwhales.cn/033/images/04.png"></p>
<p>当使用 MQ 进行异步化：A 系统产生数据之后，只要将数据成功发送给 MQ，就返回响应给用户，至于数据在 MQ 之后的操作，由要消费的系统自己去完成。</p>
<p><img src="https://image.woodwhales.cn/033/images/05.png"></p>
<h3 id="1-3-3-削峰"><a href="#1-3-3-削峰" class="headerlink" title="1.3.3 削峰"></a>1.3.3 削峰</h3><p>对于互联网应用，流量是右一定的周期性波动，对于单一架构的系统，在流量高峰的时候，由于系统资源瓶颈问题，会导致系统崩溃。</p>
<p><img src="https://image.woodwhales.cn/033/images/06.png"></p>
<p>MQ 就像一个大水库一样，当水库水满的时候，会采取开几个闸门放水，达到缓慢放水的目的，如果所有闸门全部放水，那么水库下游的村民全部遭殃。</p>
<p><img src="https://image.woodwhales.cn/033/images/07.png"></p>
<h2 id="1-4-MQ的优缺点"><a href="#1-4-MQ的优缺点" class="headerlink" title="1.4 MQ的优缺点"></a>1.4 MQ的优缺点</h2><h3 id="1-4-1-优点"><a href="#1-4-1-优点" class="headerlink" title="1.4.1 优点"></a>1.4.1 优点</h3><p>解耦、异步、削峰</p>
<h3 id="1-4-2-缺点"><a href="#1-4-2-缺点" class="headerlink" title="1.4.2 缺点"></a>1.4.2 缺点</h3><p><strong>系统可用性降低</strong></p>
<p>系统引入的外部依赖越多越容易挂掉，本来 A 系统调用 B、C、D 三个系统的接口就好了，其中一个调用失败了就返回失败响应，这没啥问题。但当加了 MQ 之后，万一 MQ 挂了咋整？MQ 挂了，整套系统崩溃了，A 系统就真的什么也不能用了。</p>
<p><img src="https://image.woodwhales.cn/033/images/08.png"></p>
<p>上图中，由于则增加了 MQ 导致系统存在的可能问题会更多。</p>
<p><strong>系统复杂性提高</strong></p>
<p>硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p>
<p><strong>一致性问题</strong></p>
<p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 B、C、D 三个系统那里，B、D 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p>
<p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，MQ 的引用会使得原有的系统复杂度提升了一个数量级，也许是复杂了 10 倍，但是关键时刻，还是得用。</p>
<h2 id="1-5-常见MQ性能对比"><a href="#1-5-常见MQ性能对比" class="headerlink" title="1.5 常见MQ性能对比"></a>1.5 常见MQ性能对比</h2><p>对于中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择。</p>
<p>如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
<h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？"><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<h2 id="1-6-如何保证MQ高可用"><a href="#1-6-如何保证MQ高可用" class="headerlink" title="1.6 如何保证MQ高可用"></a>1.6 如何保证MQ高可用</h2><h3 id="1-6-1-RabbitMQ的高可用性"><a href="#1-6-1-RabbitMQ的高可用性" class="headerlink" title="1.6.1 RabbitMQ的高可用性"></a>1.6.1 RabbitMQ的高可用性</h3><p>RabbitMQ 是比较有代表性的，因为是基于主从做高可用性的，我们就以他为例子讲解第一种MQ的高可用性怎么实现。</p>
<p>rRabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式</p>
<h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4><p>demo级别，一般就是本地学习开发使用，没人生产用单机模式。</p>
<h4 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h4><p>意思就是在多台机器上启动多个RabbitMQ实例，每个机器里含着一个实例。在创建queue的时候，这个消息队列只会放在集群中的某一个RabbtiMQ实例上，但是每个实例都同步queue的元数据。</p>
<p><img src="https://image.woodwhales.cn/033/images/10.png"></p>
<p>在消费的时候，实际上如果消费者连接到了集群中不含实际数据的节点上，那么这个节点的实例会从queue所在实际数据的实例上拉取数据过来。</p>
<p>这种方式没做到所谓的分布式，就是个普通集群。因为集群模式的限制：消费者要么每次随机连接一个实例，然后这个实例会找到真实存放数据的实例去拉取数据再消费，这会引发集群节点之间存在大量的数据传输动作，增加数据拉取的开销；要么固定连接那个queue所在实例消费数据，导致单实例性能瓶颈。</p>
<p> 另外当存放实际queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取。解决方案就是开启消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p>
<p>从上面的分析可知，这种集群模式没有什么所谓的高可用性可言，这方案主要是<strong>提高吞吐量</strong>的，就是说让集群中多个节点来服务某个queue的读写操作。</p>
<h4 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h4><p>这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，创建queue时候，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。</p>
<p>这种模式的优势：任何一个机器宕机了，别的机器都可以用。</p>
<p>弊端：第一，性能开销很大，消息同步所有机器，导致网络带宽压力和消耗很重；第二，没有扩展性可言了，如果某个queue负载很重，新增节点无济于事，因为新增的机器也包含了这个queue的所有数据，并没有办法线性扩展。</p>
<blockquote>
<p>如何开启镜像集群模式呢？</p>
<p>RabbitMQ有很好的管理控制台，在后台管理里新增一个镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/033/images/11.png"></p>
<h3 id="1-6-2-Kafka的高可用性"><a href="#1-6-2-Kafka的高可用性" class="headerlink" title="1.6.2 Kafka的高可用性"></a>1.6.2 Kafka的高可用性</h3><p><strong>架构思路</strong></p>
<p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；当创建一个 topic 的时候，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 只放一部分数据。</p>
<p>这就是天然的分布式消息队列，简单概述就是一份 topic 数据，是分散放在多个机器上的，每个机器就放一部分数据。</p>
<blockquote>
<p>严格来说，RabbitMQ 不管使用什么模式，都不是分布式消息队列，它只是传统的消息队列，只不过提供了一些集群、HA 的机制而已，因为无论怎么玩，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
</blockquote>
<p>Kafka 0.8 以前，是没有HA机制的，因此任何一个 broker 宕机了，那么这个 broker 上的 partition 就废了，没法写也没法读，也就没有什么高可用性可言。</p>
<p>Kafka 0.8 以后，提供了 HA 机制，就是 replica 副本机制。每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。然后所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上数据即可。</p>
<p><strong>为什么只能读写leader？</strong></p>
<p>因为假设可以随意读写每个 follower，那么在数据读写的时候就需要考虑数据一致性的问题，因此这样对 Kafka 系统架构设计的复杂度太高，也很容易出问题。因此为了架构简单，成本、风险小，Kafka 会均匀的将一个 partition的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p>
<p><strong>高可用性</strong></p>
<p>在上述架构的前提下，才为 Kafka 提供了高可用的可能性：如果某个 broker 宕机了，这个 broker 上面的 partition 在其他机器上还有副本，如果这个 broker 是某个 partition 的 leader，那么此时会在所有 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p>
<p><strong>读写过程浅析</strong></p>
<p>写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>
<p>消费的时候，只会从 leader 去读，但是只有一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p>
<p><img src="https://image.woodwhales.cn/033/images/12.png"></p>
<h2 id="1-7-消息幂等性"><a href="#1-7-消息幂等性" class="headerlink" title="1.7 消息幂等性"></a>1.7 消息幂等性</h2><p>如何保证消息不被重复消费啊（如何保证消息消费时的幂等性）？这种问题是面试时必问问题，因为这是实际生产上时刻会面临的系统设计问题。</p>
<h3 id="1-7-1-重复消费问题"><a href="#1-7-1-重复消费问题" class="headerlink" title="1.7.1 重复消费问题"></a>1.7.1 重复消费问题</h3><p>遇到这种问题的时候，首先需要知道哪些消息中间件可能会这种问题，产生问题的原因是什么？</p>
<p>RabbitMQ、Rocketmq、Kafka，都有可能会出现消费重复消费的问题，因为这些 MQ 可以保证消息不丢，单保证不了消费重发，所以会出现消息重复消费的问题。</p>
<p>以 Kafka 为例，Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表这条消息进入 Kafka 的序号，消费者在成功消费数据之后，会定时定期把刚才消费过的消息的 offset 提交向 zookeeper 注册中心提交，表示消费者已经成功消费消息。当消费者重启的之后，会重新要求 Kafka 继续从上次消费到的 offset 来继续消费。</p>
<p><img src="https://image.woodwhales.cn/033/images/13.png"></p>
<p>因此上述的消息消费机制，关键点在于消费者重启的时机，如果消息者消费成功之后，还没来得及提交 offset 的时候，机器重启了，那么当机器重启之后，重新去Kafka消息队列拉取数据的时候，是从上一次成功消费的地方开始，因此会出现消费重复消费的问题。</p>
<h3 id="1-7-2-保证幂等性"><a href="#1-7-2-保证幂等性" class="headerlink" title="1.7.2 保证幂等性"></a>1.7.2 保证幂等性</h3><p>其实重复消费不可怕，可怕的是没考虑到重复消费之后，怎么保证幂等性。</p>
<p>举个例子。假设有个系统，消费一条往数据库里插入一条，要是一个消息重复两次，那么不就对同一条数据做了两次插入操作吗？因此可以在消费到第二次的时候，自己判断一下已经这条消息是不是已经消费过了，如果是已经消费过的数据，那么就直接不消费这条消息，因此保证了数据操作的幂等性。</p>
<p><img src="https://image.woodwhales.cn/033/images/14.png"></p>
<p>如何保证MQ的消费是幂等性的，需要结合具体的业务来操作，以下是思路：</p>
<ol>
<li><p>比如一条数据要进行写库操作，首先根据主键查一下，如果这数据已存在，就不要执行插入操作，而是执行更新操作。</p>
</li>
<li><p>比如如果数据库是redis，那不存在这种问题，反正每次都是set，天然幂等性</p>
</li>
<li><p>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的标识（类似订单id之类的标识），然后所有消费者来自己这里消费的时候，先根据这个唯一标识去比如redis里查一下，之前是否有消费过？如果没有查到，就表示这条消费没有被处理，消费成功之后就将这个唯一标识写入redis。如果查到了，就标识消费过了，因此就不处理了。</p>
</li>
</ol>
<p>还有比如基于数据库的唯一键来保证重复数据不会重复插入多条，因为有数据库的唯一键约束保证，所以数据重复插入只会报错，不会导致数据库中出现脏数据。</p>
<h2 id="1-8-消息可靠性"><a href="#1-8-消息可靠性" class="headerlink" title="1.8 消息可靠性"></a>1.8 消息可靠性</h2><p>如何保证消息的可靠性传输（如何处理消息丢失的问题）？</p>
<p>这个问题也是实际生产中会面临的问题，对于非常核心的消息传递，比如计费系统、扣费系统等，因为业务重，所以需要使用MQ来进行消息异步化。</p>
<p>广告计费系统会统计每次用户点击广告的次数，安装次数进行计费，那么丢失了数据，积少成多，是绝对不允许出现丢数据的问题。</p>
<p>使用MQ时丢数据一般分两种情况：要么是MQ自己丢数据，要么是消费的时候丢数据。分别对RabbitMQ和Kafka进行分析：</p>
<h3 id="1-8-1-RabbitMQ"><a href="#1-8-1-RabbitMQ" class="headerlink" title="1.8.1 RabbitMQ"></a>1.8.1 RabbitMQ</h3><p><strong>（1）生产者弄丢了数据</strong></p>
<p>生产者将数据发送到RabbitMQ的时候，因为网络等问题导致数据在传输路上丢失。 </p>
<p>此时可以选择用RabbitMQ提供的<strong>事务功能</strong>：</p>
<p>生产者发送数据之前开启RabbitMQ事务（channel.txSelect），然后发送消息，如果消息没有成功被RabbitMQ接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；</p>
<p>如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p>
<p>所以一般来说，如果要确保说写RabbitMQ的消息不丢失，可以<strong>开启confirm模式</strong>：</p>
<p>在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，如果成功写入了RabbitMQ中，RabbitMQ会给你回传一个ack消息，告诉你说这个消息已成功传输到了MQ中。如果RabbitMQ没能接收这个消息，则会回调消费者的nack接口，告诉消费这个消息接收失败，此时消费者可以重试发送。而且消费者可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发。</p>
<p>事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息RabbitMQ接收了之后会异步回调你一个接口通知你这个消息接收到了。</p>
<p><strong>所以一般在生产者这块避免数据丢失，常用confirm机制。</strong></p>
<p><img src="https://image.woodwhales.cn/033/images/15.png"></p>
<p><strong>（2）RabbitMQ弄丢了数据</strong></p>
<p>为了防止RabbitMQ自己弄丢了数据，所以必须开启RabbitMQ的持久化功能：消息写入之后会持久化到磁盘，哪怕是RabbitMQ自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p>
<p>设置持久化有两个步骤：</p>
<p>第一个是创建queue的时候将其设置为持久化，这样就可以保证RabbitMQ持久化queue的元数据，但是不会持久化queue里的数据；</p>
<p>第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，RabbitMQ哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p>
<p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p>
<p>此外，RabbitMQ开启了持久化机制也并非完全不丢失数据：也存在一种消息刚写到RabbitMQ中，但还没来得及持久化到磁盘上，此时RabbitMQ挂了的情况，这会导致内存里的少量数据丢失。</p>
<p><strong>（3）消费端弄丢了数据</strong> </p>
<p>消费端丢失数据主要原因是在消费的时候，刚消费到一半，还没来得及处理完毕，结果当前的消费端进程挂了，比如重启了，那么RabbitMQ认为你都消费了，因此数据就丢了。 </p>
<p>这个时候得用RabbitMQ提供的ack机制，简单来说就是关闭RabbitMQ自动ack，可以通过一个api来调用就行：在消费端处理完数据的时候，在程序里手动ack。</p>
<p>因此，消费端如果还没处理完数据，此时没有ack回MQ，那么RabbitMQ就认为这条消息还没处理完，会把这个消费分配给别的consumer去处理，这样就保证的消息不丢失。</p>
<h3 id="1-8-2-Kafka"><a href="#1-8-2-Kafka" class="headerlink" title="1.8.2 Kafka"></a>1.8.2 Kafka</h3><p><strong>（1）消费端弄丢了数据</strong> </p>
<p>唯一可能导致消费者弄丢数据的情况：当消费者正在消费的时候，消费者这边就自动提交了offset，导致kafka以为消费者已经确认消费完毕这条消息，然而实际上消费者正准备处理这个消息，还没来得及处理消息，系统就挂了，消息自然就丢失了。</p>
<p>众所周知Kafka会自动提交offset，那么只需要关闭自动提交offset，消费者在处理消息完毕之后自己手动提交offset，就可以保证数据不会丢。</p>
<blockquote>
<p>注意：不论关闭不关闭自动提交offset，当消费者正在消费的时候，没有做幂等性机制处理，会导致重复消费问题，因此消费者须要自己解决幂等性问题。</p>
</blockquote>
<p>这种消费端丢失数据的问题在生产环境中还是很可能发生：kafka消费者消费到了数据之后是先写到入内存的queue里缓冲一下，结果有的时候，消费者刚把消息写入内存queue，然后消费者会自动提交offset，此时消费者重启了系统，就会导致内存queue里还没来得及处理的数据就丢失了。</p>
<p><strong>（2）kafka弄丢了数据</strong></p>
<p>Kafka本身丢失数据是一个比较常见的场景：众所周知，当Kafka某个broker宕机之后，Kafka需要重新选举partiton的leader。因此，如果在其他的follower刚好还有些数据没有同步完全的时候，结果此时leader挂了，然后选举某个follower成新的leader之后，这个当前新的leader自然就丢失了一些数据。 </p>
<p><img src="https://image.woodwhales.cn/033/images/16.png"></p>
<p>为了保证Kafka不丢失数据，一般是要求起码设置以下4个参数：</p>
<ul>
<li><p>topic设置replication.factor参数：这个值必须大于1，要求每个partition必须有至少2个副本。</p>
</li>
<li><p>在kafka服务端设置min.insync.replicas参数：这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系，没掉队，这样才能确保leader挂了还有一个follower。</p>
</li>
<li><p>在producer端设置acks=all：这个是要求每条数据，必须是写入所有replica之后，才能认为是写成功了。</p>
</li>
<li><p>在producer端设置retries=MAX（很大的一个值，无限次重试的意思）：这个参数是要求一旦写入失败，就无限重试，卡在这里了</p>
</li>
</ul>
<p>按照上述要求配置，至少在Kafka的broker端可以保证在leader所在broker发生故障，并进行leader切换时，数据不会丢失。</p>
<p><strong>（3）生产者会不会弄丢数据？</strong></p>
<p>如果按照上述的思路设置了ack=all，一定不会丢，因为参数设置的保证：当Kafka的leader接收到消息，所有的follower都同步完毕消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>
<h2 id="1-9-消息有序性"><a href="#1-9-消息有序性" class="headerlink" title="1.9 消息有序性"></a>1.9 消息有序性</h2><p>如何保证消息的顺序性？这个问题也是生产系统中常见的问题。</p>
<h3 id="1-9-1-消息乱序问题分析"><a href="#1-9-1-消息乱序问题分析" class="headerlink" title="1.9.1 消息乱序问题分析"></a>1.9.1 消息乱序问题分析</h3><p>举个例子，在mysql binlog同步的系统中，日同步数据要达到上亿。业务操作在mysql里增删改一条数据，对应出来了增删改3条binlog，接着这三条binlog发送到MQ里面，到消费出来依次执行，起码得保证日志数据是按照顺序，不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加。</p>
<p>这种数据同步不一致的问题十分危险：本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据未能同步。</p>
<p>顺序会错乱的俩场景：</p>
<ol>
<li>RabbitMQ：一个queue，多个consumer，导致顺序乱了</li>
</ol>
<p><img src="https://image.woodwhales.cn/033/images/17.png"></p>
<ol>
<li>Kafka：一个topic，一个partition，一个consumer，内部多线程，导致顺序乱了</li>
</ol>
<p><img src="https://image.woodwhales.cn/033/images/18.png"></p>
<h3 id="1-9-2-解决方案"><a href="#1-9-2-解决方案" class="headerlink" title="1.9.2 解决方案"></a>1.9.2 解决方案</h3><ol>
<li><p>RabbitMQ：</p>
<p> 拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。</p>
</li>
</ol>
<p><img src="https://image.woodwhales.cn/033/images/19.png"></p>
<ol start="2">
<li><p>Kafka：</p>
<p> 一个topic，一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue即可。</p>
</li>
</ol>
<p><img src="https://image.woodwhales.cn/033/images/20.png"></p>
<h2 id="1-10-消息积压"><a href="#1-10-消息积压" class="headerlink" title="1.10 消息积压"></a>1.10 消息积压</h2><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，如何解决？</p>
<p>这种问题也是实际生产中可能会发生的问题：消息队列集群的磁盘都快写满了，一直没人消费，这个时候怎么办？或者是整个这就积压了几个小时，这个时候怎么办？或者是消息积压的时间太长，以至于积压时长都超过了RabbitMQ设置了消息过期时间，此时该怎么办？</p>
<p>这种问题本质在于消费端出了问题，消费者不消费了或者消费的极其极其慢。这种问题一般不会出现，但是一旦出现了，就是巨大的系统性问题，一般常见于：消费端每次消费之后需要操作mysql，结果mysql挂了导致消费端hang在原地不动了。或者是消费端出了个什么叉子，导致消费速度极其慢。</p>
<p><strong>（1）大量消息在MQ里积压了几个小时了还没解决</strong></p>
<p>从下午4点多积压到了晚上11点多，几千万条数据在MQ里积压了七八个小时，这时第一反映就是修复consumer，让消费者恢复正常消费速度，一个消费者一秒是1000条，一秒3个消费者是3000条，一分钟是18万条，1000多万条，所以如果MQ积压了几百万到上千万的数据，即使消费者恢复了，也需要大概一小时的时间才能恢复过来。这种只修复现有consumer 是不能及时解决积压问题。</p>
<p>这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：</p>
<ol>
<li><p>先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉</p>
</li>
<li><p>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</p>
</li>
<li><p>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍或者20倍数量的queue</p>
</li>
<li><p>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</p>
</li>
<li><p>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</p>
</li>
<li><p>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p>
</li>
</ol>
<p><img src="https://image.woodwhales.cn/033/images/21.png"></p>
<p><strong>（2）这里我们假设再来第二个坑</strong></p>
<p>如果用的是RabbitMQ，RabbitMQ是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被RabbitMQ给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在MQ里，而是大量的数据会直接搞丢了。</p>
<p>这种情况下，不是增加consumer消费解决积压消息问题，因为实际上没啥积压，而是丢了大量的消息，需要找回丢失的数据。我们可以采取一个方案，就是批量重导：</p>
<p>等到用户流量峰值变小的时候，一般为凌晨之后，写个程序将丢失的那批数据，这个临时程序目的就是把丢失的数据一点一点查出来，然后重新灌入MQ里面去，把白天丢的数据给他补回来。</p>
<p>假设1万个订单积压在MQ里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次。</p>
<p><strong>（3）然后我们再来假设第三个坑</strong></p>
<p>由于消息长时间积压在MQ里，消费者消费太慢，导致MQ都快写满了，怎么办？</p>
<p>只能通过写临时程序，接入数据以消费数据，消费一个就丢弃一个，快速消费掉所有的消息。然后再将丢失的数据重新补回MQ。</p>
<h2 id="1-11-设计MQ的思路"><a href="#1-11-设计MQ的思路" class="headerlink" title="1.11 设计MQ的思路"></a>1.11 设计MQ的思路</h2><p>当自己写一个消息队列，该如何进行架构设计啊？简述思路。</p>
<p>其实这种问题，一般在面试中是考察两块：</p>
<ul>
<li><p>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个MQ的架构原理</p>
</li>
<li><p>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。</p>
</li>
</ul>
<p>说实话，我一般面类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，大多数人就是平时埋头用，从来不去思考背后的一些东西。</p>
<p>类似的问题还有：如果让你来设计一个spring框架你会怎么做？如果让你来设计一个dubbo框架你会怎么做？如果让你来设计一个mybatis框架你会怎么做？</p>
<p>这类问题不算是刁钻的问题，因为只是简述思路，而不是要求分析技术源码，因此面试者起码大概知道这个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p>
<p>比如说这个消息队列系统，我们来从以下几个角度来考虑一下：</p>
<ol>
<li><p>首先这个MQ得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下Kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了吗。</p>
</li>
<li><p>其次你得考虑一下这个MQ的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是Kafka的思路。</p>
</li>
<li><p>其次你考虑一下你的MQ的可用性啊？这个事儿，具体参考我们之前可用性那个环节讲解的Kafka的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker挂了重新选举leader即可对外服务。</p>
</li>
<li><p>能不能支持数据0丢失啊？可以的，参考我们之前说的那个Kafka数据零丢失方案</p>
</li>
</ol>
<p>其实一个MQ肯定是很复杂的，面试官问到这个问题，其实是个开放题，他就是看看面试者有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p>
<h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>互联网Java工程师面试突击训练第1季 | 微信公众号：石杉的架构笔记</p>
<p><a href="https://github.com/doocs/advanced-java/tree/master/docs/high-concurrency">互联网Java工程师面试突击训练第1季 - 学习笔记</a></p>
<h2 id="拓展资料"><a href="#拓展资料" class="headerlink" title="拓展资料"></a>拓展资料</h2><p><a href="http://zhangruibin.com/article/CompareMQ.html">几款MQ（消息中间件）的比较</a></p>
<p><a href="https://www.imooc.com/article/283988?block_id=tuijian_wz">面试官：请谈谈写入消息中间件的数据，如何保证不丢失？</a></p>
<p><a href="https://juejin.im/post/5b41fe36e51d45191252e79e">浅谈消息队列及常见的消息中间件</a></p>
<p><a href="https://www.infoq.cn/article/s*RvY8D1jrNIsfOJylPE">漫谈消息队列：以 Kafka 和 RocketMQ 为例</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-kafka-distributed/index.html">分布式消息中间件应用实践-Kafka 的优化及在商业平台中的应用</a></p>
<p><a href="https://help.aliyun.com/document_detail/68166.html?spm=a2c4g.11186623.6.612.1df164abqctOo7">消息队列 Kafka-订阅者最佳实践</a></p>
<p><a href="http://www.thinkyixia.com/2017/10/25/kafka-2/">Kafka史上最详细原理总结</a></p>
<p><a href="https://dbaplus.cn/news-73-1123-1.html">阿里RocketMQ如何解决消息的顺序&amp;重复两大硬伤？</a></p>
<p><a href="http://www.51niux.com/?id=195">大数据(十)学习kafka集群部署</a></p>
<p><a href="http://neoremind.com/2018/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF%E7%82%B9%E6%A2%B3%E7%90%86/">消息队列技术点梳理（思维导图版）</a></p>
<p><a href="http://jm.taobao.org/2017/01/26/20170126/">万亿级数据洪峰下的分布式消息引擎</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式搜索引擎</title>
    <url>/2019/06/28/034/</url>
    <content><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-认识Lucene"><a href="#1-1-认识Lucene" class="headerlink" title="1.1 认识Lucene"></a>1.1 认识Lucene</h2><p>维基百科的定义：</p>
<p>Lucene是一套用于<strong>全文检索</strong>和<strong>搜索</strong>的<strong>开放源码程序库</strong>，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程序接口，能够做全文索引和搜索，在Java开发环境里Lucene是一个成熟的免费开放源代码工具；就其本身而论，Lucene是现在并且是这几年，最受欢迎的免费Java信息检索程序库。</p>
<p>Lucene官网：<a href="http://lucene.apache.org/">http://lucene.apache.org</a></p>
<h2 id="1-2-倒排索引"><a href="#1-2-倒排索引" class="headerlink" title="1.2 倒排索引"></a>1.2 倒排索引</h2><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p>
<p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p>
<p>举个栗子：</p>
<p>有以下文档：</p>
<table>
<thead>
<tr>
<th>DocId</th>
<th>Doc</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>谷歌地图之父跳槽 Facebook</td>
</tr>
<tr>
<td>2</td>
<td>谷歌地图之父加盟 Facebook</td>
</tr>
<tr>
<td>3</td>
<td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td>
</tr>
<tr>
<td>4</td>
<td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td>
</tr>
<tr>
<td>5</td>
<td>谷歌地图之父拉斯加盟社交网站 Facebook</td>
</tr>
</tbody></table>
<p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p>
<table>
<thead>
<tr>
<th>WordId</th>
<th>Word</th>
<th>DocIds</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>谷歌</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>2</td>
<td>地图</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>3</td>
<td>之父</td>
<td>1,2,4,5</td>
</tr>
<tr>
<td>4</td>
<td>跳槽</td>
<td>1,4</td>
</tr>
<tr>
<td>5</td>
<td>Facebook</td>
<td>1,2,3,4,5</td>
</tr>
<tr>
<td>6</td>
<td>加盟</td>
<td>2,3,5</td>
</tr>
<tr>
<td>7</td>
<td>创始人</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>拉斯</td>
<td>3,5</td>
</tr>
<tr>
<td>9</td>
<td>离开</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>与</td>
<td>4</td>
</tr>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
</tbody></table>
<p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p>
<p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code>，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li>
</ul>
<blockquote>
<p>上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。</p>
</blockquote>
<h2 id="1-3-Lucene与Elasticsearch"><a href="#1-3-Lucene与Elasticsearch" class="headerlink" title="1.3 Lucene与Elasticsearch"></a>1.3 Lucene与Elasticsearch</h2><p>Lucene是一个开源的全文检索引擎工具包（类似于Java api），而Elasticsearch底层是基于这些包，对其进行了扩展，提供了比Lucene更为丰富的查询语言，可以非常方便的通过Elasticsearch的HTTP接口与底层Lucene交互。</p>
<p>如果在应用程序中直接使用Lucene，你需要覆盖大量的集成框架工作，而使用ElasticSearch就省下了这些集成工作。</p>
<p><strong>一句话概括：Elasticsearch是Lucene面向企业搜索应用的扩展，极大的缩短研发周期。</strong></p>
<p>刚刚入门Elasticsearch，只需<strong>稍微了解下Lucene，无需去真正学习它</strong>，就可以很好的完成全文索引的工作，很好的进行开发。等熟练使用es之后，可以反过头来学习Lucene里面底层的原理，也是一种提升。</p>
<p>因为Lucene是一个编程库，您可以按原始接口来调用。但是Elasticsearch是在它基础上扩展的应用程序,就可以直接拿来使用了。</p>
<p>举个例子，你直接拿汽车（Elasticsearch）来开，开好车就行，无需了解里面的发动机、各个组件（Lucene library）。后面你在去了解一些原理，对于修车等等会有帮助。</p>
<h2 id="1-4-ES的核心面试题"><a href="#1-4-ES的核心面试题" class="headerlink" title="1.4 ES的核心面试题"></a>1.4 ES的核心面试题</h2><p>（1）es的分布式架构原理是什么（es是如何实现分布式的）？</p>
<p>（2）es写入数据的工作原理是什么？es查询数据的工作原理是什么？</p>
<p>（3）es在数据量很大的情况下（数十亿级别）如何提高查询性能？</p>
<p>（4）es生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</p>
<h1 id="2-认识ES"><a href="#2-认识ES" class="headerlink" title="2. 认识ES"></a>2. 认识ES</h1><p>Lucene 是最先进、功能最强大的搜索库。如果直接基于 lucene 开发，非常复杂，即便写一些简单的功能，也要写大量的 Java 代码，需要深入理解原理。</p>
<p>elasticsearch 基于 lucene，简称es，隐藏了 lucene 的复杂性，提供了简单易用的 restful api / Java api 接口（另外还有其他语言的 api 接口）。现在分布式搜索基本已经成为大部分互联网行业的Java系统的标配，其中尤为流行的就是es，前几年es没火的时候，大家一般用solr。但是这两年基本大部分企业和项目都开始转向es了。</p>
<ul>
<li>分布式的文档存储引擎</li>
<li>分布式的搜索引擎和分析引擎</li>
<li>分布式，支持 PB 级数据</li>
</ul>
<h2 id="2-1-ES-的核心概念"><a href="#2-1-ES-的核心概念" class="headerlink" title="2.1 ES 的核心概念"></a>2.1 ES 的核心概念</h2><h3 id="Near-Realtime"><a href="#Near-Realtime" class="headerlink" title="Near Realtime"></a>Near Realtime</h3><p>近实时，有两层含义：</p>
<ul>
<li>从写入数据到数据可以被搜索到有一个小延迟（大概是 1s）</li>
<li>基于 es 执行搜索和分析可以达到秒级</li>
</ul>
<h3 id="Cluster-集群"><a href="#Cluster-集群" class="headerlink" title="Cluster 集群"></a>Cluster 集群</h3><p>集群包含多个节点，每个节点属于哪个集群都是通过一个配置来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。</p>
<h3 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h3><p>Node 是集群中的一个节点，每个节点有一个唯一的名称，这个名称默认是随机分配的。默认节点会去加入一个名称为 <code>elasticsearch</code> 的集群。如果直接启动一堆节点，那么它们会自动组成一个 elasticsearch 集群，当然一个节点也可以组成 elasticsearch集群。</p>
<h3 id="Document-field"><a href="#Document-field" class="headerlink" title="Document &amp; field"></a>Document &amp; field</h3><p><strong>文档是 es 中最小的数据单元</strong>，一个 document 可以是一条客户数据、一条商品分类数据、一条订单数据，通常用 json 数据结构来表示。每个 index 下的 type，都可以存储多条 document。一个 document 里面有多个 field，每个 field 就是一个数据字段。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    "product_id": "1",</span><br><span class="line">    "product_name": "iPhone X",</span><br><span class="line">    "product_desc": "苹果手机",</span><br><span class="line">    "category_id": "2",</span><br><span class="line">    "category_name": "电子产品"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>索引包含了一堆有相似结构的文档数据，比如商品索引。一个索引包含很多 document，一个索引就代表了一类相似或者相同的 ducument。</p>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><p>类型，每个索引里可以有一个或者多个 type，type 是 index 的一个逻辑分类，比如商品 index 下有多个 type：日化商品 type、电器商品 type、生鲜商品 type。每个 type 下的 document 的 field 可能不太一样。</p>
<h3 id="shard"><a href="#shard" class="headerlink" title="shard"></a>shard</h3><p>单台机器无法存储大量数据，es 可以将一个索引中的数据切分为多个 shard，分布在多台服务器上存储。有了 shard 就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个 shard 都是一个 Lucene index。</p>
<h3 id="replica"><a href="#replica" class="headerlink" title="replica"></a>replica</h3><p>任何一个服务器随时可能故障或宕机，此时 shard 可能就会丢失，因此可以为每个 shard 创建多个 replica 副本。replica 可以在 shard 故障时提供备用服务，保证数据不丢失，多个 replica 还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认 5 个），replica shard（随时修改数量，默认 1 个），默认每个索引 10 个 shard，5 个 primary shard，5个 replica shard，最小的高可用配置，是 2 台服务器。</p>
<p>这么说吧，shard 分为 primary shard 和 replica shard。而 primary shard 一般简称为 shard，而 replica shard 一般简称为 replica。</p>
<p><img src="https://image.woodwhales.cn/034/images/01.png"></p>
<h3 id="ES-核心概念-vs-DB-核心概念"><a href="#ES-核心概念-vs-DB-核心概念" class="headerlink" title="ES 核心概念 vs DB 核心概念"></a>ES 核心概念 vs DB 核心概念</h3><table>
<thead>
<tr>
<th>es</th>
<th>db</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>数据库</td>
</tr>
<tr>
<td>type</td>
<td>数据表</td>
</tr>
<tr>
<td>docuemnt</td>
<td>一行数据</td>
</tr>
</tbody></table>
<p>以上是一个简单的类比。</p>
<h1 id="3-ES架构原理"><a href="#3-ES架构原理" class="headerlink" title="3. ES架构原理"></a>3. ES架构原理</h1><p>elasticsearch设计的理念就是分布式搜索引擎，底层其实还是基于lucene的。核心思想就是在多台机器上启动多个es进程实例，组成了一个es集群。</p>
<p>es中存储数据的基本单位是索引，比如现在要在es中存储一些订单数据，此时就应该在es中创建一个索引，order_idx，所有的订单数据就都写到这个索引里面去，一个索引相当于mysql里的一张表。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field</span><br></pre></td></tr></tbody></table></figure>

<p>以下是对上述名词概念的一种类比，仅仅是一种类比描述：</p>
<p>index： mysql 里的一张表。</p>
<p>type：没法跟mysql里去对比，一个index里可以有多个type，每个type的字段都是差不多的，但是有一些略微的差别。</p>
<blockquote>
<p>假设有一个订单的index，里面专门是放订单数据。</p>
<p>在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。这两种订单大部分字段是一样的，但是少部分字段可能存在略微的一些差别。</p>
<p>所以就需要在订单 index 里创建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p>
</blockquote>
<p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（<strong>注意</strong>，<code>mapping types</code>这个概念在 ElasticSearch 7.X 已被完全移除，详细说明可以参考<a href="https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc">官方文档</a>）。</p>
<p>可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的<strong>表结构定义</strong>。</p>
<p>场景类比：在 mysql 中创建一个表的时候，需要定义表结构、表结构中的字段、每个字段的类型。因此 index 里的一个 type 里面写的一条数据，这条数据叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。</p>
<p> <img src="https://image.woodwhales.cn/034/images/02.png"></p>
<p>创建一个es索引的时候，这个索引可以拆分成多个 <code>shard</code>，每个 shard 存储部分数据。拆分多个 shard 是有好处：</p>
<p><strong>支持横向扩展</strong></p>
<p>比如整个数据量是 3T，3 个 shard，每个 shard 可以分别拆分成 1T 的数据，若现在数据量增加到 4T 该怎么扩展？很简单，重新建一个有 4 个 shard 的索引，将数据导进去；</p>
<p><strong>提高性能</strong></p>
<p>数据分布在多个 shard，即多台服务器上，所有的操作都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p>
<p>另外 shard 的数据实际是有多个备份，也就是说每个 shard 都有一个 <code>primary shard</code>，这个 primary shard 专门负责写入数据，同时这个还有几个副本 <code>replica shard</code>。<code>primary shard</code> 写入数据之后，会将数据同步到自己的所有副本 <code>replica shard</code> 上去（primary shard和其副本的replica shard不会在同一台机器上）。</p>
<p>因此通过上述的主副shard方案，每个shard的数据在多台机器上都有备份，如果某个机器宕机了，没关系，还有别的数据副本在别的机器上，这就可以保证高可用了。</p>
<p> <img src="https://image.woodwhales.cn/034/images/03.png"></p>
<p>es集群会自动从众多节点中选举某一个节点为master节点，这个master节点其实就是干一些管理的工作，比如维护索引元数据拉，负责切换primary shard和replica shard身份等。</p>
<p>当master节点宕机了，那么es集群会重新选举一个节点成为新的master节点。</p>
<p><img src="https://image.woodwhales.cn/034/images/04.png"></p>
<p>当非master节点宕机了，那么会由master节点，让那个宕机节点上的primary shard的身份转移到其他机器上的replica shard。随后当修复了那个宕机机器并重启之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p>
<p>简单说，当某个非 master 节点宕机了，那么此节点上的 primary shard 就消失了，那么 master 会检测到该节点挂了，随即让那个 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p>
<p>上述就是elasticsearch作为一个分布式搜索引擎最基本的一个架构设计。</p>
<h1 id="4-写入-查询数据的工作原理"><a href="#4-写入-查询数据的工作原理" class="headerlink" title="4. 写入&amp;查询数据的工作原理"></a>4. 写入&amp;查询数据的工作原理</h1><p>如果只把es当作一个黑盒，只会使用api读写数据是不能满足实际开发需求的，因为一旦出了问题，根本无从下手解决。</p>
<h2 id="4-1-写数据过程"><a href="#4-1-写数据过程" class="headerlink" title="4.1 写数据过程"></a>4.1 写数据过程</h2><ul>
<li><p>客户端选择一个node发送请求过去，这个node就是<code>coordinating node</code>（协调节点）。</p>
</li>
<li><p><code>coordinating node</code>对document进行<strong>路由</strong>，将请求转发给对应的node（有primary shard）。</p>
</li>
<li><p>实际的node上的<code>primary shard</code>处理请求，然后将数据同步到有对应<code>replica shard</code>的node上。</p>
</li>
<li><p>coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端。</p>
</li>
</ul>
<p><img src="https://image.woodwhales.cn/034/images/05.png"></p>
<h2 id="4-2-读数据过程"><a href="#4-2-读数据过程" class="headerlink" title="4.2 读数据过程"></a>4.2 读数据过程</h2><p>数据写入某个document的时候，es会自动会给这个document自动分配一个全局唯一的id，称为<code>doc id</code>，协同节点也是根据doc id进行hash路由到对应的primary shard上面去。也可以手动指定doc id，比如用订单id，用户id。</p>
<p>读数据的过程大致是通过doc id查询，es会根据doc id进行hash，判断出来当时把doc id分配到了哪个shard上面去，再从那个shard去查询：</p>
<ul>
<li><p>客户端发送请求到任意一个node，当前node成为<code>coordinate node</code>（协调节点）。</p>
</li>
<li><p><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</p>
</li>
<li><p>接收请求的 node 返回 document 给 <code>coordinate node</code>。</p>
</li>
<li><p><code>coordinate node</code> 返回 document 给客户端。</p>
</li>
</ul>
<h2 id="4-3-搜索数据过程"><a href="#4-3-搜索数据过程" class="headerlink" title="4.3 搜索数据过程"></a>4.3 搜索数据过程</h2><p>es 最强大的是做全文检索，就是比如你有三条数据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">java真好玩儿啊</span><br><span class="line">java好难学啊</span><br><span class="line">j2ee特别牛</span><br></pre></td></tr></tbody></table></figure>

<p>es可以根据 “java” 关键词来搜索，将包含 “java”关键词的 <code>document</code> 给搜索出来。es 就会给你返回：”java真好玩儿啊”，”java好难学啊”。</p>
<ul>
<li>客户端发送请求到一个 <code>coordinate node</code>。</li>
<li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code>。</li>
<li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li>
<li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li>
</ul>
<blockquote>
<p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
</blockquote>
<h2 id="4-4-写数据底层原理"><a href="#4-4-写数据底层原理" class="headerlink" title="4.4 写数据底层原理"></a>4.4 写数据底层原理</h2><p>es里的写流程，有4个底层的核心概念：<code>refresh</code>、<code>flush</code>、<code>translog</code>、<code>merge</code></p>
<p><img src="https://image.woodwhales.cn/034/images/06.png"></p>
<p>1）数据先写入内存buffer，在写入buffer的同时将数据写入<code>translog</code>日志文件，注意：此时数据还没有被成功es索引记录，因此无法搜索到对应数据；</p>
<p>2）如果buffer快满了或者到一定时间，es就会将buffer数据<code>refresh</code>到一个新的<code>segment file</code>中，但是此时数据不是直接进入<code>segment file</code>的磁盘文件，而是先进入<code>os cache</code>的。这个过程就是<code>refresh</code>。 </p>
<blockquote>
<p>每隔1秒钟，es将buffer中的数据写入一个新的<code>segment file</code>，因此每秒钟会产生一个新的磁盘文件<code>segment file</code>，这个segment file中就存储最近1秒内buffer中写入的数据。</p>
<p>如果buffer里面此时没有数据，那当然不会执行refresh操作咯，每秒创建换一个空的segment file，如果buffer里面有数据，默认1秒钟执行一次refresh操作，刷入一个新的segment file中。</p>
<p>操作系统中，磁盘文件其实都有一个操作系统缓存<code>os cache</code>，因此数据写入磁盘文件之前，会先进入操作系统级别的内存缓存<code>os cache</code>中。</p>
</blockquote>
<p>一旦buffer中的数据被refresh操作，刷入<code>os cache</code>中，就代表这个数据就可以被搜索到了。</p>
<p>这就是为什么es被称为<strong>准实时</strong>（NRT，near real-time）：因为写入的数据默认每隔1秒<code>refresh</code>一次，也就是数据每隔一秒才能被 es 搜索到，之后才能被看到，所以称为准实时。</p>
<blockquote>
<p>es可以通过restful api或者java api，手动执行一次<code>refresh</code>操作，也就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。</p>
</blockquote>
<p>只要数据被输入<code>os cache</code>中，buffer就会被清空，并且数据在<code>translog</code>日志文件里面持久化到磁盘了一份，此时就可以让这个<code>segment file</code>的数据对外提供搜索了。</p>
<p>3）重复1~2步骤，新的数据不断进入<code>buffer</code>和<code>translog</code>，不断将buffer数据写入一个又一个新的segment file中去，每次<code>refresh</code>完，buffer就会被清空，同时translog保留一份日志数据。随着这个过程推进，<code>translog</code>文件会不断变大。当<code>translog</code>文件达到一定程度时，就会执行<code>commit</code>操作。</p>
<p>4）commit操作发生第一步，就是将buffer中现有数据<code>refresh</code>到<code>os cache</code>中去，清空<code>buffer</code>。</p>
<p>5）将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code>，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。</p>
<p>8）将现有的<code>translog</code>清空，然后再次重启启用一个<code>translog</code>，此时commit操作完成。</p>
<blockquote>
<p>默认每隔30分钟会自动执行一次<code>commit</code>，但是如果<code>translog</code>文件过大，也会触发commit。整个commit的过程，叫做<code>flush</code>操作。我们可以手动执行<code>flush</code>操作，就是将所有<code>os cache</code>数据刷到磁盘文件中去。</p>
<p>我们也可以通过es的api，手动执行<code>flush</code>操作，手动将<code>os cache</code>中的数据fsync强刷到磁盘上去，记录一个commit point，清空translog日志文件。</p>
</blockquote>
<p><code>translog</code>日志文件的作用是什么？</p>
<p>在你执行commit操作之前，数据要么是停留在buffer中，要么是停留在<code>os cache</code>中，无论是buffer还是os cache都是内存，一旦这台机器死了，内存中的数据就全丢了。</p>
<p>因此需要将数据对应的操作写入一个专门的日志文件，也就是<code>translog</code>日志文件，一旦此时机器宕机，再次重启的时候，es会自动读取<code>translog</code>日志文件中的数据，恢复到内存buffer和os cache中去。</p>
<blockquote>
<p><code>translog</code>其实也是先写入os cache的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有5秒的数据会仅仅停留在buffer或者translog文件的<code>os cache</code>中，如果此时机器挂了，会丢失5秒钟的数据。但是这样性能比较好，最多丢5秒的数据。也可以将<code>translog</code>设置成每次写操作必须是直接fsync到磁盘，但是性能会差很多。</p>
</blockquote>
<p>综上可以看出：</p>
<ul>
<li>es是准实时的，因此数据写入1秒后才可以搜索到。</li>
<li>es可能会丢失数据：有5秒的数据停留在buffer、translog的os cache、segment file的os cache中，也就是这5秒的数据不在磁盘上，此时如果宕机，会导致5秒的数据丢失。</li>
</ul>
<p>如果你希望一定不能丢失数据，可以查官方文档设置个参数。使得每次写入一条数据，都是写入buffer，同时写入磁盘上的<code>translog</code>，但是这会导致写性能、写入吞吐量会下降一个数量级。本来一秒钟可以写2000条，现在一秒钟可能只能写200条。</p>
<p><strong>总结一下：</strong></p>
<ul>
<li><p>数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 是准实时的，因为从写入到能被搜索到中间有 1s 的延迟）。</p>
</li>
<li><p>每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失）。</p>
</li>
<li><p><code>translog</code>大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p>
</li>
</ul>
<blockquote>
<p>数据写入 segment file 之后，同时就建立好了倒排索引。</p>
</blockquote>
<h2 id="4-5-删除-更新数据底层原理"><a href="#4-5-删除-更新数据底层原理" class="headerlink" title="4.5 删除/更新数据底层原理"></a>4.5 删除/更新数据底层原理</h2><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p>
<p><strong>segment file 的 merge 操作：</strong></p>
<p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code>，所以默认情况下是 1 秒钟一个 <code>segment file</code>，这样下来 <code>segment file</code> 文件数量会越来越多，此时es会定期执行 merge。</p>
<p>每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code>，标识所有新的 <code>segment file</code>，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code>。</p>
<p>总的来说，就是当segment file多到一定程度的时候，es就会自动触发merge操作，将多个segment file给merge成一个segment file。</p>
<h1 id="5-提高查询性能"><a href="#5-提高查询性能" class="headerlink" title="5. 提高查询性能"></a>5. 提高查询性能</h1><p>es在数据量很大的情况下（数十亿级别）如何提高查询效率/性能？</p>
<p>es性能其实并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能跑个搜索怎么需要5秒<del>10秒。第一次搜索的时候，是5</del>10秒，后面反而就快了，可能就几百毫秒。</p>
<p>es性能优化是没有什么银弹的，不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是换个参数，或者调整一下语法，就可以搞定，但是绝对不是用一个配置参数通用所有场景的。</p>
<p>在这个海量数据的场景下，如何提升es搜索的性能，需要生产环境实践经验积累。</p>
<h2 id="5-1-filesystem-cache（性能优化的杀手锏）"><a href="#5-1-filesystem-cache（性能优化的杀手锏）" class="headerlink" title="5.1 filesystem cache（性能优化的杀手锏）"></a>5.1 filesystem cache（性能优化的杀手锏）</h2><blockquote>
<p> 利用操作系统的缓存 <code>os cache</code>进行性能优化点。</p>
</blockquote>
<p>es里写的数据，实际上最终都会写到磁盘文件里去，磁盘文件里的数据操作系统会自动将里面的数据缓存到<code>os cache</code>里面去。</p>
<p>因为es的搜索引擎严重依赖于底层的<code>filesystem cache</code>，所以如果给<code>filesystem cache</code>更多的内存，尽量让内存可以容纳所有的<code>indx</code>的<code>segment file</code>索引数据文件，那么es搜索的时候就基本都是走内存的，性能会非常高。</p>
<p>很多测试和压测可以看出性能差距巨大：如果走磁盘一般肯定超秒，搜索性能绝对是秒级别的，1秒，5秒，10秒。但如果是走<code>filesystem cache</code>，也就是是走纯内存，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p>
<p> <img src="https://image.woodwhales.cn/034/images/07.png"></p>
<p> 案例：某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code>。每台机器给 es jvm heap 是 <code>32G</code>，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code>，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code>，那么每台机器的数据量是 <code>300G</code>。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p>
<p><img src="https://image.woodwhales.cn/034/images/08.png"></p>
<p><strong>归根结底，让 es 查询性能很高，最佳实践是让es进程占用系统的内存尽量大，至少可以容纳你的总数据量的一半。</strong></p>
<p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是只存<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么就将索引数据量控制在 100G 以内，这样的话，数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p>
<p>比如说你现在有一行数据。id，name，age等 30 个字段。实际需求只需要根据 id，name，age 这三个字段来搜索数据，但是如果往 es 里写入一行数据所有的字段，就会导致 <code>90%</code> 的数据不用来搜索却硬是占据了 es 机器上的 <code>filesystem cache</code> 的大部分空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。</p>
<p>因此，写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如写入 es 的是 id，name，age 这三个字段，其他的字段数据存在 mysql/hbase 里，我们一般是建议用 <code>es + hbase</code>的组合架构。</p>
<p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code>，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p>
<blockquote>
<p>写入 es 的数据最好小于等于（略微大于一点也可） es 的 filesystem cache 的内存容量。粗略估算从 es 检索可能需要耗时 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能需要耗时 30ms，这样每次查询就是 50ms。而原来的一次查询就是耗时 5~10s，这种性能提升是非常显著的。</p>
</blockquote>
<h2 id="5-1-数据预热"><a href="#5-1-数据预热" class="headerlink" title="5.1 数据预热"></a>5.1 数据预热</h2><p>实际生产中还有一种情况：即使按照上述的方案去做了，因为物理设备的限制，导致 es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如有 60G 数据需要写入一台机器，结果 <code>filesystem cache</code>撑死只有 30G，那么剩下的 30G 数据只存留在了磁盘上。</p>
<p>对于这种情况，最佳解决方案就是做<strong>数据预热</strong>。</p>
<p>举例微博热搜数据，自己搭建一个后台系统，这个系统就是定时去搜索当前用户的热数据或者可能上热搜的数据，提前刷到 <code>filesystem cache</code> 里去，之后用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了。</p>
<p>电商业务也是如此，可以将用户平时热搜的商品，比如说新品上市手机或数码设备等热搜商品数据提前在后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p>
<p>对于那些比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p>
<h2 id="5-3-冷热分离"><a href="#5-3-冷热分离" class="headerlink" title="5.3 冷热分离"></a>5.3 冷热分离</h2><p>es 可以做类似于 mysql 的水平拆分，也就是将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让它们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p>
<p><img src="https://image.woodwhales.cn/034/images/09.png"></p>
<p>假设有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。90%的用户群体大量时间是在访问热数据 index，热数据可能就占总数据量的 10%，由于这部分频繁搜索的数据量很少，于是几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。</p>
<p>对于冷数据而言，是在另一个 index 里的，跟热数据 index 不在相同的机器上，两种数据存放的机器之间不存在联系。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，因为冷数据本身就是很少人访问（10%左右的用户群体），这些用户随便怎么搜索冷数据也不会把热数据从内存中”挤出来”。</p>
<h2 id="5-4-Document-模型设计"><a href="#5-4-Document-模型设计" class="headerlink" title="5.4 Document 模型设计"></a>5.4 Document 模型设计</h2><p>对于 MySQL，我们经常有一些复杂的关联查询。但在 es 里尽量不要用复杂的关联查询，一旦用了性能一般都不会太好。</p>
<p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p>
<p>因此，在搜索/查询的时候，要执行一些业务强相关的特别复杂的操作： </p>
<ul>
<li><p>在写入数据的之前就设计好模型，加几个字段，把处理好的数据写入加的字段里面。</p>
</li>
<li><p>用 Java 程序封装的复杂关联操作，es仅用来做搜索数据的操作。</p>
</li>
</ul>
<h2 id="5-5-分页性能优化"><a href="#5-5-分页性能优化" class="headerlink" title="5.5 分页性能优化"></a>5.5 分页性能优化</h2><h3 id="5-5-1-分页的坑"><a href="#5-5-1-分页的坑" class="headerlink" title="5.5.1 分页的坑"></a>5.5.1 分页的坑</h3><p>举个例子，假如每页是 10 条数据，用户现在要查询第 100 页，es实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果这个 index 有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<p>分布式情况下，要查第 100 页的 10 条数据，不可能是从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据。</p>
<p>es<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据用户搜索的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。当搜索翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，明显会发现越翻到后面越翻越慢。</p>
<blockquote>
<p>实际开发测试中遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p>
</blockquote>
<h3 id="5-5-2-解决方案"><a href="#5-5-2-解决方案" class="headerlink" title="5.5.2 解决方案"></a>5.5.2 解决方案</h3><p>1）不允许深度分页（默认深度分页性能很差）</p>
<p>一般公司要求，系统不允许翻很深的页，因为默认翻的越深，性能就越差。</p>
<p>2）类似于 APP 里的推荐商品不断下拉出来一页一页的</p>
<p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code>，关于如何使用，可自行搜索。</p>
<p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多，基本上都是毫秒级的。</p>
<p>但唯一需要注意的是：这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。</p>
<p>也就是说，用户不能先进入第 10 页，再跳到第 120 页，然后又跳到第 58 页，不能随意乱跳页。因此现在很多移动产品都是不允许用户随意翻页，也有一些网站做的就是你只能往下拉，一页一页的翻。</p>
<p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p>
<p>除了用 <code>scroll api</code>，也可以用 <code>search_after</code> 来做，<code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许用户随意翻页，用户只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>
<h1 id="6-生产部署"><a href="#6-生产部署" class="headerlink" title="6. 生产部署"></a>6. 生产部署</h1><p>ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</p>
<p>这样的问题不是技术能力问题，就是单纯考察面试者是否在真正的生产环境里使用过es，属于面试必问问题。</p>
<p>这里有个基本版本部署配置：</p>
<ul>
<li>es 生产集群，部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li>
<li>es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，也就是15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li>
<li>目前线上有 5 个索引（这个结合业务来看，看有哪些数据可以放 es 里），每个索引的数据量大概是 20G，所以这个数据量之内，每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li>
</ul>
<h1 id="7-更深的问题"><a href="#7-更深的问题" class="headerlink" title="7. 更深的问题"></a>7. 更深的问题</h1><p>分布式搜索技术如果挖深了可以问得极其深，比较严格的面试官可能会挖到es底层：相关度评分算法（TF/IDF算法）、deep paging、上千万数据批处理、跨机房多集群同步、搜索效果优化等很多的实际生产问题。</p>
<p>分布式消息队列也是如此：Kafka的主从复制的底层原理、leader选举的算法、增加partition以后的rebalance算法，如何优化 Kafka 写入的吞吐量。</p>
<p><strong>TF/IDF算法</strong></p>
<p>比如要搜索”dota ti5”，我希望第一个搜索的结果文档叫做”dota2”而不是”英雄联盟（LOL）”，那么lucene是如何做的呢？Lucene 默认的搜索算法叫做TF/IDF 算法。</p>
<p>TF-IDF算法全称为term frequency–inverse document frequency。TF就是term frequency的缩写，意为词频。IDF则是inverse document frequency的缩写，意为逆文档频率。该算法在信息处理中通常用来抽取关键词。</p>
<p>比如，对一个文章提取关键词作为搜索词，就可以采用TF-IDF算法。</p>
<p>要找出一篇文章中的关键词，通常的思路就是，就是找到出现次数最多的词。如果某个词很重要，它应该在这篇文章中多次出现。于是，我们进行”词频”（Term Frequency，缩写为TF）统计。</p>
<p>但是通常，一篇中文的文章中，都会有很多没有实际意义的词，比如”的”、”是”、”了”等助词类词，称为<strong>停用词</strong>，称它们为停用词是因为在文本处理过程中如果遇到它们，则立即停止处理，将其扔掉。将这些词扔掉减少了索引量，增加了检索效率，并且通常都会提高检索的效果。停用词主要包括英文字符、数字、数学字符、标点符号及使用频率特高的单汉字等。</p>
<p>当过滤掉所有的停用词后，剩下的都是实际意义的词，但也不能简单的认为那个词出现的次数多就是关键词。比如在一篇如何组装电脑的文章中，出现”CPU”、”主板”等关键词和出现”说明书”的次数一样多，但很显然，”CPU”、”主板”等关键词，更能确定这个文章的特性。也就是说，”CPU”、”主板”等关键词比”说明书”这个关键词更重要，需要排在前面。</p>
<p>所以我们就需要一个权重系数，用来调整各个关键词的重要性。如果一个词很少见，但是它在某个文章中反复出现多次，那么可以认为这个词反应了这个文章的特性，可以把它作为关键词。在信息检索中，这个权重非常重要，它决定了关键词的重要度，这个权重叫做”逆文档频率”（Inverse Document Frequency，缩写为IDF），它的大小与一个词的常见程度成反比。</p>
<p>在知道了词频和权重之后，两者相乘，就得到一个词的TF-IDF值，某个词对文章的重要性越高，它的TF-IDF值就越大。所以，排在最前面的几个词，就是这篇文章的关键词。</p>
<p>因此TF-IDF算法的主要工作就是计算出<code>TF*IDF</code>值最大的那几个词，作为文章的关键词。</p>
<p>TF-IDF算法的优点是简单快速，结果比较符合实际情况。缺点是，单纯以”词频”衡量一个词的重要性，不够全面，有时重要的词可能出现次数并不多。而且，这种算法无法体现词的位置信息，出现位置靠前的词与出现位置靠后的词，都被视为重要性相同，这是不正确的。（一种解决方法是，对全文的第一段和每一段的第一句话，给予较大的权重。）</p>
<p>当通过TF-IDF算法找出文章的关键字后，可以运用到一些具体的场景。比如：根据关键字找出相似的文章。  </p>
<blockquote>
<p>如果你认为lucene本身的算法不够好，那么你可以考虑去实现其他的算法。比如BM25和BM25F算法。在lucene当中，如果你想更改原本的算法，那么你需要extends原来的Similarity类，然后将它配置到你的索引writer的配置中。如果你需要更好的索引。那么你可能需要为lucene重写很多代码，包括权重包(Weight),Query包(查询),Score包(打分)。</p>
</blockquote>
<h1 id="8-扩展博文"><a href="#8-扩展博文" class="headerlink" title="8. 扩展博文"></a>8. 扩展博文</h1><p><a href="https://blog.csdn.net/wuyinggui10000/article/category/3173543"> 一步一步跟我学习lucene</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35469104">Lucene解析 - 基本概念</a></p>
<p><a href="https://zhuanlan.zhihu.com/Elasticsearch">Elasticsearch技术研讨</a></p>
<p><a href="https://juejin.im/post/5abde676f265da23a049abb6">Lucene系列（一）快速入门</a></p>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/index.html">Elasticsearch权威指南</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html">全文搜索引擎 Elasticsearch 入门教程</a></p>
<p><a href="https://www.zuojl.com/elasticsearch-getting-started/">Elasticsearch 入门教程-bitiger知乎专栏</a></p>
<p><a href="http://ghoulich.xninja.org/category/datastore/elasticsearch/">ElasticSearch入门教程-水晶命匣</a></p>
<p><a href="https://blog.csdn.net/wojiushiwo987/column/info/deep-elasticsearch">深入详解Elasticsearch</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/48429223">Elasticsearch深入理解</a></p>
<p><a href="https://zq99299.github.io/note-book/elasticsearch-core/">elasticsearch 核心知识篇</a></p>
<p>视频教程：</p>
<p>【博学谷】搜索集大成者（lucene&amp;solr&amp;es）</p>
<p><a href="https://www.bilibili.com/video/av45594844?from=search&amp;seid=10490762564639410509">https://www.bilibili.com/video/av45594844?from=search&amp;seid=10490762564639410509</a></p>
<p>千锋Java：ElasticSearch6入门教程</p>
<p><a href="https://www.bilibili.com/video/av45558199?from=search&amp;seid=10490762564639410509">https://www.bilibili.com/video/av45558199?from=search&amp;seid=10490762564639410509</a></p>
<p>龙果学院-es核心知识篇</p>
<p><a href="https://www.bilibili.com/video/av28091206?from=search&amp;seid=7590158700323939959">https://www.bilibili.com/video/av28091206?from=search&amp;seid=7590158700323939959</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之链表</title>
    <url>/2019/05/30/036/</url>
    <content><![CDATA[<h2 id="一、基础知识准备"><a href="#一、基础知识准备" class="headerlink" title="一、基础知识准备"></a>一、基础知识准备</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>万事万物在计算机中最终会归为二进制组合数字表示。</p>
<p>然而，对于现实世界的事物与事物关系，不能单纯使用某个数字和另一个数字来表示，就好比，使用年龄这一个维度来表示人类这个事物未免有些不妥。因为人类这个事物会包含很多的属性，比如姓名、年龄、身高、体重等属性，只有这些属性组合在一起才可以构成人类的基本特征。</p>
<p>然而，不同属性的设计会表现出这个事物在现实世界的表现意义，如学号、身份证、所属年级等属性的组合，很具象表示学生这个事物。</p>
<p>再回到第一句话，计算机只能使用数学上纯数字来标识事物，在硬件内存中表示上述复杂的事物结构呢？这就需要引入结构体的概念：</p>
<p>内存是一块连续的可存储空间， 一般最小的存储单位是一个字节（8bit），这里将一个字节的存储单位叫一个格子，那么内存可以表示为连续的格子组成，每一个格子可以表示的最大数值范围是 256（ 2 的 8 次方），比如一个学生的学号是20190909001，那这么大的数字在一个内存格子里放不下，该怎么办呢？</p>
<p>答案很简单，多使用几个格子来表示不就行了对吗，因此，有一块连续的存储空间，可以任意使用，想怎么存就怎么存，那么规定每四个格子表示一个事物，那么这个四个格子可以表示的数字范围是 4G（4个2的8次方相乘），这个 4G 数字单位很眼熟（不就是32位计算机最大的内存限制嘛），这四个格子可以表示的范围（42亿多）完全可以够上述的学号属性使用了，毕竟没有哪所学校会设计学生学号长度超过亿位数。</p>
<h3 id="1-2-数据类型"><a href="#1-2-数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型</h3><p>在 C 语言中，将这四个内存格子为一个单位的数字数据，其类型成为<code>int</code>，一个内存格子的数字数据类型为<code>char</code>，C 语言中还定义了一些现实世界常用的数字数据类型，这些类型是用来约束整数数据的：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">存储大小</th>
<th align="left">值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td align="left">unsigned char</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">signed char</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">2 或 4 字节</td>
<td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned int</td>
<td align="left">2 或 4 字节</td>
<td align="left">0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">2 字节</td>
<td align="left">-32,768 到 32,767</td>
</tr>
<tr>
<td align="left">unsigned short</td>
<td align="left">2 字节</td>
<td align="left">0 到 65,535</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">4 字节</td>
<td align="left">-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td align="left">unsigned long</td>
<td align="left">4 字节</td>
<td align="left">0 到 4,294,967,295</td>
</tr>
</tbody></table>
<p>注意：上表中的数据类型是针对整型数据不用的存储大小（内存格子）会对应不同的数据类型，C 语言中还定义了其他数据的数据类型：枚举类型、void 类型、派生类型。</p>
<h3 id="1-3-结构体"><a href="#1-3-结构体" class="headerlink" title="1.3 结构体"></a>1.3 结构体</h3><p>在第 2 小节中已经阐述了：内存硬件通信的基本单位是字节（8bit），而不同数量字节的组合会形成不同的数据类型，那么单从整型数据类型上映射事物，还是有不足之处：<code>int</code>类型虽然可以存储年龄属性，如果再想存储其他数据属性，就不够用了，人类的中还包括性别、身高、体重等属性，那么就需要更多的数据类型来表示其属性值。</p>
<p>而这些属性之间的关系是密不可分的，都属于人类这个事物的一部分，少了任何一个属性就无法完整表示人类这个事物在现实世界中的真实表现。因此在 C 语言中引出了结构体的概念，程序员可以使用<code>struct</code>关键词来自定义数据类型，它允许在结构体中存储不同类型的数据项。</p>
<p>通俗点讲，就是将 C 语言本身定义的一些数据类型（整数类型，字符串类型）进行组合，形成一段更有现实意义的内存格子，程序员再以这个结构体定义的内存单元格进行数据操作会更符合事物现实规律。</p>
<p>举例：</p>
<p>定义一个学生，有性别和年龄属性：性别可以使用 female 和 male 的单词首字母表示，所用 char 数据类型，年龄使用 int 数据类型，那么使用定义 Student 结构体之后，在程序中就会将 Student 类型的内存以 5 个字节（1 个字节+ 4 个字节）来表示这种数据类型：</p>
<p><img src="https://image.woodwhales.cn/036/images/1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA.png"></p>
<h3 id="1-4-typedef"><a href="#1-4-typedef" class="headerlink" title="1.4 typedef"></a>1.4 typedef</h3><p>C 语言提供了 <strong>typedef</strong> 关键字，程序员可以使用它来为数据类型取一个别名。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Sutdent</span> {</span></span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">} STUDENT;</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，定义了<code>struct Sutdent</code>数据类型的别名为：<code>STUDENT</code>，在定义语句之后的任意地方都可以使用这个别名来代表<code>struct Sutdent</code>这种数据类型。</p>
<h3 id="1-5-指针"><a href="#1-5-指针" class="headerlink" title="1.5 指针"></a>1.5 指针</h3><p>指针是 C 语言的灵魂，指针就是地址。</p>
<p>第 1 小节描述了内存是一块连续的内存空间，是由一个个 bit 组成，8 个 bit 组成一个字节，它是计算机操作数据的基本单位，因此对于程序来说，一块内存有很多内存单元（8 bit 为一个字节的单元格）。</p>
<p>此时不禁疑惑：计算机如何聪明地知道第一个单元格和其后面的三个单元格联接在一起，是表示<code>int</code>数据类型？它又是怎么知道第一个单元格和后面所有单元都没有联系，它就是孤立的<code>char</code>类型？还有它有时候是怎么知道第一个单元格和后面四个连续在一起是表示<code>Student</code>数据类型呢？</p>
<p>好比，有些租户租了一套房子，这是一家人，还有写租户租了四套连续的房子，这四套连在一起是属于一家。我们可以人为定义 1 个字节用于表示<code>char</code>数据类型，4 个字节表示<code>int</code>数据类型，是如何在连续的单元格中，准确无误地知道哪些单元格连在一起就是某种数据类型，哪些单元格和另一些不与之连续的单元格是一个整体，用来表示某种特殊数据呢？</p>
<p>由于内存的连续存储空间特性，可以将内存单元格进行人为编号， 这个编号的术语就是内存地址，CPU 能够操作内存中的数据就是通过地址总线进行对内存的精准操作，因此计算机只需要记住地址，就能知道其地址上对应的数据是什么。</p>
<p>因此，当定义一个<code>int</code>类型的数据，就是告知CPU，在读取内存的时候，记得在某某编号的位置开始读取内存，读取 4 个字节单元，读出来的数据就是有意义的数据。由此可以得知，数据类型的定义就是用来约束CPU从某个地址逐个字节读取数据，读到第几个字节表示一个有实际意义的函数。</p>
<p>下图表示的是，使用文件编辑器使用<code>UTF-8</code>字符集编码的文本文件，查看该十六进制信息，可以看到字母 a 和 b 占了 1 个字节，回车占了 2 个字节，在 UTF-8 字符集规范中，一个汉字占用 3 个字节，因此”木鲸鱼”这一串字符串占了 9 个字节。</p>
<p><img src="https://image.woodwhales.cn/036/images/3-%E6%8C%87%E9%92%88.png"></p>
<p>那么，在 C 语言中是如何告诉 CPU 地址和当前地址要读取几个字节数据表示一个有意义的数据呢？</p>
<p>答案就是指针变量类型，当定义一个 int 数据类型的数据，使用一个字母 a 来表示它，以便在程序的其他地方可以复用，那么就定义成以下语句：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>；</span><br></pre></td></tr></tbody></table></figure>

<p>当程序执行这句话的时候，就是告知计算机在内存中分配一块 4 个字节的内存单元用来保存 10 这个数值，那么当计算机分配成功，一定是通过地址总线进行内存分配的，因此只要内存分配成功就表示有个唯一的地址空间，从这个地址开始之后的 4 个字节内存空间是表示数字 10 的。</p>
<p>在 C 语言中，会使用某种特定的语法来获取分配成功的变量的地址，即在定义的变量名前面加个<code>&amp;</code>符号，就能得到内存分配成功之后的地址：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">&amp;a <span class="comment">// 使用 &amp;变量名 的语法方式获取地址</span></span><br></pre></td></tr></tbody></table></figure>

<p>因此，为何 C 语言为何引入地址（指针）的概念的目的就出来了，是用来记录数据存在内存的哪个位置，并在后续的时候让 CPU 知道去内存的哪里找数据。</p>
<p>此时有个新的问题，光知道地址，是无法知道数据是什么，因为从已知地址之后的任意字节空间都可以组合成数据，因此指针的概念引入还不够，还需要知道当前地址（指针）之后需要读取多少字节表示一个完整有意义的数据，而这个问题就是<code>指针类型</code>概念引入的目的，指针类型就是在告知计算机，当前地址之后的多少个字节是连续操作读取的，在 C 语言中，使用语法：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">数据类型 *</span><br></pre></td></tr></tbody></table></figure>

<p>因此，定义了上述的<code>&amp;a</code>取出地址之后，需要使用<code>int *</code>的指针类型来修饰。</p>
<p>此时又引出一个问题，当定义了一个地址，怎么知道地址对应的数据是多少，这个在 C 语言中得到很好的处理，只需要在指针变量前面加<code>*</code>符号即可读取到当前地址对应的数据内容了：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> * pAge;</span><br><span class="line">    <span class="type">int</span> age= <span class="number">10</span>;</span><br><span class="line">    pAge = &amp;age;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *pAge); <span class="comment">// *pAge 等价于变量 age</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也是说，<code>*指针变量</code>的方式是将会读取指针变量所在的地址，并从它的指针类型推导出应该从这个地址的内存单元开始读取几个内存单元。</p>
<p><strong>注意：</strong>指针有别于指针变量，指针是地址，而指针变量是地址（指针）对应的变量的变量。开发者常说的指针是指指针变量，这是种约定俗成的口头表述概念，不是学术上的地址概念。</p>
<h3 id="1-6-动态内存分配"><a href="#1-6-动态内存分配" class="headerlink" title="1.6 动态内存分配"></a>1.6 动态内存分配</h3><p>C 语言中提供了标准的内存管理函数库，库中的函数可以在<code>&lt;stdlib.h&gt;</code>头文件中找到，用来帮助程序员在堆中创建内存：</p>
<p><img src="/images/2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0.png"></p>
<p><strong>注意：</strong><code>void *</code>类型表示未确定类型的指针。C、C++ 规定<code>void *</code>类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<p><strong>说明：</strong>堆中的内存是完全由程序员自己来管理何时回收，因此程序员需要时刻小心自己在堆中申请的内存释放的时机，不需要再使用的内存没有及时回收，会产生内存泄漏风险，这是一件很恐怖的事情。</p>
<p>想要申请一块内存，用来存储 int 数据类型的数据，使用如下命令：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> * pTemp；</span><br><span class="line">pTemp = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>想要申请一块内存，用来存储<code>Student</code>数据类型的数据时，使用如下命令：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> * <span class="title">PStudent</span>；</span></span><br><span class="line"><span class="class"><span class="title">PStudent</span> =</span> (<span class="keyword">struct</span> Student *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student));</span><br></pre></td></tr></tbody></table></figure>

<p>注意到在申请内存的时候，在<code>malloc()</code>函数中，填写的数值是使用<code>sizeof()</code>函数动态计算要存储数据的数据类型大小，这样使得 C 程序的可移植性更好，因为在不同的系统中，相同的数据类型，可能其所占的内存空间是不一样的。</p>
<h2 id="二、链表之-C-语言描述"><a href="#二、链表之-C-语言描述" class="headerlink" title="二、链表之 C 语言描述"></a>二、链表之 C 语言描述</h2><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p>
<h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><p>链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。</p>
<p><img src="https://image.woodwhales.cn/036/images/4-%E9%93%BE%E8%A1%A8.png"></p>
<p><em>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接</em></p>
<p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。</p>
<h5 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h5><p>链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。</p>
<h4 id="1-2-设计思路"><a href="#1-2-设计思路" class="headerlink" title="1.2 设计思路"></a>1.2 设计思路</h4><p>链表是由节点进行链接的，那么链表中最小的单元就是节点，因此以链表的节点为一个结构体，其结构体中存放着数据和下一个节点的地址：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>设计好链表的数据节点之后，就需要考虑，节点和节点之间虽然都是使用上一个节点的属性关联着自己的地址，自己关联着下一个节点的地址，那么链表中，谁才是头，谁才是尾：</p>
<ul>
<li>头节点，其数据类型和其他子节点一样</li>
<li>头节点不含有数据data，下一个节点的地址可以指向NULL，也可以指向有效的节点（含有数据的节点）的地址</li>
<li>尾节点，其数据类型和其他子节点一样</li>
<li>尾节点其数据节点中含有数据，但其下一个节点的地址永远是指向NULL</li>
</ul>
<h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">pNext</span>;</span></span><br><span class="line">} NODE, *PNODE;</span><br><span class="line"></span><br><span class="line">PNODE <span class="title function_">createList</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sortList</span><span class="params">(PNODE)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertList</span><span class="params">(PNODE, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteList</span><span class="params">(PNODE, <span class="type">int</span>, <span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(PNODE *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    PNODE pHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    pHead = createList();</span><br><span class="line">    traverseList(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试链表长度</span></span><br><span class="line">    <span class="type">int</span> len = lengthList(pHead);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表的长度为：%d\n"</span>, len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 测试链表是否为空</span></span><br><span class="line"><span class="comment">    if(isEmpty(pHead)) {</span></span><br><span class="line"><span class="comment">        printf("链表为空\n");</span></span><br><span class="line"><span class="comment">    } else {</span></span><br><span class="line"><span class="comment">        printf("链表不为空\n");</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试排序</span></span><br><span class="line">    <span class="comment">// sortList(pHead);</span></span><br><span class="line">    <span class="comment">// traverseList(pHead);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试插入</span></span><br><span class="line">    <span class="comment">// insertList(pHead, 3, -1);</span></span><br><span class="line">    <span class="comment">// traverseList(pHead);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> post = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>(deleteList(pHead, post, &amp;val)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除成功，删除第%d个元素为：%d\n"</span>, post, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除失败"</span>);</span><br><span class="line">    }</span><br><span class="line">    traverseList(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    创建链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PNODE <span class="title function_">createList</span><span class="params">()</span>{</span><br><span class="line">    PNODE pHead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    PNODE pTail = pHead;</span><br><span class="line">    pTail-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要生成的链表的结点个数："</span>);</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; len; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第 %d 个结点的值: "</span>, i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line"></span><br><span class="line">        PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pNew) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pNew-&gt;data = val;</span><br><span class="line">        pTail-&gt;pNext = pNew;</span><br><span class="line">        pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">        pTail = pNew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    遍历链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    判断链表是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pHead-&gt;pNext) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    计算链表的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line">    PNODE p = pHead-&gt;pNext;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p) {</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    对链表元素进行排序，使用冒泡排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sortList</span><span class="params">(PNODE pHead)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = lengthList(pHead);</span><br><span class="line">    PNODE p,q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, p=pHead-&gt;pNext; i &lt; len<span class="number">-1</span>; ++i, p=p-&gt;pNext) {</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>, q=p-&gt;pNext;j &lt; len; ++j, q=q-&gt;pNext) {</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; q-&gt;data) {</span><br><span class="line">                t = p-&gt;data;</span><br><span class="line">                p-&gt;data = q-&gt;data;</span><br><span class="line">                q-&gt;data = t;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    链表中插入元素，在第post 个元素位置插入 val 值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">insertList</span><span class="params">(PNODE pHead, <span class="type">int</span> post, <span class="type">int</span> val)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="comment">// 遍历找第 post-1 的结点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p &amp;&amp; i&lt;post<span class="number">-1</span>) {</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面循环正确的话，此时的 i 一定是：post-1</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;post<span class="number">-1</span> || <span class="literal">NULL</span> == p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pNew-&gt;data = val;</span><br><span class="line">    pNew-&gt;pNext = p-&gt;pNext;</span><br><span class="line">    p-&gt;pNext = pNew;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">deleteList</span><span class="params">(PNODE pHead, <span class="type">int</span> post, <span class="type">int</span> * pVal)</span> {</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    PNODE p = pHead;</span><br><span class="line">    <span class="comment">// 遍历找第 post-1 的结点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">NULL</span> != p &amp;&amp; i &lt; post<span class="number">-1</span>) {</span><br><span class="line">        p = p-&gt;pNext;</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面循环正确的话，此时的 i 一定是：post-1</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;post<span class="number">-1</span> || <span class="literal">NULL</span> == p) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE pNew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == pNew) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"分配内存失败，程序终止！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    PNODE postP = p-&gt;pNext; <span class="comment">// p-&gt;pNext 是第post个元素，需要删除</span></span><br><span class="line">    *pVal = postP-&gt;data;</span><br><span class="line"></span><br><span class="line">    p-&gt;pNext = postP-&gt;pNext;</span><br><span class="line"></span><br><span class="line">    postP = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(postP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式缓存</title>
    <url>/2019/06/28/035/</url>
    <content><![CDATA[<h1 id="1-为什么使用缓存？"><a href="#1-为什么使用缓存？" class="headerlink" title="1. 为什么使用缓存？"></a>1. 为什么使用缓存？</h1><p>项目中缓存是如何使用的？为什么要用缓存？缓存使用不当会造成什么后果？</p>
<p>缓存对于互联网企业产品来说，是必须使用的技术，因此这种问题是面试必问的问题。</p>
<h2 id="1-1-使用缓存"><a href="#1-1-使用缓存" class="headerlink" title="1.1 使用缓存"></a>1.1 使用缓存</h2><p>这个问题需要结合自己项目的业务来。</p>
<h2 id="1-2-用缓存的目的"><a href="#1-2-用缓存的目的" class="headerlink" title="1.2 用缓存的目的"></a>1.2 用缓存的目的</h2><p>用缓存，主要有两个用途：<strong>高性能</strong>、<strong>高并发</strong>。</p>
<h3 id="1-2-1-高性能"><a href="#1-2-1-高性能" class="headerlink" title="1.2.1 高性能"></a>1.2.1 高性能</h3><p>假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作 mysql，半天查出来一个结果，耗时 600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？</p>
<p>缓存啊，折腾 600ms 查出来的结果，扔缓存里，一个 key 对应一个 value，下次再有人查，别走 mysql 折腾 600ms 了，直接从缓存里，通过一个 key 查出来一个 value，2ms 搞定。性能提升 300 倍。</p>
<p>就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。</p>
<h3 id="1-2-2-高并发"><a href="#1-2-2-高并发" class="headerlink" title="1.2.2 高并发"></a>1.2.2 高并发</h3><p>mysql 这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql 单机支撑到 <code>2000QPS</code> 也开始容易报警了。</p>
<p>所以要是你有个系统，高峰期一秒钟过来的请求有 1万，那一个 mysql 单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放 mysql。缓存功能简单，说白了就是 <code>key-value</code> 式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发 so easy。单机承载并发量是 mysql 单机的几十倍。</p>
<blockquote>
<p>缓存是走内存的，内存天然就支撑高并发。</p>
</blockquote>
<h2 id="1-3-使用缓存的潜在问题"><a href="#1-3-使用缓存的潜在问题" class="headerlink" title="1.3 使用缓存的潜在问题"></a>1.3 使用缓存的潜在问题</h2><p>常见的缓存问题有以下几个：</p>
<ul>
<li>缓存与数据库双写不一致</li>
<li>缓存雪崩、缓存穿透</li>
<li>缓存并发竞争</li>
</ul>
<h1 id="2-Redis-数据类型及其应用场景"><a href="#2-Redis-数据类型及其应用场景" class="headerlink" title="2. Redis 数据类型及其应用场景"></a>2. Redis 数据类型及其应用场景</h1><p>Redis 都有哪些数据类型？分别在哪些场景下使用比较合适？</p>
<p>Redis 主要有以下几种数据类型：</p>
<ul>
<li>string</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>sorted set</li>
</ul>
<h2 id="2-1-string"><a href="#2-1-string" class="headerlink" title="2.1 string"></a>2.1 string</h2><p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set college woodwhales</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-hash"><a href="#2-2-hash" class="headerlink" title="2.2 hash"></a>2.2 hash</h2><p>这个是类似 map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 redis 里，然后每次读写缓存的时候，可以就操作 hash 里的<strong>某个字段</strong>。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hset person name king</span><br><span class="line">hset person age 20</span><br><span class="line">hset person id 1</span><br><span class="line">hget person name</span><br><span class="line"></span><br><span class="line">person = {</span><br><span class="line">    "name": "king",</span><br><span class="line">    "age": 20,</span><br><span class="line">    "id": 1</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-list"><a href="#2-3-list" class="headerlink" title="2.3 list"></a>2.3 list</h2><p>list 是有序列表，这个可以玩儿出很多花样。</p>
<p>比如可以通过 list 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>
<p>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 list 实现分页查询，这个是很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 0开始位置，-1结束位置，结束位置为-1时，表示列表的最后一个位置，即查看所有。</span><br><span class="line">lrange mylist 0 -1</span><br></pre></td></tr></tbody></table></figure>

<p>比如可以搞个简单的消息队列，从 list 头怼进去，从 list 尾巴那里弄出来。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lpush mylist 1</span><br><span class="line">lpush mylist 2</span><br><span class="line">lpush mylist 3 4 5</span><br><span class="line"></span><br><span class="line"># 1</span><br><span class="line">rpop mylist</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a>2.4 set</h2><p>set 是无序集合，自动去重。</p>
<p>直接基于 set 将系统里需要去重的数据扔进去，自动就给去重了，如果需要对一些数据进行快速的全局去重，当然也可以基于 jvm 内存里的 HashSet 进行去重，但是如果某个系统部署在多台机器上呢？得基于 redis 进行全局的 set 去重。</p>
<p>可以基于 set做交集、并集、差集操作。比如交集：可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁。</p>
<p>把两个大 V 的粉丝都放在两个 set 中，对两个 set 做交集。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#-------操作一个set-------</span><br><span class="line"># 添加元素</span><br><span class="line">sadd mySet 1</span><br><span class="line"></span><br><span class="line"># 查看全部元素</span><br><span class="line">smembers mySet</span><br><span class="line"></span><br><span class="line"># 判断是否包含某个值</span><br><span class="line">sismember mySet 3</span><br><span class="line"></span><br><span class="line"># 删除某个/些元素</span><br><span class="line">srem mySet 1</span><br><span class="line">srem mySet 2 4</span><br><span class="line"></span><br><span class="line"># 查看元素个数</span><br><span class="line">scard mySet</span><br><span class="line"></span><br><span class="line"># 随机删除一个元素</span><br><span class="line">spop mySet</span><br><span class="line"></span><br><span class="line">#-------操作多个set-------</span><br><span class="line"># 将一个set的元素移动到另外一个set</span><br><span class="line">smove yourSet mySet 2</span><br><span class="line"></span><br><span class="line"># 求两set的交集</span><br><span class="line">sinter yourSet mySet</span><br><span class="line"></span><br><span class="line"># 求两set的并集</span><br><span class="line">sunion yourSet mySet</span><br><span class="line"></span><br><span class="line"># 求在yourSet中而不在mySet中的元素</span><br><span class="line">sdiff yourSet mySet</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-5-sorted-set"><a href="#2-5-sorted-set" class="headerlink" title="2.5 sorted set"></a>2.5 sorted set</h2><p>sorted set 是排序的 set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">zadd board 85 zhangsan</span><br><span class="line">zadd board 72 lisi</span><br><span class="line">zadd board 96 wangwu</span><br><span class="line">zadd board 63 zhaoliu</span><br><span class="line"></span><br><span class="line"># 获取排名前三的用户（默认是升序，所以需要 rev 改为降序）</span><br><span class="line">zrevrange board 0 3</span><br><span class="line"></span><br><span class="line"># 获取某用户的排名</span><br><span class="line">zrank board zhaoliu</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-Redis-和-memcached-的区别"><a href="#3-Redis-和-memcached-的区别" class="headerlink" title="3. Redis 和 memcached 的区别"></a>3. Redis 和 memcached 的区别</h1><p>redis 最基本的一个内部原理和特点，就是 redis 实际上是个<strong>单线程工作模型</strong>。</p>
<blockquote>
<p>memcached 是早些年各大互联网公司常用的缓存方案，但是现在近几年基本都是 redis，没什么公司用 memcached 了。</p>
</blockquote>
<h2 id="3-1-Redis-支持复杂的数据结构"><a href="#3-1-Redis-支持复杂的数据结构" class="headerlink" title="3.1 Redis 支持复杂的数据结构"></a>3.1 Redis 支持复杂的数据结构</h2><p>Redis 相比 memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， redis 会是不错的选择。</p>
<h2 id="3-2-Redis-原生支持集群模式"><a href="#3-2-Redis-原生支持集群模式" class="headerlink" title="3.2 Redis 原生支持集群模式"></a>3.2 Redis 原生支持集群模式</h2><p>在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</p>
<h1 id="为什么使用缓存？"><a href="#为什么使用缓存？" class="headerlink" title="为什么使用缓存？"></a>为什么使用缓存？</h1><h2 id="asdasdas"><a href="#asdasdas" class="headerlink" title="asdasdas"></a>asdasdas</h2><h1 id="4-Redis-单线程模型"><a href="#4-Redis-单线程模型" class="headerlink" title="4. Redis 单线程模型"></a>4. Redis 单线程模型</h1><h2 id="4-1-文件事件处理器"><a href="#4-1-文件事件处理器" class="headerlink" title="4.1 文件事件处理器"></a>4.1 文件事件处理器</h2><p>Redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器，file event handler。这个文件事件处理器，是单线程的，Redis才叫做单线程的模型，采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p>
<p>如果被监听的socket准备好执行accept、read、write、close等操作的时候，跟操作对应的文件事件就会产生，这个时候文件事件处理器就会调用之前关联好的事件处理器来处理这个事件。</p>
<p>文件事件处理器是单线程模式运行的，但是通过IO多路复用机制监听多个socket，可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了redis内部的线程模型的简单性。</p>
<p>文件事件处理器的结构包含4个部分：</p>
<ul>
<li>多个socket</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（命令请求处理器、命令回复处理器、连接应答处理器等）。</li>
</ul>
<p>多个socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，但是会将socket放入一个队列中排队，每次从队列中取出一个socket给事件分派器，事件分派器把socket给对应的事件处理器。</p>
<p>然后一个socket的事件处理完之后，IO多路复用程序才会将队列中的下一个socket给事件分派器。文件事件分派器会根据每个socket当前产生的事件，来选择对应的事件处理器来处理。</p>
<blockquote>
<p>通信是通过 socket 来完成的，不懂的可以先去看一看 socket 网络编程。</p>
</blockquote>
<h2 id="4-2-文件事件"><a href="#4-2-文件事件" class="headerlink" title="4.2 文件事件"></a>4.2 文件事件</h2><p>当socket变得可读时（比如客户端对redis执行write操作，或者close操作），或者有新的可以应答的sccket出现时（客户端对redis执行connect操作），socket就会产生一个<code>AE_READABLE</code>事件。</p>
<p>当socket变得可写的时候（客户端对redis执行read操作），socket会产生一个<code>AE_WRITABLE</code>事件。</p>
<p>IO多路复用程序可以同时监听<code>AE_REABLE</code>和<code>AE_WRITABLE</code>两种事件，要是一个socket同时产生了AE_READABLE和AE_WRITABLE两种事件，那么文件事件分派器优先处理AE_REABLE事件，然后才是AE_WRITABLE事件。</p>
<h2 id="4-3-文件事件处理器"><a href="#4-3-文件事件处理器" class="headerlink" title="4.3 文件事件处理器"></a>4.3 文件事件处理器</h2><p>如果是客户端要连接redis，那么会为socket关联连接应答处理器</p>
<p>如果是客户端要写数据到redis，那么会为socket关联命令请求处理器</p>
<p>如果是客户端要从redis读数据，那么会为socket关联命令回复处理器</p>
<h2 id="4-4-客户端与redis通信的一次流程"><a href="#4-4-客户端与redis通信的一次流程" class="headerlink" title="4.4 客户端与redis通信的一次流程"></a>4.4 客户端与redis通信的一次流程</h2><p><img src="https://image.woodwhales.cn/035/images/01.png"></p>
<p>首先，redis 服务端进程初始化的时候，会将 server socket 的 <code>AE_READABLE</code> 事件与连接应答处理器关联。</p>
<p>客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的s1事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</p>
<p>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 <code>AE_READABLE</code> 事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</p>
<p>这样便完成了一次通信。</p>
<h1 id="5-为什么-redis-单线程却能支撑高并发？"><a href="#5-为什么-redis-单线程却能支撑高并发？" class="headerlink" title="5. 为什么 redis 单线程却能支撑高并发？"></a>5. 为什么 redis 单线程却能支撑高并发？</h1><ul>
<li>纯内存操作。</li>
<li>核心是基于非阻塞的 IO 多路复用机制。</li>
<li>C 语言实现，一般来说，C 语言实现的程序”距离”操作系统更近，执行速度相对会更快。</li>
<li>单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>
</ul>
<h1 id="6-过期策略"><a href="#6-过期策略" class="headerlink" title="6.  过期策略"></a>6.  过期策略</h1><h2 id="6-1-过期策略"><a href="#6-1-过期策略" class="headerlink" title="6.1 过期策略"></a>6.1 过期策略</h2><p>Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</p>
<h3 id="6-1-1-定期删除"><a href="#6-1-1-定期删除" class="headerlink" title="6.1.1 定期删除"></a>6.1.1 定期删除</h3><p>所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>
<p>假设 redis 里放了 10w 个 key，都设置了过期时间，redis每隔几百毫秒就会检查这 10w 个 key是否过期，那么这种情况下 redis 基本上就死了，因为 cpu 资源全部消耗在检查过期 key 上了，负载巨高。</p>
<p>注意：redis可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的<strong>灾难</strong>。实际上 redis 是每隔 100ms <strong>随机抽取</strong>一些 key 来检查并删除。</p>
<h3 id="6-1-2-惰性删除"><a href="#6-1-2-惰性删除" class="headerlink" title="6.1.2 惰性删除"></a>6.1.2 惰性删除</h3><p>这种策略有个问题：定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那怎么办呢？</p>
<p>惰性删除由此产生。这种策略是，当客户读在获取某个 key 的时候，redis 会检查一下这个 key 是否设置过期时间，如果设置了过期时间那么是检查否过期了，如果过期了此时就会删除，不会给客户端返回任何东西。</p>
<p>因此，通俗来说，惰性删除就是，当要获取 key 的时候，才对这个过期的key进行删除操作。</p>
<h2 id="6-2-内存淘汰"><a href="#6-2-内存淘汰" class="headerlink" title="6.2 内存淘汰"></a>6.2 内存淘汰</h2><p>如果内存中有大量的过期的key，但是没有被定期检查删除，也没有被惰性删除，此时大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，这是很可怕的事情。由此内存淘汰机制诞生了。</p>
<p>Redis 内存淘汰机制有以下几个：</p>
<ul>
<li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，实际生产中几乎不会使用的机制。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key，<strong>最常使用的机制</strong>。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，实际生产中很少使用。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</li>
</ul>
<h2 id="6-3-手写LRU"><a href="#6-3-手写LRU" class="headerlink" title="6.3 手写LRU"></a>6.3 手写LRU</h2><p>在实际生产中，还会出现这种情况：redis 中的数据会无缘无故的丢数据。因为 redis 毕竟是缓存，不是存储，数据丢失的原因，要么是数据过期被删除，要么是 redis 在某种条件或内存满了的情况下触发了 LRU 机制，将最近很少使用的数据给清理了。</p>
<p>现场手写最原始的 LRU 算法，那个代码量太大了，似乎不太现实。但是可以利用已有的 JDK 数据结构实现一个 Java 版的 LRU。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传递进来最多能缓存多少数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheSize 缓存大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cacheSize)</span> {</span><br><span class="line">        <span class="comment">// true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在头部，最早访问的放在尾部。</span></span><br><span class="line">        <span class="built_in">super</span>((<span class="type">int</span>) Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> {</span><br><span class="line">        <span class="comment">// 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老访问的数据。</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="7-Redis-的高并发和高可用"><a href="#7-Redis-的高并发和高可用" class="headerlink" title="7. Redis 的高并发和高可用"></a>7. Redis 的高并发和高可用</h1><p>Redis单机能承载多高并发？如果单机扛不住如何扩容抗更多的并发？Redis会不会挂？既然 Redis 会挂那怎么保证redis 是高可用的？</p>
<p>这种问题表示，只要用 redis 缓存技术，肯定需要考虑如何用 redis 来加多台机器，也就是如何保证 redis 是高并发。还有就是如何让 redis 保证自己不是挂掉以后就直接死掉了，也就是如何保证 redis 高可用。</p>
<h2 id="7-1-Redis-高并发"><a href="#7-1-Redis-高并发" class="headerlink" title="7.1 Redis 高并发"></a>7.1 Redis 高并发</h2><p>单机的 redis 几乎不太可能说QPS超过10万+，所以能支持高并发一定要上集群，使用主从机制保证高并发。</p>
<p>主从架构表示一主多从，主专门用来写入数据（单机几万QPS），并将数据同步复制到其他的从节点上。多从专门用来读数据（多个从实例可以提供每秒10万的QPS），因为所有的读数据都从从节点读取数据。这种架构一般满足很多项目业务场景了。</p>
<p>当并发很高的时候，主从架构可以轻松水平扩容，多增加从节点机器即可。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS的架构</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-1-1-主从复制核心机制"><a href="#7-1-1-主从复制核心机制" class="headerlink" title="7.1.1 主从复制核心机制"></a>7.1.1 主从复制核心机制</h3><p>Redis 之所以能支持高并发的主要原因，就是主从复制机制。</p>
<p>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量。<br>（2）一个master node是可以配置多个slave node的。</p>
<p>（3）slave node也可以连接其他的slave node。</p>
<p>（4）slave node做复制的时候，是不会block master node的正常工作的。</p>
<p>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了。</p>
<p>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。</p>
<h3 id="7-1-2-主从架构的核心原理"><a href="#7-1-2-主从架构的核心原理" class="headerlink" title="7.1.2 主从架构的核心原理"></a>7.1.2 主从架构的核心原理</h3><p>当启动一个 slave node 的时候，它会发送一个<code>PSYNC</code>命令给 master node：</p>
<ul>
<li>如果是slave node第一次连接master node，那么会触发一次<code>full resynchronization</code>。</li>
</ul>
<p>开始<code>full resynchronization</code>的时候，master会启动一个后台线程，开始生成一份RDB快照文件，与此同时master还会继续将从客户端收到的所有写命令缓存在内存中。</p>
<p>等RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先将这个RDB文件先写入本地磁盘，然后再从本地磁盘加载到内存中。</p>
<p>最后master会将内存中缓存的写命令发送给slave，slave就会同步这些数据。</p>
<ul>
<li>如果这个 slave node 重新连接master node，那么master node仅仅会复制给slave部分缺少的数据。</li>
</ul>
<p>slave node如果跟master node有网络故障，断开了连接，此时slave node自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用这一份数据服务所有slave node。</p>
<p><strong>主从复制的断点续传</strong></p>
<p>从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p>
<p>master node 会在内存中创建一个<code>backlog</code>，master 和 slave 都会保存一个<code>replica offset</code>还有一个<code>master id</code>，<code>offset</code>就是保存在<code>backlog</code>中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次的<code>replica offset</code>开始继续复制。但是如果没有找到对应的offset，那么就会执行一次<code>resynchronization</code>。</p>
<p><strong>无磁盘化复制</strong></p>
<p>master 可以在内存中直接创建RDB文件并发送给slave，而不需要先存到磁盘再发给从节点。</p>
<p>参数设置：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">repl-diskless-sync yes       <span class="comment"># 开启无磁盘化同步复制</span></span><br><span class="line">repl-diskless-sync-delay 5   <span class="comment"># 等待5s再开始无磁盘化同步复制，因为要等更多slave重新连接过来</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>过期key处理</strong></p>
<p>slave本身不会将过期key删除，而是等待master决定自己的key是否过期：</p>
<p>如果master过期了一个key或者通过LRU淘汰了一个key，那么会模拟一条<code>del</code>命令发送给slave。</p>
<h3 id="7-1-4-持久化主节点"><a href="#7-1-4-持久化主节点" class="headerlink" title="7.1.4 持久化主节点"></a>7.1.4 持久化主节点</h3><p><strong>如果采用了主从架构，那么必须开启master node的持久化。</strong>因为如果 master 节点的 RDB 和 AOF 都关闭了的时候宕机了，那么 master 节点中的数据在内存中都消失了，本地也没有数据备份， 此时 master 机器再重启之后，就没有可恢复的数据，于是这个主节点就认为自己没有数据，由于自己是主节点，那么就会将自己的空数据集同步到slave节点上，这时发生了很灾难的事情：所有从节点的数据都被清空了。</p>
<p>另外 redis 的备份方案也需要做好。</p>
<h3 id="7-1-5-主从复制的完整流程"><a href="#7-1-5-主从复制的完整流程" class="headerlink" title="7.1.5 主从复制的完整流程"></a>7.1.5 主从复制的完整流程</h3><p>（1）slave node启动，仅仅保存master node的信息，包括master node的<code>host</code>和<code>ip</code>，此时复制流程没开始。</p>
<blockquote>
<p>master的<code>host</code>和<code>ip</code>是从哪儿来？答：从 redis.conf 配置文件里面的<code>slaveof</code>配置读取到的。</p>
</blockquote>
<p>（2）slave node内部有个定时任务，每秒检查是否有新的master node要连接，如果发现有则跟这个master node建立socket网络连接。</p>
<p>（3）slave node发送<code>ping</code>命令给master node。</p>
<p>（4）口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证。</p>
<p>（5）master node第一次执行全量复制，将所有数据发给slave node。</p>
<p>（6）master node后续持续将写命令，异步复制给slave node。</p>
<h3 id="7-1-6-数据同步的核心机制"><a href="#7-1-6-数据同步的核心机制" class="headerlink" title="7.1.6 数据同步的核心机制"></a>7.1.6 数据同步的核心机制</h3><blockquote>
<p>这里的数据同步机制，是指第一次slave连接msater的时候，执行的全量复制，那个过程里面你的一些细节的机制。</p>
</blockquote>
<p>（1）master和slave都会各自维护一个<code>offset</code></p>
<p>master会在自身不断累加<code>offset</code>，slave也会在自身不断累加<code>offset</code>，slave每秒都会上报自己的<code>offset</code>给master，同时master也会保存每个slave的<code>offset</code>。</p>
<blockquote>
<p>说明：这个机制并不是特定用在全量复制的，主要是master和slave都要知道各自的数据的<code>offset</code>，才能知道互相之间的数据不一致的情况。</p>
</blockquote>
<p>（2）backlog</p>
<p>master node有一个<code>backlog</code>，默认是1MB大小。master node给slave node复制数据时，也会将数据在backlog中同步写一份，这个<code>backlog</code>主要是用来做全量复制中断后的增量复制的。</p>
<p>（3）master run id</p>
<p>通过客户端执行<code>info server</code>命令可以看到<code>master run id</code>。</p>
<p>如果根据<code>host+ip</code>定位master node，是不靠谱的，如果master node重启或者重启之后的master数据出现了变化，那么slave node数据和master的不同，由于<code>run id</code>随着机器重启会变化，所以slave检测到master 的<code>run id</code>变化了，就会做一次全量同步操作。</p>
<blockquote>
<p>如果需要重启redis并且不更改run id，重启可以使用<code>redis-cli debug reload</code>命令。</p>
</blockquote>
<p>（4）psync</p>
<p>从节点使用<code>psync</code>从master node进行复制：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">psync runid offset</span><br></pre></td></tr></tbody></table></figure>

<p>master node会根据自身的情况返回响应信息，可能是<code>FULLRESYNC runid offset</code>触发全量复制，可能是<code>CONTINUE</code>触发增量复制。</p>
<h3 id="7-1-7-全量复制"><a href="#7-1-7-全量复制" class="headerlink" title="7.1.7 全量复制"></a>7.1.7 全量复制</h3><p>（1）master执行bgsave，在本地生成一份RDB快照文件。</p>
<p>（2）master node将RDB快照文件发送给salve node，如果RDB复制时间超过60秒（repl-timeout），那么slave node就会认为复制失败，可以手动适当调节大这个参数。</p>
<blockquote>
<p><code>client-output-buffer-limit slave 256MB 64MB 60</code>，如果在复制期间，内存缓冲区持续消耗超过64MB，或者一次性超过256MB，那么停止复制，复制失败。</p>
<p>对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s。</p>
</blockquote>
<p>（3）master node在生成RDB时，会将所有新的写命令缓存在内存中，在salve node保存了RDB之后，再将新的写命令复制给salve node。</p>
<p>（4）slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于旧的数据版本对外提供服务。</p>
<p>（5）如果slave node开启了AOF，那么会立即执行BGREWRITEAOF，重写AOF。</p>
<blockquote>
<p>综上可以看出：RDB生成、RDB通过网络拷贝、slave旧数据的清理、slave aof rewrite这些过程都是很耗费时间，如果复制的数据量在4G~6G之间，那么很可能全量复制时间消耗到1分半到2分钟。</p>
</blockquote>
<h3 id="7-1-8-增量复制"><a href="#7-1-8-增量复制" class="headerlink" title="7.1.8 增量复制"></a>7.1.8 增量复制</h3><p>（1）如果全量复制过程中，master-slave网络连接断掉，那么salve重新连接master时，会触发增量复制。</p>
<p>（2）master直接从自己的<code>backlog</code>中获取部分丢失的数据，发送给slave node，<code>backlog</code>默认大小是1MB。</p>
<p>（3）msater 就是根据 slave 发送的<code>psync</code>中的<code>offset</code>来从backlog中获取数据的。</p>
<h3 id="7-1-9-主从心跳机制"><a href="#7-1-9-主从心跳机制" class="headerlink" title="7.1.9 主从心跳机制"></a>7.1.9 主从心跳机制</h3><p>主从节点互相都会发送heartbeat信息：master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat。</p>
<h3 id="7-1-10-异步复制"><a href="#7-1-10-异步复制" class="headerlink" title="7.1.10 异步复制"></a>7.1.10 异步复制</h3><p>master每次接收到写命令之后，先在内部写入数据，然后异步发送给slave node。</p>
<h2 id="7-2-Redis-高可用"><a href="#7-2-Redis-高可用" class="headerlink" title="7.2 Redis 高可用"></a>7.2 Redis 高可用</h2><p>使用哨兵模式保证高可用。</p>
<p>如果做了主从架构部署，其实就是加上哨兵机制就可以了可以实现：任何一个实例宕机，自动会进行主备切换。</p>
<h3 id="7-2-1-高可用性"><a href="#7-2-1-高可用性" class="headerlink" title="7.2.1 高可用性"></a>7.2.1 高可用性</h3><p>高可用性，是指系统在一年 365 天 * 99.99%的时间内都能持续提供服务，那么就是高可用性。</p>
<p>上一节中的主从复制机制看起来很完善，如果集群中的某个 slave 节点挂了，没有问题，还有其他的从节点顶上，但是有个潜在的问题：主节点挂了，那么就不能写数据了，从节点的数据就不会”更新”了，大量的请求就直接去找mysql 了。</p>
<h3 id="7-2-2-故障转移"><a href="#7-2-2-故障转移" class="headerlink" title="7.2.2 故障转移"></a>7.2.2 故障转移</h3><p>故障转移（failover）是 redis 高可用的重要基础，也叫主备切换。</p>
<p>当redis自动监测到master node出现故障时，将集群中的某个slave node自动切换为master node，这个过程叫主备切换。</p>
<p>要想实现redis可以自动监测master node出现故障时，自动主备切换，就需要增加哨兵节点（sentinal node）。</p>
<h2 id="7-3-哨兵"><a href="#7-3-哨兵" class="headerlink" title="7.3 哨兵"></a>7.3 哨兵</h2><h3 id="7-3-1-哨兵的功能"><a href="#7-3-1-哨兵的功能" class="headerlink" title="7.3.1 哨兵的功能"></a>7.3.1 哨兵的功能</h3><p>sentinal，哨兵是redis集群架构中非常重要的一个组件，主要功能如下：</p>
<p>（1）集群监控，负责监控redis master和slave进程是否正常工作。</p>
<p>（2）消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</p>
<p>（3）故障转移，如果master node挂掉了，会自动转移到slave node上。</p>
<p>（4）配置中心，如果故障转移发生了，通知client客户端新的master地址。</p>
<p>哨兵本身也是分布式的，作为一个哨兵集群去运行，互相协同工作：</p>
<ul>
<li><p>故障转移时，判断一个master node是宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</p>
</li>
<li><p>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</p>
</li>
</ul>
<blockquote>
<p>目前采用的是sentinal 2版本，sentinal 2相对于sentinal 1来说，重写了很多代码，主要是让故障转移的机制和算法变得更加健壮和简单。</p>
</blockquote>
<h3 id="7-3-2-哨兵的核心知识"><a href="#7-3-2-哨兵的核心知识" class="headerlink" title="7.3.2 哨兵的核心知识"></a>7.3.2 哨兵的核心知识</h3><p>（1）哨兵至少需要 3 个实例，来保证自己的健壮性。</p>
<p>（2）哨兵 + redis主从的部署架构，不会保证数据零丢失，只能保证redis集群的高可用性。</p>
<p>（3）对于哨兵 + redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p>
<p><strong>为什么 redis 哨兵集群只有2个节点无法正常工作？</strong></p>
<p>哨兵集群必须部署2个以上节点，如果redis集群部署了两个节点，两个节点分别开启了一个哨兵进程，此时哨兵集群中仅仅部署了个2个哨兵实例。哨兵参数配置成<code>quorum=1</code>（表示只要有一个哨兵监测到了master node宕机了，就可以准备故障转移了）。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 1</span><br></pre></td></tr></tbody></table></figure>

<p>如果哨兵集群仅仅部署了个2个哨兵实例，那么它的majority就是2（2的majority=2，3的majority=2，5的majority=3，4的majority=2），如果其中一个哨兵宕机了，就无法满足majority&gt;=2这个条件，那么在master发生故障的时候也就无法进行主从切换。</p>
<h3 id="7-3-3-经典的3节点哨兵集群"><a href="#7-3-3-经典的3节点哨兵集群" class="headerlink" title="7.3.3 经典的3节点哨兵集群"></a>7.3.3 经典的3节点哨兵集群</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">       +----+</span><br><span class="line">       | M1 |</span><br><span class="line">       | S1 |</span><br><span class="line">       +----+</span><br><span class="line">          |</span><br><span class="line">+----+    |    +----+</span><br><span class="line">| R2 |----+----| R3 |</span><br><span class="line">| S2 |         | S3 |</span><br><span class="line">+----+         +----+</span><br><span class="line"></span><br><span class="line">Configuration: quorum = 2，majority=2（哨兵集群总数/2：3/2=2）</span><br></pre></td></tr></tbody></table></figure>

<p>如果M1所在机器宕机了，那么三个哨兵还剩下2个，S2和S3可以一致认为master宕机，然后选举出一个来执行故障转移，同时3个哨兵的majority是2，所以还剩下的2个哨兵运行着，就可以允许执行故障转移。</p>
<h3 id="7-3-4-哨兵主备切换的数据丢失问题"><a href="#7-3-4-哨兵主备切换的数据丢失问题" class="headerlink" title="7.3.4 哨兵主备切换的数据丢失问题"></a>7.3.4 哨兵主备切换的数据丢失问题</h3><p>主备切换的过程，可能会导致数据丢失：异步复制导致的数据丢失，脑裂导致的数据丢失。</p>
<h4 id="7-3-4-1-异步复制"><a href="#7-3-4-1-异步复制" class="headerlink" title="7.3.4.1 异步复制"></a>7.3.4.1 异步复制</h4><p>因为master -&gt; slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了。</p>
<h4 id="7-3-4-2-集群脑裂"><a href="#7-3-4-2-集群脑裂" class="headerlink" title="7.3.4.2 集群脑裂"></a>7.3.4.2 集群脑裂</h4><p>脑裂，是指某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着，此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。</p>
<p>此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了，因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，因此自己的数据会被清空，重新从新的master复制数据。</p>
<p><img src="https://image.woodwhales.cn/035/images/02.png"></p>
<h4 id="7-3-4-3-解决方案"><a href="#7-3-4-3-解决方案" class="headerlink" title="7.3.4.3 解决方案"></a>7.3.4.3 解决方案</h4><p>在<code>redis.conf</code>配置文件中配置相关参数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></tbody></table></figure>

<p><code>min-slaves-to-write 1</code>：表示要求至少有1个slave，数据复制和同步的延迟不能超过10秒</p>
<p><code>min-slaves-max-lag 10</code>：如果一旦所有的 slave 数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。</p>
<p>上面两个配置可以减少异步复制和脑裂导致的数据丢失：</p>
<p>（1）减少异步复制的数据丢失</p>
<p>有了<code>min-slaves-max-lag</code>这个配置，就可以确保：一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内。</p>
<p><img src="https://image.woodwhales.cn/035/images/03.png"></p>
<p>（2）减少脑裂的数据丢失</p>
<p>如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保：如果不能继续给指定数量的slave发送数据，而且slave超过10秒还没有给自己ack消息，那么就直接拒绝客户端的写请求。这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失。</p>
<p><img src="https://image.woodwhales.cn/035/images/04.png"></p>
<p>因此，上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求，在脑裂场景下，最多就丢失10秒的数据。</p>
<h2 id="7-4-深入理解哨兵底层原理"><a href="#7-4-深入理解哨兵底层原理" class="headerlink" title="7.4 深入理解哨兵底层原理"></a>7.4 深入理解哨兵底层原理</h2><h3 id="7-4-1-sdown-和-odown"><a href="#7-4-1-sdown-和-odown" class="headerlink" title="7.4.1 sdown 和 odown"></a>7.4.1 sdown 和 odown</h3><p><code>sdown</code>和<code>odown</code>两种失败状态：</p>
<p>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机。</p>
<ul>
<li><p>sdown达成的条件：</p>
<p>如果一个哨兵ping一个master，超过了<code>is-master-down-after-milliseconds</code>指定的毫秒数之后，就主观认为master宕机。</p>
</li>
</ul>
<p>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机。</p>
<ul>
<li><p>odown达成的条件</p>
<p>sdown到odown转换的条件很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机。</p>
</li>
</ul>
<h3 id="7-4-2-哨兵集群的自动发现机制"><a href="#7-4-2-哨兵集群的自动发现机制" class="headerlink" title="7.4.2 哨兵集群的自动发现机制"></a>7.4.2 哨兵集群的自动发现机制</h3><p>哨兵互相之间的发现是通过 redis 的<code>pub/sub系统</code>实现的，每个哨兵都会往<code>__sentinel__:hello</code>这个channel里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。</p>
<p>每隔两秒钟，每个哨兵都会往自己监控的某个 master + slaves 对应的<code>__sentinel__:hello</code> 这个channel里发送一个消息，内容是自己的<code>host</code>、<code>ip</code>和<code>runid</code>还有对这个master的监控配置。</p>
<p>每个哨兵也会去监听自己监控的每个 master + slaves 对应的<code>__sentinel__:hello</code>这个channel，然后去感知到同样在监听这个 master + slaves 的其他哨兵的存在。</p>
<p>每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p>
<h3 id="7-4-3-Slave配置的自动纠正"><a href="#7-4-3-Slave配置的自动纠正" class="headerlink" title="7.4.3 Slave配置的自动纠正"></a>7.4.3 Slave配置的自动纠正</h3><p>哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave在复制现有master的数据；</p>
<p>如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上。</p>
<h3 id="7-4-5-选举算法"><a href="#7-4-5-选举算法" class="headerlink" title="7.4.5 选举算法"></a>7.4.5 选举算法</h3><p>如果一个master被认为odown了，而且majority哨兵也允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave出来执行这个主备切换操作。</p>
<p>选举会考虑这些因素：跟master断开连接的时长、slave优先级、复制offset、<code>run id</code>。</p>
<p>如果一个slave跟master断开连接已经超过了<code>down-after-milliseconds</code>的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</span><br></pre></td></tr></tbody></table></figure>

<p>接下来会对 slave 进行排序：</p>
<p>（1）按照slave优先级进行排序，slave priority越低，优先级就越高。</p>
<p>（2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</p>
<p>（3）如果上面两个条件都相同，那么选择一个<code>run id</code>比较小的那个slave。</p>
<h3 id="7-4-6-quorum和majority"><a href="#7-4-6-quorum和majority" class="headerlink" title="7.4.6 quorum和majority"></a>7.4.6 quorum和majority</h3><p>quorum：确认odown的最少的哨兵数量。</p>
<blockquote>
<p><code>quorum=1</code>表示只要有一个哨兵监测到了master node 节点宕机了，就可以故障转移了，也就是开始要选举新的master node了。</p>
</blockquote>
<p>majority：授权进行主从切换的最少的哨兵数量，（int 类型）majority = 哨兵集群总数/2 </p>
<p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还得得到majority哨兵的授权，才能正式执行切换。</p>
<p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，那么就3个哨兵授权就可以执行切换，但是如果quorum &gt;= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换。</p>
<h3 id="7-4-7-configuration-epoch"><a href="#7-4-7-configuration-epoch" class="headerlink" title="7.4.7 configuration epoch"></a>7.4.7 configuration epoch</h3><p>哨兵会对一套 redis 的master+slave进行监控，有相应的监控的配置</p>
<p>执行切换的那个哨兵，会从要切换到的新master（salve-&gt;master）那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。</p>
<p>如果第一个选举出的哨兵切换失败了，那么其他哨兵会等待<code>failover-timeout</code>时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch，作为新的version号。</p>
<h3 id="7-4-8-configuraiton传播"><a href="#7-4-8-configuraiton传播" class="headerlink" title="7.4.8 configuraiton传播"></a>7.4.8 configuraiton传播</h3><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后通过上节提到的<code>pub/sub消息机制</code>同步给其他的哨兵。</p>
<p>因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的。其他的哨兵都是根据自己之前的版本号与新master配置版本号大小对比，来更新自己的master配置。</p>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h2><p>主从架构，即一主多从，一般来说已经足够满足很多项目了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒 10W 的 QPS。</p>
<blockquote>
<p>Redis高并发的同时，还需要容纳大量的数据：</p>
<p>一主多从，每个实例都容纳了完整的数据，比如 redis 主就 10G 的内存量，那么这个redis就只能容纳 10G 的数据量。如果需要缓存的数据量很大，因此需要的可容纳缓存内存要达到了几十G，甚至几百G，或者是几G，那么就需要搭建 redis 集群，并且要保证用redis集群之后，可以提供可能每秒几十万的读写并发。</p>
</blockquote>
<p>实现 Redis 高可用是在高并发的基础之上的愿景，所以在主从架构的集群基础之上，加上哨兵机制就可以保证redis 的高可用性。</p>
<h1 id="8-缓存的持久化"><a href="#8-缓存的持久化" class="headerlink" title="8. 缓存的持久化"></a>8. 缓存的持久化</h1><p>Redis的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</p>
<p>redis如果仅仅只是将数据缓存在内存里面，如果redis宕机了，再重启，内存里的数据就会有全部丢失的风险，因此做缓存就必须要持久化缓存：将数据写入内存的同时，异步的慢慢的将数据写入磁盘文件里，进行持久化。</p>
<p>因此做了缓存持久化可以保证：如果 redis 宕机了，重启启动，自动从磁盘上加载之前持久化的一些数据，就可以恢复数据，也许会丢失少许数据，但是至少不会将所有数据都弄丢。</p>
<p>通俗来说，缓存的持久化思路就是将缓存数据搞一份儿在磁盘上去，然后定期同步和备份到云存储服务上，那么就可以保证数据不丢失全部，必要时可以及时恢复一部分数据回来。</p>
<p>由此引出问题：对于 redis 的持久化如何做？RDB与AOF的区别，它们各自的特点是什么？分别适合什么场景？redis 的企业级的持久化方案是什么，是用来跟哪些企业级的场景结合起来使用的？</p>
<p><strong>Redis 的持久化机制</strong></p>
<p>Redis 的持久化机制分为：RDB 和 AOF，通过 RDB 或 AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如云存储服务。</p>
<p>如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务。</p>
<p><strong>RDB</strong>，是指对 Redis 中的全部数据执行周期性的持久化，也就是某个周期性时刻的快照。</p>
<p><strong>AOF</strong>，对每条写入命令作为日志，以<code>append-only</code>的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。</p>
<blockquote>
<p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 redis 重启的时候，会使用 AOF 来重新构建数据，因为 AOF 中的数据更加完整。</p>
<p>如果想要 redis 仅仅作为纯内存的缓存来用，那么可以禁止 RDB 和 AOF 所有的持久化机制。</p>
</blockquote>
<h2 id="8-1-RDB"><a href="#8-1-RDB" class="headerlink" title="8.1 RDB"></a>8.1 RDB</h2><h3 id="8-1-1-RDB-持久化机制的优点"><a href="#8-1-1-RDB-持久化机制的优点" class="headerlink" title="8.1.1 RDB 持久化机制的优点"></a>8.1.1 RDB 持久化机制的优点</h3><p>（1）RDB 会生成多个数据文件，每个数据文件都代表了某一个时刻中 redis 的数据，这种多个数据文件的方式，非常适合做冷备。</p>
<blockquote>
<p>RBD 可以做冷备，生成多个文件，每个文件代表了某一个时刻的完整的数据快照，这个是由 redis 控制固定时长生成快照文件的。</p>
<p>AOF 也可以做冷备，只生成一个文件，可以自己写脚本定时去copy一份文件出来。</p>
</blockquote>
<p>可以将这种完整的数据文件发送到一些远程的安全存储上去，比如Amazon的S3云服务上去，在国内可以是阿里云的 ODPS 分布式存储上，以预定好的备份策略来定期备份 redis 中的数据。</p>
<p>（2）RDB对 redis 对外提供的读写服务，影响非常小，可以让 redis 保持高性能，因为 redis 主进程只需要fork一个子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化即可。</p>
<blockquote>
<p>RDB 每次只在固定的时间点将数据写入磁盘，而 AOF 每次有写数据的操作就需要记录下来，即使可以快速写入<code>os cache</code>，但是还是有一定的时间开销，所以速度略慢于RDB。</p>
</blockquote>
<p>（3）相对于 AOF 持久化机制来说，直接基于 RDB 数据文件来重启和恢复 redis 进程，更加快速。</p>
<blockquote>
<p>因为 AOF 存放的是指令日志，做数据恢复的时候，本质就是将指令日志从头到尾回放执行一遍所有的指令。而 RDB 文件就是一份数据文件，直接加载内存中即可。 </p>
</blockquote>
<h3 id="8-1-2-RDB-持久化机制的缺点"><a href="#8-1-2-RDB-持久化机制的缺点" class="headerlink" title="8.1.2 RDB 持久化机制的缺点"></a>8.1.2 RDB 持久化机制的缺点</h3><p>（1）如果想要在 redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好。一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 redis 进程宕机，那么会丢失最近 5 分钟的数据。</p>
<blockquote>
<p>这个问题是RDB最大的缺点，因此RDB不适合做第一优先的数据恢复方案，因为丢失数据很多。</p>
</blockquote>
<p>（2）RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</p>
<blockquote>
<p>一般不要设置 RDB 持久化时间间隔太长，否则每次生成的 RDB 文件太大了，对 redis 性能有影响。</p>
</blockquote>
<h2 id="8-2-AOF"><a href="#8-2-AOF" class="headerlink" title="8.2 AOF"></a>8.2 AOF</h2><h3 id="8-2-1-AOF-持久化机制的优点"><a href="#8-2-1-AOF-持久化机制的优点" class="headerlink" title="8.2.1 AOF 持久化机制的优点"></a>8.2.1 AOF 持久化机制的优点</h3><p>（1）AOF可以更好的保护数据不丢失，一般 AOF 会每隔1秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失1秒钟的数据。</p>
<p>（2）AOF日志文件以<code>append-only</code>模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复。</p>
<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。</p>
<p>因为在<code>rewrite log</code>的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，旧的日志文件还是照常写入。当新的<code>merge</code>后的日志文件ready的时候，再交换新老日志文件即可。</p>
<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。</p>
<p>比如某人不小心用<code>flushall</code>命令清空了所有数据，只要这个时候后台<code>rewrite</code>还没有发生，那么就可以立即拷贝AOF文件，将最后一条<code>flushall</code>命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</p>
<h3 id="8-2-2-AOF-持久化机制的缺点"><a href="#8-2-2-AOF-持久化机制的缺点" class="headerlink" title="8.2.2 AOF 持久化机制的缺点"></a>8.2.2 AOF 持久化机制的缺点</h3><p>（1）对于同一份数据来说，AOF 日志文件通常比 RDB 数据快照文件更大</p>
<p>（2）AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低，因为 AOF 一般会配置成每秒<code>fsync</code>一次日志文件，当然每秒一次<code>fsync</code>，性能也还是很高的。</p>
<p>（3）以前 AOF 发生过bug，就是通过A OF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p>
<p>（4）唯一较大的缺点就是数据恢复的速度比较慢，做冷备的时候，需要自己手写复杂的脚本。</p>
<h2 id="8-3-RDB和AOF到底该如何选择"><a href="#8-3-RDB和AOF到底该如何选择" class="headerlink" title="8.3 RDB和AOF到底该如何选择"></a>8.3 RDB和AOF到底该如何选择</h2><p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据。</p>
<p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。</p>
<p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。</p>
<h1 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9. Redis集群"></a>9. Redis集群</h1><p>Redis集群模式的工作原理能说一下么？在集群模式下，redis的key是如何寻址的？分布式寻址都有哪些算法？了解一致性hash算法吗？</p>
<p>在 redis cluster 之前，redis 如果要搞几个节点，每个节点只存储一部分的数据，需要借助中间件来实现，比如codis、twemproxy等。只要读写 redis 中间件，这些中间件就可以负责将数据分布式存储在多台机器上的 redis 实例中。</p>
<p>随着 redis 不断更新迭代，redis 自己搞了个官方的集群模式：<code>redis cluster</code>。</p>
<p>多台机器上，部署多个 redis 实例，每个实例存储一部分的数据，同时每个 redis 实例可以挂 redis 从实例，如果redis 主实例挂了，会自动切换到 redis 从实例顶上来。</p>
<h2 id="9-1-Redis-Cluster"><a href="#9-1-Redis-Cluster" class="headerlink" title="9.1 Redis Cluster"></a>9.1 Redis Cluster</h2><p>在单个 master 节点的主从架构集群中，存在一个问题：所有从节点的数据的上限是受 master 节点的上限限制，比如 master 节点的物理上限是 30G，那么这个集群的上限就是 30G，因此无法承受更大数据量的缓存，即使是机器配置再好，业务需求有 1T 数据需要缓存，那么matser 节点机器可能就没有那么大的物理内存。</p>
<p>由此，需要在原有集群的基础上，增加master节点，每个 master 节点都有自己的 slave 节点，缓存不同的数据。这种机制可以让 redis 具备横向扩展的能力，即使是海量数据，因为有多个 master 节点的保证。</p>
<p>因此只需要基于<code>redis cluster</code>去搭建 redis 集群即可，而不需要手工去搭建 replication 复制 + 主从架构 + 读写分离 + 哨兵集群的高可用缓存架构了。</p>
<blockquote>
<p>如果要缓存数据量很少，主要是承载高并发高的场景，如缓存一般只有几个G，单机足够了。</p>
<p>如果要缓存数据量稍微大一些，replication复制架构，一个 mater，多个 slave，具体需要多少个 slave 由读数据的吞吐量决定，再搭建一个sentinal 集群，保证 redis 主从架构的高可用性就可以了。</p>
<p>redis cluster，主要是针对海量数据+高并发+高可用的场景。</p>
</blockquote>
<h2 id="9-2-数据分布算法"><a href="#9-2-数据分布算法" class="headerlink" title="9.2 数据分布算法"></a>9.2 数据分布算法</h2><h3 id="9-2-1-简单哈希算法"><a href="#9-2-1-简单哈希算法" class="headerlink" title="9.2.1 简单哈希算法"></a>9.2.1 简单哈希算法</h3><p>假设有三台机，数据落在哪台机的算法为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">c = Hash(key) % 3</span><br></pre></td></tr></tbody></table></figure>

<p>例如key A的哈希值为4，4%3=1，则落在第二台机。Key ABC哈希值为11，11%3=2，则落在第三台机上。</p>
<p>利用这样的算法，假设现在数据量太大了，需要增加一台机器。A原本落在第二台上，现在根据算法4%4=0，落到了第一台机器上了，但是第一台机器上根本没有A的值。这样的算法会导致增加机器或减少机器的时候，引起大量的缓存穿透，造成雪崩。</p>
<h3 id="9-2-2-一致性哈希算法"><a href="#9-2-2-一致性哈希算法" class="headerlink" title="9.2.2 一致性哈希算法"></a>9.2.2 一致性哈希算法</h3><p>一致性 <code>Hash</code> 可以很好的解决稳定性问题，可以将所有的存储节点排列在收尾相接的 <code>Hash</code> 环上，每个 <code>key</code> 在计算 <code>Hash</code> 后会 顺时针找到先遇到的存储节点存放。而当有节点加入或退出时，仅影响该节点在 <code>Hash</code> 环上顺时针相邻的后续节点。</p>
<p><img src="https://image.woodwhales.cn/035/images/05.png"></p>
<p>但这有带来 <strong>均匀性</strong> 的问题，即使可以将存储节点等距排列，也会在 <strong>存储节点个数</strong> 变化时带来 <strong>数据的不均匀</strong>。而这种可能 <strong>成倍数的不均匀</strong> 在实际工程中是不可接受的。</p>
<h3 id="9-2-3-哈希槽"><a href="#9-2-3-哈希槽" class="headerlink" title="9.2.3 哈希槽"></a>9.2.3 哈希槽</h3><p>hash slot 算法巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。Redis Cluster 就是采用此算法， Redis Cluster 有固定的 <strong>16384</strong> 个 hash slot，槽是集群内数据管理和迁移的基本单位，采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽，比如说当前集群有 5 个节点，每个节点平均大约负责 3276 个槽，如下所示：</p>
<p><img src="https://image.woodwhales.cn/035/images/06.png"></p>
<p>hash slot 的计算公式：<strong>slot = CRC16（key）% 16384</strong> ，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的hash slot，根据 solt 值就可以该 key 将存放到哪个节点上去。</p>
<p>hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去，移动 hash slot 的成本是非常低的。</p>
<p>hash slot 的特点总结如下：</p>
<ul>
<li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li>
<li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li>
<li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li>
</ul>
<h2 id="9-3-节点间的内部通信机制"><a href="#9-3-节点间的内部通信机制" class="headerlink" title="9.3 节点间的内部通信机制"></a>9.3 节点间的内部通信机制</h2><h3 id="9-3-1-基础通信原理"><a href="#9-3-1-基础通信原理" class="headerlink" title="9.3.1 基础通信原理"></a>9.3.1 基础通信原理</h3><p>（1）Redis Cluster节点间采取<code>gossip协议</code>进行通信</p>
<p>gossip协议：互相之间不断通信，保持整个集群所有节点的数据是完整的。而集中式是将集群元数据（节点信息，故障，等等）集中存储在某个节点上。</p>
<p>维护集群的元数据有两种方式：集中式和<code>gossip 协议 </code></p>
<p>集中式：</p>
<ul>
<li><p>优点：数据更新及时，时效好</p>
<p>元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到;</p>
</li>
<li><p>缺点：数据更新压力集中</p>
<p>所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力</p>
</li>
</ul>
<p>gossip：</p>
<ul>
<li><p>优点：数据更新压力分散</p>
<p>元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力;</p>
</li>
<li><p>缺点：数据更新延迟</p>
<p>元数据更新有延时，可能导致集群的一些操作会有一些滞后</p>
</li>
</ul>
<p>综上可见，集中式 与 gossip 的优缺点是相互的。</p>
<p>（2）10000端口</p>
<p>每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口。</p>
<p>每隔节点每隔一段时间都会往另外几个节点发送<code>ping</code>消息，同时其他几点接收到<code>ping</code>之后返回<code>pong</code>。</p>
<p>（3）交换的信息</p>
<p>故障信息，节点的增加和移除，hash slot信息等。</p>
<h3 id="9-3-2-gossip协议"><a href="#9-3-2-gossip协议" class="headerlink" title="9.3.2 gossip协议"></a>9.3.2 <code>gossip</code>协议</h3><p>gossip协议包含多种消息，包括<code>ping</code>、<code>pong</code>、<code>meet</code>、<code>fail</code>等</p>
<p><code>meet</code>：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信。</p>
<blockquote>
<p><code>redis-trib.rb add-node</code>其实内部就是发送了一个gossip meet消息，将要加入的新节点加入集群。</p>
</blockquote>
<p><code>ping</code>：每个节点都会频繁给其他节点发送<code>ping</code>，其中包含自己的状态还有自己维护的集群元数据，互相通过<code>ping</code>交换元数据。</p>
<p><code>pong</code>：返回<code>ping</code>和<code>meet</code>，包含自己的状态和其他信息，也可以用于信息广播和更新。</p>
<p><code>fail</code>：某个节点判断另一个节点<code>fail</code>之后，就发送<code>fail</code>给其他节点，通知其他节点，指定的节点宕机了。</p>
<h3 id="9-3-3-ping消息"><a href="#9-3-3-ping消息" class="headerlink" title="9.3.3 ping消息"></a>9.3.3 <code>ping</code>消息</h3><p>每个节点每秒会执行10次<code>ping</code>，每次会选择 5 个最久没有通信的其他节点进行ping。</p>
<blockquote>
<p>ping很频繁，而且要携带一些元数据，所以可能会加重网络负担。</p>
</blockquote>
<p>如果发现某个节点通信延时达到了cluster_node_timeout / 2，那么立即发送ping，避免数据交换延时过长，落后的时间太长了。</p>
<p>比如，两个节点之间都10分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以<code>cluster_node_timeout</code>可以调节，如果调节比较大，那么会降低发送的频率。</p>
<blockquote>
<p>每次ping会携带上自己节点的信息，也会带上1/10其他节点的信息，进行数据交换。</p>
<p>每次ping至少包含 3 个其他节点的信息，最多包含<code>总节点-2</code>个其他节点的信息。</p>
</blockquote>
<h2 id="9-4-面向集群的-jedis-内部实现原理"><a href="#9-4-面向集群的-jedis-内部实现原理" class="headerlink" title="9.4 面向集群的 jedis 内部实现原理"></a>9.4 面向集群的 jedis 内部实现原理</h2><h3 id="9-4-1-基于重定向的客户端"><a href="#9-4-1-基于重定向的客户端" class="headerlink" title="9.4.1 基于重定向的客户端"></a>9.4.1 基于重定向的客户端</h3><p>（1）请求重定向</p>
<p>客户端会挑选任意一个redis实例去发送命令，每个redis实例接收到请求重定向命令，都会计算key对应的<code>hash slot</code>，如果分片落在本地就本地处理，否则返回<code>moved</code>给客户端，让客户端进行重定向。</p>
<blockquote>
<p><code>cluster keyslot mykey</code>，可以查看一个key对应的<code>hash slot</code>是什么</p>
</blockquote>
<p>用<code>redis-cli</code>的时候，可以加入-c参数，支持自动的请求重定向，<code>redis-cli</code>接收到<code>moved</code>之后，会自动重定向到对应的节点执行命令</p>
<blockquote>
<p><code>redis-cli -c</code> 自动重定向命令</p>
</blockquote>
<p>（2）计算hash slot</p>
<p>计算<code>hash slot</code>的算法，就是根据 key 计算 CRC16 值，然后对16384取模，得到对应的<code>hash slot</code></p>
<p>用<code>hash tag</code>可以手动指定 key 对应的 slot，同一个<code>hash tag</code>下的 key，都会在一个<code>hash slot</code>中，比如</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set mykey1:{100}</span><br><span class="line">set mykey2:{100}</span><br></pre></td></tr></tbody></table></figure>

<p>（3）<code>hash slot</code>查找</p>
<p>节点间通过<code>gossip协议</code>进行数据交换，就知道每个<code>hash slot</code>在哪个节点上</p>
<h3 id="9-4-2-smart-jedis"><a href="#9-4-2-smart-jedis" class="headerlink" title="9.4.2 smart jedis"></a>9.4.2 smart jedis</h3><p>（1）什么是smart jedis</p>
<p>基于重定向的客户端，很消耗网络IO，因为大部分情况下，可能都会出现一次请求重定向，才能找到正确的节点</p>
<p>所以大部分的客户端。</p>
<p>java的 redis 客户端，就是<code>smart jedis</code>。本地维护一份<code>hashslot -&gt; node</code>的映射表，缓存大部分情况下，直接走本地缓存就可以找到<code>hashslot -&gt; node</code>，不需要通过节点进行<code>moved</code>重定向。</p>
<p>（2）JedisCluster的工作原理</p>
<p>在<code>JedisCluster</code>初始化的时候，就会随机选择一个node，初始化<code>hashslot -&gt; node</code>映射表，同时为每个节点创建一个JedisPool连接池。</p>
<p>每次基于<code>JedisCluster</code>执行操作，首先<code>JedisCluster</code>都会在本地计算 key 的<code>hashslot</code>，然后在本地映射表找到对应的节点。</p>
<p>如果那个node正好还是持有那个hashslot，那么就ok。如果进行了<code>reshard</code>这样的操作，可能<code>hashslot</code>已经不在那个node上了，就会返回<code>moved</code>。</p>
<p>如果<code>JedisCluter API</code>发现对应的节点返回<code>moved</code>，那么利用该节点的元数据，更新本地的<code>hashslot -&gt; node</code>映射表的缓存。</p>
<p>重复上面几个步骤，直到找到对应的节点，如果重试超过5次就会报<code>JedisClusterMaxRedirectionException</code></p>
<p>异常。</p>
<p>jedis 老版本，可能会出现在集群某个节点故障还没完成自动切换恢复时，频繁更新<code>hash slot</code>，频繁ping节点检查活跃，导致大量网络IO开销。jedis 最新版本，对于这些过度的hash slot更新和ping，都进行了优化，避免了类似问题。</p>
<p>（3）<code>hashslot</code>迁移和<code>ask</code>重定向</p>
<p>如果<code>hash slot</code>正在迁移，那么会返回ask重定向给 jedis，jedis接收到 ask 重定向之后，会重新定位到目标节点去执行，但是因为ask发生在hash slot迁移过程中，所以<code>JedisCluster API</code>收到ask是不会更新<code>hashslot</code>本地缓存。</p>
<p>因此可以确定地说，<code>hashslot</code>已经迁移完了，<code>moved</code>是会更新本地<code>hashslot-&gt;node</code>映射表缓存的。</p>
<h2 id="9-5-高可用性与主备切换原理"><a href="#9-5-高可用性与主备切换原理" class="headerlink" title="9.5 高可用性与主备切换原理"></a>9.5 高可用性与主备切换原理</h2><blockquote>
<p>Redis Cluster的高可用原理，几乎和哨兵机制类似</p>
</blockquote>
<h3 id="9-5-1-判断节点宕机"><a href="#9-5-1-判断节点宕机" class="headerlink" title="9.5.1 判断节点宕机"></a>9.5.1 判断节点宕机</h3><p>如果一个节点认为另外一个节点宕机，那么就是<code>pfail</code>，主观宕机。</p>
<p>如果多个节点都认为另外一个节点宕机了，那么就是<code>fail</code>，客观宕机。</p>
<blockquote>
<p>跟哨兵的原理（sdown / odown）几乎一样。</p>
</blockquote>
<p>在<code>cluster-node-timeout</code>参数设置的时间内，某个节点一直没有返回<code>pong</code>，那么就被认为<code>pfail</code>。</p>
<p>如果一个节点认为某个节点<code>pfail</code>了，那么这个节点会使用gossip协议与其他节点通信：将这个<code>pfail</code>信息携带在<code>ping</code>消息中<code>ping</code>给其他节点，如果超过半数的节点都认为<code>pfail</code>了，那么就会变成<code>fail</code>。</p>
<h3 id="9-5-2-从节点过滤"><a href="#9-5-2-从节点过滤" class="headerlink" title="9.5.2 从节点过滤"></a>9.5.2 从节点过滤</h3><p>对宕机的<code>master node</code>，从其所有的<code>slave node</code>中，选择一个切换成<code>master node</code></p>
<p>检查每个<code>slave node</code>与<code>master node</code>断开连接的时间，如果超过了<code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就没有资格切换成<code>master</code>。</p>
<h3 id="9-5-3-从节点选举"><a href="#9-5-3-从节点选举" class="headerlink" title="9.5.3 从节点选举"></a>9.5.3 从节点选举</h3><blockquote>
<p>哨兵：对所有从节点进行排序：slave priority，offset，run id</p>
</blockquote>
<p>每个从节点，都根据自己对<code>master</code>复制数据的<code>offset</code>，来设置一个选举时间，<code>offset</code>越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</p>
<p>所有的<code>master node</code>开始<code>slave</code>选举投票，给要进行选举的<code>slave</code>进行投票，如果大部分<code>master node</code>（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成<code>master</code>。从节点执行主备切换，从节点切换为主节点。</p>
<h3 id="9-5-4-与哨兵比较"><a href="#9-5-4-与哨兵比较" class="headerlink" title="9.5.4 与哨兵比较"></a>9.5.4 与哨兵比较</h3><p>redis cluster 的整个流程跟哨兵相比非常类似，但 redis cluster 功能更强大，直接集成了<code>replication</code>和<code>sentinal</code>的功能。</p>
<h1 id="10-缓存雪崩与缓存穿透"><a href="#10-缓存雪崩与缓存穿透" class="headerlink" title="10. 缓存雪崩与缓存穿透"></a>10. 缓存雪崩与缓存穿透</h1><p>了解什么是redis的雪崩和穿透？redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？</p>
<p>在实际生产中缓存雪崩和穿透是缓存最大的两个问题，要么不出现，一旦出现就是致命性的问题，因此是面试必问的问题。</p>
<h2 id="10-1-缓存雪崩发生的现象"><a href="#10-1-缓存雪崩发生的现象" class="headerlink" title="10.1 缓存雪崩发生的现象"></a>10.1 缓存雪崩发生的现象</h2><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。这种灾难，如果不采取特殊的方案，重启数据库是无效的，因为新的流量瞬间打过来，数据库又会宕机。</p>
<p><img src="https://image.woodwhales.cn/035/images/07.png"></p>
<h2 id="10-2-缓存雪崩的解决方案"><a href="#10-2-缓存雪崩的解决方案" class="headerlink" title="10.2 缓存雪崩的解决方案"></a>10.2 缓存雪崩的解决方案</h2><p>事前预防：缓存的架构必须是集群式的，不能是单机版的，要么是主从架构+哨兵，要么是<code>redis cluster</code>。</p>
<p>事中限流：本地<code>ehcache</code>缓存 + <code>hystrix</code>限流&amp;降级，避免MySQL被打死。</p>
<p>事后：redis持久化，快速恢复缓存数据。</p>
<p>这种方案下的请求流程是，用户发送的请求先去系统本地缓存<code>ehcache</code>中找数据，如果没有本地缓存没有，就去 redis 中找数据。如果 redis 没有才去数据库找数据，并且在数据返回的时候，在<code>redis</code> 和<code>ehcache</code>都要写一份数据。</p>
<p>当 redis 集群宕机时，限流组件发挥作用，将去数据库的请求限制在 2000 次/s，其他流量走降级组件。</p>
<p><img src="https://image.woodwhales.cn/035/images/08.png"></p>
<p>这种方案的优点：</p>
<p>（1）数据库绝对不会被海量请求打死，因为限流组件限制了最多只有 2000 个请求可以访问数据库。</p>
<p>（2）只要数据库不死，对用户来说，起码有2/5的请求是可以被及时处理的。</p>
<p>（3）对多数用户来说，只不过在请求的时候只会觉得比较“卡”，多尝试几次请求即可，不会出现不能访问的情况。</p>
<h2 id="10-3-缓存穿透发生的现象"><a href="#10-3-缓存穿透发生的现象" class="headerlink" title="10.3 缓存穿透发生的现象"></a>10.3 缓存穿透发生的现象</h2><p>缓存穿透是指查询一个<strong>一定不存在的数据</strong>，由于缓存中查不到，所以一定会去数据库查询，但是数据库也不存在，所以这些请求会永远在查数据库。如果有恶意用户利用不存在的 key 频繁攻击我们的应用，数据库也就会直接被打死，这就是漏洞。</p>
<p><img src="https://image.woodwhales.cn/035/images/09.png"></p>
<h2 id="10-4-缓存穿透的解决方法"><a href="#10-4-缓存穿透的解决方法" class="headerlink" title="10.4 缓存穿透的解决方法"></a>10.4 缓存穿透的解决方法</h2><p>有很多种方法可以有效地解决缓存穿透问题：</p>
<p>最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>另外也有一个更为简单粗暴的方法：如果一个查询返回的数据为空（不管是数据由于不存在，还是系统故障导致），数据库查询不到也会把这个空结果进行缓存，并设置这些 key 过期时间短一些，最长不超过五分钟。</p>
<p><img src="https://image.woodwhales.cn/035/images/10.png"></p>
<h1 id="11-缓存与数据库双写的一致性问题"><a href="#11-缓存与数据库双写的一致性问题" class="headerlink" title="11. 缓存与数据库双写的一致性问题"></a>11. 缓存与数据库双写的一致性问题</h1><p>如何保证缓存与数据库的双写一致性？</p>
<p>一般来说，如果业务需求不严格要求缓存+数据库必须一致性的话，建议不做双写一致方案，因为缓存中的数据和数据库会偶尔出现有不一致的情况，因为要想保证双写数据一致性就需要将<strong>读请求和写请求串行化</strong>，也就是将读写请求串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况，但是这样串行化之后，就会导致系统的吞吐量会大幅度的降低，如果还需要保证很高的吞吐，就需要用比正常情况下多几倍的机器，然而加了那么多机器只为了去支撑线上的一个请求，有点”得不偿失”。</p>
<h2 id="11-1-经典的双读写模式"><a href="#11-1-经典的双读写模式" class="headerlink" title="11.1 经典的双读写模式"></a>11.1 经典的双读写模式</h2><h3 id="11-1-1-Cache-Aside-Pattern"><a href="#11-1-1-Cache-Aside-Pattern" class="headerlink" title="11.1.1 Cache Aside Pattern"></a>11.1.1 Cache Aside Pattern</h3><p>Cache Aside Pattern 是最经典的缓存+数据库读写的模式：缓存失效时回源取数据，更新缓存；命中缓存时，返回缓存数据；先数据源更新后，再失效缓存（由等待下次读取来回写缓存）</p>
<p>通俗说就是，读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先删除缓存，然后再更新数据库。</p>
<p><strong>优势：</strong></p>
<ul>
<li>无缓存旧数据问题、缓存系统维护简单、Facebook推荐方案。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li><p>无法绝对杜绝并发读写问题：缓存过期的背景下，读操作回源取数据（此时为旧数据）。</p>
</li>
<li><p>写操作：更新数据源，失效缓存。</p>
</li>
<li><p>读操作：将回源数据（旧数据）写缓存，出现缓存数据不一致问题。</p>
</li>
<li><p>这种问题出现概率极低，几点要求：缓存已过期、并发读写、读数据比写数据快、但读操作更新缓存比写操作失效缓存慢（也就是说写操作的行为需完全发生在读操作两步之间），一般而言读操作（读库+更新缓存）时长要小于写操作（更新数据源+失效缓存），所以认为这种并发问题概率较低。</p>
</li>
<li><p>是否可进一步解决此问题：增加锁机制，解决并发问题。</p>
</li>
</ul>
<h3 id="11-1-2-Read-Through-Pattern"><a href="#11-1-2-Read-Through-Pattern" class="headerlink" title="11.1.2 Read Through Pattern"></a>11.1.2 Read Through Pattern</h3><p>Read Through Pattern：更新数据源由缓存系统操作，读取数据时，如缓存失效，则缓存服务取回源数据更新缓存。而Cache Aside中是由应用服务（调用方）更新缓存。这套对调用方是透明的，只有一套存储系统，而无视缓存、数据源的差异。</p>
<h3 id="11-1-3-Write-Through-Pattern"><a href="#11-1-3-Write-Through-Pattern" class="headerlink" title="11.1.3 Write Through Pattern"></a>11.1.3 Write Through Pattern</h3><p>Write Through Pattern：更新数据源由缓存系统操作，<code>写数据</code>时，如缓存失效，则直接更新数据源（不做任何缓存操作）；如命中缓存，则更新缓存（由缓存系统更新数据源）。</p>
<p>在缓存失效下写操作的处理后，何时更新缓存呢？下一次读操作，按<code>Read Through</code>中缓存失效策略来更新缓存</p>
<h3 id="11-1-4-Write-Behind-Caching-Pattern"><a href="#11-1-4-Write-Behind-Caching-Pattern" class="headerlink" title="11.1.4 Write Behind Caching Pattern"></a>11.1.4 Write Behind Caching Pattern</h3><p>Write Behind Caching Pattern：又称<code>Write Back</code>，一句话总结：更新数据时，只更新缓存，不更新数据源（缓存<code>异步批量</code>更新数据源）。</p>
<p><strong>优势：</strong></p>
<ul>
<li>更新缓存为内存操作，读写I/O非常高。异步批量更新数据源，合并多个操作。</li>
</ul>
<p><strong>问题：</strong></p>
<ul>
<li><p>缓存不满足强一致性要求。</p>
</li>
<li><p>强一致性和高性能的冲突<code>、</code>高可用和高性能的冲突终究会使Trade-Off。</p>
</li>
<li><p>实现复杂，需跟踪哪些Cache更新，成本较高。</p>
</li>
</ul>
<h3 id="11-1-5-小结"><a href="#11-1-5-小结" class="headerlink" title="11.1.5 小结"></a>11.1.5 小结</h3><p>总体来说，不同方案在不同场景下是有各自优劣的，技术选型、架构设计应根据实际场景取舍，并对选择方案的利弊有足够且深入理解。</p>
<p>一般而言，推荐<code>Cache Aside Pattern</code>方案，容忍较小概率的不一致（同时也可以增加锁机制解决此低概率并发问题），简化缓存系统复杂度。</p>
<h2 id="11-2-缓存不一致问题"><a href="#11-2-缓存不一致问题" class="headerlink" title="11.2 缓存不一致问题"></a>11.2 缓存不一致问题</h2><p>结合实时性较高的库存服务来分析：数据库与缓存双写不一致问题以及其解决方案</p>
<h3 id="11-2-1-最初级的不一致问题"><a href="#11-2-1-最初级的不一致问题" class="headerlink" title="11.2.1 最初级的不一致问题"></a>11.2.1 最初级的不一致问题</h3><p><strong>问题：</strong></p>
<p>先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。</p>
<p><strong>解决思路：</strong></p>
<p>先删除缓存，再修改数据库。</p>
<blockquote>
<p>如果删除缓存成功了，但修改数据库失败了，那么数据库中是旧数据，缓存是空的，那么数据不会不一致。因为读的时发现缓存中没有，则从读数据库中旧数据，然后更新回缓存中。</p>
</blockquote>
<h3 id="11-2-2-复杂的不一致问题"><a href="#11-2-2-复杂的不一致问题" class="headerlink" title="11.2.2 复杂的不一致问题"></a>11.2.2 复杂的不一致问题</h3><p>上节的解决思路<strong>在高并发的情况下</strong>还是会出现不一致的问题：</p>
<p>在第一个请求已经删除缓存，并要修改数据库但还没来得及改的时候，另一请求来查数据库。</p>
<p>此时，看到缓存中没有数据，于是去数据库读取一次，这个请求读到的就是旧的数据，当这个第二个请求读完之后，第一个请求开始修改数据库。</p>
<p><img src="https://image.woodwhales.cn/035/images/11.png"></p>
<p>于是缓存本来是空的，现在存了旧的数据，而数据库中是新的数据，造成了缓存和数据库不一致的问题。</p>
<h2 id="11-3-缓存不一致问题的解决方案"><a href="#11-3-缓存不一致问题的解决方案" class="headerlink" title="11.3 缓存不一致问题的解决方案"></a>11.3 缓存不一致问题的解决方案</h2><h3 id="11-3-1-缓存与数据库读取异步串行化"><a href="#11-3-1-缓存与数据库读取异步串行化" class="headerlink" title="11.3.1 缓存与数据库读取异步串行化"></a>11.3.1 缓存与数据库读取异步串行化</h3><p>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个JVM内部的队列中。</p>
<p>读取数据的时候，如果发现数据不在缓存中，那么将进行重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个JVM内部的队列中。</p>
<p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p>
<p>这样的方案下，一个数据变更的操作分为：先执行删除缓存，后再去更新数据库，当执行完删除缓存操作还没完成更新的时候，如果再来一个读请求，此时读到了空的缓存，那么可以先将更新缓存的请求发送到队列中，此时当前请求的更新缓存（读取数据库操作）会在队列中积压，然后同步等待缓存更新完成。</p>
<p><img src="https://image.woodwhales.cn/035/images/12.png"></p>
<p>这里有一个优化点：一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>
<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作（也就是缓存更新的操作），此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<h3 id="11-3-2-解决方案要注意的问题"><a href="#11-3-2-解决方案要注意的问题" class="headerlink" title="11.3.2 解决方案要注意的问题"></a>11.3.2 解决方案要注意的问题</h3><h4 id="11-3-2-1-读请求长时阻塞"><a href="#11-3-2-1-读请求长时阻塞" class="headerlink" title="11.3.2.1 读请求长时阻塞"></a>11.3.2.1 读请求长时阻塞</h4><p>在上一节的解决方案中，读请求是非常轻度的异步化操作，但存在一个很大的潜在风险：出现数据更新操作频繁的操作时，那么会导致队列中积压了大量更新操作，所以后面的读请求会发生大量超时，最终导致大量的请求直接走了数据库。因此一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p>
<blockquote>
<p>举例，如果一个内存队列里居然会积压 100 个商品的库存修改操作，每条库存修改操作要耗费 10ms 区完成，那么最后一个商品的读请求，可能等待<code>10 * 100 = 1000ms = 1s</code>后，才能得到数据。这个时候就导致读请求的长时阻塞。</p>
</blockquote>
<p>因此一定要做根据实际业务系统的运行情况，去进行压力测试和线上环境模拟，测试最繁忙的时候，内存队列可能会积压多少更新操作，可能会导致最后一个更新操作对应的读请求被 hang 多长时间。</p>
<blockquote>
<p>如果读请求在 200ms 之内返回，如果经过压力测试计算过后，即使是最繁忙的时候，内存队列中只积压了 10 个更新操作，最多等待 200ms，那么还是可以接受的。</p>
</blockquote>
<p>如果一个内存队列可能积压的更新操作特别多就要加机器，这样就可以将大流量数据操作请求分摊到每个机器上的请求操作量会少一些，那么在每个机器中的JVM中的内存队列中积压的更新操作就会越少。</p>
<h4 id="11-3-2-2-读请求并发量过高"><a href="#11-3-2-2-读请求并发量过高" class="headerlink" title="11.3.2.2 读请求并发量过高"></a>11.3.2.2 读请求并发量过高</h4><p>除了上述的读操作阻塞超时问题，还有一个风险：突然间大量读请求会在几十毫秒的延时hang在服务上，看服务能不能抗的住，需要多少机器才能抗住最大的极限情况的峰值。</p>
<blockquote>
<p>因为并不是所有的数据都在同一时间更新，所以缓存也不会在同一时间失效，因此每次可能只有少量数据的缓存失效了，然后这些少量数据对应的读请求，并发量也不会特别大。</p>
</blockquote>
<p>因此需要严格测算，有多少更新操作的数据在更新的时候，刚好出现大量对这个数据的读操作，需要测算此时的读请求被阻塞的数据量，比如一台单机中有 500 条数据存在更新的时候会跟随大量的读请求，更新操作和读请求的并发占比是 1:20 的话，那么这台机器里就会出现 500* 20  = 1w 个请求 hang 在服务器里，这是很致命的，所以需要根据测算来增加机器。</p>
<h4 id="11-3-2-3-多服务实例下的请求路由"><a href="#11-3-2-3-多服务实例下的请求路由" class="headerlink" title="11.3.2.3 多服务实例下的请求路由"></a>11.3.2.3 多服务实例下的请求路由</h4><p>由于多服务实例部署在不同的机器，所以同一个数据的读或写请求过来的时候，可能会路由到不同的机器中的队列里，那么上述的异步串行化就失效了。</p>
<p><img src="https://image.woodwhales.cn/035/images/13.png"></p>
<p>因此必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过<code>nginx 服务器</code>路由到相同的服务实例上。</p>
<h4 id="11-3-2-4-热点商品的路由问题"><a href="#11-3-2-4-热点商品的路由问题" class="headerlink" title="11.3.2.4 热点商品的路由问题"></a>11.3.2.4 热点商品的路由问题</h4><p>热点商品的路由问题会导致请求的倾斜：万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能造成某台机器的负载过大。</p>
<blockquote>
<p>只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是特别大。</p>
</blockquote>
<h1 id="12-缓存并发竞争"><a href="#12-缓存并发竞争" class="headerlink" title="12. 缓存并发竞争"></a>12. 缓存并发竞争</h1><p>Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？</p>
<h2 id="12-1-问题分析"><a href="#12-1-问题分析" class="headerlink" title="12.1 问题分析"></a>12.1 问题分析</h2><p>Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以Redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对Redis进行并发访问时会出现问题。</p>
<p><img src="https://image.woodwhales.cn/035/images/14.png"></p>
<h2 id="12-2-解决方案"><a href="#12-2-解决方案" class="headerlink" title="12.2 解决方案"></a>12.2 解决方案</h2><h3 id="12-2-1-分布式锁-时间戳"><a href="#12-2-1-分布式锁-时间戳" class="headerlink" title="12.2.1 分布式锁+时间戳"></a>12.2.1 分布式锁+时间戳</h3><p>这种情况，主要是准备一个分布式锁，大家去抢锁，抢到锁就做set操作。加锁的目的实际上就是把并行读写改成串行读写的方式，从而来避免资源竞争。</p>
<blockquote>
<p>因为传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。</p>
</blockquote>
<h4 id="12-2-1-1-分布式锁"><a href="#12-2-1-1-分布式锁" class="headerlink" title="12.2.1.1 分布式锁"></a>12.2.1.1 分布式锁</h4><p>分布式锁可以基于很多种方式实现，比如<code>zookeeper</code>、<code>redis</code>等，不管哪种方式实现，基本原理是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</strong></p>
<p>这里利用 redis 的<code>SETNX</code>非常简单地实现分布式锁。例如：某客户端要获得一个名字<code>woodwhales</code>的锁，客户端使用下面的命令进行获取：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SETNX lock.woodwhales&lt;current Unix time + lock timeout + 1&gt;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如返回 1，则该客户端获得锁，把<code>lock.woodwhales</code>的键值设置为时间值表示该键已被锁定，该客户端最后可以通过<code>DEL lock.foo</code>来释放该锁。</li>
<li>如返回 0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</li>
</ul>
<h4 id="12-2-1-2-时间戳"><a href="#12-2-1-2-时间戳" class="headerlink" title="12.2.1.2 时间戳"></a>12.2.1.2 时间戳</h4><p>上节中场景需求是要求 key 的操作需要顺序执行，所以需要保存一个时间戳判断set顺序。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">系统A test_key { ValueA 10:00 }</span><br><span class="line">系统B test_key { ValueB 10:05 }</span><br></pre></td></tr></tbody></table></figure>

<p>假设系统B先抢到锁，将 test_key 设置为 { ValueB 7:05 }。接下来系统A抢到锁，发现自己的 test_key 的时间戳早于缓存中的时间戳（10:00 &lt; 10:05），那就不做set操作了。</p>
<p><img src="https://image.woodwhales.cn/035/images/15.png"></p>
<h3 id="12-2-2-利用消息队列"><a href="#12-2-2-利用消息队列" class="headerlink" title="12.2.2 利用消息队列"></a>12.2.2 利用消息队列</h3><p>在并发量过大的情况下，可以通过消息中间件进行处理，把并行读写进行串行化。把<code>Redis.set</code>操作放在队列中使其串行化，必须的一个一个执行。这种方式在一些高并发的场景中算是一种通用的解决方案。</p>
<h1 id="13-缓存生产部署架构"><a href="#13-缓存生产部署架构" class="headerlink" title="13. 缓存生产部署架构"></a>13. 缓存生产部署架构</h1><p>生产环境中的redis是怎么部署的？Redis 是主从架构还是集群架构？用了哪种集群方案？有没有做高可用保证？有没有开启持久化机制确保可以进行数据恢复？线上 redis 的内存大小？设置了哪些参数？压测后 redis 集群承载多少 QPS？</p>
<p>redis cluster 方案，10 台机器，5 台机器部署了redis主实例，另外5台机器部署了redis的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰QPS可能可以达到 5万/秒，5 台机器最多是每秒 25 万读写请求。</p>
<p>机器是什么配置？</p>
<p>32G内存 + 8核CPU + 1T磁盘，分配给 redis 进程的是 10G 内存，一般线上生产环境，redis 的内存尽量不要超过10G，超过 10G 可能会有问题。5台机器对外提供读写，一共有 50G内存。</p>
<p>每个主实例都挂载了一个从实例，可以保证高可用，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p>
<p>往内存里写的是什么数据？每条数据的大小是多少？</p>
<p>商品数据，每条数据是 10KB。100 条数据是 1MB，10 万条数据是 1G。常驻内存的是 200万 条商品数据，占用内存是 20G，仅仅不到总内存（50G）的 50%。目前高峰期每秒就是3500左右的请求量。</p>
<h1 id="14-扩展博文"><a href="#14-扩展博文" class="headerlink" title="14. 扩展博文"></a>14. 扩展博文</h1><p><a href="https://tech.meituan.com/2017/03/17/cache-about.html">缓存那些事</a></p>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/79470556">为什么说Redis是单线程的以及Redis为什么这么快！</a></p>
<p><a href="https://blog.csdn.net/bird73/article/details/79792548">Redis面试题（一）: Redis到底是多线程还是单线程？</a></p>
<p><a href="https://jlj98.top/redis-01">Redis —— 初识Redis</a></p>
<p><a href="https://draveness.me/redis-io-multiplexing">Redis 和 I/O 多路复用</a></p>
<p><a href="https://www.jianshu.com/p/3441f6998f87">高并发架构系列：Redis为什么是单线程、及高并发快的3大原因详解</a></p>
<p><a href="https://blog.csdn.net/elricboa/article/details/78847305">LRU算法四种实现方式介绍</a></p>
<p><a href="https://blog.csdn.net/xgq330409675/article/details/82691668">LRU算法实现</a></p>
<p><a href="https://learnku.com/articles/25070">面试之 Redis 基础、高级特性与性能调优</a></p>
<p><a href="https://juejin.im/post/5b76e732f265da4376203849">深入剖析Redis系列(一)</a></p>
<p><a href="https://juejin.im/entry/584659a6ac502e006bb1e6f7">redis 之父的博客翻译 - Redis 中的 LRU 算法改进</a></p>
<p><a href="https://juejin.im/post/5ac9878551882555770cb9bb">动手实现一个 LRU cache</a></p>
<p><a href="https://www.cnblogs.com/lzrabbit/p/3734850.html">LRU缓存实现(Java)</a></p>
<p><a href="https://www.cnblogs.com/Dhouse/p/8615481.html">LRU算法 缓存淘汰策略</a></p>
<p><a href="https://www.cnblogs.com/wyq178/p/9976815.html">LRU算法</a></p>
<p><a href="https://www.cnblogs.com/linxiyue/p/10926944.html">LRU算法原理解析</a></p>
<p><a href="http://www.pianshen.com/article/9792197828/">LRU(least recently used)算法浅析</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3749259.html">缓存算法（页面置换算法）-FIFO、LFU、LRU</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/9004460.html">Redis哨兵模式（sentinel）学习总结及部署记录（主从复制、读写分离、主从切换）</a></p>
<p><a href="http://flygopher.top/2018/10/20/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Redis%EF%BC%9ARedis%E7%BB%8F%E5%85%B8%E4%B8%89%E8%8A%82%E7%82%B9%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.html">深入学习Redis：Redis经典三节点哨兵集群搭建</a></p>
<p><a href="http://dennis.pathto.top/2017/08/13/redis-4-sentinal-core-theory/">redis哨兵核心原理</a></p>
<p><a href="https://juejin.im/post/5d08b2816fb9a07ebd48d859">Redis进阶笔记03：Redis的哨兵机制与容灾实践</a></p>
<p><a href="https://zackku.com/redis-rdb-aof/">进阶的Redis之数据持久化RDB与AOF</a></p>
<p><a href="https://juejin.im/post/5b38cffae51d4558e36037ec">浅谈分布式存储系统的数据分布算法</a></p>
<p><a href="https://zackku.com/redis-sentinel/">进阶的Redis之Sentinel原理及实战</a></p>
<p><a href="https://zackku.com/redis-cluster/">进阶的Redis之哈希分片原理与集群实战</a></p>
<p><a href="https://www.leeyom.top/2018/04/28/dis-storage/">分布式数据存储算法浅析</a></p>
<p><a href="https://juejin.im/post/5cf7c811f265da1b7a4b6368">高级开发不得不懂的Redis Cluster数据分片机制</a></p>
<p><a href="https://www.imooc.com/article/31965">Redis 基础数据结构和操作API</a></p>
<p><a href="http://arganzheng.life/redis-cluster.html">Redis集群学习</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/7955725.html">Redis Cluster集群知识学习总结</a></p>
<p><a href="https://imfox.io/2015/12/14/redis-cluster/">RedisCluster</a></p>
<p><a href="http://www.yangguanjun.com/2017/03/10/redis-cluster-trove/">Redis集群方案</a></p>
<p><a href="https://my.oschina.net/u/2600078/blog/1923696">redis架构演变与redis-cluster群集读写方案</a></p>
<p><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">基于Redis的分布式锁到底安全吗（上）？</a></p>
<p><a href="https://yq.aliyun.com/articles/638627?spm=a2c4e.11153940.0.0.1d374286jk3TO1&amp;utm_content=m_1000016044">深入理解redis cluster的failover机制</a></p>
<p><a href="https://yq.aliyun.com/articles/680237#">深入解析redis cluster gossip机制</a></p>
<p><a href="http://cmsblogs.com/?p=4559">Redis源码剖析和注释（二十五）— Redis Cluster 的通信流程深入剖析</a></p>
<p><a href="http://tech-happen.site/518e1dfd.html">Redis 源码分析之 cluster meet</a></p>
<p><a href="http://ifeve.com/redis-cluster-tutorial/">《Redis官方文档》Redis集群教程</a></p>
<p><a href="https://shift-alt-ctrl.iteye.com/blog/2285470">Redis Cluster实现原理</a></p>
<p><a href="https://lijh.dev/2019/02/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-Master-Slaver-Sentinel%E4%B8%8ECluster%E5%8E%9F%E7%90%86/">深入理解Redis Master-Slaver/Sentinel/Cluster原理</a></p>
<p><a href="https://www.mutounao.cn/index.php/archives/67/">深入RedisCluster（十）</a></p>
<p><a href="https://blog.csdn.net/u012062455/article/details/87603234">redis实战第十四篇 redis cluster ask重定向</a></p>
<p><a href="https://juejin.im/post/5d08faeff265da1bce3dd3b2">你不知道的Redis：RedisCluster与JedisCluster</a></p>
<p><a href="https://juejin.im/post/5d03030ff265da1b957052e3">这可能是最中肯的Redis规范了</a></p>
<p><a href="https://juejin.im/post/5cb13b4d6fb9a0687b7dd0bd">50道Redis面试题史上最全，以后面试再也不怕问Redis了</a></p>
<p><a href="https://blog.csdn.net/javaloveiphone/article/details/53187314">分布式缓存技术redis学习系列（八）——JedisCluster源码解读：集群初始化、slot(槽)的分配、值的存取</a></p>
<p><a href="https://blog.csdn.net/xlgen157387/article/details/79530877">缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</a></p>
<p><a href="https://juejin.im/post/5aa8d3d9f265da2392360a37">缓存世界中的三大问题及解决方案</a></p>
<p><a href="https://juejin.im/post/5b961172f265da0ab7198f4d">Redis缓存穿透、缓存雪崩、redis并发问题分析</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9240611.html">【原创】分布式之数据库和缓存双写一致性方案解析(二)</a></p>
<p><a href="https://github.com/liukelin/canal_mysql_nosql_sync">基于canal 的 mysql 与 redis/memcached/mongodb 的 nosql 数据实时同步方案 案例 demo canal client</a></p>
<p><a href="https://my.oschina.net/jiagouzhan/blog/2990423">高并发架构系列：Redis缓存和MySQL数据一致性方案详解</a></p>
<p><a href="https://ouyblog.com/2017/04/Redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7">Redis缓存数据一致性</a></p>
<p><a href="https://blog.csdn.net/qq_27384769/article/details/79499373">redis缓存与数据库一致性问题解决</a></p>
<p><a href="https://www.cnblogs.com/senlinyang/p/8830611.html">redis缓存与数据库一致性问题</a></p>
<p><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路 | 酷壳- CoolShell</a></p>
<p><a href="https://www.infoq.cn/article/cache-coherency-primer">缓存一致性（Cache Coherency）入门 | 《Cache coherency primer》原文翻译</a></p>
<p><a href="http://fivezh.github.io/2019/02/11/cache-things/">缓存系统中面临的雪崩/穿透/一致性问题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/58331707">如何解决Redis雪崩、穿透、并发等5大难题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52756935">高并发架构系列：Redis并发竞争key的解决方案详解</a></p>
<p><a href="http://youzhixueyuan.com/3-implementations-of-distributed-locks.html">分布式锁的3种实现（数据库、缓存、Zookeeper)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/58038188">Redis为什么是单线程，高并发快的3大原因详解</a></p>
<p><a href="https://juejin.im/post/5bf6b40de51d4536656f1f28">每秒上千订单场景下的分布式锁高并发优化实践！【石杉的架构笔记】</a></p>
<p><a href="https://juejin.im/post/5caaaa67e51d452b63241954">漫话：如何给女朋友解释什么是乐观锁与悲观锁</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1399872">高并发案例 - 库存超发问题</a></p>
<p><a href="%5Bhttp://hackjutsu.com/2016/01/25/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/%5D(http://hackjutsu.com/2016/01/25/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/)">秒杀系统架构分析与实战</a></p>
<p><a href="https://imfox.io/2016/11/04/seckill/">秒杀系统设计总结</a></p>
<p><a href="http://www.ostour.cn/cache/article_106.html">Redis的并发竞争问题如何解决</a></p>
<p>参考书籍：</p>
<p>《Redis设计与实现》黄健宏</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式系统（一）</title>
    <url>/2019/07/01/037/</url>
    <content><![CDATA[<h1 id="1-分布式系统"><a href="#1-分布式系统" class="headerlink" title="1. 分布式系统"></a>1. 分布式系统</h1><h2 id="1-1-集中式系统"><a href="#1-1-集中式系统" class="headerlink" title="1.1 集中式系统"></a>1.1 集中式系统</h2><p>集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力，仅负责数据的录入和输出。而运算、存储等全部在主机上进行。</p>
<p><strong>特点</strong></p>
<p>集中式系统的最大的特点就是部署结构非常简单，底层一般采用从IBM、HP等厂商购买到的昂贵的大型主机。因此无需考虑如何对服务进行多节点的部署，也就不用考虑各节点之间的分布式协作问题。</p>
<p>但是，由于采用单机部署。很可能带来系统大而复杂、难于维护、发生单点故障（单个点发生故障的时候会波及到整个系统或者网络，从而导致整个系统或者网络的瘫痪）、扩展性差等问题。</p>
<blockquote>
<p>正是由于集中式系统的问题在大量互联网中变得极为显著，因此诞生出分布式系统架构的使用必要性。</p>
</blockquote>
<h2 id="1-2-分布式系统-distributed-system"><a href="#1-2-分布式系统-distributed-system" class="headerlink" title="1.2 分布式系统(distributed system)"></a>1.2 分布式系统(distributed system)</h2><p>在《分布式系统概念与设计》一书中，对分布式系统做了如下定义：</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<p>简单来说就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。</p>
<p>一个标准的分布式系统应该具有以下几个<strong>主要特征</strong>：</p>
<ul>
<li><p>分布性</p>
<p>分布式系统中的多台计算机之间在空间位置上可以随意分布，系统中的多台计算机之间没有主、从之分，即没有控制整个系统的主机，也没有受控的从机。</p>
</li>
<li><p>透明性</p>
<p>系统资源被所有计算机共享。每台计算机的用户不仅可以使用本机的资源，还可以使用本分布式系统中其他计算机的资源(包括CPU、文件、打印机等)。</p>
</li>
<li><p>同一性</p>
<p>系统中的若干台计算机可以互相协作来完成一个共同的任务，或者说一个程序可以分布在几台计算机上并行地运行。</p>
</li>
<li><p>通信性</p>
<p>系统中任意两台计算机都可以通过通信来交换信息。</p>
</li>
</ul>
<p>和集中式系统相比，分布式系统的性价比更高、处理能力更强、可靠性更高、也有很好的扩展性。</p>
<p>但是，分布式在解决了网站的高并发问题的同时也带来了一些其他问题：</p>
<p>首先，分布式的必要条件就是<strong>网络</strong>，这可能对性能甚至服务能力造成一定的影响。其次，一个集群中的服务器数量越多，服务器<strong>宕机的概率也就越大</strong>。</p>
<p>另外，由于服务在集群中分布式部署，用户的请求只会落到其中一台机器上，所以，一旦处理不好就很容易产生数据<strong>一致性问题</strong>。</p>
<h1 id="2-分布式系统关联的实际问题"><a href="#2-分布式系统关联的实际问题" class="headerlink" title="2. 分布式系统关联的实际问题"></a>2. 分布式系统关联的实际问题</h1><p>说一下dubbo的工作原理？注册中心挂了可以继续通信吗？说说一次rpc请求的流程？</p>
<p>分布式系统的架构离不开分布式消息中间件、分布式搜索引擎、分布式缓存、RPC框架相关的问题：</p>
<ul>
<li><p><strong>原理性问题</strong></p>
<p>kafka高可用架构原理、es分布式架构原理、redis线程模型原理、Dubbo工作原理。及这些技术的高级应用和特性。</p>
</li>
<li><p><strong>新技术的新问题</strong></p>
<p>每种技术引入之后生产环境都可能会碰到一些问题。</p>
</li>
<li><p><strong>如何自己设计系统</strong></p>
<p>如何自己设计MQ、如何自己设计搜索引擎，如何自己设计缓存，如何自己设计RPC框架</p>
</li>
</ul>
<blockquote>
<p>一般来说结合项目死扣细节是严格的面试官习惯的面试模式：</p>
<p>百度：深入底层、基础性；</p>
<p>阿里：结合项目死扣细节，扣很深的技术底层；</p>
<p>小米：数据结构和算法。</p>
</blockquote>
<h1 id="3-RPC（远程过程调用）"><a href="#3-RPC（远程过程调用）" class="headerlink" title="3. RPC（远程过程调用）"></a>3. RPC（远程过程调用）</h1><h2 id="3-1-RPC"><a href="#3-1-RPC" class="headerlink" title="3.1 RPC"></a>3.1 RPC</h2><p>RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。</p>
<p>通俗表述就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。</p>
<p>通过上面的概念可知，实现RPC主要是做到两点：</p>
<p>（1）实现远程调用其他计算机的服务</p>
<p>要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。因此需要考虑：</p>
<ul>
<li>采用何种网络通讯协议？</li>
</ul>
<p>现在比较流行的RPC框架，都会采用TCP作为底层传输协议。</p>
<ul>
<li>数据传输的格式怎样？</li>
</ul>
<p>两个程序进行通讯，必须约定好数据传输格式。另外数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。</p>
<p>（2）像调用本地服务一样调用远程服务</p>
<p>如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装。</p>
<p><img src="https://image.woodwhales.cn/037/images/01.png"></p>
<h2 id="3-2-HTTP"><a href="#3-2-HTTP" class="headerlink" title="3.2 HTTP"></a>3.2 HTTP</h2><p>Http协议，超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。</p>
<p><img src="https://image.woodwhales.cn/037/images/02.png"></p>
<blockquote>
<p>综上，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求有响应。两者非常相似，但是还是有一些细微差别。</p>
</blockquote>
<h2 id="3-4-http-和-RPC-的区别"><a href="#3-4-http-和-RPC-的区别" class="headerlink" title="3.4 http 和 RPC 的区别"></a>3.4 http 和 RPC 的区别</h2><p>1）RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。</p>
<p>2）Http中还定义了资源定位的路径，RPC中并不需要</p>
<p>3）最重要的区别，RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。</p>
<p>通过对比可以看出：</p>
<p>RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台。但RPC方式需要在 API 层面进行封装，限制了开发的语言环境。</p>
<h2 id="3-3-常见实现框架"><a href="#3-3-常见实现框架" class="headerlink" title="3.3 常见实现框架"></a>3.3 常见实现框架</h2><h3 id="3-3-1-国内框架"><a href="#3-3-1-国内框架" class="headerlink" title="3.3.1 国内框架"></a>3.3.1 国内框架</h3><p><strong>Dubbo</strong></p>
<p>阿里开源的一款高性能RPC框架，在国内应用广泛，期间停止维护过一段时间，如今又开始了更新，并且捐献给Apache基金会，孵化中。</p>
<blockquote>
<p>由于 spring cloud 全家桶的出现，也有很多公司转向 spring cloud 快速开发微服务。</p>
</blockquote>
<p><strong>Dubbox</strong></p>
<p>当当团队基于Dubbo升级的一个版本，支持RESTful风格API的远程调用，基于Kryo/FST的Java高效序列化实现等功能，可直接用于生产环境。</p>
<p><strong>Motan</strong></p>
<p>新浪微博于2016年开源，”在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用”。</p>
<h3 id="3-3-2-国外框架"><a href="#3-3-2-国外框架" class="headerlink" title="3.3.2 国外框架"></a>3.3.2 国外框架</h3><p><strong>GRPC</strong></p>
<p>Google开源，具有平台无关性，基于http/2协议，支持服务追踪、负载均衡、健康检查等功能。</p>
<p><strong>Thrift</strong></p>
<p>可伸缩的跨语言服务的RPC软件框架，最早由Facebook开发，2007年捐献给了Apache基金会管理，现在是Apache的顶级项目。</p>
<p><strong>Finagle</strong></p>
<p>Twitter基于Netty开发的支持容错的、协议无关的RPC框架，支撑了Twitter的核心服务。</p>
<h1 id="4-Dubbo"><a href="#4-Dubbo" class="headerlink" title="4. Dubbo"></a>4. Dubbo</h1><h2 id="4-1-框架设计"><a href="#4-1-框架设计" class="headerlink" title="4.1 框架设计"></a>4.1 框架设计</h2><p><img src="https://image.woodwhales.cn/037/images/03.png"></p>
<p>图例说明：</p>
<p>1）图中左边淡蓝背景的为<strong>服务消费方</strong>使用的接口，右边淡绿色背景的为<strong>服务提供方</strong>使用的接口，位于中轴线上的为<strong>双方</strong>都用到的接口。</p>
<p>2）图中从下至上分为十层，各层均为<strong>单向依赖</strong>，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中：Service 和 Config 层为 API，其它各层均为 SPI。</p>
<blockquote>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p>
<p>SPI 在<code>java.util.ServiceLoader</code>的文档里有比较详细的介绍。</p>
<p>不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。如果想要学习 Dubbo 的源码，SPI 机制务必弄懂。</p>
<p>Dubbo SPI 官方文档：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html</a></p>
</blockquote>
<p>3）图中绿色小块的为扩展接口，蓝色小块为实现类，图中只显示用于关联各层的实现类。</p>
<p>4）图中蓝色虚线为初始化过程，即启动时组装链，红色实线为方法调用过程，即运行时调时链，紫色三角箭头为继承，可以把子类看作父类的同一个节点，线上的文字为调用的方法。</p>
<h2 id="4-2-各层说明"><a href="#4-2-各层说明" class="headerlink" title="4.2 各层说明"></a>4.2 各层说明</h2><p><strong>service 配置层</strong></p>
<p>接口层，其接口的具体实现是由服务提供者和消费者自己来实现。</p>
<p><strong>config 配置层</strong></p>
<p>对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</p>
<p><strong>proxy 服务代理层</strong></p>
<p>服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code>为中心，扩展接口为 <code>ProxyFactory</code></p>
<p><strong>registry 注册中心层</strong></p>
<p>封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></p>
<p><strong>cluster 路由层</strong></p>
<p>封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></p>
<p><strong>monitor 监控层</strong></p>
<p>RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></p>
<p><strong>protocol 远程调用层</strong></p>
<p>封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></p>
<p><strong>exchange 信息交换层</strong></p>
<p>封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></p>
<p><strong>transport 网络传输层</strong></p>
<p>抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></p>
<p><strong>serialize 数据序列化层</strong></p>
<p>可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></p>
<blockquote>
<p>官方参考文档：</p>
<p>架构设计：<a href="https://dubbo.apache.org/zh-cn/docs/dev/design.html">https://dubbo.apache.org/zh-cn/docs/dev/design.html</a></p>
</blockquote>
<h2 id="4-3-工作流程"><a href="#4-3-工作流程" class="headerlink" title="4.3 工作流程"></a>4.3 工作流程</h2><p><img src="https://image.woodwhales.cn/037/images/04.png"></p>
<p>第一步，<code>provider</code>向<code>注册中心</code>注册。</p>
<p>第二步，<code>consumer</code>从注册中心订阅服务，注册中心会通知<code>consumer</code>注册成功的服务。</p>
<p>第三步，<code>consumer</code>调用<code>provider</code>提供接口。</p>
<p>第四步，consumer和provider都异步的通知监控中心。</p>
<blockquote>
<p>官方参考文档：</p>
<p>服务调用过程：<a href="https://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html">https://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html</a></p>
</blockquote>
<h2 id="4-4-通信协议"><a href="#4-4-通信协议" class="headerlink" title="4.4 通信协议"></a>4.4 通信协议</h2><p>dubbo支持哪些通信协议？支持哪些序列化协议？</p>
<h3 id="4-4-1-dubbo"><a href="#4-4-1-dubbo" class="headerlink" title="4.4.1 dubbo://"></a>4.4.1 dubbo://</h3><p>Dubbo 缺省协议采用<strong>单一长连接</strong>和 <strong>NIO 异步通讯</strong>，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p>
<p>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<h3 id="4-4-2-hessian"><a href="#4-4-2-hessian" class="headerlink" title="4.4.2 hessian://"></a>4.4.2 hessian://</h3><p>Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</p>
<blockquote>
<p>Hessian 是 Caucho 开源的一个 RPC 框架，其通讯效率高于 WebService 和 Java 自带的序列化。</p>
</blockquote>
<p>Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：</p>
<ul>
<li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li>
<li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li>
</ul>
<blockquote>
<p>官方参考文档：</p>
<p>协议参考手册：<a href="https://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html">https://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html</a></p>
<p>性能测试报告：<a href="https://dubbo.apache.org/zh-cn/docs/user/perf-test.html">https://dubbo.apache.org/zh-cn/docs/user/perf-test.html</a></p>
</blockquote>
<h2 id="4-5-负载均衡"><a href="#4-5-负载均衡" class="headerlink" title="4.5 负载均衡"></a>4.5 负载均衡</h2><p>dubbo负载均衡策略和集群容错策略都有哪些？动态代理策略呢？</p>
<p>Dubbo 提供了 4 种负载均衡实现，分别是：</p>
<p>基于权重随机算法的<code>RandomLoadBalance</code></p>
<p>基于最少活跃调用数算法的<code>LeastActiveLoadBalance</code></p>
<p>基于 hash 一致性的<code>ConsistentHashLoadBalance</code></p>
<p>基于加权轮询算法的<code>RoundRobinLoadBalance</code></p>
<blockquote>
<p>官方参考文档：</p>
<p>负载均衡源码分析：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a></p>
<p>Dubbo的负载均衡：<a href="http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html">http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html</a></p>
</blockquote>
<h2 id="4-6-集群容错"><a href="#4-6-集群容错" class="headerlink" title="4.6 集群容错"></a>4.6 集群容错</h2><h3 id="4-6-1-集群容错策略"><a href="#4-6-1-集群容错策略" class="headerlink" title="4.6.1 集群容错策略"></a>4.6.1 集群容错策略</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p><img src="https://image.woodwhales.cn/037/images/05.png"></p>
<p>各节点关系：</p>
<ul>
<li>这里的 <code>Invoker</code> 是 <code>Provider</code> 的一个可调用 <code>Service</code> 的抽象，<code>Invoker</code> 封装了 <code>Provider</code> 地址及 <code>Service</code> 接口信息</li>
<li><code>Directory</code> 代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更</li>
<li><code>Cluster</code> 将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code>，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个</li>
<li><code>Router</code> 负责从多个 <code>Invoker</code> 中按路由规则选出子集，比如读写分离，应用隔离等</li>
<li><code>LoadBalance</code> 负责从多个 <code>Invoker</code> 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选</li>
</ul>
<p>Dubbo主要内置了如下几种策略：</p>
<h4 id="4-6-1-1-Failover-Cluster"><a href="#4-6-1-1-Failover-Cluster" class="headerlink" title="4.6.1.1 Failover Cluster"></a>4.6.1.1 Failover Cluster</h4><p>失败自动切换，当出现失败，重试其它服务器。Dubbo 默认的容错策略。</p>
<h4 id="4-6-1-2-Failfast-Cluster"><a href="#4-6-1-2-Failfast-Cluster" class="headerlink" title="4.6.1.2 Failfast Cluster"></a>4.6.1.2 Failfast Cluster</h4><p>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<h4 id="4-6-1-3-Failsafe-Cluster"><a href="#4-6-1-3-Failsafe-Cluster" class="headerlink" title="4.6.1.3 Failsafe Cluster"></a>4.6.1.3 Failsafe Cluster</h4><p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
<h4 id="4-6-1-4-Failback-Cluster"><a href="#4-6-1-4-Failback-Cluster" class="headerlink" title="4.6.1.4 Failback Cluster"></a>4.6.1.4 Failback Cluster</h4><p>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
<h4 id="4-6-1-5-Forking-Cluster"><a href="#4-6-1-5-Forking-Cluster" class="headerlink" title="4.6.1.5 Forking Cluster"></a>4.6.1.5 Forking Cluster</h4><p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 <code>forks="2"</code> 来设置最大并行数。</p>
<h4 id="4-6-1-6-Broadcast-Cluster"><a href="#4-6-1-6-Broadcast-Cluster" class="headerlink" title="4.6.1.6 Broadcast Cluster"></a>4.6.1.6 Broadcast Cluster</h4><p>广播调用所有提供者，逐个调用，任意一台报错则报错 [<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html#fn2">2]</a>。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
<blockquote>
<p>官方参考文档：</p>
<p>Design For failure：<a href="https://dubbo.apache.org/zh-cn/blog/dubbo-cluster-error-handling.html">https://dubbo.apache.org/zh-cn/blog/dubbo-cluster-error-handling.html</a></p>
<p>集群容错：<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a></p>
</blockquote>
<h3 id="4-6-2-各种策略对比"><a href="#4-6-2-各种策略对比" class="headerlink" title="4.6.2 各种策略对比"></a>4.6.2 各种策略对比</h3><p>下表对各种策略做一个简单对比：</p>
<table>
<thead>
<tr>
<th>策略名称</th>
<th>优点</th>
<th>缺点</th>
<th>主要应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Failover</td>
<td>对调用者屏蔽调用失败的信息</td>
<td>增加RT，额外资源开销，资源浪费</td>
<td>对调用rt不敏感的场景</td>
</tr>
<tr>
<td>Failfast</td>
<td>业务快速感知失败状态进行自主决策</td>
<td>产生较多报错的信息</td>
<td>非幂等性操作，需要快速感知失败的场景</td>
</tr>
<tr>
<td>Failsafe</td>
<td>即使失败了也不会影响核心流程</td>
<td>对于失败的信息不敏感，需要额外的监控</td>
<td>旁路系统，失败不影响核心流程正确性的场景</td>
</tr>
<tr>
<td>Failback</td>
<td>失败自动异步重试</td>
<td>重试任务可能堆积</td>
<td>对于实时性要求不高，且不需要返回值的一些异步操作</td>
</tr>
<tr>
<td>Forking</td>
<td>并行发起多个调用，降低失败概率</td>
<td>消耗额外的机器资源，需要确保操作幂等性</td>
<td>资源充足，且对于失败的容忍度较低，实时性要求高的场景</td>
</tr>
<tr>
<td>Broadcast</td>
<td>支持对所有的服务提供者进行操作</td>
<td>资源消耗很大</td>
<td>通知所有提供者更新缓存或日志等本地资源信息</td>
</tr>
</tbody></table>
<h2 id="4-7-动态代理扩展"><a href="#4-7-动态代理扩展" class="headerlink" title="4.7 动态代理扩展"></a>4.7 动态代理扩展</h2><p>dubbo 的 SPI 思想是什么？</p>
<blockquote>
<p>官方参考文档：</p>
<p>Dubbo可扩展机制实战：<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html</a></p>
<p>动态代理扩展：<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/proxy-factory.html">http://dubbo.apache.org/zh-cn/docs/dev/impls/proxy-factory.html</a></p>
</blockquote>
<h3 id="4-7-1-Java-SPI-机制"><a href="#4-7-1-Java-SPI-机制" class="headerlink" title="4.7.1 Java SPI 机制"></a>4.7.1 Java SPI 机制</h3><p>Java SPI(Service Provider Interface)是JDK内置的一种动态加载扩展点的实现。在ClassPath的<code>META-INF/services</code>目录下放置一个与接口同名的文本文件，文件的内容为接口的实现类，多个实现类用换行符分隔。JDK中使用<code>java.util.ServiceLoader</code>来加载具体的实现。 </p>
<h3 id="4-7-2-Dubbo-的-SPI-机制"><a href="#4-7-2-Dubbo-的-SPI-机制" class="headerlink" title="4.7.2 Dubbo 的 SPI 机制"></a>4.7.2 Dubbo 的 SPI 机制</h3><p>Java SPI的使用很简单。也做到了基本的加载扩展点的功能。但Java SPI有以下的不足:</p>
<ul>
<li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现。</li>
<li>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。</li>
<li>扩展如果依赖其他的扩展，做不到自动注入和装配</li>
<li>不提供类似于Spring的IOC和AOP功能</li>
<li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持</li>
</ul>
<p>所以Java SPI应付一些简单的场景是可以的，但对于Dubbo，它的功能还是比较弱的。Dubbo对原生SPI机制进行了一些扩展。接下来，我们就更深入地了解下Dubbo的SPI机制。</p>
<h3 id="4-7-3-Dubbo-的-SPI-的特点"><a href="#4-7-3-Dubbo-的-SPI-的特点" class="headerlink" title="4.7.3 Dubbo 的 SPI 的特点:"></a>4.7.3 Dubbo 的 SPI 的特点:</h3><p>1）对Dubbo进行扩展，不需要改动Dubbo的源码</p>
<p>2）自定义的Dubbo的扩展点实现，是一个普通的Java类，Dubbo没有引入任何Dubbo特有的元素，对代码侵入性几乎为零。</p>
<p>3）将扩展注册到Dubbo中，只需要在ClassPath中添加配置文件。使用简单。而且不会对现有代码造成影响。符合开闭原则。</p>
<p>4）Dubbo的扩展机制设计默认值：@SPI(“dubbo”) 代表默认的spi对象</p>
<p>5）Dubbo的扩展机制支持IoC,AoP等高级功能</p>
<p>6）Dubbo的扩展机制能很好的支持第三方IoC容器，默认支持Spring Bean，可自己扩展来支持其他容器，比如Google的Guice。</p>
<p>7）切换扩展点的实现，只需要在配置文件中修改具体的实现，不需要改代码。使用方便。</p>
<h3 id="4-7-4-如何扩展dubbo中的组件"><a href="#4-7-4-如何扩展dubbo中的组件" class="headerlink" title="4.7.4 如何扩展dubbo中的组件"></a>4.7.4 如何扩展dubbo中的组件</h3><p>首先自己实现<code>org.apache.dubbo.rpc.Protocol</code>接口，比如实现类叫：<code>org.woodwhales.dubbo.MyProtocol</code>，这个实现类可以是本地jar，也可以是pom.xml 依赖的远程jar。</p>
<p>随后将这个jar 信息配置到 dubbo 配置中：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!-- 声明协议，如果没有配置id，将以name为id --&gt;</span><br><span class="line">&lt;dubbo:protocol id="myProtocol_Id" name="myProtocol" /&gt;</span><br><span class="line">&lt;!-- 引用协议，如果没有配置protocol属性，将在ApplicationContext中自动扫描protocol配置 --&gt;</span><br><span class="line">&lt;dubbo:service protocol="myProtocol_Id" /&gt;</span><br><span class="line">&lt;!-- 引用协议缺省值，当&lt;dubbo:service&gt;没有配置prototol属性时，使用此配置 --&gt;</span><br><span class="line">&lt;dubbo:provider protocol="myProtocol_Id" /&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>最后，需要在<code>META-INF</code>配置文件中创建一个名称为：<code>org.apache.dubbo.rpc.Protocol</code>的配置文件，里面写上name对应的类全名：</p>
<p>如：</p>
<p>META-INF/dubbo/org.apache.dubbo.rpc.Protocol：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">myProtocol</span>=<span class="string">org.woodwhales.dubbo.MyProtocol</span></span><br></pre></td></tr></tbody></table></figure>

<p>官方参考文档：<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html">http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html</a></p>
<h2 id="4-8-服务治理"><a href="#4-8-服务治理" class="headerlink" title="4.8 服务治理"></a>4.8 服务治理</h2><p>如何基于dubbo进行服务治理、服务降级、失败重试以及超时重试？</p>
<p>服务治理是一个很复杂且很需要话费精力去研究的课题，一般会从以下方面进行课题研究：</p>
<p>1）调用链路自动生成</p>
<p>一个大型的分布式系统或微服务架构，其系统是由大量的服务组成。那么这些服务之间互相是如何调用的？调用链路是怎么样的？就需要基于dubbo做的分布式系统中，对各个服务之间的调用自动记录下来，然后自动将各个服务之间的依赖关系和调用链路生成出来，做成一张可视化的图，方便查看当前服务的运行情况。</p>
<blockquote>
<p>dubbo 服务治理官方参考文档：</p>
<p>服务治理和配置管理：<a href="http://dubbo.apache.org/zh-cn/docs/admin/serviceGovernance.html">http://dubbo.apache.org/zh-cn/docs/admin/serviceGovernance.html</a></p>
</blockquote>
<p>2）服务访问压力以及时长统计</p>
<p>需要自动统计各个接口和服务之间的调用次数以及访问延时，而且要分成两个级别。</p>
<p>一个级别是<strong>接口粒度</strong>，就是每个服务的每个接口每天被调用多少次，TP50，TP90，TP99，三个档次的请求延时分别是多少；</p>
<p>第二个级别是从<strong>源头入口开始</strong>，一个完整的请求链路经过几十个服务之后，完成一次请求，每天全链路走多少次，全链路请求延时的TP50，TP90，TP99，分别是多少。</p>
<blockquote>
<p>这些东西都搞定了之后，后面才可以来看当前系统的压力主要在哪里，如何来扩容和优化。</p>
</blockquote>
<p>3）其他</p>
<p>服务分层（避免循环依赖），调用链路失败监控和报警，服务鉴权，每个服务的可用性的监控（接口调用成功率？几个9？）99.99%，99.9%，99%。</p>
<h2 id="4-9-服务降级"><a href="#4-9-服务降级" class="headerlink" title="4.9 服务降级"></a>4.9 服务降级</h2><p>比如服务A调用服务B，结果服务B挂掉了，暂停了服务，此时服务A会重试多次尝试继续调用服务B，发现一直无法正常调用，那么就需要将服务A采取降级措施：让服务A执行一个备用的逻辑，给用户返回响应。</p>
<p>Dubbo 中可以在消费者的配置一个本地伪装的<code>mock</code>服务。</p>
<blockquote>
<p>官方参考文档：</p>
<p>本地伪装：<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html">http://dubbo.apache.org/zh-cn/docs/user/demos/local-mock.html</a></p>
<p>服务降级：<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html">http://dubbo.apache.org/zh-cn/docs/user/demos/service-downgrade.html</a></p>
</blockquote>
<h2 id="4-10-失败-超时重试"><a href="#4-10-失败-超时重试" class="headerlink" title="4.10 失败/超时重试"></a>4.10 失败/超时重试</h2><p>Dubbo启动时默认有重试机制和超时机制。 超时机制的规则是如果在一定的时间内，provider没有返回，则认为本次调用失败， 重试机制在出现调用失败时，会再次调用。如果在配置的调用次数内都失败，则认为此次请求异常，抛出异常。</p>
<p><strong>重试机制带来的问题</strong></p>
<p>由于服务响应慢，Dubbo自身的超时重试机制可能会带来一些麻烦，常见的应用场景故障：重复发送邮件 、重复账户注册。</p>
<p><strong>解决方案</strong></p>
<p>1）对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。</p>
<p>去掉超时重试机制 ：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">delay</span>=<span class="string">"-1"</span> <span class="attr">timeout</span>=<span class="string">"6000"</span>  <span class="attr">retries</span>=<span class="string">"0"</span>/&gt;</span> </span><br></pre></td></tr></tbody></table></figure>

<p>重新评估设置超时时间：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"*.*"</span> <span class="attr">ref</span>=<span class="string">"*"</span>  <span class="attr">timeout</span>=<span class="string">"延长服务时间"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>2）业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理。</p>
<h1 id="5-幂等性"><a href="#5-幂等性" class="headerlink" title="5. 幂等性"></a>5. 幂等性</h1><p>分布式服务接口的幂等性如何设计（比如不能重复扣款）？</p>
<p>幂等性问题不是技术问题，这个问题没有通用方法，需要结合业务来看应该如何保证幂等性。</p>
<p>基于唯一标识，存到缓存中或者存到数据库中，因此每次操作就有了一个操作日志。当第一个操作请求操作了就记录下来，下一个相同的操作发现有这个操作的日志，那么就不再执行这次操作。</p>
<h1 id="6-顺序性"><a href="#6-顺序性" class="headerlink" title="6.  顺序性"></a>6.  顺序性</h1><p>对于数据顺性不严格的情况下，可以使用算法将同一个操作的相同操行都 hash 到同一个节点中，节点机器系统的内部使用内存队列来顺序执行操作，这样能很大程度保证数据的顺序性。</p>
<p>如果对数据的顺序性十分严格，那么就需要使用到分布式锁 + 消息中间件，但是这样会使得高并发的性能降低。</p>
<h1 id="7-如何自己设计一个RPC框架"><a href="#7-如何自己设计一个RPC框架" class="headerlink" title="7.如何自己设计一个RPC框架"></a>7.如何自己设计一个RPC框架</h1><h2 id="7-1-实现思路"><a href="#7-1-实现思路" class="headerlink" title="7.1 实现思路"></a>7.1 实现思路</h2><ul>
<li>RPC有两个使用方式：一个是本地调用端，一个是远程实现端</li>
<li>调用端使用动态代理，代理消费者需要远程调用的接口。</li>
<li>将本地调用的接口方法信息(形参，方法名，返回类型等)通过网络发送至远程实现端。</li>
<li>远程实现端接收到相应信息，反射调用对象的实现类。</li>
<li>执行完实现类后把返回值发回给调用端。</li>
<li>调用端接收到返回值，代理返回结果，远程调用完毕。</li>
</ul>
<h2 id="7-2-实现细节问题"><a href="#7-2-实现细节问题" class="headerlink" title="7.2 实现细节问题"></a>7.2 实现细节问题</h2><p>远程调用要解决的主要/细节问题：</p>
<p>1）序列化 : 如何将对象转化为二进制数据进行传输，如何将二进制数据转化对象。</p>
<p>可以使用java自带的序列化，Hessian，protobuff，json，xml等</p>
<p>性能比较高的是<code>protobuff</code>和<code>hessian</code>，<code>protobuff</code>使用的时候需要编写proto文件，有侵入性，比较麻烦，而<code>Hessian</code>性能比<code>protobuff</code>稍差，不过近来出现了一个基于protobuff的框架：<code>protostuff--</code>不用编写proto文件，基于注解，性能可以，推荐使用。</p>
<p>2）数据的传输(协议，第三方框架，如netty)</p>
<p>出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的<code>NIO.2</code>支持。可以选择<code>Netty</code>或者<code>mina</code>来解决 NIO 数据传输的问题。</p>
<p>3）服务的注册/发现，单点故障，分布式服务</p>
<p>使用<code>ZooKeeper</code>提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)</p>
<p>4）服务的监控和管理</p>
<p> 需要单独开发一个应用对服务进行监控和管理。</p>
<h2 id="8-扩展资料"><a href="#8-扩展资料" class="headerlink" title="8. 扩展资料"></a>8. 扩展资料</h2><p><a href="https://waylau.com/talk-about-distributed-system/">用大白话聊聊分布式系统</a></p>
<p><a href="https://www.cnblogs.com/bangerlee/p/6216997.html">分布式系统理论 - 从放弃到入门</a></p>
<p><a href="https://juejin.im/post/5af8ea34f265da0b9f40622a">大家都在说的分布式系统到底是什么？</a></p>
<p><a href="https://www.zhihu.com/question/23645117">学习分布式系统需要怎样的知识？</a></p>
<p><a href="https://www.jianshu.com/p/bc764647169c">[分布式系统]全面介绍分布式系统</a></p>
<p><a href="https://lrita.github.io/images/posts/distribution/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D.pdf">分布式系统原理介绍</a></p>
<p><a href="https://www.cnblogs.com/xybaby/p/8544715.html">分布式学习最佳实践：从分布式系统的特征开始（附思维导图）</a></p>
<p><a href="https://www.cnblogs.com/xybaby/p/7787034.html">什么是分布式系统，如何学习分布式系统</a></p>
<p><a href="https://www.infoq.cn/article/lw_Ax10OXkL2zcIDRkJ1">详解分布式系统本质：“分治”和“冗余”</a></p>
<p><a href="https://www.infoq.cn/article/VShD*wVd1zJJYsTGsswe">美团即时物流的分布式系统架构设计</a></p>
<p><a href="https://juejin.im/post/5a5cc9f5f265da3e58595611">认识分布式架构</a></p>
<p><a href="https://ningning.today/booknotes/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">《大规模分布式存储系统》学习笔记</a></p>
<p><a href="https://www.nosuchfield.com/2019/02/28/Introduction-to-distributed-systems/">分布式系统简介</a></p>
<p><a href="https://36kr.com/p/5176249">原生分布式数据库与中间件的区别</a></p>
<p><a href="http://wrran.com/blog/2017/12/17/review/distributed-system/2-architecture/">分布式系统 - 体系结构</a></p>
<p><a href="https://juejin.im/post/5c7cd6eee51d457c042d4b52">我理解的分布式系统-饿了么物流技术团队</a></p>
<p><a href="http://developer.51cto.com/art/201807/578451.htm">一文详解：如何设计出高可用的分布式架构？</a></p>
<p><a href="https://www.jianshu.com/p/cd2696879877">各大厂分布式链路跟踪系统架构对比</a></p>
<p><a href="http://youzhixueyuan.com/the-principles-and-steps-of-distributed-architecture-system-resolution.html">分布式架构系统拆分原则、需求、微服务拆分步骤</a></p>
<p><a href="http://ksoong.org/docs/content/solutions/abc-distribute-arch.html">核心银行系统分布式架构转型</a></p>
<p><a href="https://servicecomb.apache.org/cn/docs/distributed-transaction-of-services-1/">基于服务的分布式事务(上篇)</a></p>
<p><a href="https://learnku.com/articles/25823">分布式架构的概述</a></p>
<p><a href="https://mp.weixin.qq.com/s/igv8mEON4YyruLHv_ZnYGw">图解分布式系统架构演进之路</a></p>
<p><a href="https://www.infoq.cn/article/2018/05/distributed-system-architecture">左耳朵耗子推荐：分布式系统架构经典资料</a></p>
<p><a href="http://zhuanlan.51cto.com/art/201712/561516.htm">聊聊分布式系统的架构套路</a></p>
<p><a href="https://www.infoq.cn/article/features-and-design-concept-of-distributed-system">分布式系统的特点以及设计理念</a></p>
<p><a href="https://dbaplus.cn/news-141-1368-1.html">以电商网站为例，谈大型分布式架构设计与优化</a></p>
<p><a href="https://www.cnblogs.com/wchukai/p/5653135.html">分布式系统的架构思路</a></p>
<p><a href="https://www.jdon.com/DistributedSystems.html">分布式系统</a></p>
<p><a href="https://juejin.im/post/5cfdb72f6fb9a07f087089b2">《大型网站系统与Java中间件》读书笔记（上）</a></p>
<p><a href="https://yucs.github.io/2018/01/04/2018-1-4-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E6%8E%A8%E8%8D%90/">分布式系统之学习资源推荐</a></p>
<p><a href="http://blog.itpub.net/31557822/viewspace-2641139/">一文讲透分布式系统的精髓</a></p>
<p><a href="http://wuchong.me/blog/2014/08/07/distributed-storage-system-knowledge/">分布式存储系统 知识体系</a></p>
<p><a href="https://wdhdmx.iteye.com/blog/1144574">《分布式java应用》读书笔记–第六章</a></p>
<p><a href="https://www.jianshu.com/p/2accc2840a1b">如何给老婆解释什么是RPC</a></p>
<p><a href="https://www.cnblogs.com/crazylqy/p/7995395.html">RPC原理及RPC实例分析</a></p>
<p><a href="https://blog.csdn.net/fhkkkbfgggjk/article/details/84817103">RPC和HTTP</a></p>
<p><a href="https://my.oschina.net/u/1474131/blog/1834038">simpleRpc解析-服务端</a></p>
<p><a href="https://www.jianshu.com/p/b0343bfd216e">RPC简介及框架选择</a></p>
<p><a href="https://blog.csdn.net/bwh0520/article/details/80148405">关于RPC协议的通俗理解</a></p>
<p><a href="https://blog.csdn.net/u013201439/article/details/81460373">如何理解RPC</a></p>
<p><a href="https://www.zhihu.com/question/41609070">既然有 HTTP 请求，为什么还要用 RPC 调用？</a></p>
<p><a href="https://www.jianshu.com/p/959030de7f1c">HTTP，TCP， socket，RPC 与gRPC都是啥？</a></p>
<p><a href="https://www.zhihu.com/question/25536695">谁能用通俗的语言解释一下什么是 RPC 框架？</a></p>
<p><a href="https://www.infoq.cn/article/get-to-know-rpc">体系化认识 RPC</a></p>
<p><a href="https://blog.csdn.net/mindfloating/article/details/39473807">深入浅出 RPC - 浅出篇</a></p>
<p><a href="https://blog.csdn.net/mindfloating/article/details/39474123">深入浅出 RPC - 深入篇</a></p>
<p><a href="https://www.cnkirito.moe/rpc-protocol/">深入理解RPC之协议篇</a></p>
<p><a href="https://www.itcodemonkey.com/article/6874.html">深入理解 RPC 消息协议设计</a></p>
<p><a href="%5Bhttp://cmsblogs.com/?tag=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-rpc%5D(http://cmsblogs.com/?tag=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-rpc)">深入理解 RPC</a></p>
<p><a href="https://www.yuque.com/xiewenlin/develop-sikll/yn39ta">深入理解 RPC 专题</a></p>
<p><a href="https://pylixm.cc/posts/2018-06-25-Chief-Software-Architect-RPC.html">架构师之路 - RPC 理解</a></p>
<p><a href="https://www.jianshu.com/p/cae9e88cad21">解密Dubbo:自己动手编写RPC框架</a></p>
<p><a href="https://www.cnblogs.com/LBSer/p/4853234.html">你应该知道的RPC原理</a></p>
<p><a href="https://blog.csdn.net/MOU_IT/article/details/79873612">Http和RPC区别</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/48760074">RPC、HTTP、Socket区别</a></p>
<p><a href="https://segmentfault.com/q/1010000003049016">关于RPC、HTTP、WebService的区别</a></p>
<p><a href="http://developer.51cto.com/art/201904/595840.htm">微服务调用为啥用RPC框架，Http不更简单吗？</a></p>
<p><a href="https://www.infoq.cn/article/HTTP-RPC-Cross-Platform-REST-Framework">HTTP-RPC：轻量级跨平台 REST 框架</a></p>
<p><a href="http://ifeve.com/rabbitmq-rpc/">《RabbitMQ官方指南》RPC</a></p>
<p><a href="http://www.pianshen.com/article/3450107411/">远程调用方式 ==&gt; RPC与Http的比较</a></p>
<p><a href="https://blog.csdn.net/Soinice/article/details/83989225">微服务（概念篇）：什么是微服务？一篇文章让你彻底搞明白</a></p>
<p><a href="https://www.jianshu.com/p/46b42f7f593c">高级开发必须理解的Java中SPI机制</a></p>
<p><a href="http://qinghua.github.io/dubbo-1/">服务治理框架dubbo上手指南</a></p>
<p><a href="http://itindex.net/detail/54006-dubbo-%E6%9C%8D%E5%8A%A1-%E6%A1%86%E6%9E%B6">谈Dubbo服务框架</a></p>
<p><a href="https://www.cnblogs.com/yougewe/p/10491667.html">dubbo 序列化机制之 hessian2序列化实现原理分析</a></p>
<p><a href="https://dangdangdotcom.github.io/dubbox/serialization.html">在Dubbo中使用高效的Java序列化（Kryo和FST）</a></p>
<p><a href="https://lionbule.iteye.com/blog/523355">hessian学习基础篇——序列化和反序列化</a></p>
<p><a href="https://agapple.iteye.com/blog/949266">hessian序列化源码分析</a></p>
<p><a href="https://www.jianshu.com/p/e800d8af4e22">浅析Hessian协议</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/44787200">Hessian Lite序列化简析</a></p>
<p><a href="https://segmentfault.com/a/1190000018505481">dubbo源码解析（四十二）序列化——开篇</a></p>
<p><a href="https://my.oschina.net/ywbrj042/blog/690691">dubbo典型协议、传输组件、序列化方式组合性能对比测试</a></p>
<p><a href="https://colobu.com/2015/07/21/dubbo-performance-test/">基于dubbo框架下的RPC通讯协议性能测试</a></p>
<p><a href="https://www.cnblogs.com/qujiajun/p/4070182.html">Java学习之路-Hessian学习</a></p>
<p><a href="https://blog.csdn.net/sunwei_pyw/article/details/74002351">Hessian的使用以及理解</a></p>
<p><a href="https://www.cnblogs.com/happyday56/p/4268249.html">Hessian原理分析</a></p>
<p><a href="https://blog.csdn.net/qq_28834183/article/details/80609409">分布式服务架构之Hessian原理分析(一)</a></p>
<p><a href="https://blog.csdn.net/shengqianfeng/article/details/82314269">dubbo高可用：负载均衡机制（十二）</a></p>
<p><a href="https://www.cnblogs.com/twoheads/p/10131656.html">Dubbo的负载均衡</a></p>
<p><a href="https://www.cnblogs.com/xhj123/p/9087532.html">Dubbo学习笔记7：Dubbo的集群容错与负载均衡策略</a></p>
<p><a href="http://huangzehong.me/2018/09/06/20180906-%E3%80%90Dubbo%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91%E5%9B%9B%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">【Dubbo源码分析】四种负载均衡</a></p>
<p><a href="https://m.imooc.com/article/22596">深入浅出微服务框架dubbo(三):流程篇</a></p>
<p><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html">Dubbo的负载均衡</a></p>
<p><a href="https://www.cnblogs.com/markcd/p/8504674.html">Dubbo学习源码总结系列四–集群容错机制</a></p>
<p><a href="https://www.cnblogs.com/-flq/p/9449150.html">Dubbo负载均衡与集群容错机制</a></p>
<p><a href="https://shuaijunlan.github.io/2018/09/18/dubbo-cluster-fault-tolerance/">Dubbo集群容错机制</a></p>
<p><a href="https://my.oschina.net/j4love/blog/1813040">理解 Dubbo SPI 扩展机制</a></p>
<p><a href="https://www.jianshu.com/p/a72856c77b6a">Dubbo SPI机制详解</a></p>
<p><a href="https://www.jianshu.com/p/7daa38fc9711">聊聊Dubbo（五）：核心源码-SPI扩展</a></p>
<p><a href="https://www.jianshu.com/p/99f568df0f05">dubbo源码解析-从spi聊聊双亲委派机制</a></p>
<p><a href="https://blog.csdn.net/qiangcai/article/details/77750541">dubbo之SPI解析</a></p>
<p><a href="https://blog.csdn.net/cltcl/article/details/79828648">深入剖析 dubbo spi 机制（一）——扩展点加载</a></p>
<p><a href="https://my.oschina.net/u/3847203/blog/2907025">dubbo SPI</a></p>
<p><a href="https://shuaijunlan.github.io/2018/08/03/java-spi-introduction/">深入理解Java SPI机制</a></p>
<p><a href="https://www.jianshu.com/p/6b2cab0ecaf3">dubbo SPI机制分析浅析</a></p>
<p><a href="https://wely.iteye.com/blog/2304718">Dubbo扩展点加载机制 - ExtensionLoader</a></p>
<p><a href="https://www.cnblogs.com/warehouse/p/9336293.html">Dubbo实践（七）扩展点</a></p>
<p><a href="https://www.jianshu.com/p/72079a698dce">dubbo 大白话系列-扩展点机制</a></p>
<p><a href="https://www.jianshu.com/p/e26b87bcd162">分布式服务治理框架Dubbo</a></p>
<p><a href="https://lipengjavablog.iteye.com/blog/2408331">dubbo服务治理（一）降级</a></p>
<p><a href="https://www.cnblogs.com/xuwc/p/8974709.html">dubbo超时重试和异常处理</a></p>
<p><a href="https://blog.csdn.net/Revivedsun/article/details/72851417">Dubbo 超时与重试的实现分析</a></p>
<p><a href="https://www.cnblogs.com/leechenxiang/p/6626629.html">什么是分布式系统中的幂等性</a></p>
<p><a href="https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html">分布式系统互斥性与幂等性问题的分析与解决</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30493445">什么是分布式系统中的幂等性</a></p>
<p><a href="https://www.jianshu.com/p/c3f305a1de6e">分布式系统中的幂等设计</a></p>
<p><a href="https://825635381.iteye.com/blog/2276077">高并发的核心技术-幂等的实现方案</a></p>
<p><a href="https://www.cnblogs.com/QG-whz/p/10372458.html">分布式服务的幂等性设计</a></p>
<p><a href="https://coolshell.cn/articles/4787.html">HTTP幂等性概念和应用 | 酷 壳 – CoolShell</a></p>
<p><a href="http://xiaonanbobo.com/2018/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BA%92%E6%96%A5%E6%80%A7%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/">分布式系统互斥性与幂等性问题的分析和解决</a></p>
<p><a href="http://www.chilangedu.com/blog/1000000394357140.html">基于redis(lua)和zookeeper分布式锁(秒杀)实现,分布式接口幂等实现,分布式速率限制实现,分布式ID生成器实现</a></p>
<p><a href="http://www.nginx.cn/4331.html">分布式系统的数据一致性和处理顺序问题</a></p>
<p><a href="https://www.cnblogs.com/aigongsi/archive/2012/09/21/2696773.html">关于分布式系统的数据一致性问题(一)</a></p>
<p><a href="https://elf8848.iteye.com/blog/2067771">关于分布式系统的数据一致性问题</a></p>
<p><a href="https://www.cnblogs.com/hzmark/p/consistency_model.html">谈谈分布式系统的一致性</a></p>
<p><a href="http://gaocegege.com/Blog/%E9%9A%8F%E7%AC%94/consistency">小议分布式系统的一致性模型</a></p>
<p><a href="https://my.oschina.net/fileoptions/blog/1821958">分布式系统中的时间、时钟和事件顺序</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35596768">分布式系统的一致性与共识性</a></p>
<p><a href="https://36kr.com/p/5037166">分布式系统一致性的发展历史（一）</a></p>
<p><a href="https://wudaijun.com/2018/09/distributed-consistency/">一致性杂谈</a></p>
<p><a href="https://blog.xiaohansong.com/lamport-logic-clock.html">分布式系统：Lamport 逻辑时钟</a></p>
<p><a href="http://wrran.com/blog/2017/12/28/review/distributed-system/7-consistency-and-replication/">分布式系统 - 一致性和复制</a></p>
<p><a href="http://www.dengshenyu.com/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/11/01/zookeeper.html">Zookeeper: 分布式过程协同技术详解</a></p>
<p><a href="https://draveness.me/message-delivery">分布式系统与消息的投递</a></p>
<p><a href="http://loopjump.com/distributed_consistency_model/">浅析分布式一致性模型</a></p>
<p><a href="https://dunwu.github.io/blog/2018/10/13/design/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86/">分布式原理</a></p>
<p><a href="https://qimiguang.github.io/2018/06/20/Partition/">分布式存储：Partition 细节</a></p>
<p><a href="http://www.toocruel.net/di-07ke-fen-bu-shi-wei-fu-wu-jia-gou-ti-xi-xiang-jie-fen-bu-shi-zhi-xing/">第07课：分布式微服务架构体系详解——分布式一致性</a></p>
<p><a href="http://www.10tiao.com/html/616/201605/2652227239/1.html">几种一致性模型的分析</a></p>
<p><a href="http://harlon.org/2018/04/14/distributedsystemlock/">分布式锁以及三种实现方式</a></p>
<p><a href="http://www.jasongj.com/zookeeper/distributedlock/">深入浅出Zookeeper（二） 基于Zookeeper的分布式锁与领导选举</a></p>
<p><a href="https://juejin.im/post/5ab86713f265da2398673ff2">自己用 Netty 实现一个简单的 RPC</a></p>
<p><a href="https://beck5859509.iteye.com/blog/2371301">y解读及如何设计一个简单的RPC框架</a></p>
<p><a href="https://www.cnblogs.com/haolujun/p/7527313.html">如何用一天时间实现自己的RPC框架</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004410">如何设计一个 RPC 系统</a></p>
<p><a href="https://blog.csdn.net/u012422829/article/details/78375839">如何写一个RPC框架（一）：关注点与我的实现</a></p>
<p><a href="https://blog.csdn.net/three_man/article/details/40296909">自己实现一个RPC框架</a></p>
<p><a href="https://blog.csdn.net/u013177446/article/details/66473066">【远程调用框架】如何实现一个简单的RPC框架（一）想法与设计</a></p>
<p><a href="https://www.cnkirito.moe/rpc-interface-design/">设计RPC接口时，你有考虑过这些吗？</a></p>
<p><a href="https://www.iloveqyc.com/2019/04/06/air-rpc/">从 0 到 1 编写一个 RPC 框架 (基于 Zookeeper)</a></p>
<p><a href="http://mrpeak.cn/blog/tcp-rpc-protocol/">如何设计一个通讯协议</a></p>
<p><a href="https://xilidou.com/2018/09/26/dourpc-remoting/">徒手撸框架–实现 RPC 远程调用</a></p>
<p><a href="https://ketao1989.github.io/2016/12/10/rpc-theory-in-action/">深入浅出RPC原理</a></p>
<p><a href="https://www.infoq.cn/article/weibo-rpc-practice">微博平台的 RPC 服务化实践</a></p>
<p><a href="https://yq.aliyun.com/articles/688616">高并发架构系列：如何从0到1设计一个类Dubbo的RPC框架</a></p>
<p><a href="http://www.ityouknow.com/it/2019/05/05/koalas-rpc.html">百亿级企业级 RPC 框架开源了！</a></p>
<p><a href="https://colobu.com/2016/05/26/RPCX-a-distributed-rpc-dubbo-like-framework-by-Go/">RPCX: 一个用Go实现的类似Dubbo的分布式RPC框架</a></p>
<p><a href="http://kriszhang.com/motan-rpc-impl/">从motan看RPC框架设计</a></p>
<p><a href="http://byteliu.com/2018/06/11/RPC%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/">RPC消息协议设计</a></p>
<p><a href="http://www.xuxueli.com/xxl-rpc/#/?id=%e3%80%8a%e5%88%86%e5%b8%83%e5%bc%8f%e6%9c%8d%e5%8a%a1%e9%80%9a%e8%ae%af%e6%a1%86%e6%9e%b6xxl-rpc%e3%80%8b">分布式服务框架XXL-RPC</a></p>
<p><a href="http://www.iocoder.cn/Fight/Seven-steps-to-quickly-read-RPC-framework-principles/">七个步骤，带你快速读懂 RPC 框架原理</a></p>
<p><a href="https://sq.163yun.com/blog/article/170699295282356224">网易有钱RPC框架介绍</a></p>
<p><a href="http://blog.enixjin.net/api_design_part1/">API设计，从RPC、SOAP、REST到GraphQL（一）</a></p>
<p><a href="https://waylau.com/remote-procedure-calls/">远程过程调用(RPC)详解</a></p>
<p><a href="http://www.9191boke.com/439321859.html">RPC - 麻雀虽小，五脏俱全</a></p>
<p><a href="https://my.oschina.net/u/3869066/blog/3067607">一文看懂微服务和常用的微服务落地技术</a></p>
<p><a href="http://wulc.me/2019/01/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0(1)-MapReduce/">分布式系统笔记(1)-MapReduce</a></p>
<p><a href="https://colobu.com/2017/04/06/dive-into-gRPC-streaming/">gRPC的那些事 - streaming</a></p>
<p><a href="https://blog.dingkewz.com/post/tech/go_ewan_microservices_in_golang_part_1/">用GoLang实现微服务（一）</a></p>
<p><a href="https://wuyin.io/2018/05/02/protobuf-with-grpc-in-golang/">gRPC 使用 protobuf 构建微服务</a></p>
<p><a href="https://skyao.io/learning-grpc/grpc/official_docs.html">gRPC官方文档(中文版)</a></p>
<p><a href="https://www.cnblogs.com/yjmyzz/p/grpc-hello-world.html">rpc框架之gRPC 学习 - hello world</a></p>
<p><a href="http://blog.jrwang.me/2016/grpc-at-first-view/">Google 开源 RPC 框架 gRPC 初探</a></p>
<p><a href="http://www.liuhaihua.cn/archives/430833.html">Google gRPC学习笔记</a></p>
<p><a href="https://www.familyhealth.top/?p=922">gRPC的原理和使用</a></p>
<p><a href="https://blog.csdn.net/lilyssh/article/details/84306486">自定义RPC框架实战(一) 设计思路</a></p>
<p><a href="https://blog.csdn.net/we_phone/article/details/78949331">Java打造RPC框架(一):思路</a></p>
<p><a href="https://blog.csdn.net/we_phone/article/details/78949856">Java打造RPC框架(二):11个类实现简单Java RPC</a></p>
<p><a href="https://blog.csdn.net/acmman/article/details/88370184">【RPC高性能框架总结】7.手写rpc框架-整体设计思路</a></p>
<p>视频/专栏学习资料：</p>
<p><a href="https://juejin.im/book/5af56a3c518825426642e004/section">深入理解 RPC : 基于 Python 自建分布式高并发 RPC 服务</a></p>
<p><a href="https://www.bilibili.com/video/av30612478?from=search&amp;seid=7611938649575404523">Java视频教程_Dubbo</a>  </p>
<p><a href="https://www.bilibili.com/video/av45646849?from=search&amp;seid=7611938649575404523">2019Java微服务架构(SpringBoot+Dubbo+Zookeeper)</a></p>
<p><a href="https://www.bilibili.com/video/av36799192?from=search&amp;seid=5070552182560742915">Dubbo教程-分布式项目实战演示</a></p>
<p><a href="https://www.bilibili.com/video/av50439424?from=search&amp;seid=5070552182560742915">ZooKeeper分布式专题与Dubbo微服务入门</a></p>
<p><a href="https://www.bilibili.com/video/av46991434/">老司机带你在分布式系统下掌握编程式事务以及接口的幂等性设计精髓</a></p>
<p><a href="https://www.bilibili.com/video/av30026039?from=search&amp;seid=1172859081863450406">手写RPC框架及原理分析</a></p>
<p><a href="https://www.bilibili.com/video/av44457831?from=search&amp;seid=1172859081863450406">netty入门到精通(RPC实现)</a></p>
<p><a href="https://www.bilibili.com/video/av50838032?from=search&amp;seid=1172859081863450406">如何手写RPC框架</a></p>
<p><a href="https://www.bilibili.com/video/av54523638?from=search&amp;seid=1172859081863450406">手写实现千万级流量架构必备的RPC框架</a></p>
<p><a href="https://www.bilibili.com/video/av35992521?from=search&amp;seid=1172859081863450406">RPC远程调用综合实战</a></p>
<p><a href="https://www.bilibili.com/video/av30113141?from=search&amp;seid=1172859081863450406">Rpc架构设计分析与实现</a></p>
<p><a href="https://www.bilibili.com/video/av52571925?from=search&amp;seid=1172859081863450406">分布式通信rpc教程</a></p>
<p>参考书籍：</p>
<p>《大型网站系统与Java中间件实践》</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>进击的Java面试</title>
    <url>/2019/07/02/038/</url>
    <content><![CDATA[<h2 id="1-自增自减问题"><a href="#1-自增自减问题" class="headerlink" title="1. 自增自减问题"></a>1. 自增自减问题</h2><h3 id="1-1-i"><a href="#1-1-i" class="headerlink" title="1.1 i++"></a>1.1 i++</h3><p>对于<code>i++</code>，在程序执行时会先将<code>i</code>赋值给变量，等语句执行完以后<code>i</code>的值再加1。如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先将i的值1赋给a，所以a=1。然后i再加1，i = 2</span></span><br><span class="line">    a = i++;</span><br><span class="line">    System.out.println(<span class="string">"a的值为："</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"i的值为："</span> + i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">a的值为：<span class="number">1</span></span><br><span class="line">i的值为：<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="1-2-i"><a href="#1-2-i" class="headerlink" title="1.2 ++i"></a>1.2 ++i</h3><p>对于<code>++i</code>，程序运行时先将<code> i</code>的值加1再赋值给变量，当然语句执行结束后<code>i</code>的值。如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先将i的值加1然后再赋给b，所以b=2；i=2</span></span><br><span class="line">    b = ++i;</span><br><span class="line">    System.out.println(<span class="string">"b的值为："</span> + b);</span><br><span class="line">    System.out.println(<span class="string">"i的值为："</span> + i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">b的值为：<span class="number">2</span></span><br><span class="line">i的值为：<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-3-综合问题"><a href="#1-3-综合问题" class="headerlink" title="1.3 综合问题"></a>1.3 综合问题</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    i = i++; <span class="comment">// i=1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i++; <span class="comment">// j=1,i=2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + ++i * i++; <span class="comment">// k=2+3*3=11,i=4</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"i的值为："</span>+ i);</span><br><span class="line">    System.out.println(<span class="string">"j的值为："</span>+ j);</span><br><span class="line">    System.out.println(<span class="string">"k的值为："</span>+ k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">i的值为：<span class="number">4</span></span><br><span class="line">j的值为：<span class="number">1</span></span><br><span class="line">k的值为：<span class="number">11</span></span><br></pre></td></tr></tbody></table></figure>

<p>分析：</p>
<p>通过<code>javap</code>命令对字节码进行反汇编：<code>javap -c MyCode.class</code>，得到如下信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Method descriptor #15 ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="comment">// Stack: 4, Locals: 4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[] args)</span>;</span><br><span class="line">   <span class="number">0</span>  iconst_1</span><br><span class="line">   <span class="number">1</span>  istore_1 [i]</span><br><span class="line">   <span class="number">2</span>  iload_1 [i]</span><br><span class="line">   <span class="number">3</span>  iinc <span class="number">1</span> <span class="number">1</span> [i]</span><br><span class="line">   <span class="number">6</span>  istore_1 [i]</span><br><span class="line">   <span class="number">7</span>  iload_1 [i]</span><br><span class="line">   <span class="number">8</span>  iinc <span class="number">1</span> <span class="number">1</span> [i]</span><br><span class="line">  <span class="number">11</span>  istore_2 [j]</span><br><span class="line">  <span class="number">12</span>  iload_1 [i]</span><br><span class="line">  <span class="number">13</span>  iinc <span class="number">1</span> <span class="number">1</span> [i]</span><br><span class="line">  <span class="number">16</span>  iload_1 [i]</span><br><span class="line">  <span class="number">17</span>  iload_1 [i]</span><br><span class="line">  <span class="number">18</span>  iinc <span class="number">1</span> <span class="number">1</span> [i]</span><br><span class="line">  <span class="number">21</span>  imul</span><br><span class="line">  <span class="number">22</span>  iadd</span><br><span class="line">  <span class="number">23</span>  istore_3 [k]</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>0  iconst_1</code>和<code>1  istore_1 [i]</code>表示源码中的<code>int i = 1;</code>语句：首先静态变量1被初始化，随后赋值给了变量<code>i</code>。</p>
<p><code>istore_x</code>表示将操作树栈的结果赋值给对应的局部变量。</p>
<p><code>iload_x</code>表示将局部变量的值压入操作数的栈中。</p>
<p><code>iinc</code>表示局部变量自身自增。</p>
<p><code>imul</code>表示求乘积。</p>
<p><code>iadd</code>表示求和。</p>
<p><img src="https://image.woodwhales.cn/038/images/01.png"></p>
<p><img src="https://image.woodwhales.cn/038/images/02.png" alt="02"></p>
<p><img src="https://image.woodwhales.cn/038/images/03.png" alt="03"></p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><ul>
<li>表达式中，赋值（=）最后计算</li>
<li>= 右边的从左到右依次加载值，并压入操作数栈</li>
<li>实际算哪个，看运算符的优先级</li>
<li>自增、自减操作都是直接修改变量的值，不经过操作数栈</li>
<li>最后的赋值操作之前，临时结果也是存储在操作数栈中</li>
</ul>
<blockquote>
<p>建议参考《JVM虚拟机规范》关于指令的部分。</p>
</blockquote>
<h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><p>Singleton：在Java中即指单例设计模式，它是软件开发中最常用的设计模式之一。</p>
<ul>
<li><p>单：唯一</p>
</li>
<li><p>例：实例</p>
</li>
</ul>
<p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。例如：代表JVM运行环境的<code>Runtime</code>类。</p>
<h3 id="2-1-代码实现要点"><a href="#2-1-代码实现要点" class="headerlink" title="2.1 代码实现要点"></a>2.1 代码实现要点</h3><p>实现单例模式的重要点：</p>
<ol>
<li><p>某个类只能有一个实例；</p>
<ul>
<li>代码实现：构造器私有化</li>
</ul>
</li>
<li><p>它必须自行创建这个实例</p>
<ul>
<li>代码实现：含有一个该类的静态变量来保存这个唯一的实例</li>
</ul>
</li>
<li><p>必须自行向整个系统提供这个实例</p>
<p>代码实现：对外提供获取该实例对象的方式：1）直接暴露。2）用静态变量的get方法获取。</p>
</li>
</ol>
<h3 id="2-2-单例类型"><a href="#2-2-单例类型" class="headerlink" title="2.2 单例类型"></a>2.2 单例类型</h3><h4 id="2-2-1-饿汉式"><a href="#2-2-1-饿汉式" class="headerlink" title="2.2.1 饿汉式"></a>2.2.1 饿汉式</h4><p>直接创建对象，不存在线程安全问题</p>
<ul>
<li>直接实例化饿汉式（简洁直观）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 饿汉式：</span></span><br><span class="line"><span class="comment"> * 	在类初始化时直接创建实例对象，不管你是否需要这个对象都会创建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * （1）构造器私有化</span></span><br><span class="line"><span class="comment"> * （2）自行创建，并且用静态变量保存</span></span><br><span class="line"><span class="comment"> * （3）向外提供这个实例</span></span><br><span class="line"><span class="comment"> * （4）强调这是一个单例，我们可以用final修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>{</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>枚举式（最简洁）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 枚举类型：表示该类型的对象是有限的几个</span></span><br><span class="line"><span class="comment"> * 我们可以限定为一个，就成了单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> {</span><br><span class="line">	INSTANCE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>静态代码块饿汉式（适合复杂实例化），适用于初始化一些配置文件。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE;</span><br><span class="line">	<span class="keyword">private</span> String info;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>{</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>()</span><br><span class="line">            <span class="comment">// 从配置文件中加载类名	pro.load(Singleton3.class.getClassLoader().getResourceAsStream("single.properties"));</span></span><br><span class="line">			</span><br><span class="line">			INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>(pro.getProperty(<span class="string">"info"</span>));</span><br><span class="line">		} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">(String info)</span>{</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> {</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Singleton3 [info="</span> + info + <span class="string">"]"</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-2-懒汉式"><a href="#2-2-2-懒汉式" class="headerlink" title="2.2.2 懒汉式"></a>2.2.2 懒汉式</h4><p>延迟创建对象</p>
<ul>
<li>线程不安全（适用于单线程）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式：</span></span><br><span class="line"><span class="comment"> * 	延迟创建这个实例对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (1)构造器私有化</span></span><br><span class="line"><span class="comment"> * (2)用一个静态变量保存这个唯一的实例</span></span><br><span class="line"><span class="comment"> * (3)提供一个静态方法，获取这个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span>{	</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>) {</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>线程安全（适用于多线程）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式：</span></span><br><span class="line"><span class="comment"> * 	延迟创建这个实例对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (1)构造器私有化</span></span><br><span class="line"><span class="comment"> * (2)用一个静态变量保存这个唯一的实例</span></span><br><span class="line"><span class="comment"> * (3)提供一个静态方法，获取这个实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> {</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>){</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton5.class) {</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="literal">null</span>){</span><br><span class="line">					<span class="keyword">try</span> {</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					}</span><br><span class="line">					</span><br><span class="line">					instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>静态内部类形式（适用于多线程）</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在内部类被加载和初始化时，才创建INSTANCE实例对象</span></span><br><span class="line"><span class="comment"> * 静态内部类不会自动随着外部类的加载和初始化而初始化，它是要单独去加载和初始化的。</span></span><br><span class="line"><span class="comment"> * 因为是在内部类加载和初始化时，创建的，因此是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> {</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> {	</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton6</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-走台阶算法（循环实现）"><a href="#3-走台阶算法（循环实现）" class="headerlink" title="3. 走台阶算法（循环实现）"></a>3. 走台阶算法（循环实现）</h2><p><strong>编程题</strong>：</p>
<p>有n步台阶，一次只能上1步或2步，共有多少种走法？</p>
<h3 id="3-1-思路分析"><a href="#3-1-思路分析" class="headerlink" title="3.1 思路分析"></a>3.1 思路分析</h3><p>走第 1 个台阶</p>
<ul>
<li><p>走第 1 个台阶</p>
<p>只有 1 种走法，即：走1步。</p>
</li>
<li><p>走第 2 个台阶</p>
<p>有 2 种走法，即：可以俩个 1 步，也可以走一个 2 步。</p>
</li>
<li><p>走第 3 个台阶</p>
<p>因为只能走 1 步或者 2 步，所以能走到最后一个台阶，一定是走到了前面某个台阶，再跨一步就到了最后一个台阶。</p>
<p>因此，能走到第 3 个台阶的之前一个台阶，只能以下俩种可能：</p>
<ul>
<li>走到第 1 个台阶， 再走 2 步。</li>
<li>走到第 2 个台阶，再走 1 步。</li>
</ul>
</li>
<li><p>依次类推</p>
</li>
<li><p>走第 n 个台阶（n &gt;= 3）</p>
<p>因为只能走 1 步或者 2 步，所以只能走到最后一个台阶的情况，只能是下面这俩种可能：</p>
<p>走到第 n-2 个台阶了，再走 2 步。</p>
<p>走到第 n-1 个台阶了，再走 1 步。</p>
</li>
</ul>
<p>从上述推理过程可以，推导出数学函数公式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span></span><br><span class="line">f(n) = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>), n&gt;=<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里的<code>f(n)</code>函数表示走到第 n 个台阶能走到的可能数。</p>
<h3 id="3-2-递归实现"><a href="#3-2-递归实现" class="headerlink" title="3.2 递归实现"></a>3.2 递归实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStep1</span> {</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>{</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(f(<span class="number">100</span>));<span class="comment">//165580141</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(end-start);<span class="comment">//586ms</span></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//实现f(n)：求n步台阶，一共有几种走法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">1</span>){</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(n + <span class="string">"不能小于1"</span>);</span><br><span class="line">		}</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		}</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> f(n-<span class="number">2</span>) + f(n-<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>递归实现的最大弊端在于，递归太深可能会导致栈溢出，同时递归调用很耗费CPU且耗时。</p>
<h3 id="3-3-循环实现"><a href="#3-3-循环实现" class="headerlink" title="3.3 循环实现"></a>3.3 循环实现</h3><p>在递归中，如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">f(<span class="number">2</span>) = <span class="number">1</span> </span><br><span class="line">f(<span class="number">3</span>) = f(<span class="number">1</span>) + f(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(4) = f(2) + f(3), f(3) 需要用到上一步的 f(3)，所以</span></span><br><span class="line">f(<span class="number">4</span>) = f(<span class="number">2</span>) + f(<span class="number">1</span>) + f(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(5) = f(3) + f(4), f(3) f(4) 需要用到上面的 f(3) 和 f(4)，所以</span></span><br><span class="line">f(<span class="number">5</span>) = f(<span class="number">1</span>) + f(<span class="number">2</span>) + f(<span class="number">2</span>) + f(<span class="number">1</span>) + f(<span class="number">2</span>)</span><br><span class="line">……   			</span><br></pre></td></tr></tbody></table></figure>

<p>从上面的分析可以出：<code>f(5)</code>中的<code>f(1)+f(2)</code>已经计算了2 次。</p>
<p>这算是一种不必要的浪费，可以将<code>f(1)+f(2)</code>的计算结果保存下来，在计算<code>f(4)</code>的使用这个结果能更快。</p>
<p>所以每次都到的台阶的前 2 种可能记住，那么就省去再次计算。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 循环实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStep2</span> {</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(f(<span class="number">100</span>));<span class="comment">//165580141</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(end-start);<span class="comment">//&lt;1ms</span></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">1</span>) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(n + <span class="string">"不能小于1"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>) {</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//初始化为走到第二级台阶的走法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//初始化为走到第一级台阶的走法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=n; i++) {</span><br><span class="line">			<span class="comment">//最后跨2步 + 最后跨1步的走法</span></span><br><span class="line">			sum = two + one;</span><br><span class="line">			two = one;</span><br><span class="line">			one = sum;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式系统（二）</title>
    <url>/2019/07/02/039/</url>
    <content><![CDATA[<h1 id="1-zookeeper"><a href="#1-zookeeper" class="headerlink" title="1. zookeeper"></a>1. zookeeper</h1><p>zk都有哪些使用场景？</p>
<p>ZooKeeper是一个高可用的分布式数据管理与系统协调框架。基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得ZooKeeper解决很多分布式问题</p>
<blockquote>
<p>值得注意的是，ZK并非天生就是为这些应用场景设计的，都是后来众多开发者根据其框架的特性，利用其提供的一系列API接口（或者称为原语集），摸索出来的典型使用方法。</p>
</blockquote>
<h2 id="1-1-分布式协调"><a href="#1-1-分布式协调" class="headerlink" title="1.1 分布式协调"></a>1.1 分布式协调</h2><p>分布式协调/通知服务是分布式系统中将不同的分布式组件结合起来。</p>
<p>通常需要一个协调者来控制整个系统的运行流程，这个协调者便于将分布式协调的职责从应用中分离出来，从而可以大大减少系统之间的耦合性，而且能够显著提高系统的可扩展性。</p>
<p>ZooKeeper中特有的<code>Watcher</code>注册与异步通知机制，能够很好地实现分布式环境下不同机器，甚至是不同系统之间的协调与通知，从而实现对数据变更的实时处理。</p>
<p><strong>常用做法</strong></p>
<p>不同系统都对ZK上同一个<code>znode</code>进行注册，监听<code>znode</code>的变化（包括znode本身内容及子节点的），其中一个系统<code>update</code>了znode，那么另一个系统能够收到通知，并作出相应处理。</p>
<h2 id="1-2-分布式锁"><a href="#1-2-分布式锁" class="headerlink" title="1.2 分布式锁"></a>1.2 分布式锁</h2><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同的系统或是同一个系统的不同主机之间共享一个或一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段来防止彼此之间的干扰，以保证一致性，在这种情况下，需要使用分布式锁。</p>
<p>ZooKeeper 可用于分布式锁，这个主要得益于zk为我们保证了数据的强一致性。锁服务可以分为两类，一个是<strong>保持独占</strong>，另一个是<strong>控制时序</strong>。</p>
<h3 id="1-2-1-保持独占"><a href="#1-2-1-保持独占" class="headerlink" title="1.2.1 保持独占"></a>1.2.1 保持独占</h3><p>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。</p>
<p><strong>常用做法</strong></p>
<p>通常的做法是把zk上的一个<code>znode</code>看作是一把锁，通过<code>create znode</code>的方式来实现。所有客户端都去创建<code>/distribute_lock</code>节点，最终成功创建的那个客户端也即拥有了这把锁。</p>
<h3 id="1-2-2-控制时序"><a href="#1-2-2-控制时序" class="headerlink" title="1.2.2 控制时序"></a>1.2.2 控制时序</h3><p>控制时序，就是所有视图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。</p>
<p><strong>常用做法</strong></p>
<p>做法和上面基本类似，只是这里<code>/distribute_lock</code>已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：<code>CreateMode.EPHEMERAL_SEQUENTIAL</code>来指定）。Zk的父节点（<code>/distribute_lock</code>）维持一份<code>sequence</code>，保证子节点创建的时序性，从而也形成了每个客户端的全局时序。</p>
<h2 id="1-3-数据发布与订阅（配置中心）"><a href="#1-3-数据发布与订阅（配置中心）" class="headerlink" title="1.3 数据发布与订阅（配置中心）"></a>1.3 数据发布与订阅（配置中心）</h2><blockquote>
<p>集群中配置文件的更新和同步十分频繁：</p>
<ul>
<li><p>传统的配置文件分发都是需要把配置文件数据分发到每台worker上，然后进行worker的reload，这种方式是最笨的方式，结构很难维护，因为如果集群当中有可能很多种应用的配置文件要同步，而且效率很低，集群规模一大负载很高。</p>
</li>
<li><p>还有一种就是每次更新把配置文件单独保存到一个数据库里面，然后worker端定期pull数据，这种方式就是数据及时性得不到同步。</p>
</li>
</ul>
</blockquote>
<p>发布与订阅模型，即所谓的元数据/配置中心，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。</p>
<ul>
<li>应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候会主动来获取一次配置，同时，在节点上注册一个Watcher，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从来达到获取最新配置信息的目的。</li>
<li>分布式搜索服务中，索引的元信息和服务器集群机器的节点状态存放在ZK的一些指定节点，供各个客户端订阅使用。</li>
<li>分布式日志收集系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的节点P，并将这个应用的所有机器ip，以子节点的形式注册到节点P上，这样一来就能够实现机器变动的时候，能够实时通知到收集器调整任务分配。</li>
<li>系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发文。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息。引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK节点上即可。</li>
</ul>
<p><strong>注意</strong>：在上面提到的应用场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。</p>
<h2 id="1-4-Master节点管理"><a href="#1-4-Master节点管理" class="headerlink" title="1.4 Master节点管理"></a>1.4 Master节点管理</h2><blockquote>
<p>集群当中最重要的是Master，所以一般都会设置一台Master的Backup。</p>
<p>Backup会定期向Master获取Meta信息并且检测Master的存活性，一旦Master挂了，Backup立马启动，接替Master的工作自己成为Master，分布式的情况多种多样，因为涉及到了网络的抖动，针对下面的情况：</p>
<ul>
<li><p>Backup检测Master存活性传统的就是定期发包，一旦一定时间段内没有收到响应就判定Master Down了，于是Backup就启动。</p>
<p>如果Master其实是没有down，Backup收不到响应或者收到响应延迟的原因是因为网络阻塞的问题，此时Backup不知道Master是假的挂了，于是也启动了，这时候集群里就有了两个Master，很有可能部分workers汇报给Master，另一部分workers汇报给后来启动的Backup，这下子服务就全乱了。</p>
</li>
<li><p>Backup是定期同步Master中的meta信息，所以总是滞后的，一旦Master挂了，Backup的信息必然是老的，很有可能会影响集群运行状态。</p>
</li>
</ul>
</blockquote>
<p>zookeeper Master选举解决问题：</p>
<p>1）Master节点高可用，并且保证唯一。</p>
<p>Zookeeper为我们保证了数据的强一致性，即：zookeeper集群中任意节点上相同的znode数据一定是相同的。</p>
<p>也就是说，如果同时有多个客户端请求创建同一个临时节点，那么最终一定只有一个客户端 请求能够创建成功。</p>
<p>利用这个特性，就能很容易地在分布式环境中进行 Master 选举了。</p>
<p>成功创建该节点的客户端所在的机器就成为了 Master。同时，其他没有成功创建该节点的 客户端，都会在该节点上注册一个子节点变更的 Watcher，用于监控当前 Master 机器是否存 活，一旦发现当前的Master挂了，那么其他客户端将会重新进行 Master 选举。</p>
<p>2）Meta信息的及时同步。</p>
<p>zookeeper 会分配给注册到它上面的客户端一个编号，并且 zk 自己会保证这个编号的唯一性和递增性，N多机器中只需选出编号最小的 Client 作为 Master 就行，并且保证这些机器的都维护一个一样的 meta 信息视图，一旦 Master 挂了，那么这N机器中编号最小的胜任 Master，Meta 信息是一致的。</p>
<h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h1><p>一般实现分布式锁都有哪些方式？使用redis如何设计分布式锁？使用zk来设计分布式锁可以吗？这两种分布式锁的实现方式哪种效率比较高？</p>
<h2 id="2-1-redis分布式锁"><a href="#2-1-redis分布式锁" class="headerlink" title="2.1 redis分布式锁"></a>2.1 redis分布式锁</h2><h3 id="2-1-1-获取锁"><a href="#2-1-1-获取锁" class="headerlink" title="2.1.1 获取锁"></a>2.1.1 获取锁</h3><blockquote>
<p>Redis 分布式加锁的主要流程</p>
<ul>
<li>产生随机数，可用UUID，存储起来，一般存储在ThreadLocal中，以便解锁用。</li>
<li>调用Redis 的SETNX命令将随机数当作value存入，key为taskId，同时设置过期时间。（实际项目中过期时间的多少主要是取决任务估算的执行时间，一般为估算执行时间*2，如该任务的估算时间是2m，则过期就要设置4m）。</li>
<li>如果返回ok，说明加锁成功，否则失败。</li>
</ul>
</blockquote>
<p>redis是一种key-value形式的NOSQL数据库，常用于作服务器的缓存。从redis v2.6.12开始，set命令开始变成如下格式：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></tbody></table></figure>

<p>除 key 和 value 外，<code>EX</code>是超时时间，<code>NX</code>表示只有在 key 不存在的时候才会设置 key 的值，而<code>XX</code>表示在 key 存在的时间才会设置 key 的值。<strong>NX机制就是基于redis分布式锁的核心。</strong>能够解决以下问题：</p>
<ul>
<li><p>节点1获取key，并且设置超时时间后，还没来得及释放就挂掉了</p>
<p>这里<code>EX</code>超时时间会发挥作用，超时后自动释放锁。</p>
</li>
<li><p>刚获取到锁，还没来得及设置超时时间就挂了</p>
<p>这里设置key和设置超时时间是原子操作，如果出现这种情况，会返回0，即获取不到锁。</p>
</li>
</ul>
<h3 id="2-1-2-释放锁"><a href="#2-1-2-释放锁" class="headerlink" title="2.1.2 释放锁"></a>2.1.2 释放锁</h3><blockquote>
<p>Redis分布式解锁的主要流程</p>
<ul>
<li>调用lua脚本进行解锁，保证原子性。</li>
<li>Lua脚本实现：判断key的值和我们存入的UUID随机数是不是相等，是的话，则调用DEL指令进行删除操作。</li>
</ul>
</blockquote>
<p>为了解决非原子操作带来的问题，常采用<code>lua</code>脚本实现。lua脚本的操作会被认为是原子性的，类似于事务。</p>
<p>伪代码如下：</p>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">String luaScript =</span><br><span class="line"><span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] "</span>+</span><br><span class="line"><span class="string">"then return redis.call('del', KEYS[1]) "</span>+</span><br><span class="line"><span class="string">"else return 0 end"</span>;</span><br><span class="line">redisClient.eval(luaScript , Collections.singletonList(key), Collections.singletonList(threadId)); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-zk分布式锁"><a href="#2-2-zk分布式锁" class="headerlink" title="2.2 zk分布式锁"></a>2.2 zk分布式锁</h2><p>zookeeper是一种分布式协调服务，其中每个节点称为znode，并有自己独立的路径。 </p>
<p><code>znode</code>有四种类型：</p>
<ul>
<li><p><strong>持久节点</strong></p>
<p>默认的节点类型。创建节点的客户端与zk断开连接后，该节点依旧存在 。</p>
</li>
<li><p><strong>持久节点顺序节点</strong></p>
<p>所谓顺序节点，就是在创建节点时，zk根据创建的时间顺序给该节点名称进行编号。</p>
</li>
<li><p><strong>临时节点</strong></p>
<p>和持久节点相反，当创建节点的客户端与zk断开连接后，临时节点会被删除。</p>
</li>
<li><p><strong>临时顺序节点</strong></p>
<p>结合和临时节点和顺序节点的特点：在创建节点时，zk根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</p>
</li>
</ul>
<p>下面看看是怎样基于上面的四类节点实现分布式锁的。</p>
<p><strong>1、获取锁</strong></p>
<p>1）在 zk 当中创建一个持久节，当第一个客户端Client1想要获得锁时，需要在这个节点下面创建一个临时顺序节点。</p>
<p>2）Client1查找持久节点下面所有的临时顺序节点并排序，判断自己所创建的节点是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</p>
<p>3）如果再有一个客户端 Client2 前来获取锁，则在持久节点下面再创建一个临时顺序节点Lock2。</p>
<p>4）Client2查找持久节点下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是顺序最靠前的一个，结果发现节点Lock2并不是最小的。</p>
<p>于是，Client2向排序仅比它靠前的节点Lock1注册Watcher，用于监听Lock1节点是否存在。这意味着Client2抢锁失败，进入了等待状态。</p>
<p>5）如果又有一个客户端Client3前来获取锁，则在持久节点下载再创建一个临时顺序节点Lock3。</p>
<p>Client3查找持久节点下面所有的临时顺序节点并排序，判断自己所创建的节点Lock3是不是顺序最靠前的一个，结果同样发现节点Lock3并不是最小的。</p>
<p>于是，Client3向排序仅比它靠前的节点Lock2注册Watcher，用于监听Lock2节点是否存在。这意味着Client3同样抢锁失败，进入了等待状态。</p>
<p><strong>2、释放锁</strong></p>
<p>释放锁就比较简单了，因为前面创建的临时顺序节点，所以在出现下面两种情况时，都会自动释放锁：</p>
<p>1）任务完成后，Client会释放锁。</p>
<p>2）任务没完成，也就是Client就崩溃了，zk会检测这个client挂了，就会自动释放锁。</p>
<h1 id="3-分布式会话"><a href="#3-分布式会话" class="headerlink" title="3. 分布式会话"></a>3. 分布式会话</h1><p>集群部署时的分布式session如何实现？</p>
<h2 id="3-1-Tomcat-Redis"><a href="#3-1-Tomcat-Redis" class="headerlink" title="3.1 Tomcat + Redis"></a>3.1 Tomcat + Redis</h2><p>分布式系统在集群部署后需要实现session共享，针对 tomcat 服务器的实现方案多种多样，比如 tomcat cluster session 广播、nginx IP hash策略、nginx sticky module等方案，常见的分布式会话是使用 redis 服务器进行 session 统一存储管理的共享方案。</p>
<h3 id="3-1-1-nginx-负载均衡配置"><a href="#3-1-1-nginx-负载均衡配置" class="headerlink" title="3.1.1 nginx 负载均衡配置"></a>3.1.1 nginx 负载均衡配置</h3><p>1）修改nginx conf配置文件加入</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">upstream tomcat {</span><br><span class="line">    server 127.0.0.1:8110;</span><br><span class="line">    server 127.0.0.1:8120;</span><br><span class="line">    server 127.0.0.1:8110;</span><br><span class="line">    server 127.0.0.1:8110;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，配置 相应的server或者<code>location</code>地址到 <a href="http://tomcat/">http://tomcat</a></p>
<h3 id="3-1-2-tomcat-session共享配置步骤"><a href="#3-1-2-tomcat-session共享配置步骤" class="headerlink" title="3.1.2 tomcat session共享配置步骤"></a>3.1.2 tomcat session共享配置步骤</h3><p>1）添加redis session集群依赖的jar包到<code>TOMCAT_BASE/lib</code>目录下</p>
<ul>
<li>tomcat-redis-session-manager-2.0.0.jar</li>
<li>jedis-2.5.2.jar</li>
<li>commons-pool2-2.2.jar</li>
</ul>
<p>2）修改<code>TOMCAT_BASE/conf</code>目录下的<code>context.xml</code>文件</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">host</span>=<span class="string">"localhost"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">port</span>=<span class="string">"6379"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">database</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">sessionPersistPolicies</span>=<span class="string">"PERSIST_POLICY_1,PERSIST_POLICY_2,.."</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">sentinelMaster</span>=<span class="string">"SentinelMasterName"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">sentinels</span>=<span class="string">"sentinel-host-1:port,sentinel-host-2:port,.."</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>属性解释：</p>
<ul>
<li><p><code>host</code>：redis服务器地址，可选用，默认”localhost”</p>
</li>
<li><p><code>port</code>：redis服务器的端口号，可选用，默认”6379”</p>
</li>
<li><p><code>database</code>：要使用的redis数据库索引，可选用，默认”0”</p>
</li>
<li><p><code>maxInactiveInterval</code>：session最大空闲超时时间（失效时间，单位秒），如果不填则使用tomcat的超时时长，一般tomcat默认为 1800 即半个小时</p>
</li>
<li><p><code>sessionPersistPolicies</code>：session保存策略，除了默认的策略还可以选择的策略有：</p>
</li>
</ul>
<blockquote>
<p><code>SAVE_ON_CHANGE</code>：每次 session.setAttribute() 、 session.removeAttribute() 触发都会保存。</p>
<p>注意：此功能无法检测已经存在redis的特定属性的变化。<br>权衡：这种策略会略微降低会话的性能，任何改变都会保存到redis中。</p>
<p><code>ALWAYS_SAVE_AFTER_REQUEST</code>：每一个request请求后都强制保存，无论是否检测到变化。</p>
<p>注意：对于更改一个已经存储在redis中的会话属性，该选项特别有用。<br>权衡：如果不是所有的request请求都要求改变会话属性的话不推荐使用，因为会增加并发竞争的情况。 </p>
</blockquote>
<ul>
<li><strong>sentinelMaster</strong>	redis集群主节点名称（Redis集群是以分片(Sharding)加主从的方式搭建，满足可扩展性的要求）</li>
<li><strong>sentinels</strong>	redis集群列表配置（类似zookeeper，通过多个Sentinel来提高系统的可用性）</li>
</ul>
<p>3）重启tomcat，session存储即可生效。</p>
<h2 id="3-2-Spring-Session-Redis"><a href="#3-2-Spring-Session-Redis" class="headerlink" title="3.2 Spring Session + Redis"></a>3.2 Spring Session + Redis</h2><p>虽然<code>tomcat + redis</code>的方案很好用，但是会严重依赖于web容器，不方便将代码移植到其他web容器上去，尤其是换了技术栈，比如换成了spring cloud或者是spring boot之类的。</p>
<p>Spring家族中的一个项目<code>Spring Session</code>可以来实现session的共享。现在Web项目几乎都使用了Spring，既然Spring全家桶里提供这种方案，所以还是建议使用这种方式。</p>
<blockquote>
<p>官方参考文档：</p>
<p>Spring Session 快速入门：<a href="https://spring.io/projects/spring-session#samples">https://spring.io/projects/spring-session#samples</a></p>
</blockquote>
<h3 id="3-2-1-pom文件添加依赖"><a href="#3-2-1-pom文件添加依赖" class="headerlink" title="3.2.1 pom文件添加依赖"></a>3.2.1 pom文件添加依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<p>这里我使用的 Spring Boot 版本是 2.1.4 ，如果使用当前最新版 Spring Boot2.1.5 的话，除了上面这些依赖之外，需要额外添加 Spring Security 依赖（其他操作不受影响，仅仅只是多了一个依赖，当然也多了 Spring Security 的一些默认认证流程）。</p>
<h3 id="3-2-2-spring-配置"><a href="#3-2-2-spring-配置" class="headerlink" title="3.2.2 spring 配置"></a>3.2.2 spring 配置</h3><figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.0.1</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里的 Redis 配置虽然配置了四行，但是考虑到端口默认就是 6379 ，database 默认就是 0，所以真正要配置的，其实就是两行。</p>
<p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> {</span><br><span class="line">    <span class="meta">@Value("${server.port}")</span></span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="meta">@GetMapping("/set")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(HttpSession session)</span> {</span><br><span class="line">        session.setAttribute(<span class="string">"user"</span>, <span class="string">"javaboy"</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(port);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@GetMapping("/get")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(HttpSession session)</span> {</span><br><span class="line">        <span class="keyword">return</span> session.getAttribute(<span class="string">"user"</span>) + <span class="string">":"</span> + port;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>考虑到一会 Spring Boot 将以集群的方式启动 ，为了获取每一个请求到底是哪一个 Spring Boot 提供的服务，需要在每次请求时返回当前服务的端口号，因此这里注入了 server.port 。</p>
<h1 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4. 分布式事务"></a>4. 分布式事务</h1><p>分布式事务了解吗？你们如何解决分布式事务问题的？</p>
<h2 id="4-1-两阶段提交（2PC-XA）"><a href="#4-1-两阶段提交（2PC-XA）" class="headerlink" title="4.1 两阶段提交（2PC/XA）"></a>4.1 两阶段提交（2PC/XA）</h2><p>两阶段提交（Two-phase Commit，2PC，又叫 XA Transactions），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<p>2PC 是一个两阶段提交协议，该协议分为下面两个阶段：</p>
<ul>
<li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并反映是否可以提交。</li>
<li>第二阶段：事务协调器要求每个数据库提交数据。</li>
</ul>
<p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p>
<p>优点：</p>
<ul>
<li>尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。</li>
</ul>
<p>缺点：</p>
<ul>
<li>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>
<li>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li>
<li>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能。</li>
</ul>
<p>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p>
<p>总的来说，XA 协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。</p>
<h2 id="4-2-补偿事务（TCC）"><a href="#4-2-补偿事务（TCC）" class="headerlink" title="4.2 补偿事务（TCC）"></a>4.2 补偿事务（TCC）</h2><p>TCC 事务机制相比于上面介绍的 XA，解决了如下几个缺点：</p>
<ul>
<li>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li>
<li>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li>
<li>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。</li>
</ul>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<p>注意Confirm 和 Cancel要保证操作的幂等性。</p>
<blockquote>
<p>举个简单的例子：比如跨银行转账的时候，要涉及到两个银行的分布式事务，如果用TCC方案来实现，思路如下：</p>
<p>1）Try阶段：先检测两个账户是不可以进行交易（如A转B之前，A的余额足不足，AB是否被冻住等），可以交易则把两个银行账户中的资金给它冻结住，不任何其他人操作。</p>
<p>2）Confirm阶段：执行实际的转账操作，A银行账户的资金扣减，B银行账户的资金增加</p>
<p>3）Cancel阶段：如果任何一个银行的操作执行失败，那么就需要回滚进行补偿，比如A银行账户如果已经扣减了，但是B银行账户资金增加失败了，那么就得把A银行账户资金给加回去。</p>
<p>对于 TCC 来说适合一些：</p>
<ul>
<li>强隔离性，严格一致性要求的活动业务。</li>
<li>执行时间较短的业务。</li>
</ul>
</blockquote>
<p>这种方案只适用金融金钱等十分核心的业务，因为这个事务回需要适用大量的代码来来控制事务逻辑，代码和业务的耦合度十分高。</p>
<h2 id="4-3-本地消息表（异步确保）"><a href="#4-3-本地消息表（异步确保）" class="headerlink" title="4.3 本地消息表（异步确保）"></a>4.3 本地消息表（异步确保）</h2><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案。</p>
<blockquote>
<p>原文：<a href="https://queue.acm.org/detail.cfm?id=1394128">https://queue.acm.org/detail.cfm?id=1394128</a></p>
</blockquote>
<p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。</p>
<p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p>
<p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p>
<p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p>
<blockquote>
<p>通俗地讲：</p>
<p>1）A系统在自己本地一个事务里操作同时，插入一条数据到消息表。</p>
<p>2）接着A系统将这个消息发送到MQ中去。</p>
<p>3）B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息。</p>
<p>4）B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态。</p>
<p>5）如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有没处理的消息，会再次发送到MQ中去，让B再次处理。</p>
<p>6）这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。</p>
</blockquote>
<p>但是这个方案最大的问题就在于严重依赖于数据库的消息表来管理事务，高并发场景不适用，扩展性也不好。</p>
<p>本地消息队列是<code>BASE 理论</code>，是最终一致模型，适用于对一致性要求不高的情况。实现这个模型时需要注意重试的幂等。</p>
<h2 id="4-4-MQ-事务"><a href="#4-4-MQ-事务" class="headerlink" title="4.4 MQ 事务"></a>4.4 MQ 事务</h2><p>在 RocketMQ 中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了 MQ 内部。</p>
<p>基本流程如下：</p>
<p>1）A系统向消息中间件发送一条预备消息</p>
<p>2）消息中间件保存预备消息并返回成功</p>
<p>3）A执行本地事务</p>
<p>4）A发送提交消息给消息中间件</p>
<p>通过以上4步完成了一个消息事务。</p>
<p>对于以上的 4 个步骤，每个步骤都可能产生错误，下面一一分析：</p>
<p>步骤一出错，则整个事务失败，不会执行A的本地操作。</p>
<p>步骤二出错，则整个事务失败，不会执行A的本地操作。</p>
<p>步骤三出错，这时候需要回滚预备消息，怎么回滚？</p>
<p>答案是 A 系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查 A 事务执行是否执行成功，如果失败则回滚预备消息。</p>
<p>步骤四出错，这时候 A 的本地事务是成功的，那么消息中间件要回滚A吗？</p>
<p>答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务。</p>
<p><img src="https://image.woodwhales.cn/039/images/01.png"></p>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个：</p>
<ul>
<li><p>消息事务（A系统的本地操作+发消息）</p>
</li>
<li><p>B系统的本地操作</p>
</li>
</ul>
<p>其中B系统的操作由消息中间件的消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息消费消息，去执行本地操作：</p>
<p>如果B本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。</p>
<blockquote>
<p>消息重投之前会再调用一次A操作的结果，一定是成功的，因为这个消息能被中间件存起来并打算给消费者消息，那么这条消息一定是成功的，只是消费者没有成功消费。</p>
</blockquote>
<h1 id="扩展博文"><a href="#扩展博文" class="headerlink" title="扩展博文"></a>扩展博文</h1><p><a href="https://www.cnblogs.com/niechen/p/8597344.html">zookeeper快速入门</a></p>
<p><a href="https://blog.csdn.net/liweisnake/article/details/63251252">zookeeper入门系列-概述</a></p>
<p><a href="https://blog.csdn.net/liyiming2017/article/details/83035157">原创ZooKeeper入门实战教程（一）-介绍与核心概念</a></p>
<p><a href="https://www.cnblogs.com/xymqx/p/4465610.html">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></p>
<p><a href="https://www.cnblogs.com/leocook/p/zk_0.html">ZooKeeper学习总结 第一篇：ZooKeeper快速入门</a></p>
<p><a href="https://www.cnblogs.com/gaojy/p/6635026.html">zookeeper入门与实践</a></p>
<p><a href="https://www.cnblogs.com/luxiaoxun/p/4887452.html">ZooKeeper基本原理</a></p>
<p><a href="https://wely.iteye.com/blog/2228976">zookeeper原理入门</a></p>
<p><a href="http://www.firefoxbug.com/index.php/archives/2556/">zookeeper基本原理</a></p>
<p><a href="https://www.jianshu.com/p/1f4c70d7ef40">ZooKeeper入门教程（一）</a></p>
<p><a href="https://www.iteblog.com/archives/904.html">Zookeeper 3.4.5分布式安装手册</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/30024403">ZooKeeper基本原理及安装部署</a></p>
<p><a href="https://www.cnblogs.com/zhengbin/p/10401058.html">详解Zookeeper原理与应用场景</a></p>
<p><a href="https://www.cnblogs.com/tommyli/p/3766189.html">ZooKeeper典型应用场景一览</a></p>
<p><a href="https://www.owenzhang.net/blog/131.html">ZOOKEEPER典型应用场景解析</a></p>
<p><a href="https://blog.csdn.net/yunpiao123456/article/details/51888342">Zookeeper基本原理与应用场景</a></p>
<p><a href="http://www.wuzesheng.com/?p=2609">ZooKeeper原理及使用</a></p>
<p><a href="https://draveness.me/zookeeper-chubby">详解分布式协调服务 ZooKeeper</a></p>
<p><a href="https://cshihong.github.io/2018/06/03/ZooKeeper%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/">ZooKeeper技术原理</a></p>
<p><a href="https://xuliugen.gitbooks.io/javaweb-1/112-zookeeper-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html">zookeeper-基本原理</a></p>
<p><a href="https://www.jianshu.com/p/2e970fe35c3f">ZooKeeper应用场景及方案介绍</a></p>
<p><a href="http://bk.poph163.com/2018/07/25/zookeeper%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/">Zookeeper由浅入深</a></p>
<p><a href="https://www.jianshu.com/p/cfcacc87d74a">ZooKeeper应用场景</a></p>
<p><a href="http://www.dczou.com/viemall/467.html">zookeeper典型应用场景之一：master选举</a></p>
<p><a href="https://vimsky.com/article/292.html">ZooKeeper典型使用场景一览</a></p>
<p><a href="https://goreliu.github.io/zookeeper-he-etcd-shi-yong-chang-jing.html">Zookeeper 和 etcd 使用场景 </a></p>
<p><a href="http://www.wangt.cc/2017/12/zookeeper%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">zookeeper的应用场景</a></p>
<p><a href="https://blog.51cto.com/snowtiger/2073908">Zookeeper的几个应用场景</a></p>
<p><a href="https://juejin.im/post/5cfe0617e51d45777540fd85">【分布式解决方案】ZooKeeper经典应用场景</a></p>
<p><a href="http://www.laphilee.com/posts/21319.html">zookeeper基本原理及适用场景</a></p>
<p><a href="http://www.blogjava.net/jinfeng_wang/archive/2017/02/03/432286.html">基于ZooKeeper的分布式系统的应用场景</a></p>
<p><a href="https://www.cnblogs.com/sky-sql/p/6804467.html">ZooKeeper 典型应用场景-Master选举</a></p>
<p><a href="https://www.jianshu.com/p/e72baf5e5617">实践基于Redis的分布式锁</a></p>
<p><a href="http://ifeve.com/redis-lock/">用Redis构建分布式锁</a></p>
<p><a href="https://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/">基于 Redis 的分布式锁</a></p>
<p><a href="http://blueskykong.com/2018/01/06/redislock/">基于redis的分布式锁实现</a></p>
<p><a href="https://juejin.im/post/5b737b9b518825613d3894f4">redis系列：分布式锁</a></p>
<p><a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">基于Redis的分布式锁到底安全吗（上）？</a></p>
<p><a href="https://segmentfault.com/a/1190000012919740">基于redis的分布式锁实现</a></p>
<p><a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/">Redis分布式锁的正确实现方式（Java版）</a></p>
<p><a href="https://www.cnblogs.com/0201zcr/p/5942748.html">jedisLock—redis分布式锁实现</a></p>
<p><a href="http://tech.dianwoda.com/2018/04/11/redisfen-bu-shi-suo-jin-hua-shi/">Redis分布式锁进化史</a></p>
<p><a href="https://blog.csdn.net/canot/article/details/79945895">使用redis实现分布式锁</a></p>
<p><a href="https://benjaminwhx.com/2018/08/26/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E5%A7%BF%E5%8A%BF/">Redis分布式锁的正确实现姿势</a></p>
<p><a href="https://sanyuesha.com/2016/08/20/distributed-lock-with-redis/">如何用 redis 造一把分布式锁</a></p>
<p><a href="http://blog.itpub.net/69917606/viewspace-2642811/">Redlock：Redis分布式锁最牛逼的实现</a></p>
<p><a href="https://juejin.im/post/5bf3f15851882526a643e207">拜托，面试请不要再问我Redis分布式锁的实现原理！【石杉的架构笔记】</a></p>
<p><a href="https://juejin.im/post/5c01532ef265da61362232ed">七张图彻底讲清楚ZooKeeper分布式锁的实现原理【石杉的架构笔记】</a></p>
<p><a href="https://imfox.io/2016/01/30/redis-lock/">Redis 分布式锁</a></p>
<p><a href="https://www.ricefur.cn/topics/131/redis-distributed-lock">Redis-分布式锁</a></p>
<p><a href="https://www.cnblogs.com/jpcflyer/p/9142813.html">分布式锁的两种实现方式（基于redis和基于zookeeper）</a></p>
<p><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/90036180">Springboot分别使用乐观锁和分布式锁（基于redisson）完成高并发防超卖</a></p>
<p><a href="https://juejin.im/post/59f592c65188255f5c5142d2">Redis RedLock 完美的分布式锁么？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/40915772">基于 Redis 的分布式锁 Redlock</a></p>
<p><a href="https://www.jianshu.com/p/fba7dd6dcef5">RedLock算法-使用redis实现分布式锁服务</a></p>
<p><a href="https://blog.brickgao.com/2018/05/06/distributed-lock-with-redlock/">通过 Redlock 实现分布式锁</a></p>
<p><a href="%5Bhttps://blog.wangqi.love/articles/distributed/Redlock%E7%AE%97%E6%B3%95.html%5D(https://blog.wangqi.love/articles/distributed/Redlock%E7%AE%97%E6%B3%95.html)">Redlock算法</a></p>
<p><a href="https://www.cnblogs.com/cc11001100/p/10269494.html">zookeeper笔记之基于zk实现分布式锁</a></p>
<p><a href="https://www.cnblogs.com/wangiqngpei557/p/10323149.html">zookeeper 实现分布式锁安全用法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/48586740">使用zookeeper实现分布式锁</a></p>
<p><a href="https://juejin.im/post/5c13bea65188251595128d4b">分布式Session共享解决方案</a></p>
<p><a href="https://www.jianshu.com/p/3dd4e06bdfa4">细说分布式Session管理</a></p>
<p><a href="https://blog.csdn.net/u010028869/article/details/50773174?ref=myread">【Linux运维-集群技术进阶】集群/分布式环境下5种session处理策略</a></p>
<p><a href="https://blog.csdn.net/qq_32331073/article/details/80292780">分布式Session之坑：分布式Session的使用场景</a></p>
<p><a href="http://ifeve.com/dis-session-manager/">大型网站之分布式会话管理</a></p>
<p><a href="https://my.oschina.net/u/3967312/blog/2988763">分布式Session共享解决方案</a></p>
<p><a href="https://www.cnblogs.com/study-everyday/p/7853145.html">分布式系统session一致性的问题</a></p>
<p><a href="https://segmentfault.com/a/1190000011091273">基于 spring-session 解决分布式 session 共享问题</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1096878">一文读懂分布式Session常见解决方案</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1080833">微服务架构下的分布式Session管理（PPT详解）</a></p>
<p><a href="https://www.ktanx.com/blog/p/4777">redis实现分布式session共享</a></p>
<p><a href="http://www.hzkangs.com/archives/123">分布式-Redis+SpringSession实现session共享</a></p>
<p><a href="http://www.dczou.com/viemall/382.html">分布式Session管理实战</a></p>
<p><a href="https://www.letiantian.me/2013-09-01-redis-session-manager/">基于Redis的分布式会话管理系统</a></p>
<p><a href="https://www.breakyizhan.com/java/7138.html">Java中，分布式session存储解决方案</a></p>
<p><a href="https://tech.meituan.com/2016/10/14/mt-mtrace.html">分布式会话跟踪系统架构设计与实践</a></p>
<p><a href="http://congboss.top/2018/05/15/%E5%88%86%E5%B8%83%E5%BC%8Fsession/">分布式session</a></p>
<p><a href="https://blog.soaer.com/1/71c674d268e24007b939f1ea7d8437e5.html">Session在分布式系统中实现方式</a></p>
<p><a href="https://www.cnblogs.com/liuning8023/p/4874488.html">大型网站之分布式会话管理</a></p>
<p><a href="http://www.voycn.com/article/fenbushisessiondejizhongshixianfangshi">分布式Session的几种实现方式</a></p>
<p><a href="http://www.glmapper.com/2018/11/24/springsessionthree/">SpringSession系列-分布式Session实现方案</a></p>
<p><a href="https://blog.csdn.net/xiao__gui/article/details/52706243">Spring Session + Redis实现分布式Session共享</a></p>
<p><a href="https://segmentfault.com/a/1190000009591087">搭建Tomcat集群&amp;通过Redis缓存共享session的一种流行方案</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/9541551.html">Tomcat通过Redis实现session共享的完整部署记录</a></p>
<p><a href="https://blog.csdn.net/jerome_s/article/details/52658946">分布式集群Session共享 简单多tomcat8+redis的session共享实现</a></p>
<p><a href="https://github.com/izerui/tomcat-redis-session-manager">tomcat-redis-session-manager</a></p>
<p><a href="https://juejin.im/post/5cf5bc6ae51d45775313817b">Spring Boot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></p>
<p><a href="https://www.docs4dev.com/docs/zh/spring-session/2.1.2.RELEASE/reference/httpsession.html">HttpSession集成</a></p>
<p><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案</a></p>
<p><a href="https://juejin.im/post/5aa3c7736fb9a028bb189bca">常用的分布式事务解决方案</a></p>
<p><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b">再有人问你分布式事务，把这篇扔给他</a></p>
<p><a href="http://www.codeceo.com/article/spring-transactions.html">深入理解 Spring 事务原理</a></p>
<p><a href="http://www.codeceo.com/article/distributed-transaction.html">深入理解分布式事务</a></p>
<p><a href="https://dbaplus.cn/news-159-1929-1.html">分布式事务主流解决方案优缺点大pk</a></p>
<p><a href="https://weibo.com/ttarticle/p/show?id=2309403965965003062676">保证分布式系统数据一致性的6种方案</a></p>
<p><a href="https://github.com/TFdream/blog/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">分布式事务解决方案</a></p>
<p><a href="https://www.zhihu.com/question/64921387">常用的分布式事务解决方案介绍有多少种？</a></p>
<p><a href="https://blog.roncoo.com/article/127500">常用的分布式事务解决方案介绍</a></p>
<p><a href="https://www.javazhiyin.com/573.html">浅谈，分布式事务与解决方案</a></p>
<p><a href="https://www.throwable.club/2019/03/23/j-action-about-distributed-transaction/">谈谈对分布式事务的一点理解和解决方案</a></p>
<p><a href="http://wuwenliang.net/2018/11/20/%E6%88%91%E8%AF%B4%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BTCC/">我说分布式事务之TCC</a></p>
<p><a href="https://www.miwho.com/posts/e37377a1.html">分布式事务解决方案总结</a></p>
<p><a href="https://toutiao.io/posts/j1fbr5/preview">FESCAR：阿里重磅开源分布式事务解决方案</a></p>
<p><a href="https://www.sofastack.tech/blog/seata-distributed-transaction-open-source/">蚂蚁金服分布式事务开源以及实践 | SOFA 开源一周年献礼</a></p>
<p><a href="http://www.spring4all.com/article/527">Spring Cloud分布式事务终极解决方案探讨</a></p>
<p><a href="https://ehlxr.me/2019/01/25/eventually-consistency/">可靠消息最终一致性分布式事务实现方案</a></p>
<p><a href="https://super2bai.github.io/distributed/solution.html">分布式事务解决方案</a></p>
<p><a href="https://hacpai.com/article/1515511635962">分布式事务终极解决方案探讨</a></p>
<p><a href="https://www.jdon.com/49338">分布式事务Saga模式</a></p>
<p><a href="https://yuerblog.cc/2016/08/12/talking-about-reentrant-idempotent-distributed-transactions-in-web-systems-1/">谈谈web系统中的可重入，幂等性，分布式事务的那些事 – 上</a></p>
<p><a href="http://codin.im/2018/06/25/implementing-distributed-transaction-with-spring/">Spring分布式事务实现概览</a></p>
<p><a href="https://hhbbz.github.io/2018/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">分布式事务的四种解决方案</a></p>
<p><a href="https://blog.csdn.net/wuzhiwei549/article/details/79787866">分布式事务解决方案(总览)</a></p>
<p><a href="https://www.jianshu.com/p/b0d19cb6de70">高并发下分布式事务的解决方案-MQ消息事务+最终一致性</a></p>
<p><a href="https://my.oschina.net/90888/blog/1635485?from=timeline">分布式事物，解决分布式系统事务一致性的几种方案对比，你有更好的吗？ </a></p>
<p><a href="https://www.liangzl.com/get-article-detail-97306.html">分布式事务五种方案</a></p>
<p><a href="https://my.oschina.net/u/2286631/blog/1505151">分布式事务解决方案—-最大努力通知解决方案</a></p>
<p>视频资料：</p>
<p><a href="https://www.bilibili.com/video/av23742194/">微服务架构的分布式事务解决方案</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式系统（四）</title>
    <url>/2019/07/04/041/</url>
    <content><![CDATA[<p>分布式系统环境下，服务间类似依赖非常常见，一个业务调用通常依赖多个基础服务。如下图，对于同步调用，当库存服务不可用时，商品服务请求线程被阻塞，当有大批量请求调用库存服务时，最终可能导致整个商品服务资源耗尽，无法继续对外提供服务。并且这种不可用可能沿请求调用链向上传递，这种现象被称为雪崩效应。</p>
<blockquote>
<p>左耳听风 | 从亚马逊的实践，谈分布式系统的难点</p>
<p>问题二：系统架构中的服务依赖性问题</p>
<p>对于传统的单体应用，一台机器挂了，整个软件就挂掉了。但是你千万不要以为在分布式的架构下不会发生这样的事。分布式架构下，服务是会有依赖的，一个服务依赖链上的某个服务挂掉了，可能会导致出现“多米诺骨牌”效应。</p>
</blockquote>
<p>扩展博文</p>
<p><a href="https://www.cnblogs.com/raoshaoquan/articles/6636067.html">熔断，限流，降级</a></p>
<p><a href="https://www.cnblogs.com/cjsblog/p/9391819.html">Hystrix介绍</a></p>
<p><a href="https://blog.csdn.net/qq_33394088/article/details/80210679">服务降级，服务熔断，服务限流</a></p>
<p><a href="https://www.cnblogs.com/xiong2ge/p/hystrix_faststudy.html">Hystrix快速入门</a></p>
<p><a href="https://www.jianshu.com/p/b9af028efebb">Hystrix使用入门手册（中文）</a></p>
<p><a href="https://blog.csdn.net/lemon89/article/details/80460876">Hystrix 从入门到深入——一阅读官网</a></p>
<p><a href="https://www.jianshu.com/p/9cf7dd341bad">Hystrix系列之入门</a></p>
<p><a href="https://my.oschina.net/7001/blog/1619842">Hystrix原理与实战</a></p>
<p><a href="https://juejin.im/post/5c009ff6f265da614b11b84d">Hystrix都停更了，我为什么还要学？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/51008825">高可用框架Resilience4j使用指南</a></p>
<p><a href="https://hot66hot.iteye.com/blog/2155036">Hystrix 使用与分析</a></p>
<p><a href="https://www.itslide.com/slide/244438/">Dubbo应用和实践 曹胜利</a></p>
<p><a href="https://www.infoq.cn/article/IwZCAp3jo_H5fJFbWOZu">阿里技术专家详解 Dubbo 实践，演进及未来规划</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析分布式系统（三）</title>
    <url>/2019/07/04/040/</url>
    <content><![CDATA[<h1 id="1-分库分表"><a href="#1-分库分表" class="headerlink" title="1. 分库分表"></a>1. 分库分表</h1><h2 id="1-1-为什么要分库分表"><a href="#1-1-为什么要分库分表" class="headerlink" title="1.1 为什么要分库分表"></a>1.1 为什么要分库分表</h2><p>我们看一下 sql 的执行过程。mysql 执行一条sql的过程如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1. 收到sql</span><br><span class="line">2. 把sql放到排队队列中</span><br><span class="line">3. 执行sql</span><br><span class="line">4. 返回结果</span><br></pre></td></tr></tbody></table></figure>

<p>在这个执行过程中最花时间的地方在于：排队等待的时间和sql的执行时间。</p>
<p>如果有 2 个 sql 都要同时修改同一张表的同一条数据，mysql 对这种情况的处理是：</p>
<ul>
<li>一种是表锁定（MyISAM存储引擎）<br>表锁定表示其他操作都不能对<strong>这张表</strong>进行操作，必须等当前对表的操作完才行。</li>
<li>一个是行锁定（InnoDB存储引擎）<br>行锁定也一样，别的sql必须等<strong>这条数据</strong>操作完了，其他人才能对这条数据进行操作。</li>
</ul>
<p>如果数据太多，一次执行的时间太长，等待的时间就越长，这也是我们为什么要分表的原因。</p>
<h2 id="1-2-分库分表术语"><a href="#1-2-分库分表术语" class="headerlink" title="1.2 分库分表术语"></a>1.2 分库分表术语</h2><p><strong>读写分离：</strong> 不同的数据库，同步相同的数据，分别只负责数据的读和写。</p>
<p><strong>分区：</strong>指定分区列表达式，把记录拆分到不同的区域中（必须是同一服务器，可以是不同硬盘），应用看来还是同一张表，没有变化。</p>
<p><strong>分库：</strong>一个系统的多张数据表，存储到多个数据库实例中。</p>
<p><strong>分表：</strong> 对于一张多行（记录）多列（字段）的二维数据表，又分两种情形：</p>
<ul>
<li>垂直分表<br>竖向切分，不同分表存储不同的字段，可以把不常用或者大容量、或者不同业务的字段拆分出去</li>
<li>水平分表(最复杂)<br>横向切分，按照特定分片算法，不同分表存储不同的记录。</li>
</ul>
<p>在实际生产中，通常的进化过程是：</p>
<ul>
<li>单库单表 -&gt; 单库多表 -&gt; 多库多表</li>
<li>分区 -&gt; 分表 -&gt; 分库（垂直分库 - 水平分库 - 读写分离）</li>
</ul>
<blockquote>
<p><strong>单库单表</strong></p>
<p>单库单表是最常见的数据库设计，如有一张订单表（order）放在数据库中，所有的订单都可以在 order 表中查到。</p>
<p><strong>单库多表</strong></p>
<p>随着需求的迭代，如果增加添加一列的时候，mysql会锁表，期间所有的读写操作只能等待，别无他法。</p>
<p>这时候，可以将 order 进行水平的切分，产生多个表结构完全一样的 order 表。比如：<code>order_01</code>，<code>order_02</code>， …，<code>order_n</code>，那么<code>order_01</code> + <code>order_02</code> + … + <code>order_n</code> 的数据是一份完整的订单数据。</p>
</blockquote>
<p>水平切分，简单的做法如：</p>
<p><strong>按ID区间来切分</strong>，将<code>orderId</code>为 1<del>9999 的记录分到第一个库，10000</del>20000 的分到第二个库，以此类推。</p>
<p>好处在于扩容很方便，因为只要每个月预备好合适大小的新库，到了一个新的月份的时候，自然而然就会写新的库了。缺点在于如果大部分请求都是访问最新的数据，那么局部表的负荷很大，旧数据的数据库几乎没有负荷。</p>
<p><strong>按时间切分</strong>，按日期将不同月甚至是日的数据分散到不同的库中，比如：2019年1月份存在第一张表，2019年2月份存在第二张表。依次类推。还可以按照id的哈希值进行切分等。</p>
<p>好处在于可以平均分配没给库的数据量和请求压力。坏处在于扩容起来比较麻烦，会有一个数据迁移的这么一个过程。</p>
<h1 id="2-分表中间件"><a href="#2-分表中间件" class="headerlink" title="2. 分表中间件"></a>2. 分表中间件</h1><p>用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</p>
<h2 id="2-1-Cobar"><a href="#2-1-Cobar" class="headerlink" title="2.1 Cobar"></a>2.1 Cobar</h2><p>Cobar 是提供关系型数据库（MySQL）分布式服务的中间件，它可以让传统的数据库得到良好的线性扩展，并看上去还是一个数据库，对应用保持透明。</p>
<p>Cobar以<code>Proxy</code>的形式位于前台应用和实际数据库之间，对前台的开放的接口是 MySQL 通信协议，将前台 SQL 语句变更并按照数据分布规则发到合适的后台数据分库，再合并返回结果，模拟单库下的数据库行为。</p>
<p>Cobar 属于中间层方案，在应用程序和 MySQL 之间搭建一层 Proxy。中间层介于应用程序与数据库间，需要做一次转发，而基于 JDBC 协议并无额外转发，直接由应用程序连接数据库。</p>
<p>性能上有些许优势。这里并非说明中间层一定不如客户端直连，除了性能，需要考虑的因素还有很多，中间层更便于实现监控、数据迁移、连接管理等功能。</p>
<p>Cobar 属于阿里 B2B 事业群，始于 2008 年，在阿里服役 3 年多，接管 3000+ 个 MySQL 数据库的 schema，集群日处理在线 SQL 请求 50 亿次以上。</p>
<p>由于Cobar发起人的离职，Cobar 停止维护。后续的类似中间件，比如 MyCAT 建立于 Cobar 之上，包括现在阿里服役的 RDRS 其中也复用了 Cobar-Proxy 的相关代码。</p>
<h2 id="2-2-MyCAT"><a href="#2-2-MyCAT" class="headerlink" title="2.2 MyCAT"></a>2.2 MyCAT</h2><p>MyCAT 是社区爱好者在阿里 cobar 基础上进行二次开发，解决了 cobar 当时存 在的一些问题，并且加入了许多新的功能在其中。目前 MyCAT 社区活 跃度很高，目前已经有一些公司在使用MyCAT。总体来说支持度比较高，也会一直维护下去，发展到目前的版本，已经不是一个单纯的 MySQL 代理了。</p>
<p>它的后端可以支持 MySQL，SQL Server，Oracle，DB2，PostgreSQL 等主流数据库，也支持 MongoDB 这种新型NoSQL 方式的存储，未来还会支持更多类型的存储。</p>
<p>MyCAT是一个强大的数据库中间件，不仅仅可以用作读写分离，以及分表分库、容灾管理，而且可以用于多租户应用开发、云平台基础设施，让你的架构具备很强的适应性和灵活性。</p>
<p>借助于即将发布的 MyCAT 性能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表隐射到不同存储引擎上，而整个应用的代码一行也不用改变。</p>
<p>MyCAT是在 Cobar 基础上发展的版本，两个显著提高：后端由 BIO 改为 NIO，并发量有大幅提高； 增加了对<code>Order By</code>，<code>Group By</code>，<code>Limit</code>等聚合功能。（虽然 Cobar 也可以支持 Order By，Group By，Limit语法，但是结果没有进行聚合，只是简单返回给前端，聚合功能还是需要业务系统自己完成）</p>
<h2 id="2-3-TDDL"><a href="#2-3-TDDL" class="headerlink" title="2.3 TDDL"></a>2.3 TDDL</h2><p>TDDL是 Tabao 根据自己的业务特点开发了（Tabao Distributed Data Layer，外号：头都大了）。主要解决了分库分表对应用的透明化以及异构数据库之间的数据复制，它是一个基于集中式配置的<code>jdbc datasourcce</code>实现，具有主备，读写分离，动态数据库配置等功能。</p>
<p>TDDL并非独立的中间件，只能算作中间层，处于业务层和JDBC层中间，是以Jar包方式提供给应用调用，属于JDBC Shard的思想。</p>
<blockquote>
<p>TDDL源码：<a href="https://github.com/alibaba/tb_tddl">https://github.com/alibaba/tb_tddl</a></p>
</blockquote>
<p>TDDL复杂度相对较高。当前公布的文档较少，只开源动态数据源，分表分库部分还未开源，还需要依赖<code>diamond</code>，不推荐使用。</p>
<h2 id="2-4-DRDS"><a href="#2-4-DRDS" class="headerlink" title="2.4 DRDS"></a>2.4 DRDS</h2><p>DRDS 是阿里巴巴自主研发的分布式数据库服务（此项目不开源），DRDS脱胎于阿里巴巴开源的 Cobar 分布式数据库引擎，吸收了 Cobar 核心的Cobar-Proxy 源码，实现了一套独立的类似<code>MySQL-Proxy</code>协议的解析端，能够对传入的SQL进行解析和处理，对应用程序屏蔽各种复杂的底层DB拓扑结构，获得单机数据库一样的使用体验。</p>
<p>同时借鉴了淘宝TDDL丰富的分布式数据库实践经验，实现了对分布式Join支持，SUM/MAX/COUNT/AVG等聚合函数支持以及排序等函数支持，通过异构索引、小表广播等解决分布式数据库使用场景下衍生出的一系列问题，最终形成了完整的分布式数据库方案。</p>
<h2 id="2-5-Atlas"><a href="#2-5-Atlas" class="headerlink" title="2.5 Atlas"></a>2.5 Atlas</h2><p>Atlas 是一个位于应用程序与MySQL之间的基于MySQL协议的数据中间层项目，它是在<code>mysql-proxy 0.8.2</code>版本上对其进行优化，360团队基于mysql proxy 把 lua 用 C 改写，它实现了MySQL的客户端和服务端协议，作为服务端与应用程序通讯，同时作为客户端与MySQL通讯。它对应用程序屏蔽了DB的细节。</p>
<blockquote>
<p>这个产品最新一次小幅度更新也是一年前，活跃度很低，不简推荐使用。</p>
</blockquote>
<h2 id="2-5-Sharding-JDBC-Sharding-Sphere"><a href="#2-5-Sharding-JDBC-Sharding-Sphere" class="headerlink" title="2.5 Sharding-JDBC/Sharding-Sphere"></a>2.5 Sharding-JDBC/Sharding-Sphere</h2><p>sharding-JDBC ，从 3.0 开始，Sharding-JDBC 将更名为 Sharding-Sphere。是当当应用框架<code>ddframe</code>中，从关系型数据库模块<code>dd-rdb</code>中分离出来的数据库水平分片框架，实现透明化数据库分库分表访问。</p>
<blockquote>
<p>Sharding-JDBC 是继<code>dubbox</code>和<code>elastic-job</code>之后，<code>ddframe</code>系列开源的第 3 个项目。</p>
</blockquote>
<p>Sharding-JDBC直接封装JDBC API，可以理解为增强版的JDBC驱动，旧代码迁移成本几乎为零：</p>
<ul>
<li>可适用于任何基于Java的ORM框架，如JPA、Hibernate、Mybatis、Spring JDBC Template或直接使用JDBC。</li>
<li>可基于任何第三方的数据库连接池，如DBCP、C3P0、 BoneCP、Druid等。</li>
<li>理论上可支持任意实现JDBC规范的数据库。虽然目前仅支持MySQL，但已有支持Oracle、SQLServer等数据库的计划。</li>
</ul>
<p>Sharding-JDBC定位为轻量Java框架，使用客户端直连数据库，以 jar 包形式提供服务，无proxy代理层，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。</p>
<p>Sharding-JDBC分片策略灵活，可支持等号、between、in等多维度分片，也可支持多分片键。</p>
<p>SQL解析功能完善，支持聚合、分组、排序、limit、or等查询，并支持Binding Table以及笛卡尔积表查询。</p>
<h1 id="2-数据库迁移方案"><a href="#2-数据库迁移方案" class="headerlink" title="2. 数据库迁移方案"></a>2. 数据库迁移方案</h1><p>现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？</p>
<h2 id="2-1-停机迁移方案"><a href="#2-1-停机迁移方案" class="headerlink" title="2.1 停机迁移方案"></a>2.1 停机迁移方案</h2><p>系统停掉，然后将老库的数据迁移到分库分表的数据中</p>
<h2 id="2-2-双写迁移方案"><a href="#2-2-双写迁移方案" class="headerlink" title="2.2 双写迁移方案"></a>2.2 双写迁移方案</h2><p>双写迁移方案就是同时写两个库，一个是老库，一个是新库。也就是在线上系统里面，除了对所有老库的增删改地方，同时对新库同样执行增删改，这就是所谓的双写。</p>
<p>系统部署之后，新库数据差太远，用导数工具读老库数据并写到新库中，写的时候要根据<code>gmt_modified</code>这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据。</p>
<p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p>
<p>当数据完全一致时，基于仅使用分库分表的最新代码，重新部署一次。</p>
<h1 id="4-动态扩容"><a href="#4-动态扩容" class="headerlink" title="4. 动态扩容"></a>4. 动态扩容</h1><p>如何设计可以动态扩容缩容的分库分表方案？</p>
<p>动态扩容做到很优雅就是要保证扩容缩容的代价要小，迁移数据要快。可以采用<strong>逻辑分库分表</strong>的方式来代替<strong>物理分库分表</strong>的方式：要扩容缩容时，只需要将逻辑上的数据库和表改为物理上的数据库和表。</p>
<p>快速平稳的扩容缩容是建立在合理的分库分表的基础之上，利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，可以避免行级别数据的迁移，但是依然需要进行表级别数据的迁移。所以第一次进行分库分表时多分几个库，以保证未来很长时间内都不需要再分库分表。</p>
<p>这里有个实践参考：利用 32 * 32 来分库分表，即分为 32 个库，每个库 32 张表，一共就是 1024 张表，一条数据先根据先根据数据库数量取模路由到哪个库，再根据库的表数量取模路由到哪张表。</p>
<blockquote>
<p>一般路由到表的时候，先将数据的 id 对表的总数整除，再对表的总数取模，这样数据会更均匀分布在一个库的表中。</p>
<p>为什么是若表的数量为 1024，库的数量为 33，则无法均分。</p>
</blockquote>
<p>刚开始的时候，这个库可能就是逻辑库，等到需要扩容的时候改成物理扩容即可。</p>
<h1 id="5-分布式全局唯一ID"><a href="#5-分布式全局唯一ID" class="headerlink" title="5. 分布式全局唯一ID"></a>5. 分布式全局唯一ID</h1><p>5.2 结合数据库维护一个Sequence表</p>
<p>此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `SEQUENCE` (  </span><br><span class="line">    `table_name` <span class="type">varchar</span>(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">    `next_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`table_name`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></tbody></table></figure>

<p>每当需要为某个表的新纪录生成 ID 时就从<code>Sequence</code>表中取出对应表的<code>next_id</code>，并将<code>next_id</code>的值加1后更新到数据库中以备下次使用。</p>
<p>此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。</p>
<blockquote>
<p>有人提出使用<code>Master-Slave</code>进行主从同步，但这也只能解决单点问题，并不能解决读写比为<code>1:1</code>的访问压力问题。</p>
</blockquote>
<h2 id="5-2-UUID"><a href="#5-2-UUID" class="headerlink" title="5.2 UUID"></a>5.2 UUID</h2><p>UUID 生成的是<code>length=32</code>的<code>16</code>进制格式的字符串，算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成 UUID，使用 UUID 作主键是最简单的方案。</p>
<p>但是缺点也是非常明显的，由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上。</p>
<h2 id="5-3-获取系统当前时间"><a href="#5-3-获取系统当前时间" class="headerlink" title="5.3 获取系统当前时间"></a>5.3 获取系统当前时间</h2><p>纯获取系统当前时间作为唯一id在高并发情况下是有风险的，会出现重复主键的情况，因此可以再增加一些唯一标识，如业务字段值跟当前时间拼接起来，组成一个全局唯一的编号：订单编号 + 时间戳 + 用户id + 业务含义编码。</p>
<h2 id="5-4-Snowflake-算法生成全局ID"><a href="#5-4-Snowflake-算法生成全局ID" class="headerlink" title="5.4 Snowflake 算法生成全局ID"></a>5.4 Snowflake 算法生成全局ID</h2><p>Twitter的<code>snowflake</code>算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字，组成部分：</p>
<ul>
<li><p><code>1bit</code>：第一位不使用<br>永远是0，保证是正数。</p>
</li>
<li><p><code>41bit</code>：表示的是时间戳，单位是毫秒<br>41 bit 的长度可以表示 69 年的时间</p>
</li>
<li><p><code>10bit</code>：节点 ID<br>5位数据中心（机房）+ 5位节点ID（服务器），支持 32 * 32 = 1024 个节点</p>
</li>
<li><p><code>12bit</code>：流水号，用来记录同一个毫秒内产生的不同 ID<br>12 bit 的计数顺序号，支持每个节点每毫秒产生4096个ID序列，每个节点每毫秒内支持 4096 个 ID，相当于 409万的 QPS，相同时间内如 ID 遇翻转，则等待至下一毫秒。</p>
</li>
</ul>
<p><img src="https://image.woodwhales.cn/040/images/01.png"></p>
<h1 id="6-MySQL-读写分离"><a href="#6-MySQL-读写分离" class="headerlink" title="6. MySQL 读写分离"></a>6. MySQL 读写分离</h1><p>读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p>
<p>因为数据库的”写”（写 10000 条数据到 oracle 可能要3分钟）操作是比较耗时的。 但是数据库的”读”（从 oracle 读10000 条数据可能只要 5 秒钟）。 <strong>所以读写分离，解决的是，数据库的写入，影响了查询的效率。</strong></p>
<blockquote>
<p>数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。</p>
</blockquote>
<h1 id="7-MySQL-主从复制"><a href="#7-MySQL-主从复制" class="headerlink" title="7. MySQL 主从复制"></a>7. MySQL 主从复制</h1><p>在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。</p>
<p>因此，通过<code>主从复制</code>的方式来同步数据，再通过<code>读写分离</code>来提升数据库的并发负载能力。有点类似于 ES 搜索引擎的<code>rsync</code>，但是不同的是<code>rsync</code>是对磁盘文件做备份，而 MySQL 主从复制是对数据库中的数据、语句做备份。</p>
<h2 id="7-1-MySQL支持的复制类型"><a href="#7-1-MySQL支持的复制类型" class="headerlink" title="7.1 MySQL支持的复制类型"></a>7.1 MySQL支持的复制类型</h2><p><strong>1. 基于语句的复制</strong></p>
<p>在服务器上执行sql语句，在从服务器上执行同样的语句，MySQL 默认采用基于语句的复制，执行效率高。</p>
<p><strong>2. 基于行的复制</strong></p>
<p>把改变的内容复制过去，而不是把命令在从服务器上执行一遍。</p>
<p><strong>3. 混合类型的复制</strong></p>
<p>默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</p>
<h2 id="7-2-复制的工作过程"><a href="#7-2-复制的工作过程" class="headerlink" title="7.2 复制的工作过程"></a>7.2 复制的工作过程</h2><p>mysql主从复制需要三个线程，master（binlog dump thread）、slave（I/O thread 、SQL thread）。</p>
<p><strong>master</strong></p>
<p>（1）<code>binlog dump线程</code>：当主库中有数据更新时，那么主库就会根据按照设置的<code>binlog</code>格式，将此次更新的事件类型写入到主库的<code>binlog</code>文件中，此时主库会创建<code>log dump</code>线程通知slave有数据更新，当I/O线程请求日志内容时，会将此时的<code>binlog</code>名称和当前更新的位置同时传给slave的I/O线程。</p>
<p><strong>slave</strong></p>
<p>（2）<code>I/O线程</code>：该线程会连接到master，向<code>log dump</code>线程请求一份指定<code>binlog</code>文件位置的副本，并将请求回来的<code>binlog</code>存到本地的<code>relay log</code>中，<code>relay log</code>和<code>binlog</code>日志一样也是记录了数据更新的事件，它也是按照递增后缀名的方式，产生多个<code>relay log</code>（ host_name-relay-bin.000001）文件，slave会使用一个 index 文件（ host_name-relay-bin.index）来追踪当前正在使用的<code>relay log</code>文件。</p>
<p>（3）<code>SQL线程</code>：该线程检测到relay log有更新后，会读取并在本地做<code>redo</code>操作，将发生在主库的事件在本地重新执行一遍，来保证主从数据同步。</p>
<blockquote>
<p>如果一个<code>relay log</code>文件中的全部事件都执行完毕，那么SQL线程会自动将该<code>relay log</code>文件删除掉。</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/040/images/02.png"></p>
<p>MySQL 5.7 之后增加了并行复制功能，并行复制指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p>
<p>建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用 MySQL 主从同步。</p>
<h2 id="7-3-主从同步的延时问题"><a href="#7-3-主从同步的延时问题" class="headerlink" title="7.3 主从同步的延时问题"></a>7.3 主从同步的延时问题</h2><p>当写数据的并发很高的时候，可能会出现少许数据不能及时查询到，很有可能就是数据库主从同步延时问题。</p>
<p><strong>slave 同步延迟的可能原因</strong></p>
<ul>
<li>slave的I/O线程推迟读取日志中的事件信息；最常见原因是slave是在单线程中执行所有事务，而master有很多线程可以并行执行事务。</li>
<li>带来低效连接的长查询、磁盘读取的I/O限制、锁竞争和<code>innodb</code>线程同步启动等。</li>
<li>Master负载、Slave负载</li>
<li>网络延迟</li>
</ul>
<p><strong>如何查看同步延迟</strong></p>
<ul>
<li>可以通过比对master、slave上的日志位置</li>
<li>通过<code>show slave status</code>查看<code>Seconds_Behind_Master</code>的值，这个值代表主从同步延迟的时间，值越大说明延迟越严重。值为0为正常情况，正值表示已经出现延迟，数字越大从库落后主库越多。</li>
<li>使用<code>percona-toolkit</code>的<code>pt-hearbeat</code>工具进行查看。</li>
</ul>
<p><strong>减少同步延迟的操作方案</strong></p>
<ul>
<li><p>拆分主库<br>将主库拆分，降低每个主库写的并发量，这样主从同步的延时时长就能有效缩短。</p>
</li>
<li><p>优化代码逻辑<br>插入数据的时候立即查数据是主从复制架构上开发的一个大忌。因此，代码修改逻辑可以借鉴如下：</p>
<ul>
<li>如果第二步获取的数据不需要第一步更新的status字段，那就先读，然后再更新</li>
<li>如果第二步获取的数据需要依赖第一步的status字段，那就在读出来的时候先判断是否为空，如果是空的，报错，下一次重试。</li>
</ul>
</li>
<li><p>负载均衡<br>搭建多少slave，并且使用<code>lvs</code>或<code>nginx</code>进行查询负载均衡，可以减少每个 slave 执行查询的次数和时间，从而将更多的时间用于去处理主从同步。</p>
</li>
<li><p>Slave调整参数<br>为了保障较高的数据安全性，配置<code>sync_binlog=1</code>，<code>innodb_flush_log_at_trx_commit=1</code>等设置。而Slave可以关闭<code>binlog</code>，<code>innodb_flush_log_at_trx_commit</code>也可以设置为 0 来提高sql的执行效率（这两个参数很管用）</p>
</li>
<li><p>并行复制<br>即有单线程的复制改成多线程复制，从库有两个线程与复制相关：<code>io_thread</code>负责从主库拿<code>binlog</code>并写到<code>relaylog</code>，<code>sql_thread</code>负责读<code>relaylog</code>并执行。<br>多线程的思路就是把<code>sql_thread</code>变成分发线程，然后由一组<code>worker_thread</code>来负责执行。几乎所有的并行复制都是这个思路，有不同的，便是sql_thread 的分发策略。</p>
<blockquote>
<p>MySQL 5.7 的真正并行复制<code>enhanced multi-threaded slave（MTS）</code>很好的解决了主从同步复制的延迟问题。</p>
</blockquote>
</li>
</ul>
<h1 id="8-扩展博文"><a href="#8-扩展博文" class="headerlink" title="8. 扩展博文"></a>8. 扩展博文</h1><p><a href="https://www.cnblogs.com/butterfly100/p/9034281.html">数据库分库分表思路</a></p>
<p><a href="https://www.jianshu.com/p/32b3e91aa22c">分库分表需要考虑的问题及方案</a></p>
<p><a href="https://blog.csdn.net/bluishglc/article/details/6274841">关于垂直切分Vertical Sharding的粒度</a></p>
<p><a href="https://www.cnblogs.com/scode2/p/8718509.html">分库分表、主从、读写分离</a></p>
<p><a href="https://www.cnblogs.com/405845829qq/p/7552736.html">数据库分库分表</a></p>
<p><a href="https://www.jianshu.com/p/3fed6db29a01">分库分表浅谈</a></p>
<p><a href="https://blog.csdn.net/mingover/article/details/71108852">千万数据的分库分表(一)</a></p>
<p><a href="https://segmentfault.com/a/1190000017272697">“分库分表” ？选型和流程要慎重，否则会失控</a></p>
<p><a href="https://blog.csdn.net/dinglang_2009/article/details/53195835">分库分表的几种常见玩法及如何解决跨库查询等问题</a></p>
<p><a href="https://www.cnblogs.com/wangzhongqiu/p/7100332.html">数据库（分库分表）中间件对比</a></p>
<p><a href="https://www.guokr.com/blog/475765/">mysql中间件研究（Atlas，cobar，TDDL）</a></p>
<p><a href="https://www.cnblogs.com/itech/archive/2011/09/22/2185365.html">MySQL Proxy使用</a></p>
<p><a href="https://blog.csdn.net/xinzhi8/article/details/72598455">mysql-proxy数据库中间件架构</a></p>
<p><a href="https://blog.csdn.net/piantoutongyang/article/details/91410959#7_shardingjdbc_416">7.偏头痛杨的mysql教学系列之分布式数据库</a></p>
<p><a href="https://blog.csdn.net/qq_22152261/article/details/80374990">使用Spring Boot + Sharding-JDBC 快速简单地实现数据库读写分离</a></p>
<p><a href="https://segmentfault.com/a/1190000014037539">springboot实践笔记之一：springboot+sharding-jdbc+mybatis全注解实现增量数据库分片实现</a></p>
<p><a href="https://mp.weixin.qq.com/s/VlJ_3oN0Us2e_ZPk0sDT7w">Spring Boot中整合Sharding-JDBC读写分离示例</a></p>
<p><a href="https://www.52lhd.com/article/21">Spring Boot整合sharding-jdbc读写分离+分库分表操作</a></p>
<p><a href="https://www.infoq.cn/article/1QvyzW9W*YuF685kYBkq">分布式数据库中间件 Apache ShardingSphere 京东落地实战</a></p>
<p><a href="https://www.codesheep.cn/2018/12/19/mycattest/">基于代理的数据库分库分表框架 Mycat实践</a></p>
<p><a href="https://www.jianshu.com/p/f81422b1c915">数据库中间件Mycat+SpringBoot完成分库分表</a></p>
<p><a href="https://www.cnblogs.com/youzhibing/p/10384439.html">应用集成mycat，实现mycat的高可用与mysql的读写分离</a></p>
<p><a href="https://bboyjing.github.io/2016/08/10/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8BMycat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%E3%80%90%E6%96%B0%E5%BB%BAJava%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE%E3%80%91/">Mysql分库分表之Mycat学习笔记四【新建Java测试项目】</a></p>
<p><a href="https://www.linliuxing.top/2018/08/31/SpringBoot-MyCat-Mybatis/">SpringBoot+MyCat+Mybatis</a></p>
<p><a href="https://raye.wang/mycatji-chu-pei-zhi-shuo-ming/">MySQL读写分离基于Mycat实现</a></p>
<p><a href="https://raye.wang/springboot-mybatis-du-xie-fen-chi-pei-zhi/">SpringBoot Mybatis 读写分离配置</a></p>
<p><a href="https://my.oschina.net/u/3768341/blog/3051296">Springboot2使用shardingsphere分表攻略</a></p>
<p><a href="https://blog.51cto.com/shangdc/2121209">Sharding-Sphere 3.X 与spring与mybatis集成（分库分表）demo</a></p>
<p><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">大众点评订单系统分库分表实践</a></p>
<p><a href="https://yuerblog.cc/2018/05/31/mysql-database-partition/">mysql分库分表方案</a></p>
<p><a href="https://chaser520.iteye.com/blog/2428261">不停机分库分表迁移</a></p>
<p><a href="http://xiaorui.cc/2016/11/06/%E5%85%B3%E4%BA%8Emysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%BB%8F%E9%AA%8C-%E4%B8%8B/">关于mysql分库分表及高可用集群经验 [下]</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9597810.html">【原创】分库分表后如何部署上线</a></p>
<p><a href="https://kefeng.wang/2018/07/22/mysql-sharding/">MySQL 分库分表及其平滑扩容方案</a></p>
<p><a href="http://www.10tiao.com/html/249/201703/2651959953/1.html">分页与分库那些事儿（线上交流纪要）</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9302609.html">【原创】分布式之数据库和缓存双写一致性方案解析(三)</a></p>
<p><a href="https://quericy.me/blog/867/">记一次数据双写平滑迁移实践</a></p>
<p><a href="https://www.w3cschool.cn/architectroad/architectroad-data-smooth-migration.html">100亿数据平滑数据迁移,不影响服务</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4MDUxOTI5NA==&amp;mid=2247484360&amp;idx=1&amp;sn=322ad96dfc5ac4b6e3b148ea6398dc8a&amp;chksm=fd54d7d9ca235ecf11459a2021c87cc601b687bb3ccaae7c6f5a8ca5d98bd49f2bd859cf1f90&amp;token=1060232458&amp;lang=zh_CN#rd">21世纪了还愚公移山？数据库这么迁移更稳定！</a></p>
<p><a href="https://lzjohnny.github.io/2019/04/01/database-migration/">数据库拆分迁移</a></p>
<p><a href="https://m.w3cschool.cn/architectroad/architectroad-database-smooth-expansion.html">数据库秒级平滑扩容架构方案</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37792971">浅谈数据库扩容方案</a></p>
<p><a href="http://www.sohu.com/a/205762066_463989">数据库 schema 迁移数据最佳实践</a></p>
<p><a href="https://www.dutycode.com/yizhixing_hash_shujuqianyi.html">一致性哈希-数据迁移</a></p>
<p><a href="https://www.upyun.com/opentalk/285.html">产品架构专场：58同城数据库架构最佳实践</a></p>
<p><a href="http://www.jiangxinlingdu.com/thought/2018/08/15/images.html">不停机图片升级迁移</a></p>
<p><a href="https://sq.163yun.com/blog/article/178242037354303488">网易考拉内容管理平台全量ES数据迁移总结</a></p>
<p><a href="https://www.owenzhang.net/blog/100.html">互联网服务线上数据迁移的原则和方法</a></p>
<p><a href="https://www.01hai.com/note/av246858">也谈分库分表在实际应用的实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/59167071">Redis与Mysql双写一致性方案解析</a></p>
<p><a href="https://hackjutsu.com/2016/01/25/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/">秒杀系统架构分析与实战</a></p>
<p><a href="http://database.51cto.com/art/201801/563567.htm">水平分库如何做到平滑扩展</a></p>
<p><a href="https://juejin.im/post/5992b2f8f265da3e185eb75d">贝聊亿级数据库分库分表实践</a></p>
<p><a href="https://linux.cn/blog-47901-6359.html">直播平台的数据库架构演变</a></p>
<p><a href="http://apsarastackdocument.oss-cn-hangzhou.aliyuncs.com/04_ApsaraStackLite/V2.1.0/%E9%98%BF%E9%87%8C%E4%BA%91%20%E4%B8%93%E6%9C%89%E4%BA%91%E6%95%8F%E6%8D%B7%E7%89%88%20V2.1.0%20%E4%BA%A7%E5%93%81%E7%AE%80%E4%BB%8B%2020190227.pdf">《阿里云专有云敏捷版》</a></p>
<p><a href="http://www.mycat.io/document/mycat-definitive-guide.pdf">《mycat权威指南》</a></p>
<p><a href="https://juejin.im/post/5a61ad34f265da3e3c6c3943">让数据库不再成为业务发展瓶颈——分布式数据库架构设计</a></p>
<p><a href="http://www.apexyun.com/logistics-order/">基于中台思想的物流系统设计（二）：构建物流订单能力</a></p>
<p><a href="https://www.qdcto.com/archives/271">浅析数据库表拆分的原理及思路</a></p>
<p><a href="https://blog.csdn.net/u013467442/article/details/73864846">mysql动态扩容调研</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27871998">数据库分布式架构扫盲——分库分表（及银行核心系统适用性思考）</a></p>
<p><a href="https://blog.csdn.net/u013421629/article/details/78793966">【mysql 读写分离】10分钟了解读写分离的作用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50597960">深度探索MySQL主从复制原理</a></p>
<p><a href="http://database.51cto.com/art/201801/563213.htm">数据库读写分离架构，为什么我不喜欢</a></p>
<p><a href="https://www.cnblogs.com/Aiapple/p/5792939.html">mysql 主从复制原理</a></p>
<p><a href="https://www.liuliya.com/archive/580.html">MySQL主从复制原理</a></p>
<p><a href="http://www.linkedkeeper.com/1028.html">MySQL主从同步那点事儿</a></p>
<p><a href="https://www.hi-linux.com/posts/9892.html">MySQL 5.7 并行复制实践</a></p>
<p><a href="https://www.ihaiyun.cc/2018/08/24/MySQL-replication-1/">MySQL 主从复制原理</a></p>
<p><a href="https://i4t.com/42.html">MySQL主从复制原理、半同步操作步骤及原理</a></p>
<p><a href="http://eyesmoons.com/article/70">mysql主从复制实践</a></p>
<p><a href="https://juejin.im/post/5ca2a176f265da30ba5b0b91">MySQL主从复制原理</a></p>
<p><a href="http://www.tianfeiyu.com/?p=1640">MySQL主从复制原理及配置</a></p>
<p><a href="http://www.simlinux.com/2014/08/20/mysql-rep.html">MySQL复制原理与配置</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/6261111.html">mysql主从同步(2)-问题梳理</a></p>
<p><a href="https://www.cnblogs.com/hoohack/p/7073286.html">【踩坑记录】记一次MySQL主从复制延迟的坑</a></p>
<p>视频资料：</p>
<p><a href="https://www.bilibili.com/video/av32782483?from=search&amp;seid=9619289845834549705">亿级大表分库分表解决方案</a></p>
<p><a href="https://www.bilibili.com/video/av44292088?from=search&amp;seid=9619289845834549705">基于mycat分库分表</a></p>
<p><a href="https://www.bilibili.com/video/av26912145?from=search&amp;seid=9619289845834549705">分库分表应对数据量过大</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解驱动开发之组件注册</title>
    <url>/2019/07/06/042/</url>
    <content><![CDATA[<h1 id="1-注解驱动开发"><a href="#1-注解驱动开发" class="headerlink" title="1. 注解驱动开发"></a>1. 注解驱动开发</h1><p>当我们还在使用Spring、SpringMVC、Mybatis三大框架来整合开发的时候，我们会写大量的xml文件来进行配置。然而在Springboot和SpringCloud兴起之后，学习Spring的注解驱动及其原理那将会是非常有必要的了，因为在Springboot和SpringCloud里面会使用到大量的注解来进行配置；当我们熟练掌握了Spring的注解驱动，那当我们在学习Springboot和SpringCloud框架的时候，那将会更加的轻松自如。</p>
<h2 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h2><p>这里使用<code>spring-context</code>来演示工程demo，pom 依赖如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="2-组件注册"><a href="#2-组件注册" class="headerlink" title="2. 组件注册"></a>2. 组件注册</h1><p>创建一个<code>Person</code>类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer age;	</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-1-xml方式注册"><a href="#2-1-xml方式注册" class="headerlink" title="2.1 xml方式注册"></a>2.1 xml方式注册</h2><p>创建一个 xml 配置文件，用于注册这个 Person 对象：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.woodwhale.king.code01.Person"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>ClassPathXmlApplicationContext</code>加载这个配置文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoadXml</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">"beans.xml"</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) applicationContext.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>Person(name=zhangsan, age=20)</p>
</blockquote>
<h2 id="2-2-注解方式注册"><a href="#2-2-注解方式注册" class="headerlink" title="2.2 注解方式注册"></a>2.2 注解方式注册</h2><p>使用注解的方式进行加载 bean，就需要编写一个配置类，等同于 xml 配置文件：</p>
<ul>
<li><p><code>@Bean</code>：相当于xml配置文件中的<code>&lt;bean&gt;</code>标签，告诉容器注册一个bean</p>
</li>
<li><p>之前xml文件中<code>&lt;bean&gt;</code>标签有bean的class类型，那么现在注解方式的类型当然也就是返回值的类型</p>
</li>
<li><p>之前xml文件中<code>&lt;bean&gt;</code>标签有bean的id，现在注解的方式默认用的是方法名来作为bean的id，也就是说当前注解的方法名是<code>person()</code>，那么id 就是<code>person</code>，如果方法名是<code>person01()</code>，那么id 就是<code>person01</code></p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"lisi"</span>, <span class="number">20</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果通过<code>@Bean</code>注解的<code>value</code>属性显式指定 bean 在 IOC 容器的id，那么就会以这个指定的id 为准注入容器中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean("person")</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person01</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">"king"</span>, <span class="number">22</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>AnnotationConfigApplicationContext</code>加载这个配置类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLoadAnnotation</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有 Person 类型的 bean 的id</span></span><br><span class="line">    printBeanName(applicationContext, Person.class);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printBeanName</span><span class="params">(ApplicationContext applicationContext, Class clazz)</span> {</span><br><span class="line">    String[] beanNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        System.out.println(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>Person(name=king, age=22)<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>appConfig<br>person</p>
</blockquote>
<p>从输出结果可以看到：配置类也作为了 bean 注入容器中，当使用@Bean 注解显示指定id 的时候，注册到容器中就是这个指定的id。</p>
<h2 id="2-3-组件自动扫描组件"><a href="#2-3-组件自动扫描组件" class="headerlink" title="2.3 组件自动扫描组件"></a>2.3 组件自动扫描组件</h2><p>在xml文件配置的方式，我们可以这样来进行配置：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包扫描、只要标注了@Controller、@Service、@Repository，@Component --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.woodwhale.king.code01"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>以前是在xml配置文件里面写包扫描，现在我们可以在配置类里面写包扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code01"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig2</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>@ComponentScan</code>注解会扫描当前包及其子包的所有带<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>注解的组件。</p>
<p><img src="https://image.woodwhales.cn/042/images/01.png"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testComponentScan</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig2.class);</span><br><span class="line">    String[] definitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : definitionNames) {</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>appConfig2<br>appConfig<br>book<br>bookController<br>bookDao<br>bookService<br>person</p>
</blockquote>
<p>在 <code>@ComponentScan</code> 这个注解上，也是可以指定要排除哪些包或者是只包含哪些包来进行管理：里面传是一个Filter[]数组：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// @ComponentScan 源码</span></span><br><span class="line">Filter[] includeFilters() <span class="keyword">default</span> {};</span><br><span class="line">Filter[] excludeFilters() <span class="keyword">default</span> {};</span><br></pre></td></tr></tbody></table></figure>

<p>xml 版本：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--包扫描，只要注解了@Component，@Controller等会被扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.woodwhale.king.code01"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除某个注解,除了Controller其他类都会被扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只包含某个注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注解版：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code01.*"},</span></span><br><span class="line"><span class="meta">					excludeFilters = { </span></span><br><span class="line"><span class="meta">							@Filter(type = FilterType.ANNOTATION, classes = {Controller.class, Service.class})</span></span><br><span class="line"><span class="meta">					})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig2</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中Filter的type的类型有:</p>
<ol>
<li><p>FilterType.ANNOTATION 按照注解</p>
</li>
<li><p>FilterType.ASSIGNABLE_TYPE 按照类型  FilterType.REGEX 按照正则</p>
</li>
<li><p>FilterType.ASPECTJ 按照ASPECJ表达式规则</p>
</li>
<li><p>FilterType.CUSTOM 使用自定义规则</p>
</li>
</ol>
<blockquote>
<p>excludeFilters = Filter[]	指定在扫描的时候按照什么规则来排除脑哪些组件</p>
<p>includeFilters = Filter[]	指定在扫描的时候，只需要包含哪些组件</p>
</blockquote>
<p>其中自定义规则类型过滤器需要实现TypeFilter接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * metadataReader:读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">	 * metadataReaderFactory:可以获取到其他任何类信息的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span><br><span class="line">			<span class="keyword">throws</span> IOException {</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取当前类注解的信息</span></span><br><span class="line">		<span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line">		<span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">		<span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> metadataReader.getResource();</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classMetadata.getClassName();</span><br><span class="line">		<span class="keyword">if</span>(className.contains(<span class="string">"Dao"</span>)){</span><br><span class="line">			System.out.println(<span class="string">"---&gt;"</span>+className);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>FilterType.CUSTOM</code>过滤器过滤：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code02"},</span></span><br><span class="line"><span class="meta">					includeFilters = {</span></span><br><span class="line"><span class="meta">							@Filter( type=FilterType.CUSTOM, classes= { MyTypeFilter.class })</span></span><br><span class="line"><span class="meta">					}, useDefaultFilters = false)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig2</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>—&gt;org.woodwhale.king.code01.dao.BookDao<br>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>appConfig2<br>bookDao</p>
</blockquote>
<p><code>FilterType.ANNOTATION</code>注解过滤：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code02"},</span></span><br><span class="line"><span class="meta">					includeFilters = {</span></span><br><span class="line"><span class="meta">							@Filter( type=FilterType.ANNOTATION, classes= { Service.class })</span></span><br><span class="line"><span class="meta">					}, useDefaultFilters = false)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig2</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>org.springframework.context.annotation.internalConfigurationAnnotationProcessor<br>org.springframework.context.annotation.internalAutowiredAnnotationProcessor<br>org.springframework.context.annotation.internalCommonAnnotationProcessor<br>org.springframework.context.event.internalEventListenerProcessor<br>org.springframework.context.event.internalEventListenerFactory<br>appConfig2<br>bookService</p>
</blockquote>
<p>我们还可以用 <code>@ComponentScans</code>来定义多个扫描规则：里面是<code>@ComponentScan</code>规则的数组（但是这样写的话，就必须要 java8 及以上的支持）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScans({@ComponentScan("org.woodwhale.king.code01"),</span></span><br><span class="line"><span class="meta">		@ComponentScan("org.woodwhale.king.code03")</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code02"},</span></span><br><span class="line"><span class="meta">					includeFilters = {</span></span><br><span class="line"><span class="meta">							@Filter( type=FilterType.ANNOTATION, classes= { Service.class })</span></span><br><span class="line"><span class="meta">					}, useDefaultFilters = false)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig2</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-bean-的作用域"><a href="#2-4-bean-的作用域" class="headerlink" title="2.4 bean 的作用域"></a>2.4 bean 的作用域</h2><p>spring  默认将所有的bean 以单例的形式注入，在容器初始化之前就会创建这个实例，直到容器关闭，会一直存在这个唯一的对象。</p>
<blockquote>
<p>注意：当作用域为单例的时候，IOC容器在启动的时候，就会将容器中所有作用域为单例的bean的实例给创建出来；以后的每次获取，就直接从IOC容器中来获取，相当于是从map.get()的一个过程；也就是 spring 在任何人没有获取 bean 的时候就缓存一份实例。</p>
</blockquote>
<p>配置类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages= {"org.woodwhale.king.code03"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig3</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个 bean 对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>多次从容器获取 bean ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode03</span> {</span><br><span class="line"></span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig3.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScopes</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> applicationContext.getBean(Student.class);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> applicationContext.getBean(Student.class);</span><br><span class="line">		System.out.println(student1);</span><br><span class="line">		System.out.println(student2);</span><br><span class="line">        System.out.println(student1 == student2);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>org.woodwhale.king.code03.Student@b62fe6d<br>org.woodwhale.king.code03.Student@b62fe6d<br>true</p>
</blockquote>
<p>我们可以用<code>@Scope</code>这个注解来指定作用域的范围：这个就相当于在xml文件中配置的<code>&lt;bean&gt;</code>标签里面指定<code>prototype</code>属性：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	* Specifies the name of the scope to use for the annotated component/bean.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Defaults to an empty string ({<span class="doctag">@code</span> ""}) which implies</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@link</span> ConfigurableBeanFactory#SCOPE_SINGLETON SCOPE_SINGLETON}.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@AliasFor("value")</span></span><br><span class="line">String <span class="title function_">scopeName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>从源码的注释上，我们可以知道scopeName可以取下面这些值：</p>
<ul>
<li><p>ConfigurableBeanFactory#SCOPE_PROTOTYPE</p>
<p>单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿。</p>
</li>
<li><p>ConfigurableBeanFactory#SCOPE_SINGLETON</p>
<p>多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象。</p>
</li>
<li><p>org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST</p>
<p>同一次请求创建一个实例</p>
</li>
<li><p>org.springframework.web.context.WebApplicationContext#SCOPE_SESSION</p>
<p>同一个session创建一个实例</p>
</li>
</ul>
<p>配置原型模式（ConfigurableBeanFactory#SCOPE_PROTOTYPE）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages= {"org.woodwhale.king.code03"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig3</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Student <span class="title function_">student</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"drop student into Spring IOC ..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试输出结果：</p>
<blockquote>
<p>drop student into Spring IOC …<br>drop student into Spring IOC …<br>org.woodwhale.king.code03.Student@78047b92<br>org.woodwhale.king.code03.Student@8909f18<br>false</p>
</blockquote>
<p>我们可以发现，我们用<code>getBean()</code>方法获取几次，就创建几次bean的实例；也就是说当bean是作用域为多例的时候，IOC容器启动的时候，就不会去创建bean的实例的，而是当我们调用<code>getBean()</code>获取的时候去创建bean的实例；而且每次调用的时候，都会创建bean的实例；</p>
<h2 id="2-5-懒加载"><a href="#2-5-懒加载" class="headerlink" title="2.5 懒加载"></a>2.5 懒加载</h2><p><code>@Lazy</code>注解可以在容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="title function_">student</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"drop student into Spring IOC ..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-6-Conditional-按照条件注册bean"><a href="#2-6-Conditional-按照条件注册bean" class="headerlink" title="2.6 @Conditional 按照条件注册bean"></a>2.6 @Conditional 按照条件注册bean</h2><p><code>@Conditional</code>：按照一定的条件进行判断，满足条件给容器中注册bean</p>
<p>举例：要求容器根据操作系统注入不同的bean，如果系统是 windows，给容器中注册(“bill”)，如果是linux系统，给容器中注册(“linus”)。</p>
<p>实现<code>Condition</code>接口，并重写匹配条件逻辑：</p>
<p>windows 条件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class="line">		<span class="comment">// 获取当前容器的环境信息</span></span><br><span class="line">		<span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取系统的名称</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">		<span class="keyword">if</span>(osName.contains(<span class="string">"Windows"</span>)){</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>linux 条件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinuxCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class="line">		<span class="comment">// 获取当前容器的环境信息</span></span><br><span class="line">		<span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> context.getEnvironment();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取系统的名称</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"osName --&gt; "</span> + osName);</span><br><span class="line">		<span class="keyword">if</span>(osName.contains(<span class="string">"Linux"</span>)){</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>@Conditional </code>按照一定条件进行判断，满足条件容器中注册bean，若放在类中，整个配置类中的bean满足条件才会被加载到容器中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig4</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Conditional(WindowsCondition.class)</span></span><br><span class="line">	<span class="meta">@Bean("bill")</span></span><br><span class="line">	<span class="keyword">public</span> Boss <span class="title function_">boss1</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boss</span>(<span class="string">"Bill Gates"</span>, <span class="number">62</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line">	<span class="meta">@Bean("linus")</span></span><br><span class="line">	<span class="keyword">public</span> Boss <span class="title function_">boss2</span><span class="params">()</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Boss</span>(<span class="string">"linus"</span>, <span class="number">48</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试一下注入容器的 id 是谁：</p>
<p>运行测试会发现，spring 只注入了 id 为 linus 的 bean 对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode04</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig4.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCondition</span><span class="params">()</span> {</span><br><span class="line">		String[] definitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : definitionNames) {</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 windows 系统运行，可以看到只输出了 id 为 bill 的 bean，可以在 JVM 运行参数中手动设置系统环境参数：<code>-Dos.name=Linux</code>，再次运行，则输出了 id 为 linus 的 bean</p>
<h2 id="2-7-Import-导入组件"><a href="#2-7-Import-导入组件" class="headerlink" title="2.7 @Import 导入组件"></a>2.7 @Import 导入组件</h2><h3 id="2-7-1-导入-bean-的类对象"><a href="#2-7-1-导入-bean-的类对象" class="headerlink" title="2.7.1 导入 bean 的类对象"></a>2.7.1 导入 bean 的类对象</h3><p><code>@Import(bean的类对象)</code>可以快速导入一个 bean ，而不需要使用<code>@Bean</code>注解一个方法的形式：只要将要注册bean 的类对象传进去，容器就能自动注册这个组：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Import(Color.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig5</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试是否导入成功：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode05</span> {</span><br><span class="line">	<span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig5.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testImport</span><span class="params">()</span> {</span><br><span class="line">		String[] definitionNames = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : definitionNames) {</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>appConfig5<br>org.woodwhale.king.code05.Color</p>
</blockquote>
<p>从输出结果可以看出：<code>@Import(bean的类对象)</code>注册的 id 默认是全类名。</p>
<h3 id="2-7-2-导入-ImportSelector-的实现类类对象"><a href="#2-7-2-导入-ImportSelector-的实现类类对象" class="headerlink" title="2.7.2 导入 ImportSelector 的实现类类对象"></a>2.7.2 导入 ImportSelector 的实现类类对象</h3><p>实现<code>ImportSelector</code>接口，重写<code>selectImports()</code>方法，返回要注册的 bean 对象的全类名：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"org.woodwhale.king.code05.Blue"</span>};</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>导入 实现类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Import({Color.class, MyImportSelector.class})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig5</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-7-3-手动注册-bean"><a href="#2-7-3-手动注册-bean" class="headerlink" title="2.7.3 手动注册 bean"></a>2.7.3 手动注册 bean</h3><p>实现<code>ImportBeanDefinitionRegistrar</code>接口，重写注册 bean 的注册方法，将所有要注册的 bean 手动注册 进容器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata:当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> {</span><br><span class="line"></span><br><span class="line">    String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        System.out.println(<span class="string">"registerBeanDefinitions --&gt; "</span> + beanName);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">blue</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">"org.woodwhale.king.code05.Blue"</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> registry.containsBeanDefinition(<span class="string">"org.woodwhale.king.code05.Color"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(color &amp;&amp; blue) {</span><br><span class="line">        <span class="comment">// 手动创建一个 BeanDefinition 并注册到容器中</span></span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">rootBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(RainBow.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"rainBow"</span>, rootBeanDefinition);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将这个实现类导入到容器中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Import({Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig5</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>appConfig5<br>org.woodwhale.king.code05.Color<br>org.woodwhale.king.code05.Blue<br>rainBow</p>
</blockquote>
<p><strong>注意</strong>：当所有组件都注册成功之后，才执行这个实现类的注册方法。</p>
<h2 id="2-8-使用FactoryBean注册组件"><a href="#2-8-使用FactoryBean注册组件" class="headerlink" title="2.8 使用FactoryBean注册组件"></a>2.8 使用FactoryBean注册组件</h2><p>首先创建一个类实现<code>FactoryBean&lt;T&gt;</code>接口，其中T是要注册的Bean的类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Color&gt; {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Color <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">		System.out.println(<span class="string">"getObject --&gt; new Color()"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Color</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() {</span><br><span class="line">		<span class="keyword">return</span> Color.class;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	接口的默认方法，默认返回true，表示单例模式</span></span><br><span class="line"><span class="comment">	 * 	返回 false 表示每次获取 bean 的时候就会调用getObject()方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将工厂类注册到配置类中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig5</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> ColorFactoryBean <span class="title function_">colorFactoryBean</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactoryBean</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFactoryBean</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Color</span> <span class="variable">colorFactoryBean1</span> <span class="operator">=</span> (Color)applicationContext.getBean(<span class="string">"colorFactoryBean"</span>);</span><br><span class="line">    <span class="type">Color</span> <span class="variable">colorFactoryBean2</span> <span class="operator">=</span> (Color)applicationContext.getBean(<span class="string">"colorFactoryBean"</span>);</span><br><span class="line">    System.out.println(<span class="string">"bean class type --&gt; "</span> + colorFactoryBean1.getClass());</span><br><span class="line"></span><br><span class="line">    System.out.println(colorFactoryBean1 == colorFactoryBean2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在id前面增加 &amp;，获取工厂对象本身</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">"&amp;colorFactoryBean"</span>);</span><br><span class="line">    System.out.println(<span class="string">"bean class type --&gt; "</span> + bean.getClass());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>getObject –&gt; new Color()<br>getObject –&gt; new Color()<br>bean class type –&gt; class org.woodwhale.king.code05.Color<br>false<br>bean class type –&gt; class org.woodwhale.king.code05.ColorFactoryBean</p>
</blockquote>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>xml 配置文件在 spring 注解开发中已经被替换成了Java 配置类，要成为具有 xml 功能的配置类，就需要在类名上增加<code>@Configuration</code>注解。</p>
<p>bean 组件注册的方式有以下：</p>
<ol>
<li>使用<code>@Bean</code>注解，编写创建 bean 并返回这个bean 的共有方法，在这个方法上加注解，默认会将方法名作为bean 的 id。</li>
</ol>
<p>容器默认装载的 bean 都是单例的，如果需要多例的 bean ，就需要添加<code>@Scope</code>注解。</p>
<ol start="2">
<li><p>实现<code>Condition</code>接口，并自定义条件规则，使用注解<code>@Conditional</code>对 bean 进行有条件的注册</p>
</li>
<li><p>使用<code>@Import</code>注解导入组件，有三种方式：</p>
<ul>
<li>直接传入 bean 的类对象到<code>@Import</code>属性中。</li>
<li>实现<code>ImportSelector</code>接口，重写<code>selectImports()</code>方法，返回将要注册的bean 的全类名字符串数组，最后将这个实现类的类对象传入<code>@Import</code>属性中。</li>
<li>实现<code>ImportBeanDefinitionRegistrar</code>接口，手动注册 bean 到容器中。</li>
</ul>
</li>
<li><p>使用<code>FactoryBean</code>接口的实现类，即 bean 的工厂类，配置到配置类中。</p>
</li>
</ol>
<p>扩展博文：</p>
<p><a href="https://blog.csdn.net/weixin_37778801/article/details/86233124">Spring注解驱动开发（一）</a></p>
<p><a href="https://www.miaoroom.com/code/backend/java/spring-annotation.html">「Java笔记」常见的Spring 注解 总结</a></p>
<p><a href="https://www.cnblogs.com/wangxiayun/p/10083217.html">Spring注解开发系列Ⅰ— 组件注册(上)</a></p>
<p><a href="https://www.cnblogs.com/wangxiayun/p/10102763.html">Spring注解开发系列Ⅱ — 组件注册(下)</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>组件注册</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解驱动开发之组件装配</title>
    <url>/2019/07/06/043/</url>
    <content><![CDATA[<h2 id="Bean的初始化和销毁方法"><a href="#Bean的初始化和销毁方法" class="headerlink" title="Bean的初始化和销毁方法"></a>Bean的初始化和销毁方法</h2><p>Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
<blockquote>
<p>spring 管理的 bean 的作用域默认是单例，在容器启动的时候创建对象。而作用域是多例的时候，是在每次获取的时候创建对象，容器不会调用销毁方法。</p>
</blockquote>
<p>bean 的初始化和销毁方法可以：</p>
<ol>
<li><code>@Bean</code>注解的<code>init-methdod</code>和<code>destroy-method</code>属性中指定，但是要求传入的是不带参数的方法名。</li>
<li>实现<code>InitializingBean</code>和<code>DisposableBean</code>接口</li>
<li>使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解</li>
<li>实现<code>BeanPostProcessor</code>接口（后置处理器）。</li>
</ol>
<h3 id="Bean-注解属性设置"><a href="#Bean-注解属性设置" class="headerlink" title="@Bean 注解属性设置"></a>@Bean 注解属性设置</h3><p>对要注册的 bean，自定义初始化和销毁方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"car construct..."</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"car init..."</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"car destory..."</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将自定义的初始化方法和销毁方法名配置到<code>@Bean</code>注解属性中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig6</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean(initMethod = "init", destroyMethod = "destory")</span></span><br><span class="line">	<span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>加载配置类，随即关闭容器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode06</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLifeMethod</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig6.class);</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>car construct…<br>car init…<br>容器创建完成<br>car destory…</p>
</blockquote>
<p>当设置 bean 的作用域是多例的时候：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Bean(initMethod = "init", destroyMethod = "destory")</span></span><br><span class="line"><span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试结果：</p>
<blockquote>
<p>容器创建完成</p>
</blockquote>
<p>在关闭前获取一次 bean 测试 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode06</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLifeMethod</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig6.class);</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">		</span><br><span class="line">		applicationContext.getBean(Car.class);</span><br><span class="line">		</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试结果：</p>
<blockquote>
<p>car construct…<br>car init…<br>容器创建完成<br>car destory…</p>
</blockquote>
<p>因此可以得出：spring 对于多例作用域的 bean，只有在获取 bean 的时候才执行配置的初始化和销毁的方法。</p>
<h3 id="实现InitializingBean和DisposableBean接口"><a href="#实现InitializingBean和DisposableBean接口" class="headerlink" title="实现InitializingBean和DisposableBean接口"></a>实现InitializingBean和DisposableBean接口</h3><p>要注册的 bean 实现 <code>InitializingBean</code>接口和<code>DisposableBean</code>接口，自己重写初始化方法和销毁方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Tank</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"tank construct..."</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">		System.out.println(<span class="string">"tank --&gt; DisposableBean --&gt; destroy"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">		System.out.println(<span class="string">"tank --&gt; InitializingBean --&gt; afterPropertiesSet"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将这个 bean 也配置到配置类中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig6</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">// @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">	<span class="meta">@Bean(initMethod = "init", destroyMethod = "destory")</span></span><br><span class="line">	<span class="keyword">public</span> Car <span class="title function_">car</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Tank <span class="title function_">tank</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode06</span> {</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLifeMethod</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig6.class);</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>car construct…<br>car init…<br>tank construct…<br>tank –&gt; InitializingBean –&gt; afterPropertiesSet<br>容器创建完成<br>tank –&gt; DisposableBean –&gt; destroy<br>car destory…</p>
</blockquote>
<h3 id="PostConstruct和-PreDestroy注解"><a href="#PostConstruct和-PreDestroy注解" class="headerlink" title="@PostConstruct和@PreDestroy注解"></a>@PostConstruct和@PreDestroy注解</h3><p>spring 支持对JSR250规范的注解：</p>
<p><code>@PostConstruct</code>：在bean创建完成并且属性赋值完成，来执行初始化方法</p>
<p><code>@PreDestroy</code>：在容器销毁 bean 之前通知我们进行清理工作</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"dog construct..."</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"dog init..."</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"dog destory..."</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试输出结果：</p>
<blockquote>
<p>dog construct…<br>dog init…<br>容器创建完成<br>dog destory…</p>
</blockquote>
<h3 id="实现BeanPostProcessor接口"><a href="#实现BeanPostProcessor接口" class="headerlink" title="实现BeanPostProcessor接口"></a>实现BeanPostProcessor接口</h3><p>BeanPostProcessor是Spring IOC容器给我们提供的一个扩展接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如上接口声明所示，BeanPostProcessor接口有两个回调方法：</p>
<p>当一个BeanPostProcessor的实现类注册到Spring IOC容器后，对于该Spring IOC容器所创建的每个bean实例在初始化方法（如afterPropertiesSet和任意已声明的init方法）调用前，将会调用BeanPostProcessor中的postProcessBeforeInitialization方法。</p>
<p>而在bean实例初始化方法调用完成后，则会调用BeanPostProcessor中的postProcessAfterInitialization方法，整个调用顺序可以简单示意如下：</p>
<ol>
<li>Spring IOC容器实例化Bean</li>
<li>调用BeanPostProcessor的postProcessBeforeInitialization方法</li>
<li>调用bean实例的初始化方法</li>
<li>调用BeanPostProcessor的postProcessAfterInitialization方法</li>
</ol>
<p>可以看到，Spring容器通过BeanPostProcessor给了我们一个机会对Spring管理的bean进行再加工。比如：我们可以修改bean的属性，可以给bean生成一个动态代理实例等等。一些Spring AOP的底层处理也是通过实现BeanPostProcessor来执行代理包装逻辑的。</p>
<blockquote>
<p>多例作用域的 bean 不执行该接口的两个方法。</p>
</blockquote>
<p>实现<code>BeanPostProcessor</code>接口，并重写两个默认的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">		System.out.println(<span class="string">"postProcessBeforeInitialization..."</span> + beanName + <span class="string">" =&gt; "</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">		System.out.println(<span class="string">"postProcessBeforeInitialization..."</span> + beanName + <span class="string">" =&gt; "</span> + bean);</span><br><span class="line">		<span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意</strong>：在很多资料中说接口中两个方法不能返回null，如果返回null，那么在后续初始化方法将报空指针异常或者通过getBean()方法获取不到bena实例对象，因为后置处理器从Spring IoC容器中取出bean实例对象没有再次放回IoC容器中。但是本例是使用<code>spring-context 5.1.8.RELEASE</code>版本，即使返回 null 也不会报错，也可以正常获取bean。</p>
<p>配置一个 bean 到配置类中 ：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan("org.woodwhale.king.code06")</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig6</span> {</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode06</span> {	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLifeMethod</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig6.class);</span><br><span class="line">		System.out.println(<span class="string">"容器创建完成"</span>);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>dog construct…<br>postProcessBeforeInitialization…dog =&gt; org.woodwhale.king.code06.Dog@a4102b8<br>dog init…<br>postProcessBeforeInitialization…dog =&gt; org.woodwhale.king.code06.Dog@a4102b8<br>容器创建完成<br>dog destory…</p>
</blockquote>
<p>从输出结果可以看到：在 bean 构造完成，在执行初始化方法的前后可以自定义一些逻辑，这极大的增强了spring 的扩展性</p>
<p><code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code>类中的源码体现了上述接口的执行逻辑：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 给bean进行属性赋值</span></span><br><span class="line">populateBean(beanName, bd, bw);</span><br><span class="line"><span class="comment">// 初始化 bean 操作</span></span><br><span class="line">initializeBean(beanName, existingBean, bd){</span><br><span class="line">    <span class="comment">// 初始化之前回调</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// 调用自定义的初始化方法</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// 初始化之后回调</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h2><p>在Spring框架中，属性的注入我们有多种方式，我们可以通过构造方法注入，可以通过set方法注入，也可以通过p名称空间注入，方式多种多样，对于复杂的数据类型比如对象、数组、List集合、map集合、Properties等，我们也都有相应的注入方式。其中比较常用的是set注入的方式，下面来看看spring的Set注入的方式：</p>
<h3 id="使用-Value赋值"><a href="#使用-Value赋值" class="headerlink" title="使用@Value赋值"></a>使用@Value赋值</h3><p>使用<code>@Value</code>注解赋值 bean 属性</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">	<span class="comment">// 基本数值</span></span><br><span class="line">	<span class="meta">@Value("zhangsan")</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以写SpEL； #{}</span></span><br><span class="line">	<span class="meta">@Value("#{20+1}")</span></span><br><span class="line">	<span class="keyword">private</span> String age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode07</span> {</span><br><span class="line">	<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig7.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testValue</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>Person(name=zhangsan, age=21)</p>
</blockquote>
<h3 id="从配置文件中读取"><a href="#从配置文件中读取" class="headerlink" title="从配置文件中读取"></a>从配置文件中读取</h3><p>xml 版本：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:person.properties"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>@PropertySource</code>读取外部配置文件中的k/v保存到运行的环境变量中，加载完外部的配置文件以后使用<code>${}</code>取出配置文件的值：</p>
<p>创建配置文件application.properties，并存一份配置：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">person.nickName</span>=<span class="string">lisi</span></span><br></pre></td></tr></tbody></table></figure>

<p>配置类中增加<code>@PropertySource</code>注解，引入外部配置文件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = {"classpath:/application.properties"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig7</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用<code>@Value</code>注解的<code>${}</code>表达式取出容器中的配置信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">	<span class="comment">// 基本数值</span></span><br><span class="line">	<span class="meta">@Value("zhangsan")</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以写SpEL； #{}</span></span><br><span class="line">	<span class="meta">@Value("#{20+1}")</span></span><br><span class="line">	<span class="keyword">private</span> String age;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 可以写${} 取出配置文件(properties)中的值（在运行环境变量里面的值）</span></span><br><span class="line">	<span class="meta">@Value("${person.nickName}")</span></span><br><span class="line">	<span class="keyword">private</span> String nickName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外，在容器对象中也可以直接获取：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode07</span> {</span><br><span class="line">	<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig7.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testValue</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> applicationContext.getBean(Person.class);</span><br><span class="line">		System.out.println(person);</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">"person.nickName"</span>);</span><br><span class="line">		System.out.println(property);</span><br><span class="line">		applicationContext.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>Person(name=zhangsan, age=21, nickName=lisi)<br>lisi</p>
</blockquote>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>spring利用依赖注入和DI完成对IOC容器中各个组件的依赖关系赋值。自动装配的优点有：自动装配可以大大地减少属性和构造器参数的指派。自动装配也可以在解析对象时更新配置。自动装配的方式有很多，其中包含spring的注解以及java自带的注解。</p>
<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>在xml 方式的时候：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 该 BeanPostProcessor 将自动对标注 @Autowired 的 Bean 进行注入 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"</span>/&gt;</span> </span><br></pre></td></tr></tbody></table></figure>

<p>spring 提供了<code>@Autowired</code>注解可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作。无需再通过传统的在 bean 的xml文件中进行bean的注入配置。</p>
<p>@Autowired是根据类型进行标注的，如需要按照名称进行装配，则需要配合<code>@Qualifier</code>使用：</p>
<ol>
<li>默认优先按照 bean 的类型去容器中找对应的组件</li>
<li>若有多个相同类型的组件，再将属性名称作为组件的 id 去容器中查找</li>
<li>使用<code>@Qualifier("bookDao")</code>来指定需要装配的组件id而不是根据属性名</li>
<li>使用<code>@Autowired</code>注解的时候，如果容器中没有这个类型的 bean 就会报异常，可以显式指定<code>@Autowired(required=false)</code>避免报错</li>
<li><code>@Primary</code>让Spring进行自动装配时，在没有明确用<code>@Qualifier</code>指定的情况下默认使用优先首选的 bean</li>
</ol>
<p>创建 service 接口，并自定义两个实现类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>自定义 cotroller 应用 service 接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>配置包扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code08"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig8</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode08</span> {</span><br><span class="line">	<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig8.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAutowired</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(applicationContext.getBean(UserController.class));</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行会报异常：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'userController': Unsatisfied dependency expressed through field 'userService'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.woodwhale.king.code08.service.UserService' available: expected single matching bean but found 2: userServiceImpl1,userServiceImpl2</span><br></pre></td></tr></tbody></table></figure>

<p>表示容器中有多个 service 类型的 bean ，<code>@Autowired</code>注解的属性名是：userService，找不到 id 为这个属性名的 bean，所以抛出异常。</p>
<p>因此可以修改属性名找到对应的 bean：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userServiceImpl1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>UserController(userServiceImpl1=org.woodwhale.king.code08.service.UserServiceImpl1@501edcf1)</p>
</blockquote>
<p>这种方式不是很优雅，属性名改了，所有用到这个属性变量名的地方都需要改，因此可以使用<code>@Qualifier</code>注解，显式指定容器中的 bean：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Qualifier("userServiceImpl2")</span></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>UserController(userService=org.woodwhale.king.code08.service.UserServiceImpl2@78b729e6)</p>
</blockquote>
<p>还有一种办法就是，对某个组件使用<code>@Primary</code>注解，这个注解表示，如果存在相同类型的 bean，就以这个为主依赖。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userServiceImpl1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>UserController(userServiceImpl1=org.woodwhale.king.code08.service.UserServiceImpl2@3c9d0b9d)</p>
</blockquote>
<h3 id="Resource和-Inject"><a href="#Resource和-Inject" class="headerlink" title="@Resource和@Inject"></a>@Resource和@Inject</h3><p>Spring还支持使用<code>@Resource</code>（JSR250）和<code>@Inject</code>（JSR330）</p>
<p><strong>@Resource</strong></p>
<p>可以和<code>@Autowired</code>一样实现自动的装配，默认是按照组件的名称来进行装配，不支持<code>@Primary</code> 也没有支持和<code>@Autowired(required = false)</code>一样的功能。</p>
<p><strong>@Inject</strong></p>
<p>需要导入javax.inject的包，和<code>@Autowired</code>的功能一样，不支持和<code>@Autowired(required = false)</code>一样的功能。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Autowired可标注的地方"><a href="#Autowired可标注的地方" class="headerlink" title="@Autowired可标注的地方"></a>@Autowired可标注的地方</h3><p>我们从<code>@Autowired</code>这个注解点进去看一下源码，我们可以发现这个注解可以标注的位置有：构造器，参数，方法，属性；都是从容器中来获取参数组件的值：</p>
<h4 id="标注在方法的参数上"><a href="#标注在方法的参数上" class="headerlink" title="标注在方法的参数上"></a>标注在方法的参数上</h4><p><code>@Autowired</code>可以标注在方法的参数上，如果容器里只有一种类型的bean，那么在<code>@Bean</code>注解这个方法的时候，可以省略不写：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = {"org.woodwhale.king.code08"})</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig8</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(UserController userController)</span> {</span><br><span class="line">		System.out.println(userController.getClass());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以上等价于以下</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> User <span class="title function_">user</span><span class="params">(<span class="meta">@Autowired</span> UserController userController)</span> {</span><br><span class="line">		System.out.println(userController.getClass());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="标注在方法上"><a href="#标注在方法上" class="headerlink" title="标注在方法上"></a>标注在方法上</h4><p><code>@Autowired</code>可以注解在属性上，也可以注解在 setter 方法上，这种很不常用：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span>{</span><br><span class="line">    <span class="built_in">this</span>.userService = userService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="标注在构造函数上"><a href="#标注在构造函数上" class="headerlink" title="标注在构造函数上"></a>标注在构造函数上</h4><p><code>@Autowired</code>可以标注在构造函数上，需要注意的是，这种也需要注意参数名称和容器中同类型bean 的问题，解决办法还是在方法参数前面注解<code>@Qualifier</code>显式指定bean：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userServiceImpl2)</span> {</span><br><span class="line">    <span class="built_in">this</span>.userService = userServiceImpl2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>UserController(userService=org.woodwhale.king.code08.service.UserServiceImpl2@6b26e945)</p>
</blockquote>
<p>显式指定：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(<span class="meta">@Qualifier("userServiceImpl1")</span> UserService userService)</span> {</span><br><span class="line">    <span class="built_in">this</span>.userService = userService;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>UserController(userService=org.woodwhale.king.code08.service.UserServiceImpl1@54c562f7)</p>
</blockquote>
<p>综上，这种配置也是常用。</p>
<h2 id="使用spring底层组件"><a href="#使用spring底层组件" class="headerlink" title="使用spring底层组件"></a>使用spring底层组件</h2><p>要想使用spring底层组件，如<code>ApplicationContext</code>、<code>BeanFactory</code>等。假设有个 Food 组件需要使用<code>ApplicationContext</code>对象，那么可以实现<code>ApplicationContextAware</code>接口，重写<code>setApplicationContext()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, BeanNameAware, EmbeddedValueResolverAware {</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">		<span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> {</span><br><span class="line">		<span class="type">String</span> <span class="variable">resolveStringValue</span> <span class="operator">=</span> resolver.resolveStringValue(<span class="string">"current os name = ${os.name}"</span>);</span><br><span class="line">		System.out.println(resolveStringValue);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> {</span><br><span class="line">		System.out.println(<span class="string">"current bean name = "</span> + name);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>spring 提供了很多<code>Aware</code>接口的子类接口，并且提供了回调方法，用于我们自定义组件实现这些接口，重写这些回调方法就能拿到 spring 底层的对象了。<code>ApplicationContextAware</code>接口获取IOC容器，<code>BeanNameAware</code>接口获取当前 bean 在容器中的 name，<code>EmbeddedValueResolverAware</code>解析 spring 中支持的表达式。</p>
<h2 id="xxxAware接口回调原理"><a href="#xxxAware接口回调原理" class="headerlink" title="xxxAware接口回调原理"></a>xxxAware接口回调原理</h2><p>所有xxxAware都会被ApplicationContextAwareProcessor实现类调用。看<code>org.springframework.context.support.ApplicationContextAwareProcessor</code>源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException {</span><br><span class="line">    <span class="type">AccessControlContext</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">         bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">         bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware)) {</span><br><span class="line">        acc = <span class="built_in">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acc != <span class="literal">null</span>) {</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {</span><br><span class="line">            invokeAwareInterfaces(bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }, acc);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        invokeAwareInterfaces(bean);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> {</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) {</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) {</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) {</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) {</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) {</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) {</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) {</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>invokeAwareInterfaces()</code>方法中，依次找对应的接口，并调用对应的接口方法，完成传参操作。</p>
<h2 id="Profile根据环境装载"><a href="#Profile根据环境装载" class="headerlink" title="@Profile根据环境装载"></a>@Profile根据环境装载</h2><p>Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能，实际开发中分为：开发环境、测试环境和生产环境。</p>
<p><code>@Profile</code>注解可以指定组件在哪个环境下才能被注册到容器中，加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中，默认是default。</p>
<p>环境激活的两种方法：</p>
<ul>
<li><p>使用命令行动态参数：在JVM参数配置<code>-Dspring.profiles.active=test</code></p>
</li>
<li><p>代码的方式激活某种环境</p>
</li>
</ul>
<p>自定义一个数据库源：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>配置多个数据源：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig9</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Profile("test")</span></span><br><span class="line">	<span class="meta">@Bean("testDataSource")</span></span><br><span class="line">	<span class="keyword">public</span> MyDataSource <span class="title function_">testDataSource</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource; </span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile("prod")</span></span><br><span class="line">	<span class="meta">@Bean("prodDataSource")</span></span><br><span class="line">	<span class="keyword">public</span> MyDataSource <span class="title function_">prodDataSource</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/prod"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource; </span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile("dev")</span></span><br><span class="line">	<span class="meta">@Bean("devDataSource")</span></span><br><span class="line">	<span class="keyword">public</span> MyDataSource <span class="title function_">devDataSource</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/dev"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource; </span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean("dataSource")</span></span><br><span class="line">	<span class="keyword">public</span> MyDataSource <span class="title function_">dataSource</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/default"</span>);</span><br><span class="line">		<span class="keyword">return</span> dataSource; </span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCode09</span> {</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProfile</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig9.class);</span><br><span class="line">		<span class="type">MyDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> applicationContext.getBean(MyDataSource.class);</span><br><span class="line">		System.out.println(dataSource);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>MyDataSource(jdbcUrl=jdbc:mysql://localhost:3306/default)</p>
</blockquote>
<p>可以使用JVM命令行参数指定运行环境，也可以在容器初始化的时候代码指定：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProfileCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//1、创建一个applicationContext</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    <span class="comment">//2、设置需要激活的环境</span></span><br><span class="line">    applicationContext.getEnvironment().setActiveProfiles(<span class="string">"dev"</span>);</span><br><span class="line">    <span class="comment">//3、注册主配置类</span></span><br><span class="line">    applicationContext.register(AppConfig9.class);</span><br><span class="line">    <span class="comment">//4、启动刷新容器</span></span><br><span class="line">    applicationContext.refresh();</span><br><span class="line"></span><br><span class="line">    String[] beanNames = applicationContext.getBeanNamesForType(MyDataSource.class);</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) {</span><br><span class="line">        System.out.println(beanName);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>devDataSource<br>dataSource</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>bean 对象的初始化和销毁方法：</p>
<p>1）使用 @Bean 注解的属性配置</p>
<p>2）实现InitializingBean和DisposableBean接口</p>
<p>3）使用@PostConstruct和@PreDestroy注解</p>
<p>4）实现BeanPostProcessor接口，能够在bean的属性装配成功之后，在初始化方法执行的前后增加逻辑</p>
</li>
<li><p>属性赋值可以使用 @Value 注解，其属性可以配置 “${}” 占位符，配合 @PropertySource 注解引入外部配置文件，然后就可以动态为属性赋值。</p>
</li>
<li><p>组件的自动装配：</p>
<p>1）使用 @Atuowired 注解进行自动装配，当容器中存在多个相同类型的 bean 的时候，可以使用 @Qualifier 注解进行显式指定。</p>
<p>2）使用@Resource或@Inject</p>
</li>
<li><p>想要使用 spring 底层的组件，如 spring ioc 容器可以实现 ApplicationContextAware 接口。当然也可以直接在让spring 通过构造函数传入。</p>
</li>
<li><p>由于在开发中会根据不同的软件环境来装载不同的相同类型的不同组件，如根据软件环境装配数据源，就就可以使用 @Profile 注解。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>组件装配</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Java代码示例</title>
    <url>/2019/09/28/044/</url>
    <content><![CDATA[<h2 id="list-集合转-list-集合"><a href="#list-集合转-list-集合" class="headerlink" title="list 集合转 list 集合"></a>list 集合转 list 集合</h2><p>原始集合转成新的集合，如 DO 转 DTO，伪代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.woodwhales.model.UserDTO</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.entity.UserDO</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;UserDTO&gt; <span class="title function_">getAllUserDTOList</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(UserMapper.selectAll())</span><br><span class="line">                .orElse(Collections.emptyList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::do2dto)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UserDTO <span class="title function_">do2dto</span><span class="params">(UserDO userDO)</span> {</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> userDO.getId;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> userDO.getUserName;</span><br><span class="line">    </span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDTO</span>(userId, userName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userDTO;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="list-字符数据存入文件并压缩打包"><a href="#list-字符数据存入文件并压缩打包" class="headerlink" title="list 字符数据存入文件并压缩打包"></a>list 字符数据存入文件并压缩打包</h2><p>使用 apache 的文件压缩包、IO 工具包和通用包：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-compress<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>解压缩源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.woodwhales.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.ZipInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.ArchiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.ArchiveOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.ArchiveStreamFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.zip.Zip64Mode;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.zip.ZipArchiveEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class FileTools {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ZIP_SUFFIX</span> <span class="operator">=</span> <span class="string">".zip"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ATTACHMENT</span> <span class="operator">=</span> <span class="string">"attachment; filename="</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *	将list中的字符串数据压缩到文件后缀为 suffix 的文件中，</span></span><br><span class="line"><span class="comment">     *	并对当前列表文件打包成一个zip压缩包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] zipToFile(List&lt;String&gt; fileContentList, String suffix) <span class="keyword">throws</span> IOException, ArchiveException {</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">archiveStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ArchiveOutputStream</span> <span class="variable">archive</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArchiveStreamFactory</span>().createArchiveOutputStream(ArchiveStreamFactory.ZIP, archiveStream);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String fileContent : fileContentList) {</span><br><span class="line">            <span class="comment">// 生成文件名一个UUID的文件</span></span><br><span class="line">            <span class="type">ZipArchiveEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipArchiveEntry</span>(UUID.randomUUID().toString() + suffix);</span><br><span class="line">            <span class="comment">// 将要打进压缩包的文件放进压缩文件对象中</span></span><br><span class="line">            archive.putArchiveEntry(entry);</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> IOUtils.toInputStream(fileContent, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line">            IOUtils.copy(input, archive);</span><br><span class="line">            input.close();</span><br><span class="line">            archive.closeArchiveEntry();</span><br><span class="line">        }</span><br><span class="line">        archive.finish();</span><br><span class="line">        <span class="type">byte</span>[] byteArray = archiveStream.toByteArray();</span><br><span class="line">        archiveStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteArray;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isZipFile</span><span class="params">(String originalFilename)</span> {</span><br><span class="line">        <span class="keyword">return</span> StringUtils.endsWith(originalFilename, ZIP_SUFFIX);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getZipFileContent</span><span class="params">(MultipartFile file)</span> {</span><br><span class="line">		<span class="keyword">if</span> (file.isEmpty()) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; results = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			results =  unZip(file.getInputStream());</span><br><span class="line">		} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">			log.warn(<span class="string">"unzip process is filed! cause by : {}"</span>, e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> results;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getZipFileContent</span><span class="params">(String zipFile)</span> {</span><br><span class="line">		<span class="keyword">if</span>(StringUtils.isEmpty(zipFile)) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; results = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			results = unZip(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(zipFile)));</span><br><span class="line">		} <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">			log.warn(<span class="string">"unzip process is filed! cause by : {}"</span>, e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> results;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">unZip</span><span class="params">(InputStream zipFile)</span> {</span><br><span class="line">		<span class="keyword">if</span>(zipFile == <span class="literal">null</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// get the zip file content</span></span><br><span class="line">		List&lt;String&gt; lists = <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			zis = <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(zipFile);</span><br><span class="line">			<span class="comment">// get the zipped file list entry</span></span><br><span class="line">			<span class="type">ZipEntry</span> <span class="variable">ze</span> <span class="operator">=</span> zis.getNextEntry();</span><br><span class="line">			log.debug(<span class="string">"file size = {}"</span>, ze.getSize());</span><br><span class="line">			lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span> (ze != <span class="literal">null</span>) {</span><br><span class="line">				log.debug(<span class="string">"file name = {}"</span>, ze.getName());</span><br><span class="line">				<span class="type">byte</span>[] byteArray = IOUtils.toByteArray(zis);</span><br><span class="line">				lists.add(<span class="keyword">new</span> <span class="title class_">String</span>(byteArray, StandardCharsets.UTF_8));</span><br><span class="line">				ze = zis.getNextEntry();</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		} <span class="keyword">finally</span> {</span><br><span class="line">			<span class="keyword">if</span>(zis != <span class="literal">null</span>) {</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">					zis.closeEntry();</span><br><span class="line">					zis.close();</span><br><span class="line">				} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> lists; </span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compressFiles2Zip</span><span class="params">(File[] files, String zipFilePath)</span> {</span><br><span class="line">		<span class="keyword">if</span> (files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) {</span><br><span class="line">			<span class="type">ZipArchiveOutputStream</span> <span class="variable">zaos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(zipFilePath);</span><br><span class="line">			<span class="keyword">if</span> (f.isDirectory()) {</span><br><span class="line">				log.info(<span class="string">"this zipFilePath = {} is Directory"</span>, zipFilePath);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (f.exists()) {</span><br><span class="line">				f.delete();</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				<span class="type">File</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(zipFilePath);</span><br><span class="line">				zaos = <span class="keyword">new</span> <span class="title class_">ZipArchiveOutputStream</span>(zipFile);</span><br><span class="line">				zaos.setUseZip64(Zip64Mode.AsNeeded);</span><br><span class="line">				<span class="comment">// int index = 0;</span></span><br><span class="line">				<span class="keyword">for</span> (File file : files) {</span><br><span class="line">					<span class="keyword">if</span> (file != <span class="literal">null</span>) {</span><br><span class="line">						<span class="type">ZipArchiveEntry</span> <span class="variable">zipArchiveEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipArchiveEntry</span>(file,</span><br><span class="line">								<span class="keyword">new</span> <span class="title class_">File</span>(file.getParent()).getName() + File.separator + file.getName());</span><br><span class="line">						zaos.putArchiveEntry(zipArchiveEntry);</span><br><span class="line">						<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">						<span class="keyword">try</span> {</span><br><span class="line">							is = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">							<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">							<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">							<span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">								<span class="comment">// flush buffer into ZipArchiveEntry</span></span><br><span class="line">								zaos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">							}</span><br><span class="line">							<span class="comment">// Writes all necessary data for this entry.</span></span><br><span class="line">							zaos.closeArchiveEntry();</span><br><span class="line">						} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">						} <span class="keyword">finally</span> {</span><br><span class="line">							<span class="keyword">if</span> (is != <span class="literal">null</span>)</span><br><span class="line">								is.close();</span><br><span class="line">						}</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				zaos.finish();</span><br><span class="line">			} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">			} <span class="keyword">finally</span> {</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">					<span class="keyword">if</span> (zaos != <span class="literal">null</span>) {</span><br><span class="line">						zaos.close();</span><br><span class="line">					}</span><br><span class="line">				} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">genAttachment</span><span class="params">(String fileName)</span> {</span><br><span class="line">		<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">		sb.append(ATTACHMENT).append(fileName);</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getOriginalFilename</span><span class="params">(MultipartFile file)</span> {</span><br><span class="line">		<span class="keyword">if</span> (file == <span class="literal">null</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> file.getOriginalFilename();</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">FileTools</span><span class="params">()</span> {</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="时间日期工具"><a href="#时间日期工具" class="headerlink" title="时间日期工具"></a>时间日期工具</h2><p>时间日期使用了 JDK1.8 的<code>Instant</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.woodwhales.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DATE_FORMAT</span> <span class="operator">=</span> <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">YYYYMMDDHHMMSS</span> <span class="operator">=</span> <span class="string">"yyyyMMddHHmmss"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OFFSETID</span> <span class="operator">=</span> <span class="string">"+8"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(DEFAULT_DATE_FORMAT);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Long milliSecond)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(milliSecond == <span class="literal">null</span> || milliSecond &lt;= <span class="number">0</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">return</span> threadLocal.get().format(milliSecond);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Date date)</span> {</span><br><span class="line">    	<span class="keyword">if</span>(date == <span class="literal">null</span>) {</span><br><span class="line">    		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    	}</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> convertLocalDateTime(date);</span><br><span class="line">    	<span class="type">Long</span> <span class="variable">milliSecond</span> <span class="operator">=</span> getMilliSecond(localDateTime);</span><br><span class="line">    	<span class="keyword">return</span> format(milliSecond);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getMilliSecond</span><span class="params">()</span> {</span><br><span class="line">    	<span class="keyword">return</span> LocalDateTime.now().toInstant(ZoneOffset.of(OFFSETID)).toEpochMilli();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getMilliSecond</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">    	<span class="keyword">return</span> localDateTime.toInstant(ZoneOffset.of(OFFSETID)).toEpochMilli();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">()</span> {</span><br><span class="line">    	<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> LocalDateTime.now().toInstant(ZoneOffset.of(OFFSETID));</span><br><span class="line">    	<span class="keyword">return</span> instant;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getNowDate</span><span class="params">()</span> {</span><br><span class="line">    	<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> getInstant();</span><br><span class="line">    	<span class="keyword">return</span> convertDate(instant);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNowStr</span><span class="params">()</span> {</span><br><span class="line">    	<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> getInstant();</span><br><span class="line">    	<span class="keyword">return</span> formatter.format(instant);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNowStr</span><span class="params">(String formatterStr)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    	<span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(formatterStr);</span><br><span class="line">    	<span class="keyword">return</span> formatter.format(now);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">convertInstant</span><span class="params">(Date date)</span> {</span><br><span class="line">    	<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br><span class="line">    	<span class="keyword">return</span> instant;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">convertLocalDateTime</span><span class="params">(String dateStr)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">    	<span class="keyword">return</span> localDateTime;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">convertLocalDateTime</span><span class="params">(String dateStr, String formatterStr)</span> {</span><br><span class="line">    	<span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(formatterStr);</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, formatter);</span><br><span class="line">    	<span class="keyword">return</span> localDateTime;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">convertLocalDateTime</span><span class="params">(Date date)</span> {</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(convertInstant(date), ZoneId.systemDefault());</span><br><span class="line">		<span class="keyword">return</span> localDateTime;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">convertInstant</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">    	<span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> localDateTime.toInstant(ZoneOffset.of(OFFSETID));</span><br><span class="line">    	<span class="keyword">return</span> instant;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">convertDate</span><span class="params">(String dateStr)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">convertLocalDateTime</span> <span class="operator">=</span> convertLocalDateTime(dateStr);</span><br><span class="line">    	<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> convertDate(convertInstant(convertLocalDateTime));</span><br><span class="line">    	<span class="keyword">return</span> date;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">convertDate</span><span class="params">(Instant instant)</span> {</span><br><span class="line">    	<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(instant);</span><br><span class="line">    	<span class="keyword">return</span> date;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">convertDate</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">    	<span class="keyword">return</span> Date.from(convertInstant(localDateTime));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title function_">convertLocalDate</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">    	<span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> localDateTime.getYear();</span><br><span class="line">    	<span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> localDateTime.getMonth();</span><br><span class="line">    	<span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> localDateTime.getDayOfMonth();</span><br><span class="line">    	<span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(year, month, day);</span><br><span class="line">    	<span class="keyword">return</span> localDate;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compareDateisAfter</span><span class="params">(Date date)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">nowLocalDateTime</span> <span class="operator">=</span> convertLocalDateTime(getNowDate());</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">compareLocalDateTime</span> <span class="operator">=</span> convertLocalDateTime(date);</span><br><span class="line">    	<span class="keyword">return</span> compareLocalDateTime.isAfter(nowLocalDateTime);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compareDateisBefore</span><span class="params">(Date date)</span> {</span><br><span class="line">    	<span class="keyword">return</span> !compareDateisAfter(date);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">plusYears</span><span class="params">(Date date, <span class="type">int</span> years)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> convertLocalDateTime(date);</span><br><span class="line">    	<span class="keyword">return</span> convertDate(localDateTime.plusYears(years));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">plusMinutes</span><span class="params">(Date date, <span class="type">int</span> minutes)</span> {</span><br><span class="line">    	<span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> convertLocalDateTime(date);</span><br><span class="line">    	<span class="keyword">return</span> convertDate(localDateTime.plusMinutes(minutes));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="时间工具类"><a href="#时间工具类" class="headerlink" title="时间工具类"></a>时间工具类</h2><p>以下时间工具类主要增加了：<code>between()</code>方法，可以计算两个时间的差值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ZoneOffset</span> <span class="variable">zoneOffset</span> <span class="operator">=</span> ZoneOffset.ofHours(<span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">zoneId</span> <span class="operator">=</span> zoneOffset.getId();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ZoneId</span> <span class="variable">systemDefaultZoneId</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ZoneOffset <span class="title function_">getDefaultZoneOffset</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> zoneOffset;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ZoneId <span class="title function_">getSystemDefaultZoneId</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> systemDefaultZoneId;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ZoneId <span class="title function_">getDefaultZoneId</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> ZoneId.of(zoneId);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> Instant.now().atZone(zoneOffset).toInstant();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">(Long epochMilli)</span> {</span><br><span class="line">		<span class="keyword">return</span> Instant.ofEpochMilli(epochMilli);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">(Date date)</span> {</span><br><span class="line">		<span class="keyword">return</span> date.toInstant();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">(ZoneId zoneId)</span> {</span><br><span class="line">		<span class="keyword">return</span> Instant.now().atZone(zoneId).toInstant();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">(LocalDateTime localDateTime, ZoneOffset zoneOffset)</span> {</span><br><span class="line">		<span class="keyword">return</span> localDateTime.toInstant(zoneOffset);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title function_">getInstant</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">		<span class="keyword">return</span> localDateTime.toInstant(zoneOffset);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.ofInstant(getInstant(), zoneOffset);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(<span class="type">long</span> epochMilli)</span> {</span><br><span class="line">		<span class="keyword">return</span> getLocalDateTime(getInstant(epochMilli));</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(Instant instant)</span> {</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.ofInstant(instant, zoneOffset);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String dataStr)</span> {</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.parse(dataStr, formatter);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title function_">getLocalDateTime</span><span class="params">(String dataStr, DateTimeFormatter dateTimeFormatter)</span> {</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.parse(dataStr, dateTimeFormatter);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNowStr</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> getLocalDateTime().format(formatter);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNowStr</span><span class="params">(Instant instant)</span> {</span><br><span class="line">		<span class="keyword">return</span> getLocalDateTime(instant).format(formatter);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getNowStr</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">		<span class="keyword">return</span> localDateTime.format(formatter);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">toEpochMilli</span><span class="params">(Instant instant)</span> {</span><br><span class="line">		<span class="keyword">return</span> instant.toEpochMilli();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> MyDuration <span class="title function_">between</span><span class="params">(Instant startInstant, Instant endInstant)</span> {</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">startLocalDateTime</span> <span class="operator">=</span> getLocalDateTime(startInstant);</span><br><span class="line">		<span class="type">LocalDateTime</span> <span class="variable">endLocalDateTime</span> <span class="operator">=</span> getLocalDateTime(endInstant);</span><br><span class="line">		<span class="keyword">return</span> between(startLocalDateTime, endLocalDateTime);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">()</span> {</span><br><span class="line">		<span class="keyword">return</span> Date.from(getInstant());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getDate</span><span class="params">(LocalDateTime localDateTime)</span> {</span><br><span class="line">		<span class="keyword">return</span> Date.from(getInstant(localDateTime));</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startLocalDateTime  </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> endLocalDateTime 要被减的时间日期</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> MyDuration <span class="title function_">between</span><span class="params">(LocalDateTime startLocalDateTime, LocalDateTime endLocalDateTime)</span> {</span><br><span class="line">		<span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(startLocalDateTime, endLocalDateTime);</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> duration.toDays();</span><br><span class="line">		<span class="type">long</span> <span class="variable">hours</span> <span class="operator">=</span> duration.toHours();</span><br><span class="line">		<span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> duration.toMinutes();</span><br><span class="line">		<span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> duration.getSeconds();</span><br><span class="line">		</span><br><span class="line">		<span class="type">MyDuration</span> <span class="variable">myDuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDuration</span>();</span><br><span class="line">		myDuration.setDiffDays(days);</span><br><span class="line">		myDuration.setDiffHours(hours);</span><br><span class="line">		myDuration.setDiffMintines(minutes);</span><br><span class="line">		myDuration.setDiffSeconds(seconds);</span><br><span class="line">		</span><br><span class="line">		myDuration.setDays(days);</span><br><span class="line"></span><br><span class="line">		<span class="type">Duration</span> <span class="variable">ofDays</span> <span class="operator">=</span> Duration.ofDays(days);</span><br><span class="line">		<span class="type">long</span> <span class="variable">leftHours</span> <span class="operator">=</span> hours - ofDays.toHours();</span><br><span class="line">		</span><br><span class="line">		myDuration.setHours(leftHours);</span><br><span class="line">		<span class="type">Duration</span> <span class="variable">ofHours</span> <span class="operator">=</span> Duration.ofHours(leftHours);</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">leftMintines</span> <span class="operator">=</span> minutes - ofDays.toMinutes() - ofHours.toMinutes();</span><br><span class="line">		myDuration.setMintines(leftMintines);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Duration</span> <span class="variable">ofMinutes</span> <span class="operator">=</span> Duration.ofMinutes(leftMintines);</span><br><span class="line">		myDuration.setSeconds(seconds - ofDays.getSeconds() - ofHours.getSeconds() - ofMinutes.getSeconds());</span><br><span class="line">		<span class="keyword">return</span> myDuration;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">DateUtils</span><span class="params">()</span> {}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyDuration</span> {</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以天数为单位的两个日期时间之间的差值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> diffDays;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以小时为单位的两个日期时间之间的差值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> diffHours;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以分钟为单位的两个日期时间之间的差值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> diffMintines;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以秒为单位的两个日期时间之间的差值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> diffSeconds;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> days;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> hours;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> mintines;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">long</span> seconds;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOver</span><span class="params">(<span class="type">long</span> value, TimeUnit timeUnit)</span> {</span><br><span class="line">			<span class="keyword">if</span>(StringUtils.equals(timeUnit.name(), TimeUnit.DAYS.name())) {</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">this</span>.diffDays &gt;= value;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(StringUtils.equals(timeUnit.name(), TimeUnit.HOURS.name())) {</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">this</span>.diffHours &gt;= value;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(StringUtils.equals(timeUnit.name(), TimeUnit.MINUTES.name())) {</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">this</span>.diffMintines &gt;= value;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(StringUtils.equals(timeUnit.name(), TimeUnit.SECONDS.name())) {</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">this</span>.diffSeconds &gt;= value;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"timeUnit is not DAYS or HOURS or MINUTES or SECONDS"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  两个时间差的格式化表示</span></span><br><span class="line"><span class="comment">		 *  如：两个日期时间之差为：2天3小时25分钟30秒</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> String <span class="title function_">getFormatterString</span><span class="params">()</span> {</span><br><span class="line">			<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.days != <span class="number">0L</span>) {</span><br><span class="line">				sb.append(days + <span class="string">"天"</span>);</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.hours != <span class="number">0L</span>) {</span><br><span class="line">				sb.append(hours + <span class="string">"小时"</span>);</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.mintines != <span class="number">0L</span>) {</span><br><span class="line">				sb.append(mintines + <span class="string">"分钟"</span>);</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.seconds != <span class="number">0L</span>) {</span><br><span class="line">				sb.append(seconds + <span class="string">"秒"</span>);</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> sb.toString();</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>参考资料：</p>
<p><a href="https://blog.csdn.net/u010758410/article/details/80042798">对非常大的两个数字求和——数字字符串求和</a></p>
<p><a href="https://itimetraveler.github.io/2017/08/22/[%E7%AE%97%E6%B3%95]%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/">【算法】大数相乘问题及其高效算法</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/l-compress/index.html">利用JAVA API函数实现数据的压缩与解压缩</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI技术实战</title>
    <url>/2019/07/07/045/</url>
    <content><![CDATA[<p>本文运行环境：</p>
<ol>
<li><p>开发工具：</p>
<p>1）Java：STS（Spring 优化过的 eclipse）</p>
<p>2）C++：Microsoft Visual Studio 2010 Ultimate（VS 2010 旗舰版）</p>
</li>
<li><p>JDK 环境：JDK 1.8.0_144</p>
</li>
<li><p>开发平台：Windows 7 x64</p>
</li>
<li><p>源文件编码字符集：Java 源码文件使用<code>UTF8</code>编码，C++源文件使用<code>UTF8</code>编码</p>
</li>
</ol>
<h3 id="步骤1-编写-JNI-文件的-Java-源码"><a href="#步骤1-编写-JNI-文件的-Java-源码" class="headerlink" title="步骤1. 编写 JNI 文件的 Java 源码"></a>步骤1. 编写 JNI 文件的 Java 源码</h3><p>使用 STS 创建一个最简单的 Java 工程：<code>JNI_demo</code>，并创建<code>org.woodwhales.king.JniTest</code>类 ，该类有类；两个原生的方法<code>getMessage()</code>和<code>plus()</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.woodwhales.king;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JniTest</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			System.loadLibrary(<span class="string">"TestJni"</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">			System.out.println(<span class="string">"load dll error, cause : "</span> + e.getMessage());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JniTest</span><span class="params">()</span> {</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取消息</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">getMessage</span><span class="params">(String str)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 两数相加</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">native</span> Integer <span class="title function_">plus</span><span class="params">(Integer x, Integer y)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意</strong>：编写Java源码之前一定要设置文件是<code>UTF-8</code>编码保存的。</p>
<h3 id="步骤2-生成-JNI-头文件"><a href="#步骤2-生成-JNI-头文件" class="headerlink" title="步骤2. 生成 JNI 头文件"></a>步骤2. 生成 JNI 头文件</h3><p>编写完成之后，右击项目找到项目根目录对应的资源管理器：</p>
<p><img src="https://image.woodwhales.cn/045/images/01.png"></p>
<p>进入项目的<code>bin</code>目录下，运行 dos 命令窗口，执行如下命令生成 JNI 头文件：</p>
<figure class="highlight dos"><table><tbody><tr><td class="code"><pre><span class="line">javah -classpath . -jni org.woodwhales.king.JniTest</span><br></pre></td></tr></tbody></table></figure>

<p>命令执行正确，窗口不会提示任何信息，此时当前 bin 目录下会生成一个名为：<code>org_woodwhales_king_JniTest.h</code>的头文件：</p>
<p><img src="https://image.woodwhales.cn/045/images/02.png"></p>
<h3 id="步骤3-创建动态链接库项目"><a href="#步骤3-创建动态链接库项目" class="headerlink" title="步骤3. 创建动态链接库项目"></a>步骤3. 创建动态链接库项目</h3><p>打开 VS 2010 开发工具，初始化界面如下：</p>
<p><img src="https://image.woodwhales.cn/045/images/03.png"></p>
<p>点击左上角的<code>文件</code>菜单，创建一个项目：</p>
<p><img src="https://image.woodwhales.cn/045/images/05.png"></p>
<p>进入向导界面，直接下一步：</p>
<p><img src="https://image.woodwhales.cn/045/images/06.png"></p>
<p>选择<code>DLL</code>动态链接库项目，并勾选空项目：</p>
<p><img src="https://image.woodwhales.cn/045/images/07.png"></p>
<p>创建成功后，开发界面视图如下：</p>
<p><img src="https://image.woodwhales.cn/045/images/08.png"></p>
<p>此时，右击该项目，进入资源管理器文件目录：</p>
<p><img src="https://image.woodwhales.cn/045/images/09.png"></p>
<p>可以看到项目目录下，还有个<code>TestJni</code>目录，这个目录就是开发目录，外面的其他文件，是VS2010开发工具自动生成的开发环境相关文件：</p>
<p><img src="https://image.woodwhales.cn/045/images/10.png"></p>
<h3 id="步骤4-JNI相关头文件准备"><a href="#步骤4-JNI相关头文件准备" class="headerlink" title="步骤4. JNI相关头文件准备"></a>步骤4. JNI相关头文件准备</h3><p>将步骤2 中生成的JNI头文件拷贝一份到步骤3项目的开发目录中：</p>
<p><img src="https://image.woodwhales.cn/045/images/11.png"></p>
<p>另外需要将在编写Java源文件所使用的JDK中自带的<code>jni.h</code>和<code>jni_md.h</code>头文件也拷贝一份到这个开发目录：</p>
<p><img src="https://image.woodwhales.cn/045/images/12.png"></p>
<h3 id="步骤5-创建项目目录结构"><a href="#步骤5-创建项目目录结构" class="headerlink" title="步骤5. 创建项目目录结构"></a>步骤5. 创建项目目录结构</h3><p>将步骤4中的头文件添加到 VS 2010 开发工具视图的头文件目录中：</p>
<p><img src="https://image.woodwhales.cn/045/images/13.png"></p>
<p>添加头文件到头文件目录之后，再创建一个C++源文件到源文件目录中：</p>
<p><img src="https://image.woodwhales.cn/045/images/14.png"></p>
<p>选择创建<code>cpp</code>文件，文件名的命名随意写即可：<br><img src="https://image.woodwhales.cn/045/images/15.png"></p>
<h3 id="步骤6-开发"><a href="#步骤6-开发" class="headerlink" title="步骤6. 开发"></a>步骤6. 开发</h3><h4 id="开发前的问题注意"><a href="#开发前的问题注意" class="headerlink" title="开发前的问题注意"></a>开发前的问题注意</h4><p>前面所有步骤顺利完成之后，开始准备开发，但是有三点需要注意：</p>
<h5 id="问题1：JNI-头文件引用设置"><a href="#问题1：JNI-头文件引用设置" class="headerlink" title="问题1：JNI 头文件引用设置"></a>问题1：JNI 头文件引用设置</h5><p>将JNI头文件中引用<code>jni.h</code>的代码修改为双引号引用：</p>
<p><img src="https://image.woodwhales.cn/045/images/16.png"></p>
<blockquote>
<p>尖括号是引用系统库，引用非系统库使用双引号。</p>
</blockquote>
<h5 id="问题2：源文件编码设置"><a href="#问题2：源文件编码设置" class="headerlink" title="问题2：源文件编码设置"></a>问题2：源文件编码设置</h5><p>设置<code>MyDLL</code>源文件的编码格式：双击打开<code>MyDLL.cpp</code>文件，让光标在编辑区，然后点击右上角<code>文件</code>菜单，选择<code>高级保存选项</code>，设置文件编码格式为无签名的<code>UTF-8</code>，设置完成之后，保存当前空的源文件即可。</p>
<p><img src="https://image.woodwhales.cn/045/images/17.png"></p>
<blockquote>
<p>VS 2010 默认创建的文件都是<code>GB2312</code>编码的，这会在处理字符串的时候带来很多转码的麻烦。</p>
</blockquote>
<h5 id="问题3：32-64-位问题"><a href="#问题3：32-64-位问题" class="headerlink" title="问题3：32/64 位问题"></a>问题3：32/64 位问题</h5><p>点击编辑区上面的<code>Debug</code>下拉框，点击配置管理器，设置项目的解决方案生成的是 64位 项目：</p>
<p><img src="https://image.woodwhales.cn/045/images/18.png"></p>
<p>新建解决方案：</p>
<p><img src="https://image.woodwhales.cn/045/images/19.png"></p>
<p>选择生成<code>x64</code>的活动解决方案：</p>
<p><img src="https://image.woodwhales.cn/045/images/20.png"></p>
<p>最后设置配为：<code>Release</code>：</p>
<p><img src="https://image.woodwhales.cn/045/images/21.png"></p>
<blockquote>
<p>后续生成 dll 文件的时候，工具看到中文也会提示这样的信息：</p>
<p>warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失。</p>
<p>因此将源码文件设置成 UTF-8 编码是很有必要的。</p>
</blockquote>
<h4 id="开发JNI"><a href="#开发JNI" class="headerlink" title="开发JNI"></a>开发JNI</h4><p>在<code>MyDLL.cpp</code>源码中开始引入步骤5中的头文件<code>org_woodwhales_king_JniTest.h</code>，实现头文件的函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"org_woodwhales_king_JniTest.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"jni.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_org_woodwhales_king_JniTest_getMessage</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv * env, jobject thisObj, jstring j_str)</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *c_str = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="type">char</span> buff[<span class="number">2048</span>] = {<span class="number">0</span>};</span><br><span class="line">    jboolean isCopy;</span><br><span class="line">    c_str = env-&gt;<span class="built_in">GetStringUTFChars</span>(j_str, &amp;isCopy);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(c_str == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    }  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buff, <span class="string">"这里是C++部分编写的字符串，这里是Java 传过来的字符串：%s"</span>, c_str);  </span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(j_str, c_str);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(buff);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_org_woodwhales_king_JniTest_plus</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv * env, jobject j_obj, jint j_x, jint j_y)</span> </span>{</span><br><span class="line">	<span class="type">int</span> result = j_x + j_y;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码编写完成后，点击<code>生成</code>菜单生成解决方案，或按<code>Ctrl+F7</code>：</p>
<p><img src="https://image.woodwhales.cn/045/images/22.png"></p>
<p>如果编码没有问题，则会在控制台输出如下信息：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>&gt;生成成功。</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;已用时间 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.13</span></span><br><span class="line">========== 生成: 成功 <span class="number">1</span> 个，失败 <span class="number">0</span> 个，最新 <span class="number">0</span> 个，跳过 <span class="number">0</span> 个 ==========</span><br></pre></td></tr></tbody></table></figure>

<p>此时再次进入项目根目录，会发现在 x64 目录下的 Release 目录下，生成了 dll 文件：</p>
<p><img src="https://image.woodwhales.cn/045/images/23.png"></p>
<h3 id="步骤7-测试dll文件"><a href="#步骤7-测试dll文件" class="headerlink" title="步骤7. 测试dll文件"></a>步骤7. 测试dll文件</h3><p>在 java 项目根目录下创建一个名称为 lib 的资源文件目录，用于存放步骤6 开发出来的 dll 文件：</p>
<p><img src="https://image.woodwhales.cn/045/images/24.png"></p>
<p>将步骤 6开发出来的 dll 文件拷贝一份到这个lib目录下：</p>
<p><img src="https://image.woodwhales.cn/045/images/25.png"></p>
<p>将这个 lib 目录设置为 native 依赖库：</p>
<p><img src="https://image.woodwhales.cn/045/images/26.png"></p>
<p>由于 lib 已经是资源目录，所以 lib 中的文件都会被编译到项目的 bin 目录，所以指定项目的 bin 目录为 native 依赖库即可：</p>
<p><img src="https://image.woodwhales.cn/045/images/27.png"></p>
<p>编写测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">		<span class="type">JniTest</span> <span class="variable">jniTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JniTest</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> jniTest.getMessage(<span class="string">"my blog -&gt; 个人博客：https://woodwhales.github.io/"</span>);</span><br><span class="line">		System.out.println(message);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> jniTest.plus(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<blockquote>
<p>这里是C++部分编写的字符串，这里是Java 传过来的字符串：my blog -&gt; 个人博客：<a href="https://woodwhales.github.io/">https://woodwhales.github.io/</a><br>7</p>
</blockquote>
<p>参考资料：</p>
<p><a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html">Java Programming Tutorial - Java Native Interface (JNI)</a></p>
<p><a href="https://blog.csdn.net/lwcloud/article/details/78326903">JAVA之JNI从头完整实例</a></p>
<p><a href="https://blog.csdn.net/lovesummerforever/article/details/25827199">Java采用JNI调用VC++生成的dll(Java与C++交互)</a></p>
<p><a href="https://mp.weixin.qq.com/s/HChvJlZiq2kRbHuACB4SjQ">Android高级第65课 jni开发之完美解决中文乱码方案【通俗易懂-深入底层学习Android】</a></p>
<p><a href="https://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/string.html">JNI 字符串处理</a></p>
<p><a href="https://sslyxhz.github.io/post/jni%E6%89%8B%E5%86%8C3/">JNI自用手册3 - 拾遗篇</a></p>
<p><a href="https://blog.csdn.net/qq_18983205/article/details/78840507">（三）JNI 中文乱码</a></p>
<p><a href="https://blog.csdn.net/qfanmingyiq/article/details/62218550">JNI乱码问题</a></p>
<p><a href="https://juejin.im/post/5b5b1ad3f265da0f8145f194">JNI系列入门之C语言中文字符串乱码问题</a></p>
<p><a href="https://www.iteye.com/topic/304594">JNI技术实践小结</a></p>
<p><a href="https://tocreate.app/2017/11/17/Jni/">Jni ，从入门到入坟</a></p>
<p><a href="https://www.jianshu.com/p/67081d9b0a9c">Android JNI学习(四)——JNI的常用方法的中文API</a></p>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Jpa Data 快速入门指南</title>
    <url>/2019/08/02/046/</url>
    <content><![CDATA[<h1 id="1-初识Spring-Jpa-Data"><a href="#1-初识Spring-Jpa-Data" class="headerlink" title="1. 初识Spring Jpa Data"></a>1. 初识Spring Jpa Data</h1><h2 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h2><p>创建maven工程，项目继承<code>spring-boot-starter-parent</code>，只需要引入<code>spring-boot-starter-data-jpa</code>即可：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-2-数据库连接配置"><a href="#1-2-数据库连接配置" class="headerlink" title="1.2 数据库连接配置"></a>1.2 数据库连接配置</h2><p>在<code>application.yml</code>配置文件中，配置数据库源信息和jpa基础配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql:///jpa-study</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-数据库连接测试"><a href="#1-3-数据库连接测试" class="headerlink" title="1.3 数据库连接测试"></a>1.3 数据库连接测试</h2><p>首先在数据库中创建<code>jpa-study</code>数据库：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `jpa<span class="operator">-</span>study` <span class="comment">/*!40100 COLLATE 'utf8mb4_unicode_ci' */</span></span><br></pre></td></tr></tbody></table></figure>

<p>编写数据连接测试方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJpaDataStudyApplicationTests</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDataSource</span><span class="params">()</span> {</span><br><span class="line">		System.out.println(<span class="string">"dataSource-&gt;"</span> + dataSource);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>启动运行，不报异常表示数据库连接正常。</p>
<h2 id="1-4-创建表对象"><a href="#1-4-创建表对象" class="headerlink" title="1.4 创建表对象"></a>1.4 创建表对象</h2><p>编写<code>Person</code>类，这个类对应数据库表为：<code>JPA_PERSONS</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Table(name = "JPA_PERSONS")</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">	<span class="keyword">private</span> Date birth;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再次运行测试类，此时数据库创建了<code>JPA_PERSONS</code>表，使用<code>heidisql</code>工具查看数据库：</p>
<p><img src="https://image.woodwhales.cn/046/images/01.png"></p>
<p>注意：在主键属性上加了<code>@GeneratedValue</code>注解，则会在创建表的时候生成一张<code>hibernate_sequence</code>表。</p>
<h2 id="1-5-编写dao接口"><a href="#1-5-编写dao接口" class="headerlink" title="1.5 编写dao接口"></a>1.5 编写dao接口</h2><p>编写Person对象的数据库操作接口，并继承<code>Repository&lt;T, ID&gt;</code>，其中需要指定当前数据对象的类型和主键类型，并在接口中编写save()方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.repository.Repository;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.springjpadatastudy.entity.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDao</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;Person, Integer&gt; {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Person person)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此时<code>PersonDao</code>接口已经具备了保存数据的能力了。</p>
<blockquote>
<p>注意：经过测试，这个自定义的<code>save()</code>方法如果写了返回类型是Long、Integer或boolean，那么在数据执行完毕之后，会抛出异常<code>java.lang.ClassCastException</code>，但是数据会保存到数据库中，所以要注意异常情况增加事务。</p>
</blockquote>
<p>编写测试方法测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1</span>, <span class="string">"woodwhales"</span>, <span class="string">"woodwhales@163.com"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    personDao.save(person);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从执行日志可以看出，数据已经成功保存到数据库：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">Hibernate: select person0_.id as id1_0_0_, person0_.birth as birth2_0_0_, person0_.email as email3_0_0_, person0_.last_name as last_nam4_0_0_ from jpa_persons person0_ where <span class="attr">person0_.id</span>=?</span><br><span class="line">Hibernate: insert into jpa_persons (birth, email, last_name, id) values (?, ?, ?, ?)</span><br></pre></td></tr></tbody></table></figure>

<p>再到数据库中直接检查一下：</p>
<p><img src="https://image.woodwhales.cn/046/images/02.png"></p>
<p>再次在接口中编写根据id查询数据方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Person <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personDao.getById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"person -&gt; "</span> + person);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>执行日志可以看到，顺利查询出数据：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">Hibernate: select person0_.id as id1_0_, person0_.birth as birth2_0_, person0_.email as email3_0_, person0_.last_name as last_nam4_0_ from jpa_persons person0_ where <span class="attr">person0_.id</span>=?</span><br><span class="line">person -&gt; Person(<span class="attr">id</span>=<span class="number">2</span>, lastName=woodwhales, email=woodwhales@<span class="number">163</span>.com, birth=<span class="number">2019</span>-<span class="number">08</span>-<span class="number">02</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">17.0</span>)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="2-认识Repository接口"><a href="#2-认识Repository接口" class="headerlink" title="2. 认识Repository接口"></a>2. 认识Repository接口</h1><h2 id="2-1-Repository是标记接口"><a href="#2-1-Repository是标记接口" class="headerlink" title="2.1 Repository是标记接口"></a>2.1 Repository是标记接口</h2><p>点击<code>Repository</code>接口源码可以看到，这个接口就是一个空接口，从上述测试的结果可以得出：</p>
<ul>
<li>Repository 接口是一个空接口，也就是一个标记接口。</li>
<li>如果程序员自己定义的接口继承了这个 Repository 接口，那么这个自定义接口也会被加载到 spring ioc 容器中（因为使用@Autowired 拿到了这个接口，并成功执行了测试方法，所以一定被纳进了容器中），并且编写一定规则的方法，都是可以执行相应的数据库操作。</li>
<li>实际上, 也可以通过<code>@RepositoryDefinition</code>注解来替代继承 Repository 接口</li>
</ul>
<p>形如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.repository.RepositoryDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RepositoryDefinition(domainClass=Person.class,idClass = Integer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDao</span> {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-2-Repository接口的实现类-子接口"><a href="#2-2-Repository接口的实现类-子接口" class="headerlink" title="2.2 Repository接口的实现类/子接口"></a>2.2 Repository接口的实现类/子接口</h2><p>在 IDEA 编辑器中，按快捷键<code>ctrl+H</code>查看 Repository 接口的实现类：</p>
<p><img src="https://image.woodwhales.cn/046/images/03.png"></p>
<p>从继承关系图中可以看出：</p>
<p>基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下： </p>
<ul>
<li><p>Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类</p>
</li>
<li><p>CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 </p>
</li>
<li><p>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 </p>
</li>
<li><p>JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 </p>
</li>
<li><p>自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。</p>
</li>
<li><p>JpaSpecificationExecutor： <strong>不属于Repository体系</strong>，实现一组 JPA Criteria 查询相关的方法，用于条件查询。</p>
</li>
</ul>
<h2 id="2-3-方法定义规则"><a href="#2-3-方法定义规则" class="headerlink" title="2.3 方法定义规则"></a>2.3 方法定义规则</h2><p>在 Repository 子接口中声明方法，不是随便声明的，而需要符合一定的规范：</p>
<ul>
<li><p>查询方法以 find | read | get 开头。</p>
</li>
<li><p>涉及条件查询时，条件的属性用条件关键字连接。</p>
</li>
<li><p>要注意的是：条件属性以首字母大写。</p>
</li>
<li><p>支持属性的级联查询，如果当前类有符合条件的属性，则优先使用这个属性，而不使用级联属性。</p>
<p>如果想要使用级联查询，需要在属性之间使用下划线分割</p>
</li>
</ul>
<p>直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：</p>
<table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Sample</th>
<th align="left">JPQL snippet</th>
</tr>
</thead>
<tbody><tr>
<td align="left">And</td>
<td align="left">findByLastnameAndFirstname</td>
<td align="left">… where x.lastname = ?1 and x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Or</td>
<td align="left">findByLastnameOrFirstname</td>
<td align="left">… where x.lastname = ?1 or x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Is,Equals</td>
<td align="left">findByFirstname,findByFirstnameIs,findByFirstnameEquals</td>
<td align="left">… where x.firstname = ?1</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">findByStartDateBetween</td>
<td align="left">… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td align="left">LessThan</td>
<td align="left">findByAgeLessThan</td>
<td align="left">… where x.age &lt; ?1</td>
</tr>
<tr>
<td align="left">LessThanEqual</td>
<td align="left">findByAgeLessThanEqual</td>
<td align="left">… where x.age &lt;= ?1</td>
</tr>
<tr>
<td align="left">GreaterThan</td>
<td align="left">findByAgeGreaterThan</td>
<td align="left">… where x.age &gt; ?1</td>
</tr>
<tr>
<td align="left">GreaterThanEqual</td>
<td align="left">findByAgeGreaterThanEqual</td>
<td align="left">… where x.age &gt;= ?1</td>
</tr>
<tr>
<td align="left">After</td>
<td align="left">findByStartDateAfter</td>
<td align="left">… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">findByStartDateBefore</td>
<td align="left">… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td align="left">IsNull</td>
<td align="left">findByAgeIsNull</td>
<td align="left">… where x.age is null</td>
</tr>
<tr>
<td align="left">IsNotNull,NotNull</td>
<td align="left">findByAge(Is)NotNull</td>
<td align="left">… where x.age not null</td>
</tr>
<tr>
<td align="left">Like</td>
<td align="left">findByFirstnameLike</td>
<td align="left">… where x.firstname like ?1</td>
</tr>
<tr>
<td align="left">NotLike</td>
<td align="left">findByFirstnameNotLike</td>
<td align="left">… where x.firstname not like ?1</td>
</tr>
<tr>
<td align="left">StartingWith</td>
<td align="left">findByFirstnameStartingWith</td>
<td align="left">… where x.firstname like ?1(parameter bound with appended %)</td>
</tr>
<tr>
<td align="left">EndingWith</td>
<td align="left">findByFirstnameEndingWith</td>
<td align="left">… where x.firstname like ?1(parameter bound with prepended %)</td>
</tr>
<tr>
<td align="left">Containing</td>
<td align="left">findByFirstnameContaining</td>
<td align="left">… where x.firstname like ?1(parameter bound wrapped in %)</td>
</tr>
<tr>
<td align="left">OrderBy</td>
<td align="left">findByAgeOrderByLastnameDesc</td>
<td align="left">… where x.age = ?1 order by x.lastname desc</td>
</tr>
<tr>
<td align="left">Not</td>
<td align="left">findByLastnameNot</td>
<td align="left">… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td align="left">In</td>
<td align="left">findByAgeIn(Collection<age> ages)</age></td>
<td align="left">… where x.age in ?1</td>
</tr>
<tr>
<td align="left">NotIn</td>
<td align="left">findByAgeNotIn(Collection<age> ages)</age></td>
<td align="left">… where x.age not in ?1</td>
</tr>
<tr>
<td align="left">True</td>
<td align="left">findByActiveTrue()</td>
<td align="left">… where x.active = true</td>
</tr>
<tr>
<td align="left">False</td>
<td align="left">findByActiveFalse()</td>
<td align="left">… where x.active = false</td>
</tr>
<tr>
<td align="left">IgnoreCase</td>
<td align="left">findByFirstnameIgnoreCase</td>
<td align="left">… where UPPER(x.firstame) = UPPER(?1)</td>
</tr>
</tbody></table>
<p>官方文档地址：<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation</a></p>
<h3 id="定义规则举例"><a href="#定义规则举例" class="headerlink" title="定义规则举例"></a>定义规则举例</h3><p>查询 id 小于 xx 并且 lastName 以 xx 开头的所有数据：</p>
<p>使用 JPQL 表达式表示就是：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> lastName <span class="keyword">LIKE</span> ?<span class="operator">%</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> ?</span><br></pre></td></tr></tbody></table></figure>

<p>方法命名规则：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Person&gt; <span class="title function_">getByLastNameStartingWithAndIdLessThan</span><span class="params">(String lastName, Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>依次类推，查询 id 小于 xx 并且 lastName 以 xx 结尾的所有数据：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//WHERE lastName LIKE %? AND id &lt; ?</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">getByLastNameEndingWithAndIdLessThan</span><span class="params">(String lastName, Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>类似的写法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//WHERE email IN (?, ?, ?) OR birth &lt; ?</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">getByEmailInOrBirthLessThan</span><span class="params">(List&lt;String&gt; emails, Date birth)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="级联属性规则说明"><a href="#级联属性规则说明" class="headerlink" title="级联属性规则说明"></a>级联属性规则说明</h3><p>比如 Person 对象属性中有个 Address 对象属性，一个 Person 对应多个 Address 对象，如果想要级联查询，查询地址的 id 大于某某的数据，则可以写成：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//WHERE address.id &gt; ?</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">getByAddressIdGreaterThan</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>但是这里有个潜在的问题，当前 Person 对象有个叫  address 属性名的字段，而没有属性叫 addressId 的属性字段，那么查询的时候，就是先查 address 再级联到 address 的 id 的数据。</p>
<p>如果当前 Person 对象有个叫 addressId 的属性字段，那么在执行查询的时候，就是直接查了 addressId，而不是级联查询了。</p>
<p>因此为了防止歧义，对于级联的属性条件，中间需要加下划线区别：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Person&gt; <span class="title function_">getByAddress_IdGreaterThan</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>说明：其实级联查询即使使用了下划线，也很难以阅读理解，所以建议复杂的查询全部使用原生的sql。</p>
<h1 id="3-Query注解"><a href="#3-Query注解" class="headerlink" title="3. @Query注解"></a>3. @Query注解</h1><p>通过<code>@Query</code>注解，注解在方法上，编写自定义原生的sql或者JPQL语句，这里还是建议写原生的sql语句，因为在数据库中查询再拷贝到注解上，不需要改动很大，调试起来也很方便。</p>
<p>以下是JPQL语句的查询：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Query("SELECT p FROM Person p WHERE p.id = (SELECT max(p2.id) FROM Person p2)")</span></span><br><span class="line">Person <span class="title function_">getMaxIdPerson</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-1-占位符"><a href="#3-1-占位符" class="headerlink" title="3.1 占位符"></a>3.1 占位符</h2><p>索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Query("SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">testQueryAnnotationParams1</span><span class="params">(String lastName, String email)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>命名参数（推荐使用这种方式）：可以定义好参数名，赋值时采用<code>@Param</code>注解，而不用管顺序：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Query("SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">testQueryAnnotationParams2</span><span class="params">(<span class="meta">@Param("email")</span> String email, <span class="meta">@Param("lastName")</span> String lastName)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>SpringData 允许在占位符上添加<code> %%</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//SpringData 允许在占位符上添加 %%. </span></span><br><span class="line"><span class="meta">@Query("SELECT p FROM Person p WHERE p.lastName LIKE %?1% OR p.email LIKE %?2%")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">testQueryAnnotationLikeParam</span><span class="params">(String lastName, String email)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringData 允许在占位符上添加 %%. </span></span><br><span class="line"><span class="meta">@Query("SELECT p FROM Person p WHERE p.lastName LIKE %:lastName% OR p.email LIKE %:email%")</span></span><br><span class="line">List&lt;Person&gt; <span class="title function_">testQueryAnnotationLikeParam2</span><span class="params">(<span class="meta">@Param("email")</span> String email, <span class="meta">@Param("lastName")</span> String lastName)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-2-支持原生SQL"><a href="#3-2-支持原生SQL" class="headerlink" title="3.2 支持原生SQL"></a>3.2 支持原生SQL</h2><p>设置<code>nativeQuery=true</code>即可以使用原生的 SQL 查询：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value="SELECT count(id) FROM jpa_persons", nativeQuery=true)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getTotalCount</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-Modifying注解"><a href="#4-Modifying注解" class="headerlink" title="4. @Modifying注解"></a>4. @Modifying注解</h1><p><code>@Query</code>与<code>@Modifying</code>这两个注解一起声明，可定义个性化更新操作，例如只涉及某些字段更新时最为常用，示例如下： </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query("UPDATE Person p SET p.email = :email WHERE id = :id")</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updatePersonEmail</span><span class="params">(<span class="meta">@Param("id")</span> Integer id, <span class="meta">@Param("email")</span> String email)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>方法的返回值应该是 int，表示更新语句所影响的行数</p>
</li>
<li><p>在调用的地方必须加事务，没有事务不能正常执行</p>
</li>
</ul>
<p>Spring Data 提供了默认的事务处理方式，即<strong>所有的查询均声明为只读事务</strong>。对于自定义的方法，如需改变<br>Spring Data 提供的事务默认方式，可以在方法上注解<code>@Transactional</code>声明。</p>
<p>因此，对于update和delete操作，需要添加<code>@Modifying</code>注解，service 调用这些方法的时候需要申明事务。</p>
<h1 id="5-CrudRepository接口"><a href="#5-CrudRepository接口" class="headerlink" title="5. CrudRepository接口"></a>5. CrudRepository接口</h1><p>CrudRepository 接口提供了最基本的对实体类的添删改查操作，IDEA 编辑器中按快捷键<code>alt+7</code>显示 CrudRepository 接口的所有方法：</p>
<p><img src="https://image.woodwhales.cn/046/images/04.png"></p>
<h1 id="6-PagingAndSortingRepository接口"><a href="#6-PagingAndSortingRepository接口" class="headerlink" title="6. PagingAndSortingRepository接口"></a>6. PagingAndSortingRepository接口</h1><p>PagingAndSortingRepository 接口该接口提供了分页与排序功能，开发中常用的是第二个方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;T, ID&gt; {</span><br><span class="line">	Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort sort)</span>;</span><br><span class="line"></span><br><span class="line">	Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Pageable 接口的实现类为 PageRequest，在构造函数中传入页码和页数，注意的是默认页码是从 0 页开始。一般在开发中，前端传参过来的页码是从第 1 页开始的，所以创建 PageRequest 对象的时候注意减1。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort.Direction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort.Order;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPagingAndSortingRespository</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//pageNo 从 0 开始. </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//Pageable 接口通常使用的其 PageRequest 实现类. 其中封装了需要分页的信息</span></span><br><span class="line">    <span class="comment">//排序相关的. Sort 封装了排序的信息</span></span><br><span class="line">    <span class="comment">//Order 是具体针对于某一个属性进行升序还是降序.</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(Direction.DESC, <span class="string">"id"</span>);</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(Direction.ASC, <span class="string">"email"</span>);</span><br><span class="line">    <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(order1, order2);</span><br><span class="line"></span><br><span class="line">    <span class="type">PageRequest</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(pageNo - <span class="number">1</span>, pageSize, sort);</span><br><span class="line">    Page&lt;Person&gt; page = personRepsotory.findAll(pageable);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"总记录数: "</span> + page.getTotalElements());</span><br><span class="line">    System.out.println(<span class="string">"当前第几页: "</span> + (page.getNumber() + <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"总页数: "</span> + page.getTotalPages());</span><br><span class="line">    System.out.println(<span class="string">"当前页面的 List: "</span> + page.getContent());</span><br><span class="line">    System.out.println(<span class="string">"当前页面的记录数: "</span> + page.getNumberOfElements());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Order 排序对象，里面传参是数据库表中的列名。</p>
<h1 id="7-JpaRepository接口"><a href="#7-JpaRepository接口" class="headerlink" title="7. JpaRepository接口"></a>7. JpaRepository接口</h1><p>在实际开发中，自定义的接口一般继承的就是这个，而不是 Repository 这个空接口。</p>
<p><img src="https://image.woodwhales.cn/046/images/05.png"></p>
<p>其中<code>saveAndFlush()</code>表示强制执行持久化操作，返回的对象和传参对象不是同一个对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJpaRepository</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>, <span class="string">"woodwhales"</span>, <span class="string">"woodwhales@163.com"</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> personRepsotory.saveAndFlush(person);</span><br><span class="line"></span><br><span class="line">    System.out.println(person == person2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>返回结果是false，表示执行之后，创建了新的对象。</p>
<h1 id="8-JpaSpecificationExecutor接口"><a href="#8-JpaSpecificationExecutor接口" class="headerlink" title="8. JpaSpecificationExecutor接口"></a>8. JpaSpecificationExecutor接口</h1><p>JpaSpecificationExecutor 接口不属于Repository体系，实现一组 JPA Criteria 查询相关的方法：</p>
<p><img src="https://image.woodwhales.cn/046/images/06.png"></p>
<p>Specification：封装  JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象。</p>
<p>举例：实现带查询条件的分页，并且查询 id &gt; 5 的数据，使用 JpaSpecificationExecutor 接口的<code>JpaSpecificationExecutor 的 Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable)</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJpaSpecificationExecutor</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">PageRequest</span> <span class="variable">pageable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageRequest</span>(pageNo, pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通常使用 Specification 的匿名内部类</span></span><br><span class="line">    Specification&lt;Person&gt; specification = <span class="keyword">new</span> <span class="title class_">Specification</span>&lt;Person&gt;() {</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> root  根对象，也就是要把条件封装到哪个对象中</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> criteriaQuery  封装的都是查询的关键字，比如group by order by等</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> criteriaBuilder 用了封装条件对象的,如果直接返回null，表示不需要任何条件</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;Person&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder)</span> {</span><br><span class="line">            <span class="type">Predicate</span> <span class="variable">predicate</span> <span class="operator">=</span> criteriaBuilder.gt(root.get(<span class="string">"id"</span>), <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> predicate;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    Page&lt;Person&gt; page = personRepsotory.findAll(specification, pageable);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"总记录数: "</span> + page.getTotalElements());</span><br><span class="line">    System.out.println(<span class="string">"当前第几页: "</span> + (page.getNumber() + <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"总页数: "</span> + page.getTotalPages());</span><br><span class="line">    System.out.println(<span class="string">"当前页面的 List: "</span> + page.getContent());</span><br><span class="line">    System.out.println(<span class="string">"当前页面的记录数: "</span> + page.getNumberOfElements());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Jpa条件查询最佳实践"><a href="#Jpa条件查询最佳实践" class="headerlink" title="Jpa条件查询最佳实践"></a>Jpa条件查询最佳实践</h2><p>当有多个条件查询时，需要创建多个 Predicate 对象，并将这些 Predicate 对象并联起来，因此可以定义一个<code>createSpecification(Map searchMap)</code>方法，用来创建最终的 Specification 对象，以下是伪代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态条件构建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> searchMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Specification&lt;Article&gt; <span class="title function_">createSpecification</span><span class="params">(Map searchMap)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Specification</span>&lt;Article&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;Article&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> {</span><br><span class="line">            List&lt;Predicate&gt; predicateList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Predicate&gt;();</span><br><span class="line">            <span class="comment">// 获取 xxx 查询条件，依次做非空判断，之后条件对象创建并放入list中</span></span><br><span class="line">            <span class="keyword">if</span> (searchMap.get(<span class="string">"xxx"</span>)!=<span class="literal">null</span> &amp;&amp; !<span class="string">""</span>.equals(searchMap.get(<span class="string">"xxx"</span>))) {</span><br><span class="line">                predicateList.add(cb.like(root.get(<span class="string">"xxxx"</span>).as(String.class), <span class="string">"%"</span>+(String)searchMap.get(<span class="string">"xxx"</span>)+<span class="string">"%"</span>));</span><br><span class="line">            }</span><br><span class="line">            ……</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 将list转成 Predicate[] 数组，进行拼接</span></span><br><span class="line">            <span class="keyword">return</span> cb.and(predicateList.toArray(<span class="keyword">new</span> <span class="title class_">Predicate</span>[predicateList.size()]));</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码解释：比如传参 searchMap 中存了{“name”:”woodwhales”}的键值对，那么将该对象的所有属性当作key对这个map依次获取一遍，能获取到的key 就表示当前属性需要条件查询，创建条件对象并放入集合中。最后将所有条件对象并联返回。</p>
<p>简单概述就是，将传过来的map中的键值对，依次和当前对象属性比对，有值的就是要条件查询的。</p>
<h1 id="9-自定义Repository接口"><a href="#9-自定义Repository接口" class="headerlink" title="9. 自定义Repository接口"></a>9. 自定义Repository接口</h1><p>步骤1：定义一个接口：声明要添加的，并自实现的方法</p>
<p>步骤2：提供该接口的实现类：类名需在要声明的 Repository 后添加 Impl，并实现方法</p>
<p>步骤3：声明 Repository 接口，并继承步骤1 声明的接口。 </p>
<p>三步完成之后，就可以使用自定义的接口了。</p>
<p>例如：</p>
<p>步骤1：自定义Repository接口名称为：PersonRepsotory，里面有个<code>test()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepsotory</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：实现自定义接口，注意实现类必须是<code>接口名+Impl后缀</code>的类名：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonRepsotoryImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonRepsotory</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@PersistenceContext</span></span><br><span class="line">	<span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> entityManager.find(Person.class, <span class="number">11</span>);</span><br><span class="line">		System.out.println(<span class="string">"PersonRepsotoryImpl -&gt; "</span> + person);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：默认情况下，Spring Data 会在 base-package 中查找 “接口名Impl” 作为实现类。也可以通过repository-impl-postfix声明后缀。</p>
<p>步骤3：在真正的业务接口中继承自定义的接口，此时当前 PersonDao 接口就具有了自定义接口里面的方法了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, Integer&gt;, JpaSpecificationExecutor&lt;Person&gt;, PersonRepsotory {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参考资料：</p>
<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">官方文档</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>人生苦短，转行程序员要趁早(下)</title>
    <url>/2019/08/03/047/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近有朋友咨询关于如何自学编程语言的问题，发现要回答这个问题，不是一俩句就可以回答清楚并减少当事人的困惑和迷茫。</p>
<p>笔者不知道提问者是问的学习方法还是学习路径，所以特此写一篇文章，斗胆表达一下我对自学编程的一点点看法，希望能帮助到想要学编程，转行学编程，正在学编程的朋友们，包括我自己。</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>笔者也是由于兴趣所致，转行自学编程，很理解想学编程的小伙伴们的心情，其中包括不限于：</p>
<ul>
<li>我是非科班出身，零基础，能不能学编程？</li>
<li>我是科班出身，但是在学校净玩了，没有专业技能，能不能学个编程？</li>
<li>要不要报个培训班学习编程，听说机构很坑，但是也听说不少出来咸鱼翻身的，到底是报班学习，还是自学编程？</li>
<li>要不要买书自学？如果要买，应该买什么书？</li>
<li>不知道自己未来要干什么，尝试学个编程，听说就业薪资很高？</li>
</ul>
<p>上面是罗列的这些常见问题，其实根源都是指向一个问题：希望学个专业技能，立足社会，为的就是养家糊口，买米下锅。</p>
<p>笔者其实很早就写过关于转行编程的博文，可以先移步看看：<a href="https://woodwhales.github.io/2018/06/17/018/">人生苦短，转行程序员要趁早(上)</a>和<a href="https://woodwhales.github.io/2018/08/13/019/">人生苦短，转行程序员要趁早(中)</a>，这俩篇文章罗嗦一堆其实是在表达，作为成年人一定知道自己真正具体想要什么，而不是单纯的想要更多的储蓄，因为这个想法太抽象了，比数学还要抽象。</p>
<p>因此，学编程之前，首先要明白，为什么要学编程，是真的对编程感兴趣，还是因为听说这个行业挣得多，所以想学编程。</p>
<p>这个问题其实和考研的问题一样，一个是想窥探更深层次的东西，探索人类知识的边界，一个是为了研究生毕业有个金闪闪的证，方便顺利就业。</p>
<p>俩者的行为表现都是一样的，但是背后的动机和认知是天壤之别。不可否认，带着纯利益性目的的做一件事无可厚非，但是笔者认为，这只是早期可以的动机，真正驱动一个人在某领域深耕一辈子的，一定不是单纯的利益驱使，能坚持到最后的都是顺其自然，而不是咬牙切齿。</p>
<h3 id="十年认知"><a href="#十年认知" class="headerlink" title="十年认知"></a>十年认知</h3><p>前阵子，笔者的身份证快要到期了，不禁感慨，时间已经过去十年了。现在回想，十年前的自己有想过十年后的自己在干什么吗？如果没有想过，那么现在的自己，有想过十年后自己在干什么吗？如果想过，那么现在的自己是自己当初想要的结果吗？</p>
<p>说实话，笔者当时真的懵懂无知，只知道随大流念书考试，熬过艰难的高中，走进自由自在的大学。注意，这些想法仅仅停留在此，没有更深层次想过读高中考大学的真正目的是什么，也就是没有想过将来想干什么，想成为什么样的人，包括拥有多少储蓄都没有想过。仅仅停留在让我赶紧能毕业，进一所大学就行了。走一步看一步。</p>
<p>上面这种视野的局限性，导致自己对于未来的认知只是停留在想考上大学，包括老师们口中常常念叨的：只要我们熬过高中，那么在大学就可以无拘无束了，任由自己放飞自我。作为教育长者的他们的言论，对于没有思辨思维的我来说，更加深了自己对于未来的认知局限性，这很可怕。</p>
<h3 id="时间-or-金钱"><a href="#时间-or-金钱" class="headerlink" title="时间 or 金钱"></a>时间 or 金钱</h3><p>感谢读者能看我废话罗嗦到此处，笔者不是碎碎念狂，笔者打下的每个文字都是用时间堆砌的。为了所谓的用户阅读流量，大可以贴一篇看似很有道理的学习路径塘塞，但是，作为关注笔者的朋友们，怎能如此不用心写下自己的一点真心感悟呢？</p>
<p>笔者之所以唠叨之多，也是因为本篇文章算作「人生苦短，转行程序员要趁早」的终结篇，所以多写点经得起时间考验的博文，即使五年，十年之后，它一样有价值，而不是一份垃圾快餐，满足一时快乐很容易。</p>
<p>每个人的时间精力有限，终点都是一样的，如何花式过完一生，是自己的事情，就像正在打字的我和正在阅读的你，都是在浪费生命，不是浪费在此就是浪费在其他地方。</p>
<p>因此浪费时间不是一件可怕的事情，因为即使不浪费时间，时间也会消逝。可怕的是，浪费时间在没有价值的事情上，也就是穷尽一生没有为自己或者身边的人创造价值，这才是生命中最可怕的一件事。</p>
<h3 id="编程认知"><a href="#编程认知" class="headerlink" title="编程认知"></a>编程认知</h3><p>编程的魅力在于，控制重复，创造美好。</p>
<p>笔者未学编程之前，在工作中遇到一个表格统计问题，表格中的每一列表格之间有数据关联性，但是这种数据关联性，只能通过人眼识别，不能自动完成，也就会增加误填的风险和数据校验的时间成本。笔者当时想找一些资料做一个级联操作，就像我们平时在填写收获地址时，第一个选择框选择某个省之后，第二个选择框里可以选择的一定是属于这个省的城市，这样就可以精准高效地统计数据，但是苦于自己没有技术能力实现这样简单的功能。</p>
<p> 值得注意的是，在遇到那样痛苦有风险的数据统计操作的时候，笔者也是因有接触过编程，才有了想通过编程实现自动化办公的想法。笔者亲眼见过，那位数据统计员，机械地完成大量重复性的工作，不禁在想，如果我是老板，会花钱请个人肉机器人吗？</p>
<p>关键，我是老板的话，我知道下属的工作是人肉机器这事吗？</p>
<p>记得笔者看过一段亚马逊创始人贝索斯的采访，说当初刚创业的时候，天天像个机器人一样，熬夜打包图书，打得手指生疼。或许正是这位老板当初创业时，知道人肉机器人的效率底下，才有了后来超级庞大的自动化仓储物流体系。</p>
<h3 id="编程之路"><a href="#编程之路" class="headerlink" title="编程之路"></a>编程之路</h3><p>自学编程是一件很痛苦的事情，尤其对于完全零基础的人来说，笔者在自学编程这条路上，也曾中途放弃过 4 次。当时的自己，真的是对着枯燥的课本一点点肯概念和代码。</p>
<p>注意，笔者这里说的编程，是用现有的编程知识解决问题，而不是创造一种未知编程概念和知识，所以在编程这条路上，有放弃的想法很正常，一是学习的姿势不对，而不是单纯说自己不适合学编程。</p>
<p>所以可以肯定的说，不存在学不会的情况，如果网络游戏都能玩得很 6，电视剧中的各种人物角色关系都能理清，能一天沉浸在游戏和电视剧中的，都是可以学习编程的，并且不仅限于编程，学习任何一门专业技术都是可以的。</p>
<h4 id="建立基本思维"><a href="#建立基本思维" class="headerlink" title="建立基本思维"></a>建立基本思维</h4><p>到此读者应该清楚了解，笔者对于第一小节提到的常见问题的核心根源的观点和态度，以后不再赘述。</p>
<p>对于任何学习编程的朋友来说，首先要在头脑中建立一种思维：编程是工具，是手段，解决问题才是核心。</p>
<p>编程就是在解决计算机怎么实现人类遇到的问题，记录数据并处理数据，要人去记录和解决也可以，为什么要用机器解决呢？因为机器最听话，最能权威公正客观的完成任务。</p>
<p>这种思维概念的形成，有助于理解，为什么电脑、手机等智能设备为什么要有电，因为电信号的存储，就是在存储数据，就是在完成并替代本来人可以做的事情。</p>
<p>这里推荐书籍：<a href="https://github.com/woodwhales/assembly-study/blob/master/%E7%BC%96%E7%A0%81%EF%BC%9A%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80.pdf">编码：隐匿在计算机软硬件背后的语言</a></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>对于某种高级编程语言的学习，首先最开始接触到必然是数据类型，比如 Java 中的数据类型分类：</p>
<p><img src="https://image.woodwhales.cn/047/images/01.png"></p>
<p>很多完全零基础的初学者看到上面这些概念就头疼，也困惑为啥要有数据类型呢，学这么多数据类型干嘛呢，还搞这么多分类。</p>
<p>再来看看 Python 语言中的数据类型：</p>
<p><img src="https://image.woodwhales.cn/047/images/02.png"></p>
<p>再来看看 C 语言中的数据类型：</p>
<p><img src="https://image.woodwhales.cn/047/images/03.png"></p>
<p>所谓数据类型，字面意思就是数据的类型。笔者接触使用过 C 和 Java，Python 未接触过，但从上图可以粗略看出，后俩者的老祖宗都是源于前者，后俩者在前者的数据类型基础上扩展或者二次封装了更好用的数据类型，目的终究是为了人类更好的使用这些类型去存储和处理数据。</p>
<p>所以数据类型，是一门编程语言最基础核心的东西，需要掌握好它们分享适用的场景，可以存放什么数据。存放数据的目的，也是为了计算机能够针对相同类型的数据做计算处理，因此才引入了数据类型这概念。</p>
<h4 id="条件循环"><a href="#条件循环" class="headerlink" title="条件循环"></a>条件循环</h4><p>在所有高级语言中都会有条件控制 和循环语法，万变不离其宗的条件控制和循环，这是计算机能够智能化运行的基石，这些数学上基本概念在高二数学必修 3 的第一章节就有涉及：</p>
<p><img src="https://image.woodwhales.cn/047/images/04.png"></p>
<p>笔者认为在高中考试中，遇到考察这种知识点试题就是在送分，不知道读者有没有同感。有了上述的数学基础，再回过头来看编程语言对上述数学概念的语言层面实现，什么 if else， while， do while，switch case 等都是一种语法规则，目的就是让计算机按照一种循环逻辑处理数据，因此，当学完控制循环的之后，就会发现数学真的是学科的妈妈。</p>
<h4 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h4><p>当上面的编程最最基本的概念语法掌握清楚之后，就可以进行某种语言的专有语法特性的学习了。如 C 语言的核心是指针，理解指针的概念，就是理解计算机怎么分配内存，也就是数据在内存里怎么存储，怎么处理。Java 正是见指针的学习曲线很高，也不好掌控，于是提出了自己的特有概念：引用，本质还是指针，而引入引用的目的，也是为了面向对象的概念做基础铺垫。因此，在学习 Java 语言的时候，理解面向对象思想的前提是理解引用是什么。</p>
<p>如果时间充裕，建议优先学习 C  语言，了解 C 语言的指针是什么，再学习 Java 或 Python 这些语言。推荐去 B 站 搜索郝斌老师的 C 语言自学教程。</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>对于计算机网络这块，其实和编程语言本身关系不大，因为编程语言本身就是让计算机存储并处理数据，是不是和网络相关的数据，编程语言本身并不关心，但是作为互联网时代，通讯不可能像原始社会一样，出门全靠吼，而是需要更高效的方式传输数据，于是网络协议概念产生了，各种编程语言为了秀出自己的专长，于是实现了很多网络算法，目的就是为了程序员们更好地针对网络数据进行编程。</p>
<p>因此对于网络编程，重点在于对网络基本知识的理解，编程语言实现了网络领域的很多概念，因此再次强调，编程语言只是一种工具。</p>
<p>众所周知，学习网络一定要看那本经典的《TCP/IP 详解》，但是作为零基础的初学者，上来就看如何概念抽象性的书籍，完全就是像灭掉一个人的学习自信心，因此笔者推荐轻松入门读物《网络是怎样连接的》，看完之后，再时间充裕的情况下再看看《图解TCP/IP》。</p>
<p>注意：看了上面的网络基础知识，并不表示就可以完成网络开发，因为每种编程语言对于网络知识的实现是不一样的，所以需要有针对性的学习。对于 Java 语言来说，Socket 网络编程知识需要重点理解关注，对网络应用方面的实现需要学习 J2EE 知识，也就是 Servlet 相关规范，这部分内容也是学习 Java Web 知识的核心基础。</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>笔者的技术栈仅限于 Java 语言，因此这里说的框架是指 Java 相关框架，其他编程语言的框架读者欢迎留言补充。Java 语言的著名框架莫过于 Spring ，理解框架的基础，在于理解动态代理，没有 Java 语言的动态代理技术，估计 Java 框架生态也不能发展的如此火热。</p>
<p>框架的学习，首先是了解框架是用来干什么的，存在即合理，框架不是因为流行所以流行，正是因为能够解决实际生产中的问题，所以才被市场接受和认可。理解框架诞生的目的之后，就需要快速掌握框架的使用方法，在有时间精力允许的情况下，深入理解框架的实现原理。</p>
<p>因此，对于初学者来说，学习框架的节奏就是：先抓主干脉络，后细节深入。</p>
<p>Java 框架推荐学习路径：Spring，SpringMvc，Hibernate，Jpa，Spring Jpa Data，Mybatis。</p>
<p>注意上述列出的是框架，Spring Boot 和 Spring Cloud 不属于原生框架，而是集合框架之上的一种平台了。因此，只有掌握了原生框架，才能掌握这些框架的平台是怎么用的，它们又是解决了什么问题。</p>
<h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><p>数据结构与算法，估计是所有编程的核心，上面也多次提到， 编程语言的出现均为如何存储数据和处理数据服务的，因此编程语言本身不具备数据结构和算法知识，编程语言只是利用自身的特性实现了数据存储的结构和数据处理的计算流程。</p>
<p>数据结构与算法，是程序员必备的技能，因为不论是网络相关的知识，还是数学相关的知识，都是基于利用数据结构和算法知识，使用编程语言实现了这些抽象概念。</p>
<p>笔者认为，数据结构与算法的关系是，数据结构是对数据关系的结构化描述，算法是对这些有关系的数据进行结构化处理计算，并再形成结构后化关系数据的一种计算流程。</p>
<p> 对于零基础的初学者，首先应该掌握的是编程语言本身，也就是会一种工具，再利用这种工具完成某种特殊的任务。</p>
<p>笔者推荐 B 站搜索尚硅谷图解算法，这个系列视频是使用 Java 语言，当然其他语言也是可以现实算法的，都是为了解决数据如何存储和处理的问题。</p>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>对于编程语言学习者来说，首先要明白的是，我们通常编程开发环境都需要建立在某种操作系统之上，再操作系统环境上编写出来的程序，也最后交给操作系统来帮我们执行程序，因此有必要了解一下操作系统通用的知识，尤其是进程和线程的概念，因为操作系统就是对硬件CPU和内存进行统一调度处理，所以理解一些操作系统层面的知识，有助于编写出高效的程序，归根结底还是能写出优质的程序算法。</p>
<p>这部分知识，可以建立在上述知识点基础上进行深入了解。如果要推荐书籍，可以阅读《深入理解计算机系统》，注意的是，这本书名字起得很高大上，其实就是对计算系统做一个入门级介绍，不算是深入理解，由于英文原名叫：Computer Systems: A Programmer’s Perspective，所以一般简称为：CSAPP。</p>
<h3 id="Java-自学路径"><a href="#Java-自学路径" class="headerlink" title="Java 自学路径"></a>Java 自学路径</h3><p>这里列举的学习路径只是说明需要重点学习的模块，并不需要严格按照这个路径学习，具体的学习路径可以按照文末给出的视频教程学习路径进行学习，在学习过程中，可以按照这个路径作为参考。</p>
<ol>
<li><p>语言基础（OOD、OOP）</p>
</li>
<li><p>语言高级（常用API、集合、异常、多线程、IO、Socket）</p>
</li>
<li><p>JDBC、MySQL</p>
</li>
<li><p>JavaWeb（HTML、CSS、JavaScript、Jquery、Ajax、XML、Bootstrap、Tomcat、Servlet、Cookie、Session、Jsp、JSON、Maven、Git）</p>
</li>
<li><p>Linux</p>
</li>
<li><p>Oracle</p>
</li>
<li><p>Spring</p>
</li>
<li><p>SpringMVC</p>
</li>
<li><p>Mybatis</p>
</li>
<li><p>Spring Data JPA</p>
</li>
<li><p>Redis</p>
</li>
<li><p>Lucene、Elasticsearch</p>
</li>
<li><p>Spring Boot</p>
</li>
<li><p>SpringCloud</p>
</li>
<li><p>JVM</p>
</li>
</ol>
<p>在自学之前，建议学会 markdown 语法。有时间精力的可以搭建自己的 github 个人博客，没有时间精力的可以去博客园、简书、掘金等平台注册一个博客帐号。好记性不如烂笔头，这些准备工作，都是为了记录自己的学习笔记。</p>
<p>在学习过程中，遇到不懂的问题，要及时网上查资料或者咨询其他人，当然也可以向笔者交流，相互学习成长。</p>
<blockquote>
<p>遇到一些实在难以理解的问题，先记录下来，然后继续向后学习，过一阵子再回头看之前不懂的问题就不会那么理解吃力了。</p>
</blockquote>
<p>感谢读者们能耐心看完本文，附上2018年黑马57期教学视频，帮助你更好的学习和成长。关注微信公众号：woodwhales，在后台回复：<strong>资料</strong>，即可获取视频下载链接。</p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>转行</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析理解HashMap</title>
    <url>/2019/08/18/048/</url>
    <content><![CDATA[<p>对于 HashMap 的日常开发使用，形如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"java"</span>, <span class="string">"java"</span>);</span><br><span class="line">    map.put(<span class="string">"python"</span>, <span class="string">"python"</span>);</span><br><span class="line">    map.put(<span class="string">"C++"</span>, <span class="string">"C++"</span>);</span><br><span class="line">    map.put(<span class="string">"C"</span>, <span class="string">"C"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其中最核心的问题是，这个 HashMap 容器怎么就能把 k-v 保存起来，并且还能通过 key 来获取呢？其中最核心的方法就是在于如何插入数据，这个<code>put()</code>怎么就顺利将数据存入集合，有没有元素数量极限呢？容器初始化的时候是无限大，还是有个固定值，还是先有个固定值，不够装的时候再扩容呢？这些问题， 都是本文要探讨的问题。</p>
<h2 id="1-HashMap-容器本质"><a href="#1-HashMap-容器本质" class="headerlink" title="1. HashMap 容器本质"></a>1. HashMap 容器本质</h2><h3 id="1-1-数组-链表-红黑树"><a href="#1-1-数组-链表-红黑树" class="headerlink" title="1.1 数组 + 链表 / 红黑树"></a>1.1 数组 + 链表 / 红黑树</h3><p>在 JDK1.7 中，HashMap 底层采用的是<code>数组+链表</code>的形式存储数据。在 JDK1.8 中，HashMap 底层采用的是<code>数组+链表/红黑树</code>的形式存储数据（当达到链表长度一定阀值的时候，链表会转成红黑树）。</p>
<p>在 JDK1.7 中，用户保存的数据是以 k-v 的形式存进容器，容器根据 key 的 hash 值进行计算，得到当前数据要保存到数组的中索引位置，如果获得的所以位置一样，那么新来的元素会存在链表的头部。</p>
<p>通过上述的描述，可以自己纯手工撸制一个属于自己的 HashMap 容器，值得注意的是，容器对外暴露的接口就是个<code>put(k,v)</code>方法，但是为了能实现链表结果，那么就需要将用户的数据进行封装成链表节点，因此需要自定义一个链表节点对象，该对象初步应该有用户的 k-v 数据属性，还要有可以指向下一个链表节点的属性。</p>
<h3 id="1-2-伪代码实现"><a href="#1-2-伪代码实现" class="headerlink" title="1.2 伪代码实现"></a>1.2 伪代码实现</h3><p>每一个 key 在存入 HashMap 之前，要对key进行 hash 计算，并对数组长度取模等计算，得到要存储的数组索引下标：</p>
<p><img src="https://image.woodwhales.cn/048/images/02.png"></p>
<p>先模拟 key 生成 hash 值，并对数组长度进行取模计算：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String[] keys = {<span class="string">"java"</span>, <span class="string">"python"</span>, <span class="string">"C++"</span>, <span class="string">"C"</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">arrayLength</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String key : keys) {</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode % (arrayLength - <span class="number">1</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">"%s %d  %d"</span>, key , hashCode, index));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java <span class="number">3254818</span>  <span class="number">0</span></span><br><span class="line">python -<span class="number">973197092</span>  <span class="number">0</span></span><br><span class="line">C++ <span class="number">65763</span>  <span class="number">5</span></span><br><span class="line">C <span class="number">67</span>  <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>从上述输出结果可以看出，”java” 和 “python” 主键得到的要存储的索引位置是一样的，那么它们都会存储在数组索引下标为 0 的位置。</p>
<p>其中 “python” 是后存进来的，在 JDK 1.7 中，会插入到链表的头部，也就是当前数组索引所保存的数据对象一定是当前链表元素中最新（最后插入）的元素。</p>
<p>对于上述，通过 key 计算 hash 值并对数组长度取模得到下标索引的伪代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hash();</span><br><span class="line">index = hashCode % (table.size() - <span class="number">1</span>);</span><br><span class="line">table[index] = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, table[index]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 Node 为链表节点对象</span></span><br><span class="line">Node&lt;K,V&gt;{</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意的是：每次要插入的节点的下一个指针，指向当前要插入的数组的索引位置的节点，就能实现新来的节点在链表的头部，即当前数组索引位置的元素就是最新的插入元素。</p>
<h2 id="2-自定义-HashMap"><a href="#2-自定义-HashMap" class="headerlink" title="2. 自定义 HashMap"></a>2. 自定义 HashMap</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p>自定义一个<code>MyHashMap</code>，实现<code>Map</code>接口，实现如下方法，在 IDEA 工具中按<code>Alt + 7</code>快捷键显示当前类的所有方法：</p>
<p><img src="https://image.woodwhales.cn/048/images/01.png"></p>
<p>本文只为了研究理解 HashMap 的核心原理，暂只实现部分方法（也就是不实现 Map 接口）：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span>&lt;K, V&gt;  {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前容器中的元素个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了保证自定义的 HashMap 能模拟数组+ 链表的形式，就需要自定义一个链表的节点对象，数组的类型就是该链表节点对象类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyEntry</span>&lt;K, V&gt; {</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    MyEntry&lt;K,V&gt; next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-容器基本属性设计"><a href="#2-2-容器基本属性设计" class="headerlink" title="2.2 容器基本属性设计"></a>2.2 容器基本属性设计</h3><p>有了上述的基本链表节点结构之后，就可以根据 HashMap 的底层容器逻辑，设计出类似的存储结构了：在自定义的容器中，设计一个默认的链表节点数组，并设置其默认数组大小：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 记录容器元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组+链表的数据结构</span></span><br><span class="line"><span class="keyword">private</span> MyEntry[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyHashMap</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 默认的链表节点数组</span></span><br><span class="line">    <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">MyEntry</span>[DEFAULT_CAPACITY];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这样几个属性的定义和构造函数的设计，就能实现 HashMap 的存储结构了。</p>
<h3 id="2-3-插入元素代码实现"><a href="#2-3-插入元素代码实现" class="headerlink" title="2.3 插入元素代码实现"></a>2.3 插入元素代码实现</h3><p>此时，最简单版本的插入元素逻辑就可以实现出来了：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode % <span class="built_in">this</span>.table.length;</span><br><span class="line">    addEntry(key, value, index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 容器元素个数统计自增，避免每次获取元素个数要遍历整个容器，提升效率</span></span><br><span class="line">    <span class="built_in">this</span>.size++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(K key, V value, <span class="type">int</span> index)</span> {</span><br><span class="line">    <span class="built_in">this</span>.table[index] = <span class="keyword">new</span> <span class="title class_">MyEntry</span>(key, value, <span class="built_in">this</span>.table[index]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在 Map 接口中要求，插入元素要返回一个 Object 对象，如果要插入元素的 key 是个新的 key，即原始容器中不存在这个 key，那么就返回当前要插入元素的 key 对应的 value 。如果要插入元素的 key 是个已存在的，那么将新的 value 覆盖掉旧的 value，并返回旧的 value。通过查看 JDK1.7 的源码可以验证：</p>
<p><img src="https://image.woodwhales.cn/048/images/03.png"></p>
<p> 因此可以进一步完善自定义的插入元素方法实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode % <span class="built_in">this</span>.table.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，如果发现当前要插入的元素已存在，更新 value，返回旧的 value</span></span><br><span class="line">    <span class="keyword">for</span>(MyEntry&lt;K,V&gt; myEntry = <span class="built_in">this</span>.table[index]; myEntry!= <span class="literal">null</span>; myEntry = myEntry.next) {</span><br><span class="line">        <span class="keyword">if</span>(key != <span class="literal">null</span> &amp;&amp; key.equals(myEntry.key)) {</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> myEntry.value;</span><br><span class="line">            myEntry.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    addEntry(key, value, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器元素个数统计自增</span></span><br><span class="line">    <span class="built_in">this</span>.size++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4-获取元素代码实现"><a href="#2-4-获取元素代码实现" class="headerlink" title="2.4 获取元素代码实现"></a>2.4 获取元素代码实现</h3><p>由此，遍历链表的操作，在 get 操作的时候也要进行：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode % <span class="built_in">this</span>.table.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(MyEntry&lt;K,V&gt; myEntry = <span class="built_in">this</span>.table[index]; myEntry!= <span class="literal">null</span>; myEntry = myEntry.next) {</span><br><span class="line">        <span class="keyword">if</span>(key != <span class="literal">null</span> &amp;&amp; key.equals(myEntry.key)) {</span><br><span class="line">            <span class="keyword">return</span> myEntry.value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-5-测试自定义容器"><a href="#2-5-测试自定义容器" class="headerlink" title="2.5 测试自定义容器"></a>2.5 测试自定义容器</h3><p>测试自定义 HashMap 的插入元素操作：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    MyHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">MyHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) {</span><br><span class="line">        map.put(<span class="string">"java"</span>+i, <span class="string">""</span>+i);</span><br><span class="line">    }</span><br><span class="line">    map.get(<span class="string">"java3"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 debug 查看容器结构，可以看到：其中一些已经形成链表，并且后插入的元素在链表的头部：</p>
<p> <img src="https://image.woodwhales.cn/048/images/04.png"></p>
<h2 id="3-JDK-1-7源码分析"><a href="#3-JDK-1-7源码分析" class="headerlink" title="3. JDK 1.7源码分析"></a>3. JDK 1.7源码分析</h2><h3 id="3-1-HashMap-基本属性"><a href="#3-1-HashMap-基本属性" class="headerlink" title="3.1 HashMap 基本属性"></a>3.1 HashMap 基本属性</h3><p>查看 JDK 1.7 中的 HashMap 源码，首先看看其中的重要属性值，包括默认容器大小，最大最小容器大小，扩容因子：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     * 默认初始化容器大小为16，大小必须是 2 的次幂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     * 容器大小限制，取值范围为：2 - 2的30次方的 2 的次幂数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     * 默认容器扩容因子，也就是当容器中的元素数量到达一定阀值的时候，需要对容器进行扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述重要属性已经在注释中进行了说明，不再赘述。</p>
<p>在 HashMap 构造函数中，有个很特别的方法，这个方法会将用户指定的容器大小，进行计算，保证容器大小为 2 的次幂：</p>
<p><img src="https://image.woodwhales.cn/048/images/05.png"></p>
<p>在<code>roundUpToPowerOf2(toSize);</code>方法的注释也说明了该方法就是要找到：大于或等于指定数值的 2 的次幂的值。</p>
<p>通过源码可以知道，为什么 HashMap 强制要求容器大小为 2 的次幂数呢？</p>
<h3 id="3-2-插入元素"><a href="#3-2-插入元素" class="headerlink" title="3.2 插入元素"></a>3.2 插入元素</h3><p>再次细致分析插入元素方法：</p>
<p><img src="https://image.woodwhales.cn/048/images/06.png"></p>
<p>通过源码可以分析，插入元素分为了四个步骤：</p>
<ul>
<li>判断 key 是否为 null，如果是则进行空值插入处理。</li>
<li>计算 key 的 hash 值，并通过这个 hash 值得到要插入的数组索引。</li>
<li>遍历要插入的位置的链表，看是已经存在当前 key 了。已存在则更新当前 value 并返回旧的 value。</li>
<li>key 是全新的元素，则进行插入操作，也就是在链表中添加新的节点。</li>
</ul>
<p>因此对于插入元素的源码分析，可以分为上述的四个模块来分析：</p>
<h4 id="3-2-1-计算-key-要插入的索引"><a href="#3-2-1-计算-key-要插入的索引" class="headerlink" title="3.2.1 计算 key 要插入的索引"></a>3.2.1 计算 key 要插入的索引</h4><p>新来看看<code>hash()</code> 和<code>indexFor()</code>方法：</p>
<p><img src="https://image.woodwhales.cn/048/images/07.png"></p>
<p>通过源码可以看出，原生的 hash 值经过了右移操作，处理过的 hash 值和数组长度并非取模操作， 而是进行了按位与操作。</p>
<p><strong>为什么要按位与操作？</strong></p>
<p>由于数组长度限制必须为 2 的次幂，因此数组长度取值只可能为：2，4，8，16，32，……，这些数字的二进制分别为：</p>
<p>| 十进制 | 二进制 |<br>| —— | —— :|<br>| 2      | 0000 1000 |<br>| 4      | 0000 0100 |<br>| 8      | 0000 1000 |<br>| 16     | 0001 0000 |<br>| 32     | 0010 0000 |</p>
<p>当上面这些数字减 1 的时候，对应的二进制为：</p>
<p>| 十进制 | 二进制 |<br>| —— | —— :|<br>| 1     | 0000 0001 |<br>| 3    | 0000 0011 |<br>| 7  | 0000 0111 |<br>| 15    | 0000 1111 |<br>| 31    | 0001 1111 |</p>
<p>按位与操作：按位与处理两个长度相同的二进制数，两个相应的二进位都为1，该位的结果值才为1，否则为0。如：0101 AND 0011 = 0001</p>
<p>由于长度减 1 之后的数值就是索引能取到的最大索引位置，对应的二进制低位数都是 1，因此保证了低位进行与操作的时候，保持了 hash 值的低位值，高位全部被转成了 0 ，也就满足了 hash 无论多长，通过与操作，都能落在数组索引范围内：</p>
<p>上述描述很抽象，用下图例子辅助说明，假设容器大小为 16，那么对应的二进制如下：</p>
<p> <img src="https://image.woodwhales.cn/048/images/08.png"></p>
<p>其他 2 的次幂值均满足，该值减 1 之后，低位都是 1，再和其他任意数值进行与操作的时候，低位保留，高位全部变为 0，因此与操作之后，一定是一个 0 - （2的次幂-1）的值，这个取值范围就是数组索引的范围。</p>
<p><strong>为什么要右移和异或？</strong></p>
<p>明白了上述为什么要与操作，那么 hash 值右移和异或操作的目的就很一目了然，右移操作，就是保留高位，去掉低位。在进行与操作的时候，就是拿 hash 值的高位进行与操作，得到索引值。目的就是增加元素的散列性，不同 key 的hashCode 的低位存在冲突的可能性更大的一些，而高位存在冲突的可能性小一些，因此要右移和异或操作。</p>
<h4 id="3-2-2-插入新元素"><a href="#3-2-2-插入新元素" class="headerlink" title="3.2.2 插入新元素"></a>3.2.2 插入新元素</h4><p>插入新元素要看<code>addEntry()</code>方法：</p>
<p><img src="https://image.woodwhales.cn/048/images/09.png"></p>
<p>对于新增节点的逻辑，就是和 2.3 小节的实现思路是一致的，不再赘述。</p>
<blockquote>
<p>对于扩容机制单独开一个小节分析，这里只分析插入元素相关的代码逻辑。</p>
</blockquote>
<h4 id="3-2-3-插入旧元素"><a href="#3-2-3-插入旧元素" class="headerlink" title="3.2.3 插入旧元素"></a>3.2.3 插入旧元素</h4><p>对于旧元素的插入，在 2.3 小节中也已经讲述，这里不再赘述。</p>
<h4 id="3-2-4-插入null"><a href="#3-2-4-插入null" class="headerlink" title="3.2.4 插入null"></a>3.2.4 插入null</h4><p>插入key 为 null 的情况，要看<code>putForNullKey()</code>方法：</p>
<p> <img src="https://image.woodwhales.cn/048/images/10.png"></p>
<p>通过源码可以分析得出：HashMap 是可以存入 null 元素的，并且存储在数组索引为 0 的位置。</p>
<h3 id="3-3-扩容机制"><a href="#3-3-扩容机制" class="headerlink" title="3.3 扩容机制"></a>3.3 扩容机制</h3><p>在新增链表节点的<code>addEntry()</code>方法中可以看到：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> {</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) {</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>判断要扩容的条件是两个，而不是仅仅达到扩容阀值的时候才扩容，还满足当前要插入的元素在要插入的位置已经有元素了才扩容。也就是说，即使元素个数到了扩容阀值，如果当前元素进来，插入到数组某个空的”插槽”中，那么不会扩容。</p>
<p>扩容后的数组长度是原来数组长度的俩倍。重点来研究一下<code>resize()</code>方法：</p>
<p><img src="https://image.woodwhales.cn/048/images/11.png"></p>
<p>要搞清楚 HashMap 的扩容，核心就是搞懂<code>transfer()</code>方法，如何实现旧表中的元素转移到新表中：</p>
<p><img src="https://image.woodwhales.cn/048/images/12.png"></p>
<p>从上图代码可知：转移步骤如下：</p>
<ul>
<li><p>依次遍历旧表中的元素，直到所有的旧元素全部转移到新表中才结束</p>
</li>
<li><p>将当前元素的下一个元素临时保存住，以备用</p>
</li>
<li><p>重新计算当前元素插入到新表的索引</p>
</li>
<li><p>将当前元素的下一个元素指向新表的索引位置元素</p>
</li>
<li><p>将新表的元素设置为当前新插入的元素</p>
</li>
<li><p>将临时保存的下一个元素取出，继续上述循环操作</p>
</li>
</ul>
<h3 id="3-4-扩容机制引发的多线程并发问题"><a href="#3-4-扩容机制引发的多线程并发问题" class="headerlink" title="3.4 扩容机制引发的多线程并发问题"></a>3.4 扩容机制引发的多线程并发问题</h3><p>HashMap 在并发环境下多线程 put 后可能导致 get 死循环，具体表现为 CPU 使用率100%，问题根源在于扩容机制中的旧元素转移到新表中。</p>
<p>首先分析单线程情况下的扩容情况：</p>
<p><img src="https://image.woodwhales.cn/048/images/13.png"></p>
<p>一般情况下，refreah 值为 false ，因此不是扩容机制分析的重点，不作分析。</p>
<p>重新计算索引位置，并将当前线程变量 e 的 next 指向新表中的索引位置元素：</p>
<p><img src="https://image.woodwhales.cn/048/images/14.png"></p>
<p>下一步就是将插入的元素放置到链表的头部，并保存在新表索引的位置：</p>
<p><img src="https://image.woodwhales.cn/048/images/15.png"></p>
<p>第一个要转移的元素已经移动完毕，将最开始临时保存的这个已转移之前的下一个元素取出，继续新的移动操作：</p>
<p><img src="https://image.woodwhales.cn/048/images/16.png"></p>
<p>移动第二次，当移动完毕时：</p>
<p><img src="https://image.woodwhales.cn/048/images/17.png"></p>
<p>从上述一个元素的移动操作过程可以看出，旧表的链表顺序的 key1 -&gt; key2 -&gt; null，存进新的链表中的顺序的倒序的，也就是 key2 -&gt; key1 -&gt; null。</p>
<h4 id="多线程问题分析"><a href="#多线程问题分析" class="headerlink" title="多线程问题分析"></a>多线程问题分析</h4><p>由于多线程都共享旧的表，新的线程同时 put 操作的时候，可能都会触发扩容操作，那么两个线程均为创建一个新的表，假设此时线程2 在 put 操作过程中莫名地停顿了一下，线程1 继续顺畅执行。</p>
<p><img src="https://image.woodwhales.cn/048/images/18.png"></p>
<p>在两个线程都需要扩容的时候，都创建好了新表，都执行到了移动元素的方法中，此时两者的线程变量状态为：</p>
<p><img src="https://image.woodwhales.cn/048/images/19.png"></p>
<p>由于莫名的原因，线程 2 停顿了一下，线程1 正常执行完毕移动操作：</p>
<p><img src="https://image.woodwhales.cn/048/images/20.png"></p>
<p>上图只是个理想状态，因为线程2中的变量 e 指向的永远是 key1 对应的内存地址，变量 next 指向的是 key1 的 next 变量指向的内存地址，因此正确的状态图为：</p>
<p><img src="https://image.woodwhales.cn/048/images/21.png"></p>
<p>此时，线程2 继续执行移动元素操作：</p>
<p>将线程2 的 e 变量所指向的元素移动到线程2 创建的 table 中，并将线程2 的 next 变量所指向的元素赋值给线程2的 e 变量，此时的状态图为：</p>
<p> <img src="https://image.woodwhales.cn/048/images/22.png"></p>
<p>线程2 再次执行下一次循环，此时变量 next 指向的 线程2 的新表的索引位置：</p>
<p><img src="https://image.woodwhales.cn/048/images/23.png"></p>
<p>注意，此时要计算变量 e 对应的元素的索引，还是在线程2 的新表中的 key1 所在位置，当执行<code>e.next=newTable[i]</code>的时候，会发现一个问题：e 指向的元素是线程1 新表中的 key2，而 key2 的下一个元素就是指向线程2 新表中的索引位置，也就是 newTable[i] 指向的内存地址，此行代码执行无效。</p>
<p>继续执行代码新元素插入到链表头部的操作：</p>
<p><img src="https://image.woodwhales.cn/048/images/24.png"></p>
<p>继续下一次循环：</p>
<p><img src="https://image.woodwhales.cn/048/images/25.png"></p>
<p><img src="https://image.woodwhales.cn/048/images/26.png"></p>
<p>继续执行代码：</p>
<p><img src="https://image.woodwhales.cn/048/images/27.png"></p>
<p>幸好，在 JDK1.8 中已经避免了这个问题，因为在 JDk 1.8 中，元素转移到新表的时候，是保持原有顺序的，因此不会出现产生这种循环链表的情况。</p>
<h3 id="3-5-ConcurrentModificationException-异常"><a href="#3-5-ConcurrentModificationException-异常" class="headerlink" title="3.5 ConcurrentModificationException 异常"></a>3.5 ConcurrentModificationException 异常</h3><p>编写一个测试代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Integer k : set){</span><br><span class="line">            map.remove(k);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行时会报<code>java.util.ConcurrentModificationException</code>异常</p>
<p>如果换成 iterator 遍历 map，那么就不会报异常：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line">    Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) {</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-JDK-1-8-源码分析"><a href="#4-JDK-1-8-源码分析" class="headerlink" title="4. JDK 1.8 源码分析"></a>4. JDK 1.8 源码分析</h2><p>JDK 1.8 中当链表长度达到一定阀值的时候，就会将链表转成红黑树，为什么是红黑树，而不是平衡二叉树或者其他树结构，也是需要浅析一下：</p>
<h3 id="4-1-三种树结构"><a href="#4-1-三种树结构" class="headerlink" title="4.1 三种树结构"></a>4.1 三种树结构</h3><p>打旧金山大学的开数据结构可视化网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<p>分别比较二叉树、平衡二叉树（AVL）、红黑树的结构：</p>
<h4 id="4-1-1-平衡二叉树（AVL）"><a href="#4-1-1-平衡二叉树（AVL）" class="headerlink" title="4.1.1 平衡二叉树（AVL）"></a>4.1.1 平衡二叉树（AVL）</h4><p><img src="https://image.woodwhales.cn/048/images/28.png"></p>
<p>平衡二叉树或为空树，或为如下性质的二叉排序树：</p>
<p>1）左右子树深度之差的绝对值不超过1</p>
<p>2）左右子树仍然为平衡二叉树</p>
<p>平衡因子BF = 左子树深度－右子树深度</p>
<p>平衡二叉树每个结点的平衡因子只能是1，0，-1。</p>
<p>若其绝对值超过1，则该二叉排序树就是不平衡的。</p>
<h4 id="4-1-2-红黑树（RBT-）"><a href="#4-1-2-红黑树（RBT-）" class="headerlink" title="4.1.2 红黑树（RBT ）"></a>4.1.2 红黑树（RBT ）</h4><p><img src="https://image.woodwhales.cn/048/images/29.png"></p>
<p>AVL 是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p>
<p>红黑是弱平衡的，用非严格的平衡来换取增删节点时候旋转次数的降低；</p>
<p>所以简单说，搜索的次数远远大于插入和删除，那么选择 AVL 树；如果搜索，插入删除次数几乎差不多，应该选择RBT树。</p>
<p>红黑树上每个结点内含五个域，color，key，left，right，p。如果相应的指针域没有，则设为NIL。<br>一般的，红黑树满足以下性质，即只有满足以下全部性质的树，我们才称之为红黑树：<br>1）每个结点要么是红的，要么是黑的。</p>
<p>2）根结点是黑的。</p>
<p>3）每个叶结点，即空结点（NIL）是黑的。</p>
<p>4）如果一个结点是红的，那么它的俩个儿子都是黑的。</p>
<p>5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。</p>
<h4 id="4-1-3-二叉树搜索树（BST）"><a href="#4-1-3-二叉树搜索树（BST）" class="headerlink" title="4.1.3 二叉树搜索树（BST）"></a>4.1.3 二叉树搜索树（BST）</h4><p><img src="https://image.woodwhales.cn/048/images/30.png"></p>
<p>所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>所有结点存储一个关键字；</p>
<p>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p>总结下来，JDK1.7 的链表结构就类似于上图情况下的二叉搜索树，当时数据元素节点较多的时候，查询速度很慢。JDK 1.8 采用红黑树，正是均衡了元素的增删性能问题，选择了性能均衡的红黑树，当链表节点元过多的时候，将数据结构转成红黑树，元素的查询性能得到提升。</p>
<h3 id="4-2-HashMap-基本属性"><a href="#4-2-HashMap-基本属性" class="headerlink" title="4.2 HashMap 基本属性"></a>4.2 HashMap 基本属性</h3><p>HashMap 中的容器大小，默认扩容因子等都和 JDK 1.7 没有变化。在 JDK 1.8 中新增了对于红黑树相关的默认属性：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 当链表中的元素个数超过 8 个时，链表转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当链表中的元素个数小于 6 个时，红黑树转成链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-3-插入元素"><a href="#4-3-插入元素" class="headerlink" title="4.3 插入元素"></a>4.3 插入元素</h3><h4 id="4-3-1-hash-计算"><a href="#4-3-1-hash-计算" class="headerlink" title="4.3.1 hash 计算"></a>4.3.1 hash 计算</h4><p>在 JDK 1.8 中，对于 hash 值的运算比 JDK 1.7 更为简便一些，没有过多得算法，只是进行了将高 16 位和低 16 位进行了异或运算，此时相比 JDK1.7 的散列性要弱一些，因为红黑树的引用，所以不需要那么强的散列性。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-3-2-插入元素源码分析"><a href="#4-3-2-插入元素源码分析" class="headerlink" title="4.3.2 插入元素源码分析"></a>4.3.2 插入元素源码分析</h4><p>JDK 1.8 的源码的可读性没有 1.7 好，但是基本的思路和 1.7 是一致的。需要注意的是：新元素的节点是添加在链表的尾部。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> {</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 要插入的位置，没有元素，那么就直接插入到当前索引位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">           	<span class="comment">// 当前的key 已经存在了</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 当前要插入的节点是一颗红黑树，将新节点插入红黑树，如果已经存在，就返回该key所在红黑树节点</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                <span class="comment">// 直到遍历到链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// 插入新的节点到链表的尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 检查此时的链表是不是需要转成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 如果遍历的过程中，发现已经存在key了，直接跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">// 当前的key 已经存在了，更新value，返回旧的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过上面源码的注释可以看出，插入一个元素的时候一般分为三种情况：</p>
<ul>
<li>数组原本的位置为空</li>
<li>数组原本的位置不为空，并且下面是链表的结构</li>
<li>数组原本的位置不为空，并且下面是红黑树的结构</li>
</ul>
<h4 id="4-3-3-扩容时的-hash-计算"><a href="#4-3-3-扩容时的-hash-计算" class="headerlink" title="4.3.3 扩容时的 hash 计算"></a>4.3.3 扩容时的 hash 计算</h4><p>对原 key 的 hashCode 在扩容前后计算，会发现一些规律：</p>
<p><img src="https://image.woodwhales.cn/048/images/31.png"></p>
<p>hashCode 中标红的位置如果为 1，那么扩容之后，其索引=原来索引值+原来容量大小，如果该位为 0，则索引值不变化。在 JDK 1.8 中将此规律应用了起来，在扩容方法<code>resize()</code>方法中就存在着此算法，因此没有重新计算 hashCode，减少了CPU资源开销。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 原始表的容量大于最大限制了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 原始表的容量没有超过最大限制，双倍扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历旧表的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) {</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 旧表的索引位置，只有一个元素</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 红黑树拆分移动</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表元素移动</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> {</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 判断索引值要不要变化</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) {</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 索引不变化</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 索引变化，加旧表的容量大小</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此，从上述分析和源码分析得出，在 JDK 1.8 中，旧表中的 hashCode 会转移到新表中，在新表中的位置索引值只有俩种可能：一种是<code>原下标</code>，另一种是<code>原下标 + 旧表容量</code>。</p>
]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈密码技术</title>
    <url>/2019/09/27/049/</url>
    <content><![CDATA[<h2 id="一封情书引发的安全问题"><a href="#一封情书引发的安全问题" class="headerlink" title="一封情书引发的安全问题"></a>一封情书引发的安全问题</h2><p>在现代通讯中，双方传输信息均通过网络传输，那么在这个过程中，就存在着如下的信息传输场景：</p>
<p><img src="https://image.woodwhales.cn/049/images/01.png"></p>
<p>重要信息，使用明文在网络中传输很容易被窃听者窃听并攻击，造成严重的信息传输安全问题：</p>
<p><img src="https://image.woodwhales.cn/049/images/02.png"></p>
<p>上述信息传输过程，让人容易想到：只需要对原文进行加密，不就可以了吗？形如：</p>
<p><img src="https://image.woodwhales.cn/049/images/03.png"></p>
<p>在上图场景中，我们放心大胆的把加密后的密文传输给对方，就算窃听者窃取到了，对方没有密码就无法知道传输的原文信息，这种设计思想看起来很合理，但是会引发另俩个问题：</p>
<ul>
<li>加密的密钥的传输问题：双方使用的密钥怎么传输才能仅仅让对方知道？</li>
<li>加密算法的安全性问题：密钥如何加密才能不会被黑客轻松破解？</li>
</ul>
<p>本文会围绕这俩个核心问题展开讲解。其中涉及到：</p>
<ul>
<li>对称加密（对称密码）、非对称加密（公钥密码）、单向散列函数、消息认证码、数字签名、伪随即数生成器，这六种密码技术统称为：密码学家的工具箱</li>
<li>中间人攻击</li>
<li>证书</li>
<li>PKI</li>
<li>SSL/TLS</li>
</ul>
<h2 id="密码技术概述"><a href="#密码技术概述" class="headerlink" title="密码技术概述"></a>密码技术概述</h2><p>加密和解密算法合在一起统称为密码算法。</p>
<h3 id="对称密码与公钥密码"><a href="#对称密码与公钥密码" class="headerlink" title="对称密码与公钥密码"></a>对称密码与公钥密码</h3><p>对称密码：是指加密和解密时使用同一个密钥的方式；</p>
<p>公钥密码：是指在加密和解密时使用不同密钥的方式，又称为非对称密码；</p>
<p>混合密码系统：是指将对称密码和公钥密码结合起来的密码方式；</p>
<p><img src="https://image.woodwhales.cn/049/images/04.png"></p>
<h3 id="其他密码技术"><a href="#其他密码技术" class="headerlink" title="其他密码技术"></a>其他密码技术</h3><p><strong>单向散列函数</strong></p>
<p>单向散列函数是为了防止数据被篡改设计出来的，可以根据单向散列函数得出的散列值（又称哈希值、密码校验、指纹、消息摘要），对数据的完整性进行判断。如：MySQL官网下载软件包时提供MD5验证。</p>
<p><strong>消息认证码</strong></p>
<p>消息认证码是为了确认消息是否来自所期待的通信对象。通过消息认证码不仅能够保证完整性，也可以提供认证机制，但是它并不能防止否认和不能够对第三方进行确认。</p>
<p><strong>数字签名</strong></p>
<p>数字签名是一种将现实世界中的签名和盖章移植到数字世界中的技术。数字签名既可以检测出伪装和篡改，也可以防止事后否认。</p>
<p><strong>伪随机数生成器</strong></p>
<p>伪随机数生成器是一种能够模拟产生随机数列的算法。只有产生具有不可重现性（不可重现性 &gt; 不可预测性 &gt; 随机性）数值的伪随机数生成器才能够用于密码技术种。如在Web中进行SSL/TLS通信时需要使用伪随随机数生成器生成一个临时密钥（会话密钥），如果随机数算法不好，容易被推测出密钥。</p>
<h3 id="密码技术小结"><a href="#密码技术小结" class="headerlink" title="密码技术小结"></a>密码技术小结</h3><p>下图表示信息安全所面临的威胁与应对的密码技术：</p>
<p><img src="https://image.woodwhales.cn/049/images/05.png"></p>
<p>从图中可以看出：消息认证码能防止的受威胁的特性，在单单向散列函数及数字签名中已经体现，因此目前实际常用的密码技术是：对称密码、公钥密码、单向散列函数、数字签名。</p>
<h3 id="密码与信息安全常识"><a href="#密码与信息安全常识" class="headerlink" title="密码与信息安全常识"></a>密码与信息安全常识</h3><p><strong>不要使用保密的密码算法</strong></p>
<p>从历史上看，算法的秘密无一例外最终会被暴露出来。公开的算法从一开始就没有设想过要保密，因此算法的暴露丝毫不会削弱算法它们的强度。</p>
<p>高强度的密码不能像数学一样严密证明，事实上，如果专业密码破译者经过数年的尝试仍然没有破解某个密码算法，则说明这种算法的强度较高。目前世界公开的被认为强度较高的密码算法，都是经过密码破译者长期尝试破解未果而存活下来的。</p>
<p><strong>使用低强度的密码比不进行任何加密更危险</strong></p>
<p>与其使用低强度的密码，还不如从一开始就不适用任何密码。16世纪的苏格兰女王玛丽就曾认为没有人能够破译自己使用的密码。正是由于对于密码的盲信，导致她的刺杀计划被破译，将自己送上了断头台。 [扩展：玛丽女王的密码：<a href="http://www.oscca.gov.cn/sca/zxfw/2017-04/25/content_1011716.shtml]">http://www.oscca.gov.cn/sca/zxfw/2017-04/25/content_1011716.shtml]</a></p>
<p><strong>任何密码总有一天都会被破解</strong></p>
<p>密码算法生成的密文，只要把所有可能的密钥全部尝试一遍，时间允许的情况下，总会被破解。严格来说，绝对不会被破解的密码算法是存在的，这种算法成为一次性密码本。还有一种技术被认为有可能造就完美的密码技术，那就是量子密码。</p>
<p><strong>密码只是信息安全的一部分</strong></p>
<p>不用通过截取网络传输中的数据，而是通过攻击接收信息者的电脑设备，获取重要的信息。还有如社会工程学攻击等。系统的安全性是环环相扣的节点组成，每个环节都很重要。最脆弱的环节并不是密码，而是人类自己。</p>
<h2 id="历史上的密码技术"><a href="#历史上的密码技术" class="headerlink" title="历史上的密码技术"></a>历史上的密码技术</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>凯撒密码是通过将明文中所使用的字母表按照一定的字数“平移”来进行加密。</p>
<p><img src="https://image.woodwhales.cn/049/images/06.png"></p>
<p>凯撒密码的加加密原理：</p>
<p><img src="https://image.woodwhales.cn/049/images/07.png"></p>
<p><strong>凯撒密码的缺陷</strong></p>
<p>如果不知道平移的数字，那么可以通过暴力破解的方式进行破解。因为位移值就是密钥，因此有26种平移值的可能。</p>
<p><img src="https://image.woodwhales.cn/049/images/08.png"></p>
<h3 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h3><p>对于简单替换密码技术可以这样理解：凯撒密码是通过平移字母来进行加密的，而简单替换密码则是将这种平移变成了无序对应，则可以将凯撒密码看作简单替换密码的一种特殊情况。</p>
<p>简单替换密码的加密和解密的原理与凯撒密码的大同小异，但是破解方式不同：恺撒密码可以通过暴力破解进行破译，而简单替换密码则需要频率分析进行破译。</p>
<p><img src="https://image.woodwhales.cn/049/images/09.png"></p>
<p>简单替换密码很难通过暴力破解来破解：</p>
<p>因为破解可能的密钥数量远比凯撒密码多得多。</p>
<p>明文字母表中的a可以对应ABC…Z这26个字母，</p>
<p>明文字母表中的b可以对应BCD…Z这25个字母，</p>
<p>…</p>
<p>综上，替换密钥的总数为：</p>
<p><img src="https://image.woodwhales.cn/049/images/10.png"></p>
<p>约为 4 兆（1兆等于1万亿）的1000兆倍，即使计算机每秒遍历 10 亿个密钥，遍历完所有需要花费 120 亿年时间。</p>
<h3 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h3><p>频率分析是利用了明文中的字母出现的频率与密文中的字母出现的频率一致这一特性，对简单替换密码进行破译。</p>
<p>例如如下密文：</p>
<p><img src="https://image.woodwhales.cn/049/images/11.png"></p>
<p>首先统计一下密文中每个字母出现的频率，也就是，数一下每个字母出现多少次。</p>
<p><img src="https://image.woodwhales.cn/049/images/12.png"></p>
<p>英文文章中一般出现频率最高的字母是 e，上表中出现频率最高的是 I 和 Y，假设其中一个是 e。假设 Y 的原文是 e 时，将原密文中的 Y 替换成 e，得到：</p>
<p><img src="https://image.woodwhales.cn/049/images/13.png"></p>
<p>英语中最多出现的单词是 the，所以找以 e 结尾的 3 个字母组合，发现 MEe 出现频率很高，而且 MEe 出现在密文的开头，所以 MEe 很有可能就是 the。于是继续替换：</p>
<p><img src="https://image.woodwhales.cn/049/images/14.png"></p>
<p>再动员所有日常使用的英语词汇，发现有个 thPee 比较可疑，这个词很有可能是：three（P 的原文为 r）</p>
<p><img src="https://image.woodwhales.cn/049/images/15.png"></p>
<p>以此类推，通过频率分析法逐步破译替换密码，对于频率分析可以这样总结：</p>
<ul>
<li><p>除了高频字母以外，低频字母也能够成为线索；</p>
</li>
<li><p>搞清开头和结尾能够成为线索，搞清单词之间的分隔也能偶成为线索；</p>
</li>
<li><p>密文越长越容易破解；</p>
</li>
<li><p>同一个字母连续出现能够成为线索（这是因为在简单替换密码中，某个字母在替换表中所对应的另一个字母是固定的）</p>
</li>
<li><p>破译速度会越来越快</p>
</li>
</ul>
<h3 id="Enigma"><a href="#Enigma" class="headerlink" title="Enigma"></a>Enigma</h3><p>恩尼格玛密码机（德语：Enigma，又译哑谜机，或「谜」式密码机）是一种用于加密与解密文件的密码机。</p>
<p><img src="https://image.woodwhales.cn/049/images/16.png"></p>
<p>Enigma，是一种由键盘、齿轮、电池和灯泡组成的机器，通过这一台机器可以完成加密和解密两种操作。该机器由德国人 Arthur Scherbius 发明，刚刚发明之际用于商业，后来到了纳粹时期，德国军方该良之后用于军事用途。</p>
<p><img src="https://image.woodwhales.cn/049/images/17.png"></p>
<h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>下图中的接线板是一种通过改变接线方式来改变字母对应关系的部件。接线板上的接线方式是根据国防军密码本的每日密码来决定的，在一天之中不会改变。</p>
<p>当输入一个字母时，转子1旋转1/4圈，转子1每旋转1圈的时候转子2旋转1/4圈，转子2每旋转1圈的时候转子3旋转1/4圈。</p>
<p><img src="https://image.woodwhales.cn/049/images/18.png"></p>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p><img src="https://image.woodwhales.cn/049/images/19.png"></p>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><p><img src="https://image.woodwhales.cn/049/images/20.png"></p>
<h4 id="Enigma的弱点"><a href="#Enigma的弱点" class="headerlink" title="Enigma的弱点"></a>Enigma的弱点</h4><p>加密通信密码是重要步骤（最开始的6次输入），实际只有转子1会旋转。</p>
<p>将通信密码连续输入俩次并加密，因为破译者可以知道，密文开头的6个字母被解密之后的明文一定是3个字谜重复俩次的形式。</p>
<p>通信密码是人为选定的，实现使用中，发送者使用如aaa，bbb或者女友的名字作为密码，太相信 Enigma 的安全性而忽略了密钥最好是用随机数来生成。</p>
<p>必须派发国防军密码本，密码本一旦丢失一本，那么就要重新制作新的密码本并发放到全军，这属于密钥配送的问题。</p>
<h2 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h2><p>对称密码又称为共享密码</p>
<h3 id="比特序列密码"><a href="#比特序列密码" class="headerlink" title="比特序列密码"></a>比特序列密码</h3><p><strong><code>XOR</code>运算</strong>，中文称为“异或运算”。</p>
<p>它的定义是：两个值相同时，返回<code>false</code>，否则返回<code>true</code>。也就是说，<code>XOR</code>可以用来判断两个值是否不同。</p>
<p>XOR 运算有一个很奇妙的特点：如果对一个值连续做两次 XOR，会返回这个值本身。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次 XOR</span></span><br><span class="line"><span class="number">1010</span> ^ <span class="number">1111</span> <span class="comment">// 0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次 XOR</span></span><br><span class="line"><span class="number">0101</span> ^ <span class="number">1111</span> <span class="comment">// 1010</span></span><br></pre></td></tr></tbody></table></figure>

<p>关于XOR的运算规则需要注意的是：</p>
<p>和加法运算不同的是，XOR 中不需要进位</p>
<p>两个相同的数进行 XOR 运算的结果一定为 0；</p>
<p>可以通过XOR运算规则，进行加密和解密：将明文 A 用密钥 B 进行加密，得到密文 A ⊕ B；将密文 A ⊕ B 用密钥 B 进行解密，得到明文 A；</p>
<h3 id="一次性密码本"><a href="#一次性密码本" class="headerlink" title="一次性密码本"></a>一次性密码本</h3><p>只要通过暴力破解法对密钥空间进行遍历，无论是什么密文总有一天都能够被破译，然而，一次性密码本是个例外。即使用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破解。</p>
<p>一次性密码本的加密：</p>
<p><img src="https://image.woodwhales.cn/049/images/21.png"></p>
<p>一次性密码本的解密：</p>
<p><img src="https://image.woodwhales.cn/049/images/22.png"></p>
<p><strong>一次性密码本是无法破译？</strong></p>
<p>我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，也就能解密出明文midnight，这是毋庸置疑的事实。然而即使我们能够解密出midnight这个字符，我们也无法判断它是否是正确的明文。</p>
<p>所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。然而，在一次性密码本中，由于我们无法判断得到的是不是正确的明文，因此一次性密码本是无法破译的。</p>
<p>一次性密码本是无条件安全的，在理论上是无法破译的。（ 1949年香农使用数学方法证明）</p>
<p><strong>一次性密码本为什么没有被使用？</strong></p>
<ul>
<li><p>密钥配送问题</p>
<p>如果能有一种方法将密钥安全地发送出去，那么岂不是也可以用同样的方法来安全发送明文吗？</p>
</li>
<li><p>密钥保存问题</p>
<p>如果有办法安全保存与明文一样长的密钥，那不是也有办法安全保存明文本身吗？也就是说，从一开始我们根据就不需要密码。</p>
</li>
<li><p>密钥的重用</p>
<p>在一次性密码本中绝对不能重用过去用过的随机比特序列，一次性密码本中的“一次性”也正是由此而来。这是因为作为密钥的比特序列一旦泄密，过去所有的机密通信内容将全部被解密。</p>
</li>
<li><p>密钥的同步</p>
<p>当明文很长时，一次性密码本也会跟着变长。如果明文是一个大小为100MB的文件，则密钥的大小也一定是100MB。而且在通信过程中，发送者和接收者的密钥的比特序列不允许任何错位，否则错位的比特后的所有信息将无法解密。</p>
</li>
<li><p>密钥的生成</p>
<p>在一次性密码本中，需要生成大量的随机数。这里的随机数并不是通过计算机程序生成的伪随机数，而必须是无重复性的真正随机数。</p>
</li>
</ul>
<p>综上所述，一次性密码本是一种几乎没有实用性的密码，但一次性密码本却孕育了<strong>流密码</strong>，流密码使用的不是真正的随机比特序列，而是伪随机数生成器产生的比特序列。</p>
<h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p>DES（Data Encryption Standard）是1977年美国联邦信息处理标准（ FIPS ）中所采用的一种对称密码。</p>
<p><img src="https://image.woodwhales.cn/049/images/23.png"></p>
<p>DES 是一种将 64 比特的明文加密成 64 位比特的密文的对称密码算法，它的密钥长度是 64 比特，但由于每隔 7 比特会设置一个用于错误检验的比特（实际用到了56位，第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1），因此实质上其密钥长度是 56 比特。</p>
<p>DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。以分组为单位进行处理的密码算法称为分组密码。</p>
<h4 id="Feasted-网络"><a href="#Feasted-网络" class="headerlink" title="Feasted 网络"></a>Feasted 网络</h4><p>Feasted 网络/结构/密码不仅被用于 DES，在其他很多密码算法中也有应用；Feistel 网络中，加密的各个步骤称为轮，整个加密过程中就是进行若干次轮的循环，一共有 16轮；</p>
<p>轮函数的作用根据 “右侧” 和字密钥生成对 “左侧” 进行加密的比特序列，它是密码系统的核心；</p>
<p>Feistel 网络的轮数可以任意增加；</p>
<p>加密时无论使用任何函数作为轮函数都可以正确解密；</p>
<p>加密和解密可以用完全相同的结构来实现。</p>
<p><img src="https://image.woodwhales.cn/049/images/24.png"></p>
<h3 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h3><p>3DES是为了增加 DES 的强度，将 DES 重复 3 次所得到一种密码算法，缩写为3DES</p>
<p>三重 DES 是加密 → 解密 → 加密的过程，目的是为了让三重 DES 能够兼容普通的 DES（当三重 DES 中所有的密钥都相同时，三重 DES 也就是普通的 DES了），也就是说三重 DES 对 DES 具备向下兼容性；</p>
<p>如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥，这种三重DES称为DES-EDE2；如果密钥1 、密钥2、密钥3 全部使用不同的比特序列的三重DES称为DES-EDE3。</p>
<p><img src="https://image.woodwhales.cn/049/images/25.png"></p>
<h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)，它的诞生就是来取代 DES。具体的加密流程如下图： </p>
<p><img src="https://image.woodwhales.cn/049/images/26.png"></p>
<p>Rijndael 没有使用 Feistel 网络，而是使用了 SPN 结构；Rijndael 的输入分组为 128 比特，也就是 16 字节；</p>
<p><img src="https://image.woodwhales.cn/049/images/27.png"></p>
<h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><h3 id="密钥配送"><a href="#密钥配送" class="headerlink" title="密钥配送"></a>密钥配送</h3><ul>
<li>通过事先共享密钥来解决</li>
</ul>
<p>最简单的一种解决方法，就是事先用安全的方式将密钥交给对方，这称为密钥的事先共享。</p>
<ul>
<li>通过密钥分配中心来解决</li>
</ul>
<p>密钥分配中心（KeyDistributionCenter，KDC）来解决密钥配送问题。当需要进行加密通信时，密钥分配中心会生成一个通信密钥，每个人只要和密钥分配中心事先共享密钥就可以了</p>
<ul>
<li>通过 Diffie-Hellman 密钥交换来解决</li>
</ul>
<p>在DH密钥交换中，进行加密通信的双方需要交换一些信息，而这些信息即便被窃听者 窃听到也没有问题。根据所交换的信息，双方可以各自生成相同的密钥，而窃听者却无法生成相同的密钥。</p>
<ul>
<li>通过公钥密码来解决</li>
</ul>
<p>公钥密码的一个重要性质，就是只有拥有解密密钥的人才能够进行解密。 </p>
<p>接收者事先将加密密钥发送给发送者，这个加密密钥即便被窃听者获取也没有问题。发送者使用加密密钥对通信内容进行加密并发送给接收者，而只有拥有解密密钥的人（即接收者本人）才能够进行解密。</p>
<p><img src="https://image.woodwhales.cn/049/images/28.png"></p>
<h3 id="公钥密码-1"><a href="#公钥密码-1" class="headerlink" title="公钥密码"></a>公钥密码</h3><p>公钥密码中，密钥分为<strong>加密密钥</strong>和<strong>解密密钥</strong>两种。</p>
<p>发送者用加密密钥对消息进行加密，接收者用解密密钥进行解密。加密密钥是发送者加密时使用的，而解密密钥则是接收者解密时使用的。</p>
<p>加密密钥和解密密钥的区别：</p>
<ul>
<li><p>发送者只需要加密密钥</p>
</li>
<li><p>接收者只需要解密密钥</p>
</li>
<li><p>解密密钥不可以被窃听者获取</p>
</li>
<li><p>加密密钥被窃听者获取也没问题</p>
</li>
</ul>
<p>解密密钥从一开始就是由接收者自己保管的， 因此只要将加密密钥交给发送者就可以解决密钥配送问题了，而根本不需要配送解密密钥。</p>
<p><img src="https://image.woodwhales.cn/049/images/29.png"></p>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。</p>
<p><img src="https://image.woodwhales.cn/049/images/30.png"></p>
<p>RSA 算法的可靠性基础：对极大整数做因数分解是很困难的。<br>RSA 是非对称算法，加解密使用不同的密钥。</p>
<p>两个密钥都可以用于加密，解密时需要使用另一个密钥。但是，通常用公钥加密私钥解密，因为公钥是近乎完全公开的，对于私钥加密的数据，有太多的人可以解密了。理论上 A 和 B 之间要通过 RSA 实现保密通信，需要 A 和 B 各自生成一组密钥，同时保管好自己的私钥；用对方的公钥加密要发送的消息，用自己的私钥解密对方发送过来的消息。</p>
<p>在签名的场景下，用私钥签名，公钥验签。</p>
<p>RSA 比 DES 等对称算法慢得多。一般在实际数据传输时，用 RSA 来加密比较短的对称密码，双方交换密码后再使用 DES 等对称算法传输数据。</p>
<h4 id="RSA-算法原理"><a href="#RSA-算法原理" class="headerlink" title="RSA 算法原理"></a>RSA 算法原理</h4><ul>
<li><p>RSA加密：密文 = 明文 E mod N</p>
<p>明文的 E 次方对 N 求余，得到的余数就是密文。</p>
<p>E是加密（Encryption），N是数字（Number），{E，N}就是公钥。</p>
</li>
<li><p>RSA解密：明文 = 密文 D mod N</p>
<p>密文的 D 次方对 N 求余，得到的余数就是明文。</p>
<p>D是解密（Decryption），N是数字（Number），{D，N}就是私钥。</p>
</li>
</ul>
<p>公私钥算法计算步骤：</p>
<p><img src="https://image.woodwhales.cn/049/images/31.png"></p>
<p>公私钥使用方法：公钥加密的的密文，私钥可以解密。私钥加密的密文，公钥可以解密。</p>
<p><img src="https://image.woodwhales.cn/049/images/32.png"></p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻虽然不能破译RSA，但是却是一种针对机密性的有效攻击：</p>
<p><img src="https://image.woodwhales.cn/049/images/45.gif"></p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="单向散列函数"><a href="#单向散列函数" class="headerlink" title="单向散列函数"></a>单向散列函数</h3><p>单向散列函数不同于加密技术，它不是对信息进行加密，而是为了证明数据的完整性，防止数据被篡改，但是无法辨别出“伪装”（这个需要认证技术）。应用例子：MD5、SHA-1、SHA-256、SHA-384、SHA-512、PIPEMD-160</p>
<p>单向散列函数的应用场景：检测软件是否被篡改、基于口令的加密、消息认证码、数字签名、伪随机数生成、一次性口令</p>
<p><img src="https://image.woodwhales.cn/049/images/33.png"></p>
<p>MySQL 官网展示的软件 MD5 值：</p>
<p><img src="https://image.woodwhales.cn/049/images/34.png"></p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>王小云（1966年8月－）中国密码学家。山东大学数学学院教授，博士生导师。成功破解了五大国际著名密码算法：MD5、HAVAL-128、MD4 、RIPEMD 和 SHA-1</p>
<p>2004年的国际密码讨论年会（CRYPTO）尾声，王小云及其研究同事展示了MD5、SHA-0及其他相关散列函数的散列冲撞。王小云提供了第一个碰撞示例。</p>
<p>2005年2月，王小云与其同事提出SHA-1散列函数的散列冲撞。王小云所提的散列冲撞算法只需少于2^69步骤，少于生日攻击所需的2^80步。同年8月，王小云、姚期智，以及姚期智妻子姚储枫联手于国际密码讨论年会提出SHA-1散列函数散列冲撞算法的改良版。此改良版使破解SHA-1时间缩短为2^63步。</p>
<p>一个安全的散列算法需要满足如下两个条件，也是散列算法的两个特性。</p>
<p>（1）抗碰撞性。根据一个输入，找到一个其它输入得到相同的输出，在计算上是不可行的；</p>
<p>（2）不可逆性。根据一个输出，找到一个输入其散列值等于输出，在计算上是不可行的，即不可能从结果逆向推导初始值。</p>
<p>综上所述：王小云的研究成果：MD5(M1)=MD5(M2)</p>
<p><img src="https://image.woodwhales.cn/049/images/35.png"></p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>在中间人攻击中，可以得出发送公钥给对方，可能会被截获，接收公钥的人不知道自己收到的公钥是不是真正的公钥，思考：怎么保证公钥在传输过程中“保真”呢？</p>
<p>能不能设计一种算法：对当前要传输的公钥进行签名，然后再传输给对方，对方用验证密钥验证签名是不是合法，如果合法就表示当前的公钥是“真”的。</p>
<p>这种算法其实已经在上文中出现了，就是将公私钥的用法反过来使用：私钥加密的文件，只有对应的公钥解密，所以可以作为数字签名的一种算法实现：</p>
<p><img src="https://image.woodwhales.cn/049/images/36.png"></p>
<p><strong>数字签名有两种功效</strong></p>
<p>一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</p>
<p>二是数字签名能确定消息的完整性。因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。</p>
<p>一次数字签名涉及到一个哈希函数、发送者的公钥、发送者的私钥。</p>
<p><img src="https://image.woodwhales.cn/049/images/37.png"></p>
<p>验证签名的公钥在传输过程中被别人“调包”了是完全没用的。</p>
<p>因为假的公钥是验证不成功这个数字签名，所以就可以认为当前数字签名不合法或者当前验证签名的公钥是“假”的。</p>
<p>数字签名的应用实例：安全信息公告、软件下载、公钥证书、SSL/TLS</p>
<p>实现数字签名的方式：RSA实现、ElGama实现、DSA实现、Rabin方式</p>
<h3 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h3><p>用数字签名既可以识别出篡改和伪装，还可以防止否认。也就是说，我们同时实现了确认消息的完整性、进行认证以及否认防止。代社会中的计算机通信从这一技术中获益匪浅。数字签名看上去很完善，但是有个很重要的前提：<strong>用于验证签名的公钥必须属于真正的发送者</strong>。</p>
<p>现在我们发现自己陷人了一个死循环一一一数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行。</p>
<p>为了能够确认自己得到的公钥是否合法，我们需要使用证书。所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。</p>
<p>当然，这样的方法只是把问题转移了而已。为了对证书上施加的数字签名进行验证，我们必定需要另一个公钥，那么如何才能构筑一个可信的数字签名链条呢？又由谁来颁发可信的证书呢？到这一步，我们就已经踏入了社会学的领域。我们需要让公钥以及数字签名技术成为一种社会性的基础设施，即公钥基础设施（Public Key Intrastructure），简称PKI</p>
<blockquote>
<p>国际知名的 CA 机构市场份额占比：<a href="https://en.wikipedia.org/wiki/Certificate_authority">https://en.wikipedia.org/wiki/Certificate_authority</a></p>
</blockquote>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>公钥证书（Public-Key Certificate，PKC）其实和驾照很相似，里面有姓名，组织、邮箱、地址等个人信息，以及属于此人的公钥，并由认证机构（Certification Authority、Certifying Authority，CA）施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称证书。</p>
<p><img src="https://image.woodwhales.cn/049/images/38.png"></p>
<p>数字证书有很多格式版本，主要有X.509v3（1997）、X509v4（1997）、X.509v1（1988）等。比较常用的版本是TUTrec.x.509V3，由国际电信联盟制定，内容包括证书序列号、证书有效期和公开密钥等信息。不论是哪一个版本的数字证书，只要获得数字证书，用户就可以将其应用于网络安全中。</p>
<blockquote>
<p>crt和cer都是证书，通常window系统下是cer，linux和Unix是用crt。crt可能是PEM编码，也可能是DER编码，大多数应该是PEM编码。cer可能是PEM编码，也可能是DER编码，大多数应该是DER编码。</p>
</blockquote>
<p><strong>构成PKI的三要素</strong></p>
<ul>
<li><p>用户：使用PKI的人，也称为实体（Entity）</p>
</li>
<li><p>认证机构：颁发证书的人</p>
</li>
<li><p>仓库：保存证书的数据库</p>
</li>
</ul>
<p><img src="https://image.woodwhales.cn/049/images/39.png"></p>
<p>安全服务器：安全服务器面向普通用户，用于提供证书申请、浏览、证书撤销列表、证书下载等安全服务；用户需要首先得到安全服务器的证书（该证书由CA颁发）；</p>
<p>注册机构RA：在CA体系结构中起承上启下的作用，一方面向CA转发安全服务器传输过来的证书申请请求，另一方面向LDAP服务器和安全服务器转发CA颁发的数字证书和证书撤销列表（CRL）。</p>
<p>LDAP服务器：Lightweight Directory Access Protocol（轻量目录访问协议），提供目录浏览服务，负责将注册机构服务器RA传输过来的用户信息以及数字证书加入到服务器上。用户通过访问LDAP服务器就能够得到其他用户的数字证书。</p>
<p>CA服务器：整个证书机构的核心，负责证书的签发。CA首先 产生自身的私钥和公钥，然后生成数字证书，并且将数字正常传输给</p>
<p>安全服务器。CA还负责为安全服务器、RA服务器生成数字证书。</p>
<p>数据库服务器：CA中的核心部分，用于CA中数据（如密钥和用户信息等）、日志、统计信息的存储和管理。</p>
<p><img src="https://image.woodwhales.cn/049/images/40.png"></p>
<h4 id="证书的申请过程"><a href="#证书的申请过程" class="headerlink" title="证书的申请过程"></a>证书的申请过程</h4><p>1、用户申请：用户获取CA的数字证书（根证书），与安全服务器建立连接；生成自己的公钥和私钥，将公钥和自己的身份信息提交给安全服务器，安全服务器将用户的申请信息传送给RA服务器。</p>
<blockquote>
<p>生成数字证书代码示例：<a href="https://www.example-code.com/java/csr_generate_key_and_signing_request.asp">https://www.example-code.com/java/csr_generate_key_and_signing_request.asp</a></p>
</blockquote>
<p>2、RA审核：RA收到用户的申请，用户向RA证明自己的身份，RA进行核对。如果RA同意用户申请证书的请求，则对证书申请信息做数字签名；否则拒绝用户的申请。</p>
<p>3、CA发行证书：RA将用户申请和RA签名传输给CA，CA对RA数字签名做认证，如果验证通过，则同意用户请求，颁发证书，然后将证书输出。如果验证不通过，则拒绝证书申请。</p>
<p>4、RA转发证书：RA从CA得到新的证书，首先将证书输出到LDAP服务器以提供目录浏览，再通知用户证书发行成功，告知证书序列号，到指定的网址去下载证书。</p>
<p>5、用户证书获取：用户使用证书序列号去指定网址下载自己的数字证书，只有持有与申请时提交的公钥配对的私钥才能下载成功。</p>
<h4 id="证书的吊销过程"><a href="#证书的吊销过程" class="headerlink" title="证书的吊销过程"></a>证书的吊销过程</h4><p>1、用户申请：用户向RA发送一封签名加密邮件，申请撤销证书。RA审核：注册机构同意证书撤销，并对申请签名。</p>
<p>2、CA更新CRL：CA验证证书撤销请求的RA签名，如果正确，则同意申请，并更新CRL，并输出。</p>
<p>3、RA转发CRL：注册中心收到CRL，以多种方式将CRL公布（包括LDAP服务器）。</p>
<p>4、用户告知：用户访问LDAP服务器，下载或浏览CRL。</p>
<blockquote>
<p>CSR，certificate signing request，证书签名申请</p>
<p>CRL，certificate revocation list，证书吊销列表</p>
<p>OCSP，online certificate status protocol，在线证书状态协议</p>
</blockquote>
<p>认证中心CA负责维护和发布证书废除列表CRL（certificate revocation lists，又称为证书黑名单或证书吊销列表）。当一个证书，特别是其中的公钥因为其他原因无效时（不是因为到期），CRL提供了一种通知用户和其他应用的中心管理方式。CA系统生成CRL以后，放到LDAP服务器中或Web服务器的合适位置，供用户查询或下载。</p>
<p><img src="https://image.woodwhales.cn/049/images/41.png"></p>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。</p>
<blockquote>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</blockquote>
<p>SSL/TLS协议是为了解决这三大风险而设计的，希望达到：</p>
<blockquote>
<p>（1） 所有信息都是<strong>加密传播</strong>，第三方无法窃听。</p>
<p>（2） 具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现。</p>
<p>（3） 配备<strong>身份证书</strong>，防止身份被冒充。</p>
</blockquote>
<p>互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。</p>
<h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>SSL：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。SSL协议可分为两层： </p>
<p>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</p>
<p>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。</p>
<p>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<p><img src="https://image.woodwhales.cn/049/images/42.png"></p>
<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<h4 id="SSL-TLS通信流程"><a href="#SSL-TLS通信流程" class="headerlink" title="SSL/TLS通信流程"></a>SSL/TLS通信流程</h4><p>整个SSL/TLS握手阶段一共有4次通信：</p>
<p><img src="https://image.woodwhales.cn/049/images/43.png"></p>
<p><strong>1、客户端发出请求（ClientHello）</strong></p>
<p>客户端先向服务器发出加密通信的请求，并向服务器提供以下信息：</p>
<p>支持的协议版本，如TLS 1.0</p>
<p>一个客户端生成的随机数，稍后用于生成对话密钥</p>
<p>支持的加密方法，如RSA公钥加密支持的压缩方法</p>
<p><strong>2、服务器回应（ServerHello）</strong><br>确认加密通信协议版本。如果浏览器与服务器支持的版本不一致，则服务器关闭加密通信</p>
<p>一个服务器生成的随机数，稍后用于生成对话密钥</p>
<p>确认加密方法，比如RSA公钥加密。</p>
<p>服务器证书</p>
<blockquote>
<p>此处，如果服务器需要确认客户端的身份，如金融机构需要客户提供USB密钥（U盾），就会向客户端请求证书。</p>
</blockquote>
<p><strong>3、客户端回应</strong></p>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书没有问题，客户端就会从证书中取出服务器的公钥。</p>
<p>一个随机数，稍后用于生成对话密钥，并且只用服务器的公钥加密，防止被窃听。</p>
<p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</p>
<p>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验</p>
<p>如果前一步要求了客户端证书，则会发送证书及相关信息。</p>
<p><strong>4、服务器回应</strong></p>
<p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送</p>
<p>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验</p>
<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入HTTPS加密通信，后续完全是使用普通的HTTP协议，只不过用“会话密钥”加密内容。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>对称密码</strong></p>
<p>主要是为了确保消息的机密性。目前主要使用的是 AES ，它的算法为Rrijndael算法；</p>
<p>除了 AES 还有DES、三重 DES，它们是差分分析和线性分析。</p>
<p><strong>公钥密码</strong></p>
<p>是一种不同的密钥进行加密和解密的技术，也是用于确保消息的机密性（主要是密钥分配问题）。</p>
<p>使用最为广泛的一种公钥密码算法是 RSA，除此之外还有 ELGamal 和 Rabin 等算法，以及与其相关 Diffie-Hellman 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。</p>
<p>公钥密码和对称密码一般都组成混合密码系统来使用的。</p>
<p><strong>单向散列函数</strong></p>
<p>是一种将长消息转换为短散列值的技术，用于确保消息的完整性。</p>
<p>包括的算法有SHA-1、SHA-2（SHA-256、SHA-384和SHA-512）和 SHA-3，除了SHA系列算法，还有MD4、MD5和 ROIPED-160 算法。</p>
<p>单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用</p>
<p><strong>消息认证码</strong></p>
<p>是一种能识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。</p>
<p>该技术是利用了单向散列函数的HMAC，但是无法对第三方进行认证，也无法防止否认。</p>
<p><strong>数字签名</strong></p>
<p>是一种能够对第三方进行消息认证，并能够防止通信对象做出否认的技术。</p>
<p>数字签名的算法有RSA、ElGamal、DSA、椭圆曲线 DSA（ECDSA）、爱德华兹曲线DSA（EDDSA）等。</p>
<p><strong>伪随机数生成器</strong></p>
<p>是一种能够生成具备不可预测性的比特序列的技术；由密码和单向散列函数构成的；伪随机数生成器用于生成密钥、初始化向量和 nonce 等。</p>
<p><img src="https://image.woodwhales.cn/049/images/44.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p>图解密码技术(第3版) ([日]结城浩)</p>
<p>HTTPS权威指南 在服务器和Web应用上部署SSL TLS和PKI</p>
<p>深入浅出HTTPS：从原理到实战</p>
<p>数学之美（第17章　由电视剧《暗算》所想到的——谈谈密码学的数学原理）</p>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>《图解密码技术》第三章（对称密码）学习笔记：<a href="https://muzibing.github.io/2019/06/16/2019.06.16%EF%BC%8869%EF%BC%89/">https://muzibing.github.io/2019/06/16/2019.06.16%EF%BC%8869%EF%BC%89/</a></p>
<p>RSA算法原理（二）- 阮一峰的网络日志：<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html</a></p>
<p>RSA算法详解：<a href="https://blog.damonare.cn/2017/12/31/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/">https://blog.damonare.cn/2017/12/31/RSA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</a></p>
<p>一文搞懂 RSA 算法：<a href="https://zhuanlan.zhihu.com/p/44185847">https://zhuanlan.zhihu.com/p/44185847</a></p>
<p>PKI/CA工作原理及架构：<a href="https://www.jianshu.com/p/c65fa3af1c01">https://www.jianshu.com/p/c65fa3af1c01</a></p>
<p>HTTPS协议详解(一)：HTTPS基础知识：<a href="https://blog.csdn.net/hherima/article/details/52469267">https://blog.csdn.net/hherima/article/details/52469267</a></p>
<p>5分钟让你知道什么是PKI：<a href="https://www.cnblogs.com/jerain6312/p/8572841.html">https://www.cnblogs.com/jerain6312/p/8572841.html</a></p>
<p>PKI系统深入介绍：<a href="https://blog.csdn.net/liuhuiyi/article/details/7776825">https://blog.csdn.net/liuhuiyi/article/details/7776825</a></p>
<p>RSA(五) PKI (Public Key Infrastructure) 公钥基础设施：<a href="https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/">https://www.shangyang.me/2017/05/25/encrypt-rsa-pki/</a></p>
<p>HTTP与HTTPS的区别：<a href="http://www.mahaixiang.cn/internet/1233.html">http://www.mahaixiang.cn/internet/1233.html</a></p>
<p>网络7层协议，4层，5层？理清容易混淆的几个概念：<a href="https://blog.csdn.net/cc1949/article/details/79063439">https://blog.csdn.net/cc1949/article/details/79063439</a></p>
<p>SSL/TLS协议详解(下)——TLS握手协议：<a href="https://xz.aliyun.com/t/2531">https://xz.aliyun.com/t/2531</a></p>
<p>SSL/TLS协议运行机制的概述 -阮一峰的网络日志：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>Bouncycastle API文档：<a href="https://www.bouncycastle.org/documentation.html">https://www.bouncycastle.org/documentation.html</a></p>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://javadoc.scijava.org/">https://javadoc.scijava.org/</a></p>
<p><a href="https://codebeautify.org/">https://codebeautify.org/</a></p>
<p><a href="https://examples.javacodegeeks.com/">https://examples.javacodegeeks.com/</a></p>
<p><a href="https://www.owasp.org/index.php/Main_Page">https://www.owasp.org/index.php/Main_Page</a></p>
<p><a href="http://www.javased.com/">http://www.javased.com/</a></p>
<p><a href="https://www.bouncycastle.org/documentation.html">https://www.bouncycastle.org/documentation.html</a></p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 1.8 新特性</title>
    <url>/2019/11/03/050/</url>
    <content><![CDATA[<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Lambda 是一个 匿名函数，我们可以把 Lambda 表达式理解为是 一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<h4 id="从匿名类到-Lambda-的转换示例1"><a href="#从匿名类到-Lambda-的转换示例1" class="headerlink" title="从匿名类到 Lambda 的转换示例1"></a>从匿名类到 Lambda 的转换示例1</h4><p>在多线程开发中需要手动 new 一个匿名的实现了 Runnable 接口的类，并执行 start() 方法启动一个新的线程，</p>
<blockquote>
<p>注意：下面代码只是方法调用，并不是启动新的线程。仅用 Runnable 接口示例如果使用 Lambda 表达式该如何编写代码。</p>
</blockquote>
<p>示例一：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"woodwhales.github.io"</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    r1.run();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 Lambda 表达式会让代码显得更简洁，其程序运行的效果还是一样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">"woodwhales.github.io"</span>);</span><br><span class="line">    r2.run();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="从匿名类到-Lambda-的转换示例2"><a href="#从匿名类到-Lambda-的转换示例2" class="headerlink" title="从匿名类到 Lambda 的转换示例2"></a>从匿名类到 Lambda 的转换示例2</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> {</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Lambda 表达式简化：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//Lambda表达式的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更为简洁的写法：方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> com3.compare(<span class="number">32</span>,<span class="number">21</span>);</span><br><span class="line">    System.out.println(compare3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和操作符。这个操作符为<code>-&gt;</code> ， 该操作符被称为 Lambda 操作符或 箭 头操作符。它将 Lambda 分为两个部分：</p>
<p>左侧：指定了 Lambda 表达式需要的 参 数 列表</p>
<p>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能。</p>
<h4 id="语法格式一"><a href="#语法格式一" class="headerlink" title="语法格式一"></a>语法格式一</h4><p>无参，无返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; {System.out.println(<span class="string">"woodwhales.github.io"</span>);};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="语法格式二"><a href="#语法格式二" class="headerlink" title="语法格式二"></a>语法格式二</h4><p>Lambda 需要一个参数，但是没有返回值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"woodwhales.github.io"</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="语法格式三"><a href="#语法格式三" class="headerlink" title="语法格式三"></a>语法格式三</h4><p>数据类型可以省略 ，因为可由编译器推断得出，称为<code>类型推断</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer1 = (String str) -&gt; {</span><br><span class="line">    System.out.println(str);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="语法格式四"><a href="#语法格式四" class="headerlink" title="语法格式四"></a>语法格式四</h4><p>Lambda 若只需要一个参数时，参数的小括号可以省略</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer3 = str -&gt; {</span><br><span class="line">	System.out.println(str);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="语法格式五"><a href="#语法格式五" class="headerlink" title="语法格式五"></a>语法格式五</h4><p>Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator1 = (x, y) -&gt; {</span><br><span class="line">    System.out.println(<span class="string">"实现函数式接口"</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="语法格式六"><a href="#语法格式六" class="headerlink" title="语法格式六"></a>语法格式六</h4><p>当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator2 = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的<code>类型推断</code>。</p>
<p><img src="https://image.woodwhales.cn/050/images/01.png"></p>
<h2 id="函数式接口（Functional）"><a href="#函数式接口（Functional）" class="headerlink" title="函数式接口（Functional）"></a>函数式接口（Functional）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>如果一个接口中只声明了一个抽象方法，则此接口就称为函数式接口。</p>
<p>Lambda 表达式可以创建该接口的对象。</p>
<p>我们可以在一个接口上使用<code>@FunctionalInterface</code>注解，这样做可以检查它是否是一个函数式接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>
<blockquote>
<p> 在 <a href="https://docs.oracle.com/javase/8/docs/api/">JDK 1.8 API</a> 文档上会显示带有<code>@FunctionalInterface</code>注解：</p>
<p><img src="https://image.woodwhales.cn/050/images/02.png"></p>
<p><img src="https://image.woodwhales.cn/050/images/03.png"></p>
</blockquote>
<h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><p>我们可以在一个接口上使用<code>@FunctionalInterface</code> 注解，自己创建一个接口，并仅仅提供一个方法，使用<code>@FunctionalInterface</code>注解：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式接口注解，用来表示当前接口有且只有一个方法</span></span><br><span class="line"><span class="comment"> * 自定义函数式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：使用了函数式接口注解这个接口，这个接口有超过一个抽象方法，会报编译异常。</p>
<p>使用 Lambda 表达式创建上述自定义的接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(MyFunctionalInterface myFunctionalInterface)</span> {</span><br><span class="line">    myFunctionalInterface.sayHello();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 传统写法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    say(<span class="keyword">new</span> <span class="title class_">MyFunctionalInterface</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用say方法,方法的参数是一个函数式接口,所以可以Lambda表达式</span></span><br><span class="line">    say(() -&gt; {</span><br><span class="line">        System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化Lambda表达式：当实现类中只有一行代码的时候，可以简写</span></span><br><span class="line">    say(() -&gt; System.out.println(<span class="string">"使用Lambda表达式重写接口中的抽象方法"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口名及描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>BiConsumer</strong>代表了一个接受两个输入参数的操作，并且不返回任何结果。</td>
</tr>
<tr>
<td>2</td>
<td><strong>BiFunction</strong>代表了一个接受两个输入参数的方法，并且返回一个结果。</td>
</tr>
<tr>
<td>3</td>
<td><strong>BinaryOperator</strong>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果。</td>
</tr>
<tr>
<td>4</td>
<td><strong>BiPredicate</strong>代表了一个两个参数的boolean值方法。</td>
</tr>
<tr>
<td>5</td>
<td><strong>BooleanSupplier</strong>代表了boolean值结果的提供方。</td>
</tr>
<tr>
<td>6</td>
<td><strong>Consumer</strong>代表了接受一个输入参数并且无返回的操作。</td>
</tr>
<tr>
<td>7</td>
<td><strong>DoubleBinaryOperator</strong>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td>
</tr>
<tr>
<td>8</td>
<td><strong>DoubleConsumer</strong>代表一个接受double值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td>9</td>
<td><strong>DoubleFunction</strong>代表接受一个double值参数的方法，并且返回结果。</td>
</tr>
<tr>
<td>10</td>
<td><strong>DoublePredicate</strong>代表一个拥有double值参数的boolean值方法。</td>
</tr>
<tr>
<td>11</td>
<td><strong>DoubleSupplier</strong>代表一个double值结构的提供方。</td>
</tr>
<tr>
<td>12</td>
<td><strong>DoubleToIntFunction</strong>接受一个double类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>13</td>
<td><strong>DoubleToLongFunction</strong>接受一个double类型输入，返回一个long类型结果。</td>
</tr>
<tr>
<td>14</td>
<td><strong>DoubleUnaryOperator</strong>接受一个参数同为类型double,返回值类型也为double 。</td>
</tr>
<tr>
<td>15</td>
<td><strong>Function</strong>接受一个输入参数，返回一个结果。</td>
</tr>
<tr>
<td>16</td>
<td><strong>IntBinaryOperator</strong>接受两个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>17</td>
<td><strong>IntConsumer</strong>接受一个int类型的输入参数，无返回值 。</td>
</tr>
<tr>
<td>18</td>
<td><strong>IntFunction</strong>接受一个int类型输入参数，返回一个结果 。</td>
</tr>
<tr>
<td>19</td>
<td><strong>IntPredicate</strong>：接受一个int输入参数，返回一个布尔值的结果。</td>
</tr>
<tr>
<td>20</td>
<td><strong>IntSupplier</strong>无参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>21</td>
<td><strong>IntToDoubleFunction</strong>接受一个int类型输入，返回一个double类型结果 。</td>
</tr>
<tr>
<td>22</td>
<td><strong>IntToLongFunction</strong>接受一个int类型输入，返回一个long类型结果。</td>
</tr>
<tr>
<td>23</td>
<td><strong>IntUnaryOperator</strong>接受一个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>24</td>
<td><strong>LongBinaryOperator</strong>接受两个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>25</td>
<td><strong>LongConsumer</strong>接受一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>26</td>
<td><strong>LongFunction</strong>接受一个long类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>27</td>
<td><strong>LongPredicate</strong>R接受一个long输入参数，返回一个布尔值类型结果。</td>
</tr>
<tr>
<td>28</td>
<td><strong>LongSupplier</strong>无参数，返回一个结果long类型的值。</td>
</tr>
<tr>
<td>29</td>
<td><strong>LongToDoubleFunction</strong>接受一个long类型输入，返回一个double类型结果。</td>
</tr>
<tr>
<td>30</td>
<td><strong>LongToIntFunction</strong>接受一个long类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>31</td>
<td><strong>LongUnaryOperator</strong>接受一个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>32</td>
<td><strong>ObjDoubleConsumer</strong>接受一个object类型和一个double类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>33</td>
<td><strong>ObjIntConsumer</strong>接受一个object类型和一个int类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>34</td>
<td><strong>ObjLongConsumer</strong>接受一个object类型和一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>35</td>
<td><strong>Predicate</strong>接受一个输入参数，返回一个布尔值结果。</td>
</tr>
<tr>
<td>36</td>
<td><strong>Supplier</strong>无参数，返回一个结果。</td>
</tr>
<tr>
<td>37</td>
<td><strong>ToDoubleBiFunction</strong>接受两个输入参数，返回一个double类型结果。</td>
</tr>
<tr>
<td>38</td>
<td><strong>ToDoubleFunction</strong>接受一个输入参数，返回一个double类型结果。</td>
</tr>
<tr>
<td>39</td>
<td><strong>ToIntBiFunction</strong>接受两个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>40</td>
<td><strong>ToIntFunction</strong>接受一个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>41</td>
<td><strong>ToLongBiFunction</strong>接受两个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>42</td>
<td><strong>ToLongFunction</strong>接受一个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>43</td>
<td><strong>UnaryOperator</strong>接受一个参数为类型T,返回值类型也为T。</td>
</tr>
</tbody></table>
<p>对于 JDK1.8 中提供的这么多函数式接口，开发中常用的函数式接口有以下几个 Predicate，Consumer，Function，Supplier：</p>
<h3 id="内置四大核心函数式接口"><a href="#内置四大核心函数式接口" class="headerlink" title="内置四大核心函数式接口"></a>内置四大核心函数式接口</h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<t> 消费型接口</t></td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td>
</tr>
<tr>
<td>Supplier<t> 供给型接口</t></td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法：<code>T get()</code></td>
</tr>
<tr>
<td>Function&lt;T, R&gt; 函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：<code>R apply(T t)</code></td>
</tr>
<tr>
<td>Predicate<t>断定型接口</t></td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回 boolean 值。包含方法：<code>boolean test(T t)</code></td>
</tr>
</tbody></table>
<h4 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h4><blockquote>
<p>Consumer<t> void accept(T t)</t></p>
</blockquote>
<p>java.util.function.Consumer<t>接口定义了一个名叫 accept 的抽象方法，它接受泛型T，没有返回值(void)。如果需要访问类型 T 的对象，并对其执行某些操作，可以使用这个接口，通常称为消费型接口。 </t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPrice</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; consumer)</span>{</span><br><span class="line">    consumer.accept(money);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    showPrice(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double money)</span> {</span><br><span class="line">            System.out.println(<span class="string">"今天白菜的价格为："</span> + money);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    showPrice(<span class="number">400</span>, money -&gt; System.out.println(<span class="string">"明天黄金的价格为："</span> + money));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h4><blockquote>
<p>Supplier<t> T get()</t></p>
</blockquote>
<p>java.util.function.Supplier<t>接口定义了一个get的抽象方法，它没有参数，返回一个泛型T的对象，这类似于一个工厂方法，通常称为供给型接口。 </t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">readFile</span><span class="params">(String fileName)</span> {</span><br><span class="line">    Supplier&lt;Properties&gt; supplier = () -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> TestCase04.class.getClassLoader().getResourceAsStream(fileName);</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            prop.load(is);</span><br><span class="line">            <span class="keyword">return</span> prop;</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> supplier.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h4><blockquote>
<p>Function&lt;T,R&gt; R apply(T t)</p>
</blockquote>
<p>java.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型T的对象，并返回一个泛型R的对象。如果需要定义一个Lambda，将输入的信息映射到输出，可以使用这个接口(比如提取苹果的重量，或把字符串映射为它的长度),通常称为功能型接口。 </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 实现用户密码 Base64加密操作</span></span><br><span class="line">Function&lt;String,String&gt; encoded = (password)-&gt; Base64.getEncoder().encodeToString(password.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出加密后的字符串</span></span><br><span class="line">System.out.println(encoded.apply(<span class="string">"123456"</span>));</span><br></pre></td></tr></tbody></table></figure>

<h4 id="断定型接口"><a href="#断定型接口" class="headerlink" title="断定型接口"></a>断定型接口</h4><blockquote>
<p>Predicate<t> boolean test(T t)</t></p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span>{</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : list){</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(s)){</span><br><span class="line">            filterList.add(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filterList;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>{</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"北京"</span>,<span class="string">"南京"</span>,<span class="string">"天津"</span>,<span class="string">"东京"</span>,<span class="string">"普京"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; filterStrs1 = filterString(list, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> {</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">"京"</span>);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    System.out.println(filterStrs1);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; filterStrs2 = filterString(list,s -&gt; s.contains(<span class="string">"京"</span>));</span><br><span class="line">    System.out.println(filterStrs2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="其他函数式接口"><a href="#其他函数式接口" class="headerlink" title="其他函数式接口"></a>其他函数式接口</h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>T, U</td>
<td>R</td>
<td>对类型为 T, U 参数应用操作，返回 R 类型的结果。<br>包含方法为：<code>R apply(T t, U u)</code></td>
</tr>
<tr>
<td>UnaryOperator<t>(Function)</t></td>
<td>T</td>
<td>T</td>
<td>对类型为T的对象进行一元运算，并返回T类型的结果。<br>包含方法为：<code>T apply(T t)</code></td>
</tr>
<tr>
<td>BinaryOperator<t>(BiFunction 子接口)</t></td>
<td>T, T</td>
<td>T</td>
<td>对类型为T的对象进行二元运算，并返回T类型的结果。<br>包含方法为： <code>T apply(T t1, T t2)</code></td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>T, U</td>
<td>void</td>
<td>对类型为T, U 参数应用操作。<br>包含方法为：<code> void accept(T t, U u)</code></td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T, U</td>
<td>boolean</td>
<td>包含方法为： <code>boolean test(T t, U u)</code></td>
</tr>
<tr>
<td>ToIntFunction<t><br>ToLongFunction<t><br>ToDoubleFunction<t></t></t></t></td>
<td>T</td>
<td>int<br>long<br>double</td>
<td>分别计算int、long、double值的函数</td>
</tr>
<tr>
<td>IntFunction<r><br>LongFunction<r><br>DoubleFunction<r></r></r></r></td>
<td>int<br>long<br>double</td>
<td>R</td>
<td>参数分别为int、long、double 类型的函数</td>
</tr>
</tbody></table>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用。方法引用，本质上就是 Lambda 表达式，而 Lambda 表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。 </p>
<blockquote>
<p>方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是 Lambda 表达式的一个语法糖。</p>
</blockquote>
<p>使用格式：  <code>类(或对象)::方法名</code></p>
<p>具体分为如下的三种情况：</p>
<ul>
<li><p>情况1：对象 :: 实例方法</p>
</li>
<li><p>情况2：类 :: 静态方法</p>
</li>
<li><p>情况3：类 :: 非静态方法</p>
</li>
</ul>
<p>情况1 和情况3 的方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同。</p>
<h4 id="情况1、对象-非静态方法"><a href="#情况1、对象-非静态方法" class="headerlink" title="情况1、对象 :: 非静态方法"></a>情况1、对象 :: 非静态方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Consumer 中的 void accept(T t)</span></span><br><span class="line"><span class="comment">// PrintStream 中的 void println(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> {</span><br><span class="line">    Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">    con1.accept(<span class="string">"北京"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class="line">    con2.accept(<span class="string">"beijing"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supplier 中的 T get()</span></span><br><span class="line"><span class="comment">// Employee 中的 String getName()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Person</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">"Tom"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="情况2、类-静态方法"><a href="#情况2、类-静态方法" class="headerlink" title="情况2、类 :: 静态方法"></a>情况2、类 :: 静态方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator 中的 int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">// Integer 中的 int compare(T t1,T t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test9</span><span class="params">()</span> {</span><br><span class="line">    Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">    System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">    System.out.println(com2.compare(<span class="number">12</span>,<span class="number">3</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment">// Math 中的 Long round(Double d)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> {</span><br><span class="line">    Function&lt;Double,Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> {</span><br><span class="line">            <span class="keyword">return</span> Math.round(d);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">    System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">    System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="情况3、类-实例方法"><a href="#情况3、类-实例方法" class="headerlink" title="情况3、类 :: 实例方法"></a>情况3、类 :: 实例方法</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator 中的 int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String 中的 int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span> {</span><br><span class="line">    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">    System.out.println(com1.compare(<span class="string">"abc"</span>,<span class="string">"abd"</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">    System.out.println(com2.compare(<span class="string">"abd"</span>,<span class="string">"abm"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BiPredicate 中的 boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">// String 中的 boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span> {</span><br><span class="line">    BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">    System.out.println(pre1.test(<span class="string">"abc"</span>,<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line">    </span><br><span class="line">    BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">    System.out.println(pre2.test(<span class="string">"abc"</span>,<span class="string">"abd"</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee 中的 String getName()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test13</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">"Jerry"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">    System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">    System.out.println(func2.apply(employee));</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用与函数式接口相结合，自动与函数式接口中方法兼容。格式为：<code>ClassName::new</code></p>
<p>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致，且方法的返回值即为构造器对应类的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Supplier 中的 T get()</span></span><br><span class="line"><span class="comment">// Employee 的空参构造器：Employee()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test14</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;  sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 中的 R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test15</span><span class="params">()</span>{</span><br><span class="line">    Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(employee1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BiFunction 中的 R apply(T t,U u)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test16</span><span class="params">()</span>{</span><br><span class="line">    BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">    System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">"Tom"</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;Integer,String,Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">"King"</span>));</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>数组引用和构造器引用类似，格式为：<code>type[]::new</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Function 中的 R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test17</span><span class="params">()</span>{</span><br><span class="line">    Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"*******************"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,String[]&gt; func2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><p>官方文档： <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html</a> </p>
<p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</p>
<p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到 Java 中。这是目前为止对 Java 类库最好的补充，因为 Stream API 可以极大提供 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p> Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<blockquote>
<p>实际开发中，项目中多数数据源都来自于 Mysql，Oracle 等。但现在数据源可以更多了，有 MongDB，Redis 等，而这些 NoSQL 的数据就需要 Java 层面去处理。</p>
<p>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算。</p>
</blockquote>
<h3 id="Stream-到底是什么"><a href="#Stream-到底是什么" class="headerlink" title="Stream 到底是什么"></a>Stream 到底是什么</h3><p>Stream 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新 Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
<h3 id="Stream-的操作三个步骤"><a href="#Stream-的操作三个步骤" class="headerlink" title="Stream 的操作三个步骤"></a>Stream 的操作三个步骤</h3><p>Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<h4 id="步骤1：创建-Stream"><a href="#步骤1：创建-Stream" class="headerlink" title="步骤1：创建 Stream"></a>步骤1：创建 Stream</h4><p>一个数据源（如：集合、数组），获取一个流</p>
<h4 id="步骤2：中间操作"><a href="#步骤2：中间操作" class="headerlink" title="步骤2：中间操作"></a>步骤2：中间操作</h4><p>一个中间操作链，对数据源的数据进行处理</p>
<h4 id="步骤3：终止操作（终端操作）"><a href="#步骤3：终止操作（终端操作）" class="headerlink" title="步骤3：终止操作（终端操作）"></a>步骤3：终止操作（终端操作）</h4><p>一旦执行终止操作，就执行中间操作链，并产生结果。终止操作结束之后，当前被终止的流中数据不会再被使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></tbody></table></figure>

<p>中间操作总是会<strong>惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新 stream。</p>
<p>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以 pipeline 的方式执行，这样可以减少迭代次数。计算完成之后 stream 就会失效。</p>
<p>虽然大部分情况下 stream 是容器调用<code>Collection.stream()</code>方法得到的，但 stream 和 collections 有以下不同：</p>
<ul>
<li><p>无存储。stream 不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java 容器或 I/O channel等。</p>
</li>
<li><p>为函数式编程而生。对 stream 的任何修改都不会修改背后的数据源，比如对 stream 执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新 stream。</p>
</li>
<li><p>惰式执行。stream 上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</p>
</li>
<li><p>可消费性。stream 只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</p>
</li>
</ul>
<h3 id="流的使用及分类"><a href="#流的使用及分类" class="headerlink" title="流的使用及分类"></a>流的使用及分类</h3><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>：中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行（laziness）和短路（short-circuiting）。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream 提供了内部迭代的方式， 通过访问者模式（Visitor）实现。</li>
</ul>
<h4 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h4><p><img src="https://image.woodwhales.cn/050/images/04.png"></p>
<h4 id="流操作的分类"><a href="#流操作的分类" class="headerlink" title="流操作的分类"></a>流操作的分类</h4><p><img src="https://image.woodwhales.cn/050/images/05.png"></p>
<p>流操作分类为：</p>
<ul>
<li><p>中间操作（Intermediate）</p>
<p>无状态操作：filter / map / peek 等，指元素的处理不受之前元素的影响。</p>
<p>有状态操作：distinct / sorted / limit 等，指该操作只有拿到所有元素之后才能继续下去。</p>
</li>
<li><p>终端操作（Terminal）</p>
<p>非短路操作：forEach / collect / count 等，指遇到某些符合条件的元素就可以得到最终结果。</p>
<p>短路操作：anyMatch / findFirst / findAny 等，指必须处理所有元素才能得到最终结果。</p>
</li>
</ul>
<h3 id="Stream-的创建"><a href="#Stream-的创建" class="headerlink" title="Stream 的创建"></a>Stream 的创建</h3><h4 id="方式1：通过集合"><a href="#方式1：通过集合" class="headerlink" title="方式1：通过集合"></a>方式1：通过集合</h4><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<p>顺序流：default Stream<e> stream()<br>并行流：default Stream<e> parallelStream()</e></e></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test18</span><span class="params">()</span>{</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">    Stream&lt;Employee&gt; parallelStream = employees.parallelStream();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方式2：通过数组"><a href="#方式2：通过数组" class="headerlink" title="方式2：通过数组"></a>方式2：通过数组</h4><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<p> static <t> Stream<t> stream(T[] array)</t></t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test19</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">"Tom"</span>);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>,<span class="string">"Jerry"</span>);</span><br><span class="line">    Employee[] arr1 = <span class="keyword">new</span> <span class="title class_">Employee</span>[]{e1,e2};</span><br><span class="line">    </span><br><span class="line">    Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方式3：通过Stream-的of"><a href="#方式3：通过Stream-的of" class="headerlink" title="方式3：通过Stream 的of()"></a>方式3：通过Stream 的of()</h4><p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数：</p>
<p>public static<t> Stream<t> of(T… values)</t></t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test20</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方式4：创建无限流"><a href="#方式4：创建无限流" class="headerlink" title="方式4：创建无限流"></a>方式4：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate()，创建无限流：</p>
<p>迭代：public static<t> Stream<t> iterate(final T seed, final UnaryOperator<t> f)</t></t></t></p>
<p>生成：public static<t> Stream<t> generate(Supplier<t> s)</t></t></t></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test21</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">    <span class="comment">// 遍历前10个偶数，如果不用 limit() 限制，那么会无限计算下去，直到栈溢出</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成</span></span><br><span class="line">    <span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">    <span class="comment">// 生成 10 个随机数，如果不用 limit() 限制，那么会无限生成随机数，直到栈溢出</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Stream-的中间操作"><a href="#Stream-的中间操作" class="headerlink" title="Stream 的中间操作"></a>Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为<code>惰性求值</code>（中间操作只是对操作进行了记录，只有结束操作才会触发实际的计算）。</p>
<h4 id="类型1：筛选与切片"><a href="#类型1：筛选与切片" class="headerlink" title="类型1：筛选与切片"></a>类型1：筛选与切片</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>过滤，接收 Lambda ，并从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span>{</span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// filter(Predicate p)</span></span><br><span class="line">    <span class="comment">// 实战：查询员工表中薪资大于5000的员工信息</span></span><br><span class="line">    stream.filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// limit(n)</span></span><br><span class="line">    <span class="comment">// 实战：使其元素不超过给定数量。</span></span><br><span class="line">    list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip(n)</span></span><br><span class="line">    <span class="comment">// 实战：跳过前三个员工，遍历之后的</span></span><br><span class="line">    list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// distinct()</span></span><br><span class="line">    <span class="comment">// 实战：去重</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1020</span>,<span class="string">"Tom"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1020</span>,<span class="string">"Tom"</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1020</span>,<span class="string">"Tom"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1020</span>,<span class="string">"Tom"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1020</span>,<span class="string">"Tom"</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="类型2：映射"><a href="#类型2：映射" class="headerlink" title="类型2：映射"></a>类型2：映射</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test23</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">// map(Function f)</span></span><br><span class="line">    <span class="comment">// 实战：将数组中的元素都转换成大写</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map + filter</span></span><br><span class="line">    <span class="comment">//  实战：获取员工姓名长度大于3的员工的姓名</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;String&gt; namesStream = employees.stream().map(Employee::getName);</span><br><span class="line">    namesStream.filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// map 每个集合都是一个流</span></span><br><span class="line">    List&lt;Integer&gt; aList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    List&lt;Integer&gt; bList = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>);	</span><br><span class="line">    Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(aList, bList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap 所有集合合并成一个流</span></span><br><span class="line">    List&lt;Integer&gt; cList = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    List&lt;Integer&gt; dList = Arrays.asList(<span class="number">9</span>, <span class="number">10</span>);		</span><br><span class="line">    Stream&lt;Integer&gt; integerStream = Stream.of(cList, dList).flatMap(integers -&gt; integers.stream());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="类型3：排序"><a href="#类型3：排序" class="headerlink" title="类型3：排序"></a>类型3：排序</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test24</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//  sorted() 自然排序</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">87</span>, <span class="number">0</span>, -<span class="number">98</span>, <span class="number">7</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line">    <span class="comment">// List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span></span><br><span class="line">    <span class="comment">//  employees.stream().sorted().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sorted(Comparator com) 定制排序</span></span><br><span class="line"></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    employees.stream().sorted( (e1,e2) -&gt; {</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ageValue</span> <span class="operator">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">        <span class="keyword">if</span>(ageValue != <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> ageValue;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }).forEach(System.out::println);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Stream-的终止操作"><a href="#Stream-的终止操作" class="headerlink" title="Stream 的终止操作"></a>Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p>
<p>注意：流进行了终止操作后，不能再次使用。</p>
<h4 id="类型1：匹配与查找"><a href="#类型1：匹配与查找" class="headerlink" title="类型1：匹配与查找"></a>类型1：匹配与查找</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，stream API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test25</span><span class="params">()</span>{</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allMatch(Predicate p) 检查是否匹配所有元素。</span></span><br><span class="line">    <span class="comment">// 实战：是否所有的员工的年龄都大于18</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">    System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anyMatch(Predicate p) 检查是否至少匹配一个元素。</span></span><br><span class="line">    <span class="comment">// 实战：是否存在员工的工资大于 10000</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">    System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noneMatch(Predicate p) 检查是否没有匹配的元素。</span></span><br><span class="line">    <span class="comment">// 实战：是否存在员工姓“K”</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">"K"</span>));</span><br><span class="line">    System.out.println(noneMatch);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// findFirst 返回第一个元素</span></span><br><span class="line">    <span class="comment">// 实战：找到第一个元素</span></span><br><span class="line">    Optional&lt;Employee&gt; employee = employees.stream().findFirst();</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// findAny 返回当前流中的任意元素</span></span><br><span class="line">    <span class="comment">// 找任意一个元素</span></span><br><span class="line">    Optional&lt;Employee&gt; employee1 = employees.parallelStream().findAny();</span><br><span class="line">    System.out.println(employee1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test26</span><span class="params">()</span>{</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count 返回流中元素的总个数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max(Comparator c) 返回流中最大值</span></span><br><span class="line">    <span class="comment">// 实战：返回最高的工资</span></span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">    Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class="line">    System.out.println(maxSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// min(Comparator c) 返回流中最小值</span></span><br><span class="line">    <span class="comment">// 实战：返回最低工资的员工</span></span><br><span class="line">    Optional&lt;Employee&gt; employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// forEach(Consumer c)——内部迭代</span></span><br><span class="line">    employees.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="类型2：规约"><a href="#类型2：规约" class="headerlink" title="类型2：规约"></a>类型2：规约</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<t></t></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test27</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)</span></span><br><span class="line">    <span class="comment">// 实战：求所有元素的总和</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce(BinaryOperator)</span></span><br><span class="line">    <span class="comment">// 实战：计算公司所有员工工资的总和</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(Employee::getSalary);</span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">    Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class="line">    System.out.println(sumMoney.get());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="类型3：收集"><a href="#类型3：收集" class="headerlink" title="类型3：收集"></a>类型3：收集</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test28</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">// collect(Collector c)</span></span><br><span class="line">    <span class="comment">// 实战：查找工资大于5000的员工，结果返回为一个List</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    employeeList.forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    System.out.println();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实战：查找工资大于5000的员工，结果返回为一个Set</span></span><br><span class="line">    Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    employeeSet.forEach(System.out::println);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html</a></p>
<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>toList</code></td>
<td><code>List</code></td>
<td>把流中所有项目收集到一个 List</td>
<td><code>List projects = projectStream.collect(toList());</code></td>
</tr>
<tr>
<td><code>toSet</code></td>
<td><code>Set</code></td>
<td>把流中所有项目收集到一个 Set，删除重复项</td>
<td><code>Set projects = projectStream.collect(toSet());</code></td>
</tr>
<tr>
<td><code>toCollection</code></td>
<td><code>Collection</code></td>
<td>把流中所有项目收集到给定的供应源创建的集合</td>
<td><code>Collection projects = projectStream.collect(toCollection(), ArrayList::new);</code></td>
</tr>
<tr>
<td><code>counting</code></td>
<td><code>Long</code></td>
<td>计算流中元素的个数</td>
<td><code>long howManyProjects = projectStream.collect(counting());</code></td>
</tr>
<tr>
<td><code>summingInt</code></td>
<td><code>Integer</code></td>
<td>对流中项目的一个整数属性求和</td>
<td><code>int totalStars = projectStream.collect(summingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>averagingInt</code></td>
<td><code>Double</code></td>
<td>计算流中项目 Integer 属性的平均值</td>
<td><code>double avgStars = projectStream.collect(averagingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>summarizingInt</code></td>
<td><code>IntSummaryStatistics</code></td>
<td>收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td>
<td><code>IntSummaryStatistics projectStatistics = projectStream.collect(summarizingInt(Project::getStars));</code></td>
</tr>
<tr>
<td><code>joining</code></td>
<td><code>String</code></td>
<td>连接对流中每个项目调用 toString 方法所生成的字符串</td>
<td><code>String shortProject = projectStream.map(Project::getName).collect(joining(", "));</code></td>
</tr>
<tr>
<td><code>maxBy</code></td>
<td><code>Optional</code></td>
<td>按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td><code>Optional fattest = projectStream.collect(maxBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td><code>minBy</code></td>
<td><code>Optional</code></td>
<td>按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td>
<td><code>Optional fattest = projectStream.collect(minBy(comparingInt(Project::getStars)));</code></td>
</tr>
<tr>
<td><code>reducing</code></td>
<td>归约操作产生的类型</td>
<td>从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值</td>
<td><code>int totalStars = projectStream.collect(reducing(0, Project::getStars, Integer::sum));</code></td>
</tr>
<tr>
<td><code>collectingAndThen</code></td>
<td>转换函数返回的类型</td>
<td>包含另一个收集器，对其结果应用转换函数</td>
<td><code>int howManyProjects = projectStream.collect(collectingAndThen(toList(), List::size));</code></td>
</tr>
<tr>
<td><code>groupingBy</code></td>
<td><code>Map&gt;</code></td>
<td>根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td>
<td><code>Map&gt; projectByLanguage = projectStream.collect(groupingBy(Project::getLanguage));</code></td>
</tr>
<tr>
<td><code>partitioningBy</code></td>
<td><code>Map&gt;</code></td>
<td>根据对流中每个项目应用断言的结果来对项目进行分区</td>
<td><code>Map&gt; vegetarianDishes = projectStream.collect(partitioningBy(Project::isVegetarian));</code></td>
</tr>
</tbody></table>
<p>Project 类：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Project</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编程语言</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String  language;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * star 数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer stars;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String  description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String  author;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fork数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer forks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Project&gt; <span class="title function_">buildData</span><span class="params">()</span>{</span><br><span class="line">        List&lt;Project&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        data.add(Project.builder()</span><br><span class="line">                 		.name(<span class="string">"Jack"</span>)</span><br><span class="line">                 		.language(<span class="string">"javascript"</span>)</span><br><span class="line">                 		.author(<span class="string">"AAA"</span>)</span><br><span class="line">                		.stars(<span class="number">2600</span>)</span><br><span class="line">                 		.forks(<span class="number">2300</span>)</span><br><span class="line">                 		.description(<span class="string">"Best beautiful java blog, worth a try"</span>)</span><br><span class="line">                 		.build());</span><br><span class="line"></span><br><span class="line">        data.add(Project.builder()</span><br><span class="line">                 		.name(<span class="string">"Vue.js"</span>)</span><br><span class="line">                 		.language(<span class="string">"js"</span>)</span><br><span class="line">                 		.author(<span class="string">"BBB"</span>)</span><br><span class="line">                		.stars(<span class="number">83000</span>)</span><br><span class="line">                 		.forks(<span class="number">10322</span>)</span><br><span class="line">                 		.description(<span class="string">"A progressive, incrementally-adoptable JavaScript framework for building UI on the web."</span>)</span><br><span class="line">                 		.build());</span><br><span class="line"></span><br><span class="line">        data.add(Project.builder()</span><br><span class="line">                 		.name(<span class="string">"Flask"</span>)</span><br><span class="line">                 		.language(<span class="string">"python"</span>)</span><br><span class="line">                 		.author(<span class="string">"CCC"</span>)</span><br><span class="line">               			.stars(<span class="number">10500</span>)</span><br><span class="line">                 		.forks(<span class="number">3000</span>)</span><br><span class="line">                 		.description(<span class="string">"The Python micro framework for building web applications"</span>)</span><br><span class="line">                 		.build());</span><br><span class="line"></span><br><span class="line">        data.add(Project.builder()</span><br><span class="line">                 		.name(<span class="string">"Elves"</span>)</span><br><span class="line">                 		.language(<span class="string">"java"</span>)</span><br><span class="line">                 		.author(<span class="string">"DDD"</span>)</span><br><span class="line">                		.stars(<span class="number">200</span>)</span><br><span class="line">                 		.forks(<span class="number">100</span>)</span><br><span class="line">                 		.description(<span class="string">"Spider"</span>)</span><br><span class="line">                 		.build());</span><br><span class="line">        data.add(Project.builder()</span><br><span class="line">                 		.name(<span class="string">"Tom"</span>)</span><br><span class="line">                 		.language(<span class="string">"java"</span>)</span><br><span class="line">                 		.author(<span class="string">"EEE"</span>)</span><br><span class="line">                		.stars(<span class="number">3500</span>)</span><br><span class="line">                 		.forks(<span class="number">2000</span>)</span><br><span class="line">                 		.description(<span class="string">"Lightning fast and elegant mvc framework for Java8"</span>)</span><br><span class="line">                 		.build());</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a></p>
<p>到目前为止，臭名昭著的空指针异常是导致 Java 应用程序失败的最常见原因。以前，为了解决空指针异常，Google 公司著名的 Guava 项目引入了 Optional 类，Guava 通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到 Google Guava 的启发，Optional 类已经成为 Java 8 类库的一部分。</p>
<p>Optional<t> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</t></p>
<p>Optional类的 Javadoc 描述如下：这是一个可以为 null 的容器对象。如果值存在则<code>isPresent()</code>方法会返回 true，调用<code>get()</code>方法会返回该对象。 </p>
<h3 id="创建Optional-类对象的方法"><a href="#创建Optional-类对象的方法" class="headerlink" title="创建Optional 类对象的方法"></a>创建Optional 类对象的方法</h3><p>Optional.of(T t) : 创建一个 Optional 实例，t必须非空</p>
<p>Optional.empty() : 创建一个空的 Optional 实例</p>
<p>Optional.ofNullable(T t) ：t可以为null</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test29</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    <span class="comment">// girl = null;</span></span><br><span class="line">    <span class="comment">// of(T t): t 必须为非空，否则抛出空指针异常</span></span><br><span class="line">    Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test30</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    girl = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 不会抛出空指针异常</span></span><br><span class="line">    Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="判断Optional-容器中是否包含对象"><a href="#判断Optional-容器中是否包含对象" class="headerlink" title="判断Optional 容器中是否包含对象"></a>判断Optional 容器中是否包含对象</h3><p>boolean isPresent() : 判断是否包含对象</p>
<p>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test31</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 元素不为null</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">listAIsPresent</span> <span class="operator">=</span> Optional.ofNullable(listA).isPresent(); <span class="comment">// true</span></span><br><span class="line">    System.out.println(listAIsPresent);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; listB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   </span><br><span class="line">    listB = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 元素为null</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">listBIsPresent</span> <span class="operator">=</span> Optional.ofNullable(listB).isPresent(); <span class="comment">// false</span></span><br><span class="line">    System.out.println(listBIsPresent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="获取-Optional-容器的对象"><a href="#获取-Optional-容器的对象" class="headerlink" title="获取 Optional 容器的对象"></a>获取 Optional 容器的对象</h3><p>T get(): 如果调用对象包含值，返回该值，否则抛异常</p>
<p>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象</p>
<p>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由 Supplier 接口实现提供的对象。</p>
<p>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test32</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">	List&lt;String&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    listA.add(<span class="string">"AA"</span>);</span><br><span class="line">    <span class="comment">// listA 不为null，执行了 say() 中代码，但是仅仅是执行了，没有返回结果</span></span><br><span class="line">    List&lt;String&gt; listAResult = Optional.ofNullable(listA).orElse(say());</span><br><span class="line">    System.out.println(listAResult);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; listB = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// listA 为null，执行了 say() 中代码返回了结果</span></span><br><span class="line">    List&lt;String&gt; listBResult = Optional.ofNullable(listB).orElse(say());</span><br><span class="line">    System.out.println(listBResult);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"orElse 执行了"</span>);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"orElse 创建的集合"</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line">orElse 执行了</span><br><span class="line">[]</span><br><span class="line">----------</span><br><span class="line">orElse 执行了</span><br><span class="line">[orElse 创建的集合]</span><br></pre></td></tr></tbody></table></figure>

<p>从执行输出的结果可以看出：当  Optional.ofNullable() 接收到的对象：</p>
<p>元素是 null，返回 <code>orElse()</code>中的结果是符合 API 描述的。</p>
<p>元素即不为 null，<code>orElse()</code> 也会被执行一次，并且仅仅是执行一下，并不会返回该方法中的结果。这看起来有点浪费资源，多此一举。</p>
<p>因此可以使用 <code>orElseGet()</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test33</span><span class="params">()</span> {</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; listA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    listA.add(<span class="string">"AA"</span>);</span><br><span class="line">    List&lt;String&gt; listAResult = Optional.ofNullable(listA).orElseGet(() -&gt; say());</span><br><span class="line">    System.out.println(listAResult);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"----------"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; listB = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; listBResult = Optional.ofNullable(listB).orElseGet(() -&gt; say());</span><br><span class="line">    System.out.println(listBResult);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">say</span><span class="params">()</span> {</span><br><span class="line">    System.out.println(<span class="string">"orElse 执行了"</span>);</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"orElse 创建的集合"</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ========== </span><br><span class="line">[AA]</span><br><span class="line">----------</span><br><span class="line">orElse 执行了</span><br><span class="line">[orElse 创建的集合]</span><br></pre></td></tr></tbody></table></figure>

<p><code>Optional.get()</code>方法获取 Optional 容器中的值，执行下面代码会发现，容器中的值是 null，get() 的时候会抛出空指针异常：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test34</span><span class="params">()</span> {</span><br><span class="line">    Optional&lt;String&gt; AA = Optional.ofNullable(<span class="string">"AA"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> AA.get();</span><br><span class="line">    System.out.println(aa); <span class="comment">// 正常获取到了值</span></span><br><span class="line"></span><br><span class="line">    Optional&lt;String&gt; BB = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> BB.get(); <span class="comment">// 抛出异常： java.util.NoSuchElementException: No value present</span></span><br><span class="line">    System.out.println(bb);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Optional.ifPresent()</code>方法会在容器中的元素为 null 的时候执行这个方法中的程序：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test35</span><span class="params">()</span> {</span><br><span class="line">    Optional&lt;String&gt; AA = Optional.ofNullable(<span class="string">"AA"</span>);</span><br><span class="line"></span><br><span class="line">    AA.ifPresent((x) -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">    Optional&lt;String&gt; BB = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    BB.ifPresent((x) -&gt; System.out.println(x));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line">AA</span><br></pre></td></tr></tbody></table></figure>

<p>从上述结果可以看出，当容器中的元素不为空的时候，执行<code>ifPresent()</code>方法中的程序，并且这个方法不返回任何值，仅仅是”消费掉”元素。</p>
<h2 id="时间日期API"><a href="#时间日期API" class="headerlink" title="时间日期API"></a>时间日期API</h2><p>第三次引入的 API 是成功的，并且Java 8中引入的 java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p>
<p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）<br>和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了日期时间和本地化的管理。</p>
<h3 id="LocalDate-LocalTime-LocalDateTime"><a href="#LocalDate-LocalTime-LocalDateTime" class="headerlink" title="LocalDate/LocalTime/LocalDateTime"></a>LocalDate/LocalTime/LocalDateTime</h3><p><code> LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code> 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate 代表 IOS 格式（yyyy-MM-dd）的日期，可以存储 生日、纪念日等日期。 只对年月日做出处理。</li>
<li>LocalTime 表示一个时间，而不是日期。 只对时分秒纳秒做出处理。</li>
<li>LocalDateTime 是用来表示日期和时间的，这是一个最常用的类之一。 同时可以处理年月日和时分秒。</li>
</ul>
<p>三种共同特点：</p>
<ul>
<li>相比于 Date 和 Calendar，他们是线程安全的；</li>
<li>它们是不可变的日期时间对象；</li>
</ul>
<blockquote>
<p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test36</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);</span><br><span class="line">    System.out.println(localTime);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">03</span></span><br><span class="line"><span class="number">13</span>:<span class="number">01</span>:<span class="number">32.045</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-03T13:<span class="number">01</span>:<span class="number">32.045</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="LocalDateTime-常用-API"><a href="#LocalDateTime-常用-API" class="headerlink" title="LocalDateTime  常用 API"></a>LocalDateTime  常用 API</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now()<br>now(Zoneld zone)</td>
<td>静态方法，根据当前时间创建对象 ； 指定时区的对象</td>
</tr>
<tr>
<td>of()</td>
<td>静态方法，根据指定日期，时间创建对象</td>
</tr>
<tr>
<td>getDayOfMonth()</td>
<td>获得月份天数(1-31)</td>
</tr>
<tr>
<td>getDayOfYear()</td>
<td>获取年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几</td>
</tr>
<tr>
<td>getYear()</td>
<td>获得年份</td>
</tr>
<tr>
<td>getMonth()<br>getMonthValue()</td>
<td>获得月份(返回枚举值如：January) ； 返回数字(1-12)</td>
</tr>
<tr>
<td>getHour()<br>getMinute()<br>getSecond()</td>
<td>获得当前对象的时，分，秒</td>
</tr>
<tr>
<td>withDayOfMonth()<br>withDayOfYear()<br>withMonth()<br>withYear()</td>
<td>将月份天数；年份天数；月份；年份修改为指定的值并且返回新的对象，因为LocalDate等是不变性的</td>
</tr>
<tr>
<td>plusDays()<br>plusWeeks()<br>plusMonths()<br>plusYears()<br>plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年，几小时</td>
</tr>
<tr>
<td>minusDays()<br>minusWeeks()<br>minusMonths()<br>minusYears()<br>minusHours()</td>
<td>从当前对象减去几月、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否为闰年</td>
</tr>
<tr>
<td>isBefore<br>isEqual<br>isAfter</td>
<td>检查日期是否在指定日期前面，相等，后面</td>
</tr>
</tbody></table>
<p>上述 API 在 LocalDate 、LocalTime 和 LocalDateTime 三者几乎是通用的。 </p>
<h3 id="瞬时（Instant）"><a href="#瞬时（Instant）" class="headerlink" title="瞬时（Instant）"></a>瞬时（Instant）</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</p>
<p> 在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p>
<p> java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p>
<blockquote>
<p>(1 ns = 10 -9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒</p>
</blockquote>
<p>常用 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态方法，返回默认的UTC时区的Instant类的对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>将此瞬间与偏移组合起来创建一个OffsetDateTime</td>
</tr>
<tr>
<td>toEpochMilli()</td>
<td>返回1970-01-01 00:00:00到当前的毫秒数，即时间戳</td>
</tr>
<tr>
<td>ofEpochMilli(long epochMilli)</td>
<td>静态方法，返回在1970-01-01 00:00:00基础加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td>ofEpochSecond(long epochSecond)</td>
<td>静态方法，返回在1970-01-01 00:00:00基础加上指定秒数之后的Instant类的对象</td>
</tr>
</tbody></table>
<p>时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒( 北京时间 1970 年 01 月 01日 08 时 00 分00 秒) 起至现在的总秒数。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test37</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    <span class="comment">// 默认格林威治时间</span></span><br><span class="line">    System.out.println(instant);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定时区偏移8小时，输出北京时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-03T05:<span class="number">54</span>:<span class="number">59.</span>319Z</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-03T13:<span class="number">54</span>:<span class="number">59.319</span></span><br></pre></td></tr></tbody></table></figure>

<p>根据当前系统的时区值，获取当前时间：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test38</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(ZoneId.systemDefault().getId()));</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-03T14:<span class="number">05</span>:<span class="number">08.131</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="时期格式化（DateTimeFormatter）"><a href="#时期格式化（DateTimeFormatter）" class="headerlink" title="时期格式化（DateTimeFormatter）"></a>时期格式化（DateTimeFormatter）</h3><p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<p>预定义的标准格式。如：ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME</p>
<p>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</p>
<p>自定义的格式。如：ofPattern(“yyyy-MM-dd HH:mm:ss”)</p>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ofPattern(String pattern)</td>
<td>静态方法 ， 返 回一 个指定字符串格式的 DateTimeFormatter</td>
</tr>
<tr>
<td>format(TemporalAccessor t)</td>
<td>格式化一个日期、时间，返回字符串</td>
</tr>
<tr>
<td>parse(CharSequence text)</td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<p>最常用的方式使用<code>ofPattern(String pattern)</code>创建自定义的格式化工具。</p>
<p>时间转时间字符串，代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test39</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="comment">// 将当前时间格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> formatter.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(now);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">20</span>    </span><br></pre></td></tr></tbody></table></figure>

<p>时间字符串转时间，代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test40</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">temporalAccessor</span> <span class="operator">=</span> formatter.parse(<span class="string">"2019-11-03 14:14:40"</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.from(temporalAccessor);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">========== 执行结果 ==========</span><br><span class="line"><span class="number">2019</span>-<span class="number">11</span>-03T14:<span class="number">14</span>:<span class="number">40</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="新日期与传统日期的转换"><a href="#新日期与传统日期的转换" class="headerlink" title="新日期与传统日期的转换"></a>新日期与传统日期的转换</h3><table>
<thead>
<tr>
<th>类</th>
<th>To 遗留类</th>
<th>From 遗留类</th>
</tr>
</thead>
<tbody><tr>
<td>java.time.Instant 与 java.util.Date</td>
<td>Date.from(instant)</td>
<td>date.toInstant()</td>
</tr>
<tr>
<td>java.time.Instant与java.sql.Timestamp</td>
<td>Timestamp.from(instant)</td>
<td>timestamp.toInstant()</td>
</tr>
<tr>
<td>java.time.Zoned DateTime与java.util.GregorianCalendar</td>
<td>GregorianCalendar.from(zonedDateTime)</td>
<td>cal.toZonedDateTime()</td>
</tr>
<tr>
<td>java.time.LocalDate与java.sql.Time</td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalDate()</td>
</tr>
<tr>
<td>java.time.LocalTime与java.sql.Time</td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalTime()</td>
</tr>
<tr>
<td>java.time.LocalDateTime与java.sql.Timestamp</td>
<td>Timestamp.valueOf(localDateTime)</td>
<td>timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td>java.time.ZoneId与java.util.TimeZone</td>
<td>Timezone.getTimeZone(id)</td>
<td>timeZone.toZoneId()</td>
</tr>
<tr>
<td>java.time.format.DateTimeFormatter 与 java.text.DateFormat</td>
<td>formatter.toFormat()</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="JDBC-与-新API-结合"><a href="#JDBC-与-新API-结合" class="headerlink" title="JDBC 与 新API 结合"></a>JDBC 与 新API 结合</h3><p>如果想要在 JDBC 中，使用 Java8 的日期 LocalDate、LocalDateTime，则必须要求数据库驱动的版本不能低于 4.2 </p>
<p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>LocalDate</td>
</tr>
<tr>
<td>time</td>
<td>LocalTime</td>
</tr>
<tr>
<td>timestamp</td>
<td>LocalDateTime</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/java8">跟上Java8 - 带你实战Java8</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">Java 8 中的 Streams API 详解</a></p>
<p><a href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程</a></p>
<p><a href="https://www.exception.site/java8/java8-stream-tutorial">Java8 新特性 Stream 流教程</a></p>
<p><a href="https://wizardforcel.gitbooks.io/java8-tutorials/content/">Java 8 教程汇总</a></p>
<p><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></p>
<p><a href="https://github.com/biezhi/learn-java8">《跟上 Java 8》 github 代码</a></p>
]]></content>
      <categories>
        <category>Java 新特性</category>
      </categories>
      <tags>
        <tag>JDK 1.8</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 学习笔记之安装详解</title>
    <url>/2019/11/04/051/</url>
    <content><![CDATA[<blockquote>
<p>本文基于 centos 7 虚拟机操作系统，安装 Elastic Search 6.5.4</p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官方下载地址： <a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a> </p>
<p>选择合适的安装版本，本文选择 6.5.4 版本的 linux 安装包：</p>
<p><img src="https://image.woodwhales.cn/051/images/01.png"></p>
<p>下载完成之后的压缩包名为：<code>elasticsearch-6.5.4.tar.gz</code></p>
<h2 id="Linux-环境准备"><a href="#Linux-环境准备" class="headerlink" title="Linux 环境准备"></a>Linux 环境准备</h2><p>本文使用 VMWare 虚拟机运行 Centos 7 操作系统，在启动 Centos Linux 操作系统之前，注意需要设置虚拟机的处理器参数：</p>
<p><img src="https://image.woodwhales.cn/051/images/02.png"></p>
<p>由于 ES 对机器的性能有要求，所以本文设置：处理器数量为 2，每个处理器的内核数量为 2。</p>
<p>使用 root 帐号启动虚拟机，准备安装下载好的 ES 安装源文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Linux 根目录下创建名称为<code>data</code>的文件目录，在该目录下再创建一个名称为<code>es</code>的文件目录。依次执行命令：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">cd /</span><br><span class="line">mkdir /data</span><br><span class="line">cd ./data</span><br><span class="line">mkdir ./es</span><br></pre></td></tr></tbody></table></figure>

<p>命令执行完毕之后，此时命令行在的 /data 目录下，在该目录下将第一步下载好的 ES 源文件上传至本目录中，此时 ES 源码安装包和 es 文件目录在同一级目录中。</p>
<p>因为 ES 不允许 ROOT 用户启动，因此需要创建一个非 ROOT 用户帐号，因此执行如下命令创建普通用户帐号，并将 es 目录授权给该用户：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">useradd elsearch</span><br><span class="line">chown elsearch:elsearch /data/es/ -R</span><br></pre></td></tr></tbody></table></figure>

<p>在 es 目录的父级目录执行 <code>ll</code> 命令可以看到 es 目录的所属人是：elsearch。</p>
<p>切换成刚才创建的用户：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">su - elsearch</span><br></pre></td></tr></tbody></table></figure>

<p>虽然 ES 源码安装包是 ROOT 用户权限所属，但是普通用户有可读的权限，因此可以直接解压：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -xvf ./elasticsearch-6.5.4.tar.gz -C es</span><br></pre></td></tr></tbody></table></figure>

<p>解压成功之后，在 es 目录中存在 <code>elasticsearch-6.5.4</code> 的文件目录。</p>
<h2 id="启动前的配置"><a href="#启动前的配置" class="headerlink" title="启动前的配置"></a>启动前的配置</h2><p><strong>步骤1：修改 IP 和 port</strong></p>
<p>进入 <code>config</code>目录，修改 <code>elasticsearch.yml</code> 文件配置：</p>
<p>到：”#network.host: 192.168.0.1” 配置，开启 <code>network.host</code> 配置，设置成 <code>0.0.0.0</code>，这样任意的地址都可以访问。</p>
<p><strong>步骤2：修改 JVM 参数配置</strong></p>
<blockquote>
<p>在 ES 中，如果 network.host 配置的不是 127.0.0.1的话，就会认为是生产环境，那么对环境要求很高，在测试环境中不一定满足。所以需要修改 jvm 启动参数。</p>
</blockquote>
<p>修改 <code>jvm.options</code> 文件配置，将如下默认的配置设置成：<code>-Xms128m</code> 和 <code>-Xmx128m</code></p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">-Xms1g 默认初始堆内存1G</span><br><span class="line">-Xmx1g 默认最大堆内存1G</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3：配置内存映射最大内存数量</strong></p>
<p>此操作必须是 ROOT 用户权限才能修改：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内存映射最大内存数量配置</span></span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></tbody></table></figure>

<p>配置好后，执行 <code>sysctl -p</code> 命令，让刚才的系统配置生效。配置正确，会在上述命令执行完毕，控制台打印出已经配置的配置项。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在 ES 安装目录下有个 <code>bin</code> 目录，进入这个 bin 目录，执行 <code>./elasticsearch</code> 或者 <code>./elasticsearch -d</code> ，参数 <code>-d</code>表示在后台静默启动。</p>
<blockquote>
<p>建议在第一次启动的时候采用第一种启动，防止出现缺少配置问题导致无法启动，待显式启动都没问题了再执行静默启动。</p>
</blockquote>
<p>成功启动可以在浏览器访问本虚拟机IP:9200，即可得到形如下的 JSON 信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"c-mFwGL"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"cluster_name"</span><span class="punctuation">:</span> <span class="string">"elasticsearch"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"cluster_uuid"</span><span class="punctuation">:</span> <span class="string">"3IFfflBJR1ya7jj5v-VeSg"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"version"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"number"</span><span class="punctuation">:</span> <span class="string">"6.5.4"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"build_flavor"</span><span class="punctuation">:</span> <span class="string">"default"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"build_type"</span><span class="punctuation">:</span> <span class="string">"tar"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"build_hash"</span><span class="punctuation">:</span> <span class="string">"d2ef93d"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"build_date"</span><span class="punctuation">:</span> <span class="string">"2018-12-17T21:17:40.758843Z"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"build_snapshot"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"lucene_version"</span><span class="punctuation">:</span> <span class="string">"7.5.0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"minimum_wire_compatibility_version"</span><span class="punctuation">:</span> <span class="string">"5.6.0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"minimum_index_compatibility_version"</span><span class="punctuation">:</span> <span class="string">"5.0.0"</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"tagline"</span><span class="punctuation">:</span> <span class="string">"You Know, for Search"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用 <code>jps</code> 命令查看 ES 进程信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]# jps</span><br><span class="line">2979 Elasticsearch</span><br><span class="line">3115 Jps</span><br></pre></td></tr></tbody></table></figure>

<p>如果看到上述 ES 进程信息，也表示 ES 启动成功。</p>
<h2 id="启动错误问题解决"><a href="#启动错误问题解决" class="headerlink" title="启动错误问题解决"></a>启动错误问题解决</h2><p>在启动过程中，可能会提示如下三种异常问题：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[1]</span>: max ``file` `descriptors <span class="section">[4096]</span> ``for` `elasticsearch process is too low, increase to at least <span class="section">[65536]</span></span><br><span class="line"><span class="section">[2]</span>: max number of threads <span class="section">[3802]</span> ``for` `user <span class="section">[esyonghu]</span> is too low, increase to at least <span class="section">[4096]</span></span><br><span class="line"><span class="section">[3]</span>: max virtual memory areas vm.max_map_count <span class="section">[65530]</span> is too low, increase to at least <span class="section">[262144]</span></span><br></pre></td></tr></tbody></table></figure>

<p> 第一个错误表示需要将当前用户的软硬调用限制调大，切换到 ROOT 用户，然后执行：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf </span><br></pre></td></tr></tbody></table></figure>

<p>在 “# End of file” 描述下方添加如下配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></tbody></table></figure>

<p> 第二个错误需要修改<code>/etc/security/limits.d/20-nproc.conf </code>文件，这里需要注意一下，可能不叫<code>20-nproc.conf</code>，也可能是<code>90-nproc.conf</code>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/security/limits.d/20-nproc.conf</span><br></pre></td></tr></tbody></table></figure>

<p>默认为<code> * soft nproc 1024</code> ，修改成：<code>* soft nproc 4096</code></p>
<p>第三个错误解决：参见上上小节的”启动前的配置”。</p>
<h2 id="防火墙端口设置"><a href="#防火墙端口设置" class="headerlink" title="防火墙端口设置"></a>防火墙端口设置</h2><p>注意 ES 默认启动的是 9200 端口，因此要注意防火墙端口是否开启：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports	# 查看已经开放的端口</span><br><span class="line">firewall-cmd --zone=public --add-port=9200/tcp --permanent	# 永久开启 9200 端口</span><br><span class="line">firewall：firewall-cmd --reload	# 重启防火墙</span><br><span class="line">firewall：systemctl stop firewalld.service	# 停止防火墙 </span><br><span class="line">systemctl disable firewalld.service		# 禁止firewall开机启动</span><br></pre></td></tr></tbody></table></figure>

<p>注意开设端口之后，防火墙需要重启。</p>
<h2 id="ES-可视化工具"><a href="#ES-可视化工具" class="headerlink" title="ES 可视化工具"></a>ES 可视化工具</h2><p>ES 官网没有提供可视化工具，github 上有款很优秀的工具：<a href="http://mobz.github.io/elasticsearch-head/">http://mobz.github.io/elasticsearch-head/</a></p>
<p>该工具提供了多种使用方式：</p>
<p>第一种：克隆 github 上的源码，<code>npm run start</code> 编译安装。</p>
<p>第二种，使用 docker 镜像安装。</p>
<p>第三种，Chrome 插件。插件地址：<a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm">https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm</a></p>
<p>第四种，通过 ES 的 plugin 方式安装。</p>
<p>注意，上述使用途径，可能会存在前后端分离，所以最好配置一下 ES 支持跨域请求：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></tbody></table></figure>

<p>增加配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: "*"</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Elastic Stack</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>git 设置本地配置多个账户对应不同的 ssh key</title>
    <url>/2019/11/11/052/</url>
    <content><![CDATA[<h1 id="生成多个-ssh-key"><a href="#生成多个-ssh-key" class="headerlink" title="生成多个 ssh key"></a>生成多个 ssh key</h1><p>一般是这样生成 ssh key 的：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "example@email.com"</span><br></pre></td></tr></tbody></table></figure>
<p>经过多步的操作后，会在 <code>~/.ssh/ </code> （linux） ，<code>C:\Users\\username\.ssh\ </code> （windows）下生成公钥和私钥，默认名称为：<code>id_rsa</code>和<code>id_rsa.pub</code>文件。</p>
<p>上述的操作确实可以解决使用同一个邮箱账户配置git ssh key的问题，但如果我们的机器不仅仅使用github，还需要使用到公司的gitlab呢？ </p>
<p>一般公司都是用企业邮箱注册的 gitlab，这样使用通用邮箱生成的 ssh key 便无法通用，从而还需要再使用 ssh 生成一个关联企业邮箱的公私钥，如果使用默认的生成 key 命令，则会因为生成的 key 文件的名称不同，所以会有覆盖掉之前生成的 key 的问题或者根本不允许再次生成相同文件名的公私钥，因而导致一台机器上无法同时使用多个 key。 </p>
<p> 如何解决git配置多个 ssh key 时如何解决冲突的问题，即每次生成 key 的时候，给 key 取一个自己定义的别名，然后修改 ssh key 的配置文件即可。</p>
<h2 id="step-1-首先生成不同名称的-key-文件（公私钥）"><a href="#step-1-首先生成不同名称的-key-文件（公私钥）" class="headerlink" title="step 1. 首先生成不同名称的 key 文件（公私钥）"></a>step 1. 首先生成不同名称的 key 文件（公私钥）</h2><p>如生成一个 github 帐号使用的 key：</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "github@email.com" -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>如生成一个 github 帐号使用的 key：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "gitlab@email.com" -f ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>上述命令执行之后，在相应的目录下<code>~/.ssh/</code>（linux），<code>C:\Users\\username\.ssh\</code>（windows），生成了两种key。 </p>
<blockquote>
<p>git for windows 2.33.1 版本已使用 OpenSSH 8.8</p>
<p>需要使用 ed25519 算法生成 key：</p>
<p><code>ssh-keygen -t ed25519 -C "github@email.com" -f ~/.ssh/github_id_ed25519</code></p>
</blockquote>
<h2 id="step-2-给远程仓库配置添加信任-ssh-key"><a href="#step-2-给远程仓库配置添加信任-ssh-key" class="headerlink" title="step 2. 给远程仓库配置添加信任 ssh key"></a>step 2. 给远程仓库配置添加信任 ssh key</h2><h2 id="step-3-配置-config"><a href="#step-3-配置-config" class="headerlink" title="step 3. 配置 config"></a>step 3. 配置 config</h2><p>我们需要在目录：<code>~/.ssh/</code>（linux） ，<code>C:\Users\\username\.ssh\</code>（windows），创建config文件，并且配置ssh key的路由策略：</p>
<p>linux 中的配置如下： </p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">Host gitlab.com</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/gitlab_id_rsa</span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>widows 中的配置如下：（windows下配置<code>~/.ssh</code>不识别）</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 配置github.com</span></span><br><span class="line">Host github.com                 </span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile C:\\Users\\username\\.ssh\\github_id_rsa</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 配置gitlab.com</span></span><br><span class="line">Host gitlab.com </span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    IdentityFile C:\\Users\\username\\.ssh\\gitlab_id_rsa</span><br><span class="line">    PreferredAuthentications publickey</span><br></pre></td></tr></tbody></table></figure>

<h2 id="step-4-测试-ssh-key-是否通过"><a href="#step-4-测试-ssh-key-是否通过" class="headerlink" title="step 4. 测试 ssh key 是否通过"></a>step 4. 测试 ssh key 是否通过</h2><p>使用命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure>

<p>测试是否配置成功。</p>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="去除全局用户和邮箱"><a href="#去除全局用户和邮箱" class="headerlink" title="去除全局用户和邮箱"></a>去除全局用户和邮箱</h2><p>步骤1：如果已经设置过全局用户名和邮箱，那么要把取消掉，否则 默认使用全局配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></tbody></table></figure>

<p>查看全局用户配置信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></tbody></table></figure>

<p>配置全局用户和邮箱：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git config user.name "woodwhales"</span><br><span class="line">git config user.email "woodwhales@163.com"</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：将所有生成 ssh key 执行如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-add -K ~/.ssh/github_id_rsa</span><br><span class="line">ssh-add -K ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></tbody></table></figure>

<p>如果上述命令提示：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></tbody></table></figure>

<p>则需要先执行：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br></pre></td></tr></tbody></table></figure>

<p>如果提示：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Enter PIN for authenticator:</span><br></pre></td></tr></tbody></table></figure>

<p>则执行如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/github_id_rsa</span><br><span class="line">ssh-add ~/.ssh/gitlab_id_rsa</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SourceTree-配置"><a href="#SourceTree-配置" class="headerlink" title="SourceTree 配置"></a>SourceTree 配置</h2><p>步骤1：工具 - 选项</p>
<p>步骤2：选择”一般”选项卡，去除”默认用户信息”中的全名和电子邮件地址。</p>
<p>步骤3：设置”SSH客户端配置”中的SSH客户端为：OpenSSH，并将 SSH 密钥文本框清空</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机语言及操作系统发展史</title>
    <url>/2019/11/24/054/</url>
    <content><![CDATA[<h2 id="Linux-发展史"><a href="#Linux-发展史" class="headerlink" title="Linux 发展史"></a>Linux 发展史</h2><h3 id="Unix-history-simple"><a href="#Unix-history-simple" class="headerlink" title="Unix history simple"></a>Unix history simple</h3><p>原图地址： <a href="https://upload.wikimedia.org/wikipedia/commons/7/77/Unix_history-simple.svg">https://upload.wikimedia.org/wikipedia/commons/7/77/Unix_history-simple.svg</a></p>
<p>本站下载：<a href="Unix_history-simple.svg">Unix_history-simple.svg</a></p>
<p><img src="https://image.woodwhales.cn/054/images/Unix_history-simple.svg"></p>
<h3 id="Linux-Distribution-Timeline"><a href="#Linux-Distribution-Timeline" class="headerlink" title="Linux Distribution Timeline"></a>Linux Distribution Timeline</h3><p>本图的出现得益于开源世界的诸多热心人士，他们在站点<a href="http://futurist.se/gldt/%E7%9A%84%E7%BB%B4%E6%8A%A4%E4%B8%8A%E4%BB%98%E5%87%BA%E4%BA%86%E8%AF%B8%E5%A4%9A%E5%BF%83%E8%A1%80%E3%80%82%E9%81%97%E6%86%BE%E7%9A%84%E6%98%AF%EF%BC%8C%E7%94%B1%E4%BA%8E%E7%A7%8D%E7%A7%8D%E5%8E%9F%E5%9B%A0%E6%AD%A4%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8F%AA%E5%88%B02012%E5%B9%B4%E3%80%82">http://futurist.se/gldt/的维护上付出了诸多心血。遗憾的是，由于种种原因此图的更新只到2012年。</a></p>
<p>原图地址： <a href="https://futurist.se/gldt/wp-content/uploads/12.10/gldt1210.svg">https://futurist.se/gldt/wp-content/uploads/12.10/gldt1210.svg</a></p>
<p>本站下载：<a href="gldt1210.svg">gldt1210.svg</a></p>
<p><img src="https://futurist.se/gldt/wp-content/uploads/12.10/gldt1210.svg"></p>
<h2 id="Unix-发展史"><a href="#Unix-发展史" class="headerlink" title="Unix 发展史"></a>Unix 发展史</h2><p>原图地址：<a href="https://www.levenez.com/unix/unix.pdf">https://www.levenez.com/unix/unix.pdf</a> </p>
<p>本站下载：<a href="unix.pdf">unix.pdf</a></p>
<p><img src="https://image.woodwhales.cn/054/images/unix.png"></p>
<h2 id="Windows-发展史"><a href="#Windows-发展史" class="headerlink" title="Windows 发展史"></a>Windows 发展史</h2><p>原图地址： <a href="https://www.levenez.com/windows/windows.pdf">https://www.levenez.com/windows/windows.pdf</a> </p>
<p>本站下载：<a href="windows.pdf">windows.pdf</a></p>
<p><img src="https://image.woodwhales.cn/054/images/windows.png"></p>
<h2 id="计算机语言发展史"><a href="#计算机语言发展史" class="headerlink" title="计算机语言发展史"></a>计算机语言发展史</h2><p>原图地址： <a href="https://www.levenez.com/lang/lang.pdf">https://www.levenez.com/lang/lang.pdf</a> </p>
<p>本站下载：<a href="lang.pdf">lang.pdf</a></p>
<p><img src="https://image.woodwhales.cn/054/images/lang.png"></p>
<h3 id="Simplified-version-with-only-main-languages"><a href="#Simplified-version-with-only-main-languages" class="headerlink" title="Simplified version with only main languages"></a>Simplified version with only main languages</h3><p>原图地址： <a href="http://rigaux.org/language-study/diagram-light.pdf">http://rigaux.org/language-study/diagram-light.pdf</a></p>
<p>本站下载：<a href="lang-diagram-light.pdf">diagram-light.pdf</a></p>
<p><img src="https://image.woodwhales.cn/054/images/lang-diragram-light.png"></p>
<h3 id="Messy-full-version-more-than-150-languages"><a href="#Messy-full-version-more-than-150-languages" class="headerlink" title="Messy full version more than 150 languages"></a>Messy full version more than 150 languages</h3><p>原图地址：   <a href="http://rigaux.org/language-study/diagram.pdf">http://rigaux.org/language-study/diagram.pdf</a></p>
<p>本站下载：<a href="lang-diagram.pdf">diagram.pdf</a></p>
<p><img src="https://image.woodwhales.cn/054/images/lang-diragram.png"></p>
<h2 id="开源电子书"><a href="#开源电子书" class="headerlink" title="开源电子书"></a>开源电子书</h2><h3 id="UNIX-编程艺术英文版"><a href="#UNIX-编程艺术英文版" class="headerlink" title="UNIX 编程艺术英文版"></a>UNIX 编程艺术英文版</h3><p>the art of unix programming 电子书地址： <a href="https://www.arp242.net/the-art-of-unix-programming/">https://www.arp242.net/the-art-of-unix-programming/</a></p>
<p>HTML 版地址：<a href="http://www.catb.org/~esr/writings/taoup/html/">http://www.catb.org/~esr/writings/taoup/html/</a> </p>
<p>PDF 版地址： <a href="https://nakamotoinstitute.org/static/docs/taoup.pdf">https://nakamotoinstitute.org/static/docs/taoup.pdf</a></p>
<p>本站下载：<a href="taoup.pdf">the art of unix programming.pdf</a></p>
<h3 id="Linux设备驱动程序"><a href="#Linux设备驱动程序" class="headerlink" title="Linux设备驱动程序"></a>Linux设备驱动程序</h3><p>Linux Device Drivers, Third Edition 电子书地址：  <a href="https://www.oreilly.com/openbook/linuxdrive3/book/">https://www.oreilly.com/openbook/linuxdrive3/book/</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://freecomputerbooks.com/">http://freecomputerbooks.com/</a> </p>
<p><a href="https://www.foxebook.net/">https://www.foxebook.net/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言中的细节知识点</title>
    <url>/2019/11/18/053/</url>
    <content><![CDATA[<h2 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h2><p>常量的定义可以有两种方式</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>格式：<code>const 数据类型 常量名 = 常量值</code></p>
<p>示例：<code>const double PI = 3.14</code></p>
<h3 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h3><p>格式：<code>#define 常量名 常量值</code></p>
<p>示例：<code>#define SUM = 1 + 2</code></p>
<h3 id="const-和-define-的区别"><a href="#const-和-define-的区别" class="headerlink" title="const 和 #define 的区别"></a>const 和 #define 的区别</h3><ul>
<li>const 定义的常量时带类型，#define 不带类型</li>
<li>const 是在 编译、运行的时候起作用，而 #define 是在编译的预处理阶段起作用</li>
<li>#define 只是简单的替换，没有类型检查。简单的字符串替换会导致<strong>边界效应</strong></li>
<li>const 常量可以进行调试的，#define 是不能进行调试的，主要是预编译阶段就已经替换掉了，调试的时候就没它了</li>
<li>const 不能重定义，不可以定义两个一样的，而 #define 通过 #undef 取消某个符号的定义，再重新定义</li>
<li>define 可以配合<code>#ifdef</code>、 <code>#ifndef</code>、 <code>#endif</code>来使用， 可以让代码更加灵活，比如我们可以通过 #define 来启动或者关闭调试信息。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SUM_CONST = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUM_DEFINE 1 + 2;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> num1 = <span class="number">1</span> / SUM_CONST;  <span class="comment">// 表示 1 / 3</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num2 = <span class="number">1</span> / SUM_DEFINE; <span class="comment">// 预编译之后，源码中的表达式是：1 / 1 + 2，而不是 1 / (+ 2)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num1 = %d\n"</span>, num1); <span class="comment">// 输出结果：0</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num2 = %d\n"</span>, num2); <span class="comment">// 输出结果：3</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/01.png"></p>
<p>从上述的输出结果，可以看出<code>#define</code>仅仅是预编译之后将常量替换成原来的表达式。</p>
<h2 id="取模运算符"><a href="#取模运算符" class="headerlink" title="取模运算符"></a>取模运算符</h2><p>除法运算符的底层原理：</p>
<p><code>A % B</code>在编译器中会自动翻译为：<code>A - ((A) / (B)) * (B)</code>。</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A % B = A - A / B * B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> num1 = <span class="number">-1</span> % <span class="number">2</span>; <span class="comment">// 表示：-1 - (-1) / 2 * 2 = -1 - (0 * 2) = -1 - 0 = -1</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num2 = <span class="number">-3</span> % <span class="number">1</span>; <span class="comment">// 表示：-3 - (-3) / 1 * 1 = -3 - (-3 * 1) = -3 + 3 = 0</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num3 = <span class="number">-3</span> % <span class="number">2</span>; <span class="comment">// 表示：-3 - (-3) / 2 * 2 = -3 - (-1 * 2) = -3 - (-2) = -1</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num4 = <span class="number">-3</span> % <span class="number">3</span>; <span class="comment">// 表示：-3 - (-3) / 3 * 3 = -3 - (-1 * 3) = -3 + 3 = 0</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num5 = <span class="number">-3</span> % <span class="number">4</span>; <span class="comment">// 表示：-3 - (-3) / 4 * 4 = -3 - (0 * 4) = -3 + 0 = -3</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num1 = %d\n"</span>, num1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num2 = %d\n"</span>, num2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num3 = %d\n"</span>, num3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num4 = %d\n"</span>, num4);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num5 = %d\n"</span>, num5);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/02.png"></p>
<p>从取模的底层原理可以得出结论：取模数不可以为零，形如：<code>2 % 0</code>这样的表达式是非法的。</p>
<h2 id="算术运算中的自动类型转换"><a href="#算术运算中的自动类型转换" class="headerlink" title="算术运算中的自动类型转换"></a>算术运算中的自动类型转换</h2><p>在基本运算过程中，一定要注意 C 语言中不带小数点的数字默认类型是 int 类型，带小数点的数字默认类型是 double 类型，在计算中可能会存在类型自动转换问题，如下面的代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运算中的自动类型转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">double</span> num1 = <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// num 不是 2.500000，而是 2.000000，因为左边是先int类型除法计算，再类型自动转换</span></span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> num2 = <span class="number">5.0</span> / <span class="number">2</span>; <span class="comment">// num 是 2.500000，因为左边是先都double类型除法计算，再赋值。</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num1 = %f\n"</span>, num1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num2 = %f\n"</span>, num2);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/03.png"></p>
<h2 id="自增-自减运算"><a href="#自增-自减运算" class="headerlink" title="自增/自减运算"></a>自增/自减运算</h2><p>如果变量仅仅是自己自增或者自减操作，那么仅仅影响变量本身。</p>
<p>如果自增或自减并赋值给另外一个变量，那么会有赋值顺序。</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自增/自减运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">10</span>, q = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> m = i++;</span><br><span class="line">	<span class="type">int</span> n = ++j;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"j = %d\n"</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"m = %d\n"</span>, m); <span class="comment">// 等价于先赋值再自增，m = j ,j = j + 1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n); <span class="comment">// 等价于先自增再赋值，j = j + 1, m = j</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"k = %d\n"</span>, k);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"q = %d\n"</span>, q);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(k++ == <span class="number">10</span>) { <span class="comment">// 等价于先比较再自增</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"k++ == 10\n"</span>);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"k++ != 10\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(++q == <span class="number">10</span>) { <span class="comment">// 等价于先自增再比较</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"++q == 10\n"</span>);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"++q != 10\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/04.png"></p>
<h2 id="变量和指针"><a href="#变量和指针" class="headerlink" title="变量和指针"></a>变量和指针</h2><p>指针是 C 语言的灵魂，指针就是地址，地址就是指针：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变量和指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> * ptr = &amp;num;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num 变量本身的值：%d\n"</span>, num);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num 变量本身的值所在的内存地址：%p\n"</span>, &amp;num);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr 变量本身的值：%p\n"</span>, ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr 变量本身的值所在的内存地址：%p\n"</span>, &amp;ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr 变量本身的值所在的内存地址中的内容：%d\n"</span>, *ptr);</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/05.png"></p>
<p>上述的执行结果，可能存在不一样，但是<code>num 变量本身的值所在的内存地址</code>和<code>ptr 变量本身的值</code>两者一定是相等的。</p>
<p>上述执行结果解释：</p>
<p>在源码被编译之后，所有的变量都会变成了汇编指令中的开辟一块内存空间的意思，而这个赋值操作就是对这块开辟的内存空间进行设置值。</p>
<p>好比一位客人要进入酒店入住：</p>
<ul>
<li><p>这位客人要告诉前台，我要住什么类型的房间，是单人间还是双人间，这里的房间类型就是变量的类型，也就是<code>int</code>类型。</p>
</li>
<li><p>这位客人还要告诉前台，你选择的这个房间要住具体的人是谁，这里的具体的人就是变量被赋值的值，也就是数字<code>10</code>。</p>
</li>
</ul>
<p><em>以上过程中前台还需要考虑一下这位客人要求开的房间类型和要住的人是不是匹配，也就是变量申明的类型和赋值的值类型是否匹配</em></p>
<p>经过以上过程之后，这位客人就可以办理入住手续并顺利入住了。</p>
<p>注意的是客人说你们的房间号都是一大串数字记忆起来太麻烦了，我出门之后很容易忘记我的房间号，能不能我给我这个房间号起一个别名。于是前台说，那你自己起一个自己能记住的房间号别名吧，我帮你做好映射关系。于是这位客人给自己的房间号起了个别名叫<code>num</code>，也就是变量的名字。</p>
<p>当这个人被入住进入这个房间之后，酒店老板了来问前台，刚才开的房间里住着是谁啊，前台想那么多的房间号都是数字，我要是顺着数字找我也费劲，刚才的客人不是给自己起了个房间号别名叫<code>num</code>么，我也做好了映射，直接<code>&amp;num</code>就能知道这个人的房间号是多少，并且这个别名就是这个人起的，所以这个别名就代表了这个房间里住的人。也是前台很爽快的回复老板，这个人是<code>num</code>，他住的房间号是<code>&amp;num</code>。</p>
<p>这时老板再问，人既然住在了这个房间里，那么这个房间号你是记在哪里了呢，总不会用脑袋记忆吧，并且这个人所住的房间类型，我也不知道啊。聪明的前台说，这个已经记住了，就是在客人起房间号别名的时候就做好了映射记录了。我专门设置了一个专门用来存房间号的房间，叫<code>ptr</code>，这特殊的房间里面不住客人，只把某位客人所住的房间号码放在这个房间里，光记住这个客人的房间号不够，这个特殊的房间还是特殊的类型，叫客人房间号的类型，也就是<code>int *</code>。</p>
<p>前台很爽快的回复老板，这个<code>ptr</code>房间里存的某位客人的房间号就是：<code>ptr</code>，这位客人就是：<code>* ptr</code>。</p>
<p>从上述比喻可以看出，<code>ptr</code>房间里的东西存的就是客人的房间号码，只要谁拿到了这个客人的房间号码，那么就可以对这位客人为所欲为了。</p>
<p><em>如果某个杀手知道了这个房间号码，带把枪把这个房间号码里住的人给枪杀了，那么是个危险的事情。当然如果某个医生知道这个房间号码，就能在第一时间及时抢救这位客人。</em></p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>局部变量，系统不会对其默认初始化，必须对局部变量初始化之后才能使用，否则程序运行可能会异常退出。</p>
<p>全局变量，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>‘\0’</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>pointer 指针</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>正确地初始化变量是一个良好的编程习惯。否则有时程序可能产生意想不到的结果，因为未初始化的变量会保存一些内存位置中已经可用的垃圾值。</p>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p><code>static</code>关键字在 C 语言中比较常用，使用恰当能够大大提高程序的模块化特性，有利于扩展和维护。</p>
<h3 id="局部变量使用-static"><a href="#局部变量使用-static" class="headerlink" title="局部变量使用 static"></a>局部变量使用 static</h3><p>局部变量被 static 修饰后，我们称为静态局部变量</p>
<p>对应静态局部变量在声明时未赋初值，编译器也会把它初始化为默认值。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>‘\0’</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>pointer 指针</td>
<td>NULL</td>
</tr>
</tbody></table>
<p>静态局部变量存储于进程的<strong>静态存储区（全局性质）</strong>， <strong>只会被初始化一次</strong>，即使函数返回，它的值也会保持不变</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态局部变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_static</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> n = <span class="number">10</span>; <span class="comment">// static 修饰的局部变量会存在静态存储区（全局性的区域），只会初始化一次</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);</span><br><span class="line">	</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	fun_static();</span><br><span class="line"></span><br><span class="line">	fun_static();</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/06.png"></p>
<h3 id="全局变量使用-static"><a href="#全局变量使用-static" class="headerlink" title="全局变量使用 static"></a>全局变量使用 static</h3><p>普通全局变量对整个工程可见，其他文件可以使用<code>extern</code>外部声明后直接使用。也就是说其他文件不能再定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量），静态全局变量仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。</p>
<p>定义不需要与其他文件共享的全局变量时，加上<code>static</code>关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。</p>
<p>代码示例：</p>
<p>file01.c 文件中定义全局变量：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 普通全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 静态全局变量，只能在本文件中使用，而不能在其他文件中使用</span></span><br></pre></td></tr></tbody></table></figure>

<p>file02.c 文件中引入普通全局变量：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num1; <span class="comment">// 引用外部文件中的普通全局变量，千万不要对其赋值！</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num2; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num1 = %d\n"</span>, num1);</span><br><span class="line">	<span class="comment">// printf("num2 = %d\n", num2); // num2 在外部文件中已经是静态全局变量了，</span></span><br><span class="line">								    <span class="comment">// 那么本文件只是引用而不重新初始化，那么运行会报错</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/07.png"></p>
<p>代码示例：</p>
<p>file01.c 文件中定义全局变量：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 普通全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 静态全局变量，只能在本文件中使用，而不能在其他文件中使用</span></span><br></pre></td></tr></tbody></table></figure>

<p>file02.c 文件中引入普通全局变量：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num1; <span class="comment">// 引用外部文件中的普通全局变量，千万不要对其赋值！</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num2; </span><br><span class="line"></span><br><span class="line"><span class="comment">// int num1 = 9; // 这里的num1全局变量在其他文件中已经定义并被本文件引用，</span></span><br><span class="line">                 <span class="comment">// 因此不允许定义相同名的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num2 = <span class="number">11</span>; <span class="comment">// 由于 外部文件中的num2被定义成了静态全局变量，</span></span><br><span class="line">					  <span class="comment">// 那么本文件可以定义相同变量名的普通全局变量或静态全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num1 = %d\n"</span>, num1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"num2 = %d\n"</span>, num2);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/08.png"></p>
<p>从第二个示例可以看出，一般在文件中定义全局变量的时候，如果不想其他文件使用，那么就使用<code>static</code>修饰，其他文件引用了也没关系，因为它们要想使用这个变量，就得自己重新定义一个相同名字的全局变量。从而使得自己的全局变量”很安全”。</p>
<h3 id="函数使用-static"><a href="#函数使用-static" class="headerlink" title="函数使用 static"></a>函数使用 static</h3><p>函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。</p>
<p>非静态函数可以在另一个文件中通过<code>extern</code>引用。</p>
<p>静态函数只能在声明它的文件中可见，其他文件不能引用该函数。</p>
<p>不同的文件可以使用相同名字的静态函数，互不影响。</p>
<p>代码示例：</p>
<p>file03.c 文件中定义函数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数（非静态函数）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fun1 was executed...\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 修饰的函数叫静态函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fun2 was executed...\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>file04.c 文件中使用外部文件中的函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 使用 extern 引入外部文件中的非静态函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 可以引入外部文件中的静态函数，但是不能使用！</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	fun1();</span><br><span class="line">	<span class="comment">// fun2(); // 不能正常使用外部文件中的静态函数</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/09.png"></p>
<p>和静态全局变量一样，本文件中引入了外部文件中的静态函数，如果想使用相同名称的函数名，那么需要自己重新定义：</p>
<p>file03.c 文件中定义函数：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 普通函数（非静态函数）</span><br><span class="line">void fun1(void) {</span><br><span class="line">	printf("fun1 was executed...\n");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// static 修饰的函数叫静态函数</span><br><span class="line">static void fun2(void) {</span><br><span class="line">	printf("fun2 was executed...\n");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>file04.c 文件中使用外部文件中的函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 使用 extern 引入外部文件中的非静态函数，不允许重新定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 可以引入外部文件中的静态函数，但是不能使用！ 除非自己重新定义</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">()</span> {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fun2 was redefined\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	fun1();</span><br><span class="line">	fun2();</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/10.png"></p>
<h2 id="系统函数库"><a href="#系统函数库" class="headerlink" title="系统函数库"></a>系统函数库</h2><h3 id="string-h-字符串函数库"><a href="#string-h-字符串函数库" class="headerlink" title="string.h 字符串函数库"></a>string.h 字符串函数库</h3><p>字符串操作常常依赖系统依赖提供的字符串函数：</p>
<h4 id="得到字符串的长度"><a href="#得到字符串的长度" class="headerlink" title="得到字符串的长度"></a>得到字符串的长度</h4><p><code>size_t strlen(const char *str)</code></p>
<p>计算字符串 str 的长度，直到空结束字符，但不包括空结束字符 。</p>
<h4 id="拷贝字符串"><a href="#拷贝字符串" class="headerlink" title="拷贝字符串"></a>拷贝字符串</h4><p><code>char *strcpy(char *dest, const char *src)</code></p>
<p>把 src 所指向的字符串复制到 dest。</p>
<h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h4><p><code>char *strcat(char *dest, const char *src)</code></p>
<p>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">char</span> src[<span class="number">50</span>], dest[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> * str = <span class="string">"woodwhales"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 计算字符串长度（以字符为单位）</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0. str = %s, len = %d\n"</span>, str, len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(src, <span class="string">"src str"</span>); <span class="comment">// strcpy 字符串拷贝，注意源字符串会被覆盖</span></span><br><span class="line">	<span class="built_in">strcpy</span>(dest, <span class="string">"dest str"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1. src = %s\n"</span>, src);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2. dest = %s\n"</span>, dest);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(dest, <span class="string">"hello world"</span>); <span class="comment">// 证明 strcpy 字符串拷贝源字符串会被覆盖</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"3. dest = %s\n"</span>, dest);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcat</span>(dest, <span class="string">" woodwhales"</span>); <span class="comment">// strcpy 字符串拼接</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"4. dest = %s\n"</span>, dest);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/11.png"></p>
<h3 id="time-h-时间日期函数库"><a href="#time-h-时间日期函数库" class="headerlink" title="time.h 时间日期函数库"></a>time.h 时间日期函数库</h3><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><p><code>char *ctime(const time_t *timer)</code></p>
<p>返回一个表示当地时间的字符串，当地时间是基于参数 timer。</p>
<h4 id="时间差计算"><a href="#时间差计算" class="headerlink" title="时间差计算"></a>时间差计算</h4><p><code>double difftime(time_t time1, time_t time2)</code></p>
<p>返回 time1 和 time2 之间相差的秒数 (time1-time2)。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">time_t</span> currentTime; <span class="comment">// time.h 是一个结构体类型</span></span><br><span class="line">	time(&amp;currentTime); <span class="comment">// 完成初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ctime 返回一个表示当地时间的字符串，当地时间是基于参数 timer</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"current time = %s"</span>, ctime(&amp;currentTime));</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/12.png"></p>
<p>计算某个函数的执行时间：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">			sum += j;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">time_t</span> startTime, endTime; </span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> costTime;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"function is begining...\n"</span>);</span><br><span class="line">	time(&amp;startTime); <span class="comment">// 记录开始时间</span></span><br><span class="line"></span><br><span class="line">	function(); <span class="comment">// 执行函数</span></span><br><span class="line"></span><br><span class="line">	time(&amp;endTime); <span class="comment">// 记录结束时间</span></span><br><span class="line"></span><br><span class="line">	costTime = difftime(endTime, startTime);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"cost time = %f\n"</span>, costTime);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/13.png"></p>
<h2 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h2><p>使用库函数之前，应该用<code>#include</code>引入对应的头文件。这种以<code>#</code>号开头的命令称为预处理命令。</p>
<p>这些在编译之前对源文件进行简单加工的过程，就称为<code>预处理</code>（即预先处理、提前处理）。</p>
<p>预处理主要是处理以<code>#</code>开头的命令，例如 #include &lt;stdio.h&gt; 等。预处理命令要放在所有函数之外，而且一般都放在源文件的前面。</p>
<p>预处理是 C 语言的一个重要功能，由预处理程序完成。<strong>当对一个源文件进行编译时， 系统将自动调用预处理程序对源程序中的预处理部分作处理，处理完毕自动进入对源程序的编译。</strong></p>
<p>C 语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序便于阅读、修改、移植和调试，也有利于模块化程序设计。</p>
<p>应用场景：</p>
<p>开发一个C语言程序，让它暂停 5 秒以后再输出内容 “hello world”，并且要求跨平台，在 Windows 和 Linux 下都能运行，如何处理？</p>
<p>提示：</p>
<p>Windows 平台下的暂停函数的原型是<code>void Sleep(DWORD dwMilliseconds)</code>，参数的单位是”毫秒”，位于<code>&lt;windows.h&gt;</code>头文件。</p>
<p>Linux 平台下暂停函数的原型是<code>unsigned int sleep (unsigned int seconds)</code>，参数的单位是”秒”，位于<code>&lt;unistd.h&gt;</code>头文件。</p>
<p><code>#if</code>、<code>#elif</code>、<code>#endif</code>就是预处理命令，它们都是在编译之前由预处理程序来执行的。</p>
<p>代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="comment">// 不同的平台下调用不同的函数</span></span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> _WIN32 <span class="comment">// 识别 windows 平台</span></span></span><br><span class="line">	Sleep(<span class="number">5000</span>);</span><br><span class="line">	<span class="meta">#<span class="keyword">elif</span> __linux__ <span class="comment">// 识别 linux 平台</span></span></span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述源文件在预编译之后的源码中，会根据不同的平台生成对应的源码，如 windows 平台则会生成：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	Sleep(<span class="number">5000</span>);	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"hello world"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><h3 id="宏定义命令"><a href="#宏定义命令" class="headerlink" title="宏定义命令"></a>宏定义命令</h3><p><code>#define</code>叫做宏定义命令，它也是 C 语言预处理命令的一种。所谓宏定义， 就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">20</span> + N; <span class="comment">// int sum = 20 + 100</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/14.png"></p>
<p>从上述示例代码输出结果可以得出结论：</p>
<ul>
<li><code>int sum = 20 + N</code>，<code>N</code>被 100 代替了。</li>
<li><code>#define N 100</code>就是宏定义，<code>N</code>为宏名，100 是宏的内容（宏所表示的字符串）。在预处理阶段，对<br>程序中所有出现的<code>宏名</code>，预处理器都会用宏定义中的字符串去代换，这称为<code>宏替换</code>或<code>宏展开</code>。</li>
<li>宏定义是由源程序中的宏定义命令<code>#define</code>完成的，<strong>宏替换是由预处理程序完成的。</strong></li>
</ul>
<h3 id="宏定义的形式"><a href="#宏定义的形式" class="headerlink" title="宏定义的形式"></a>宏定义的形式</h3><p>#define 宏名 字符串</p>
<p><code>#</code>表示这是一条预处理命令，所有的预处理命令都以 # 开头。宏名是标识符的一种，命名规则和变量相同。字符串可以是数字、表达式、if 语句、函数等</p>
<p>这里所说的字符串是一般意义上的字符序列，不要和 C 语言中的字符串等同，它不需要双引号</p>
<p>程序中反复使用的表达式就可以使用宏定义</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宏定义的宏展开仅仅是源码级别的字符串替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M (m*m+3*m)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N n*n+3*n </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> sum1, sum2, m, n;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input a number: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">	</span><br><span class="line">	sum1 = <span class="number">3</span>*M + <span class="number">4</span>*M + <span class="number">5</span>*M; <span class="comment">// 宏展开为：3*(m*m+3*m) + 4*M(m*m+3*m) + 5*(m*m+3*m)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sum1 = %d\n"</span>, sum1);</span><br><span class="line">	</span><br><span class="line">	sum2 = <span class="number">3</span>*N + <span class="number">4</span>*N + <span class="number">5</span>*N; <span class="comment">// 宏展开为：3*n*n+3*n + 4*n*n+3*n + 5*n*n+3*n</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sum2 = %d\n"</span>, sum2);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/15.png"></p>
<h3 id="宏定义的注意事项"><a href="#宏定义的注意事项" class="headerlink" title="宏定义的注意事项"></a>宏定义的注意事项</h3><p>宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符， 它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。</p>
<p>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换</p>
<p><strong>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束</strong>。如要终止其作用域可使用<code>#undef</code>命令</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PI = %f"</span>, PI);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI <span class="comment">// 取消宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PI=%f"</span>, PI); <span class="comment">// 错误! 这里不能使用到已经取消宏定义 PI 了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"OK\n"</span>); <span class="comment">// 被双引号括起来的宏名不会被宏展开</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S PI*y*y</span></span><br></pre></td></tr></tbody></table></figure>

<p>习惯上 宏名用大写字母表示，以便于与变量区别。但也允许用小写字母</p>
<p>可用宏定义表示数据类型，使书写方便</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UINT unsigned int</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	UINT a, b; <span class="comment">// 宏替换 unsigned int a, b;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>宏定义表示数据类型和用<code>typedef</code>定义数据说明符的区别：宏定义只是简单的字符串替换，由预处理器来处理；而 typedef 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。</p>
<h3 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h3><p> C 语言允许宏带有参数。在宏定义中的参数称为<code>形式参数</code>，在宏调用中的参数称为<code>实际参数</code>，这点和函数有些类似</p>
<p>对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参</p>
<p>带参宏定义的一般形式为<code>#define 宏名( 形参列表) 字符串</code>，在字符串中可以含有各个形参</p>
<p>带参宏调用的一般形式为：<code>宏名( 实参列表)</code></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a &gt; b) ? a : b</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> x , y, max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input two numbers: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">	max = MAX(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"max = %d\n"</span>, max);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/16.png"></p>
<h3 id="带参宏定义的注意事项"><a href="#带参宏定义的注意事项" class="headerlink" title="带参宏定义的注意事项"></a>带参宏定义的注意事项</h3><p>带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (a &gt; b) ? a : b </span></span><br><span class="line"><span class="comment">// 上述如果写成了下面这样：宏名和参数列表之间有空格</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (a, b) (a &gt; b) ? a : b</span></span><br><span class="line"><span class="comment">// 将被认为是无参宏定义，宏名 MAX 代表字符串(a, b) (a&gt;b) ? a : b</span></span><br><span class="line"><span class="comment">// 而不是 : MAX(a, b) 代表 (a&gt;b) ? a : b 了</span></span><br></pre></td></tr></tbody></table></figure>

<p>在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型</p>
<p>在宏定义中，字符串内的形参通常要用括号括起来以避免出错。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQ1(y) (y) * (y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQ2(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> a, sq1, sq2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input a number: "</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">	sq1 = SQ1(a + <span class="number">1</span>); <span class="comment">// 宏展开：(a + 1) * (a + 1)</span></span><br><span class="line">	sq2 = SQ2(a + <span class="number">1</span>); <span class="comment">// 宏展开：a + 1 * a + 1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sq1 = %d\n"</span>, sq1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sq2 = %d\n"</span>, sq2);</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/17.png"></p>
<h3 id="带参宏定义和函数的区别"><a href="#带参宏定义和函数的区别" class="headerlink" title="带参宏定义和函数的区别"></a>带参宏定义和函数的区别</h3><p>宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。</p>
<p>函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SQ</span><span class="params">(<span class="type">int</span> y)</span> {</span><br><span class="line">	<span class="keyword">return</span> ((y)*(y));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= <span class="number">5</span>) {</span><br><span class="line">		<span class="comment">// 因为i++是后自增，所以会先进行函数调用再自增</span></span><br><span class="line">		<span class="comment">// 由于自增的问题，所以输出的时候要减一下，表示当时调用函数时的值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d^2 = %d\n"</span>, (i<span class="number">-1</span>), SQ(i++));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/18.png"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/19.png"></p>
<h2 id="常见预处理命令"><a href="#常见预处理命令" class="headerlink" title="常见预处理命令"></a>常见预处理命令</h2><p>预处理指令是以<code>#</code>号开头的代码行，<code>#</code>号必须是该行除了任何空白字符外的第一个字符。</p>
<p><code>#</code>后是指令关键字，在关键字和<code>#</code>号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>#</td>
<td>空指令，无任何效果</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则编译下面代码</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则编译下面代码</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的<code>#if</code>给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个<code>#if … #else</code>条件编译块</td>
</tr>
</tbody></table>
<h2 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h2><p>字符串可以使用字符数组表示，也可以使用字符指针指向一个字符串：</p>
<h3 id="用字符数组存放一个字符串"><a href="#用字符数组存放一个字符串" class="headerlink" title="用字符数组存放一个字符串"></a>用字符数组存放一个字符串</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1[]=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="type">char</span> str2[]= {<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="用字符指针指向一个字符"><a href="#用字符指针指向一个字符" class="headerlink" title="用字符指针指向一个字符"></a>用字符指针指向一个字符</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> * pStr = <span class="string">"yes"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>C语言对字符串常量”hello world”是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串常量，程序在定义字符串指针变量<code>pStr</code>时只是把字符串首地址（即存放字符串的字符数组的首地址）赋给<code>pStr</code>，图示：</p>
<p><img src="https://image.woodwhales.cn/053/images/20.png"></p>
<p>注意上图中的内存单元格中本质存储的不是字符，而是字符对应的 ASCII 码值。</p>
<p>细节注意：使用字符指针变量指向字符串时，首先这个指针变量会有自己的地址空间，在自己的地址空间中存储着字符数组的首地址。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="type">char</span> str2[] = {<span class="string">"hello"</span>};</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> * pStr = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"str1 = %p, &amp;str1[0] = %p\n"</span>, str1, &amp;str1[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"str2 = %p, &amp;str2[0] = %p\n"</span>, str2, &amp;str2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pStr = %p, &amp;pStr[0] = %p\n"</span>, pStr, &amp;pStr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/21.png">注意事项：</p>
<p>字符数组由若干个元素组成，每个元素放一个字符；而字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中（是字符串首地址）</p>
<p>对字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">14</span>];</span><br><span class="line">str = <span class="string">"hello world"</span>; <span class="comment">// 错误, 因为在第一行执行完毕之后，str本身就被定义指向了一块地址，</span></span><br><span class="line">					 <span class="comment">// 这个地址是个常量值，不允许再被赋值了</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'m'</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>

<p>对字符指针变量，采用下面方法赋值是可以的：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> * PStr = <span class="string">"yes"</span>;</span><br><span class="line">pStr = <span class="string">"hello world"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>图示：</p>
<p><img src="https://image.woodwhales.cn/053/images/22.png"></p>
<p>小结：如果定义了一个字符数组，那么它有确定的内存地址（即字符数组名是一个常量）；而定义一个字符指针变量时，它并未指向某个确定的字符数据，并且可以多次赋值。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一个变量，其值为另一个变量的地址( 上一小节的意图已经说明 )，即<strong>内存位置的直接地址</strong>。就像其他变量或常量一样，在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *intPtr; <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="type">double</span> *doublePtr; <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="type">float</span> *floatPtr; <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="type">char</span> *charPtr; <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针是一个用数值表示的地址。可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。</p>
<h4 id="指针递增操作（-）"><a href="#指针递增操作（-）" class="headerlink" title="指针递增操作（++）"></a>指针递增操作（++）</h4><p>数组在内存中是连续分布的。当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如<code>int *</code>指针，每<code>++</code>一次就增加 4 个字节。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> var[] = {<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>}; <span class="comment">// 定义一个 int 类型的数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i, *ptr; <span class="comment">// 定义整型变量，其中 ptr 是整型变量的指针变量</span></span><br><span class="line">	</span><br><span class="line">	ptr = var; <span class="comment">// 对指针初始化操作，即将数组的首地址赋值给 ptr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var[%d] = %d, &amp;var[%d] = %p \n"</span>, i, var[i], i, &amp;var[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ptr = %p, *ptr = %d \n"</span>, ptr, *ptr);</span><br><span class="line">		ptr++; <span class="comment">// 指针自增操作</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/23.png"></p>
<p>从上图输出的结果可以看出，地址的自增操作，其地址的值是按照对应的指针类型的大小进行自增的。</p>
<h4 id="指针递减操作（–）"><a href="#指针递减操作（–）" class="headerlink" title="指针递减操作（–）"></a>指针递减操作（–）</h4><p>递减操作和递增操作同理。数组在内存中是连续分布的。当对指针进行–时，指针会按照它指向的数据类型字节数大小减少，比如 <code>int *</code>指针，每<code>--</code>一次 就减少 4 个字节。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> var[] = {<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>}; <span class="comment">// 定义一个 int 类型的数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i, *ptr; <span class="comment">// 定义整型变量，其中 ptr 是整型变量的指针变量</span></span><br><span class="line">	</span><br><span class="line">	ptr = &amp;var[MAX<span class="number">-1</span>]; <span class="comment">// 对指针初始化操作，即将数组的首地址赋值给 ptr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( i = MAX<span class="number">-1</span>; i &gt;= <span class="number">0</span> ; i--) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"var[%d] = %d, &amp;var[%d] = %p \n"</span>, i, var[i], i, &amp;var[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ptr = %p, *ptr = %d \n"</span>, ptr, *ptr);</span><br><span class="line">		ptr--; <span class="comment">// 指针自减操作</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/24.png"></p>
<h4 id="指针的-操作"><a href="#指针的-操作" class="headerlink" title="指针的+/-操作"></a>指针的+/-操作</h4><p>当可以对指针按照指定的字节数大小进行 + 或者 – 的操作，可以快速定位你要的地址。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> var[] = {<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>};</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i, *ptr; </span><br><span class="line">	</span><br><span class="line">	ptr = var; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> index = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	ptr += index; <span class="comment">// 表示地址值 + index*指针类型大小</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"var[%d] = %d, &amp;var[%d] = %p \n"</span>, index, var[index], index, &amp;var[index]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr = %p, *ptr = %d \n"</span>, ptr, *ptr);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/25.png"></p>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>要让数组的元素 指向 int 或其他数据类型的地址(指针)。可以使用指针数组。</p>
<p>指针数组定义：数据类型 *指针数组名[大小]。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[<span class="number">3</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>ptr 声明为一个指针数组</p>
<p>由 3 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> var[] = {<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>};</span><br><span class="line">	<span class="type">int</span> i, *ptr[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line">		ptr[i] = &amp;var[i]; <span class="comment">/* 赋值为整数的地址 */</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Value of var[%d] = %d\n"</span>, i, *ptr[i] );</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Value of &amp;ptr[%d] = %p\n"</span>, i, &amp;ptr[i] );</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/26.png"></p>
<p>内存布局图：</p>
<p><img src="https://image.woodwhales.cn/053/images/27.png"></p>
<h3 id="指针数组应用实例"><a href="#指针数组应用实例" class="headerlink" title="指针数组应用实例"></a>指针数组应用实例</h3><p>定义一个指向字符的指针数组来存储字符串列表(四大名著书名)， 并通过遍历 该指针数组，显示字符串信息，即：定义一个指针数组，该数组的每个元素，指向的是一个字符串。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	<span class="comment">// 定义一个指针数组，该数组的每个元素，指向的是一个字符串</span></span><br><span class="line">	<span class="type">char</span> * books[] = {</span><br><span class="line">		<span class="string">"三国演义"</span>,</span><br><span class="line">		<span class="string">"西游记"</span>,</span><br><span class="line">		<span class="string">"红楼梦"</span>,</span><br><span class="line">		<span class="string">"水浒传"</span></span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, len = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\nbooks[%d] --&gt; %s"</span>, i, books[i]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/28.png"></p>
<h3 id="二级及多重指针"><a href="#二级及多重指针" class="headerlink" title="二级及多重指针"></a>二级及多重指针</h3><p>指向指针的指针是一种 多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p><img src="https://image.woodwhales.cn/053/images/29.png"></p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。</p>
<p>声明了一个指向 int 类型指针的指针：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> **ptr; <span class="comment">// ptr 的类型是：int **</span></span><br></pre></td></tr></tbody></table></figure>

<p>当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，比如<code>**ptr</code></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> var;</span><br><span class="line">	<span class="type">int</span> *ptr;</span><br><span class="line">	<span class="type">int</span> **pptr;</span><br><span class="line"></span><br><span class="line">	var = <span class="number">3000</span>;</span><br><span class="line">	ptr = &amp;var;</span><br><span class="line">	pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"var address = %p , var = %d \n"</span>, &amp;var, var);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ptr address = %p , ptr = %p , *ptr = %d \n"</span>, &amp;ptr, ptr, *ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pptr address = %p , pptr = %p , **ptr = %d \n"</span>, &amp;pptr, pptr, **pptr);</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出节果：</p>
<p><img src="https://image.woodwhales.cn/053/images/30.png"></p>
<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>当函数的形参类型是指针类型时，是使用该函数时，需要传递指针，或者地址，或者数组给该形参</p>
<h3 id="传递指针-地址-给函数"><a href="#传递指针-地址-给函数" class="headerlink" title="传递指针(地址)给函数"></a>传递指针(地址)给函数</h3><p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i, num=<span class="number">90</span>;</span><br><span class="line">	<span class="type">int</span> *p = &amp;num;</span><br><span class="line">	</span><br><span class="line">	test(&amp;num); <span class="comment">//传地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nmain() 中的num=%d"</span>, num);</span><br><span class="line">	</span><br><span class="line">	test(p); <span class="comment">//传指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nmain() 中的num=%d"</span>, num);</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *p)</span> {</span><br><span class="line">	*p += <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/31.png"></p>
<h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h3><p>C语言 允许函数的返回值是一个指针（地址），这样的函数称为指针函数。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回的char * (指针)</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strlong</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span>{ 	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nstr1.len = %d str2.len = %d"</span>, <span class="built_in">strlen</span>(str1), <span class="built_in">strlen</span>(str1));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2)){</span><br><span class="line">		<span class="keyword">return</span> str1;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">return</span> str2;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>], *str;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入第1个字符串"</span>);</span><br><span class="line">	gets(str1);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n请输入第2个字符串"</span>);</span><br><span class="line">	gets(str2);</span><br><span class="line">	</span><br><span class="line">	str = strlong(str1, str2);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nLonger string: %s \n"</span>, str);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/32.png"></p>
<h3 id="返回指针函数的注意事项"><a href="#返回指针函数的注意事项" class="headerlink" title="返回指针函数的注意事项"></a>返回指针函数的注意事项</h3><p>用指针作为函数返回值时需要注意，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针不能指向这些数据。</p>
<blockquote>
<p>函数运行结束后会销 毁该函数所 有的局部数据 ，这里所谓的销毁并不是将局部数据所占用的内存全部清零，而是程序放弃对它的使用权限，后面的代码可以使用这块内存。</p>
</blockquote>
<p><strong>C 语言不支持在调用函数时返回局部变量的地址，如果确实有这样的需求，需要定义局部变量为 static 变量</strong>。因为被 static  修饰的局部变量会存储在静态数据区，而不是栈中。</p>
<p>代码示例（危险的使用示例）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">func</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> *p = func(); <span class="comment">// 调用完 func() 方法，其方法中的局部变量的使用权被回收了</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nhello"</span>); <span class="comment">// 这行打印语句可能会使用到上述被回收使用权的内存空间</span></span><br><span class="line">	</span><br><span class="line">	n = *p; <span class="comment">// 由于func()方法的局部变量空间使用权被回收了，那么它的地址会被其他程序使用到，会修改成其他的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nvalue = %d\n"</span>, n);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/33.png"></p>
<p>代码示例（正确的使用示例，使用 static 修饰局部变量）：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">func</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> n = <span class="number">100</span>; <span class="comment">// static 修饰的局部变量会存储在静态数据区，而不是栈里面</span></span><br><span class="line">	<span class="keyword">return</span> &amp;n;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> *p = func(); <span class="comment">// 调用完 func() 方法，其方法中的静态局部变量的使用权不会被回收</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nhello"</span>); </span><br><span class="line">	</span><br><span class="line">	n = *p;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nvalue = %d\n"</span>, n);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/34.png"></p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>编写一个函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * <span class="title function_">getRandArray</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> arr[<span class="number">10</span>] ; <span class="comment">// static 修饰的局部变量会存储在静态数据区，而不是栈里面</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===getRandArray start=== \n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		arr[i] = rand();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"arr[%d] = %d\n"</span>, i, arr[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"===getRandArray end=== \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> * ptr = getRandArray();</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"arr[%d] = %d \n"</span>, i, *(ptr + i));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/35.png"></p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。</p>
<p><strong>把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指 针。</strong></p>
<h3 id="函数指针定义"><a href="#函数指针定义" class="headerlink" title="函数指针定义"></a>函数指针定义</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<ul>
<li>returnType 为函数返回值类型</li>
<li>pointerName 为指针名称</li>
<li>param list 为函数指针指向的函数参数列表</li>
<li>参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称</li>
<li>注意<code>()</code>的优先级高于<code>*</code>，第一个括号不能省略，如果写作<code>returnType *pointerName(param list);</code>就成了函数原型，它表明函数的返回值类型为<code>returnType *</code></li>
</ul>
<h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><p>用 函数指 针来实现对函数的调用，返回两个整数中的最大值。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> x, y, maxVal;</span><br><span class="line">	<span class="type">int</span> (*pmax)(<span class="type">int</span>, <span class="type">int</span>) = max; <span class="comment">// 使用pmax函数指针接收 max 函数的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Input two numbers:"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">	</span><br><span class="line">	maxVal = (*pmax)(x, y); <span class="comment">// 使用函数指针调用 max 函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Max value: %d\n"</span>, maxVal);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/36.png"></p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单的讲：回调函数是由别人的函数执行时调用你传入的函数（通过函数指针完成）。</p>
<h3 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h3><p>使用回调函数的方式，给一个整型数组<code>int arr[10]</code>赋 10 个随机数。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRandomValue</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">	<span class="keyword">return</span> rand();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initAray</span><span class="params">(<span class="type">int</span> * <span class="built_in">array</span>, <span class="type">int</span> arraySize,<span class="type">int</span> (* getRandomValuePtr)(<span class="type">void</span>))</span> {</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arraySize; i++) {</span><br><span class="line">		<span class="built_in">array</span>[i] = getRandomValuePtr();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	initAray(arr, <span class="number">10</span>, getRandomValue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n arr[%d] = %d"</span>, i, arr[i]);</span><br><span class="line">	}</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/37.png"></p>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>指针变量存放的是地址，从这个角度看指针的本质就是地址。</p>
<p>变量声明的时候，如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯。</p>
<p>赋为 NULL 值的指针被称为空指针，NULL 指针是一个定义在标准库<code>&lt;stdio.h&gt;</code>中的值为零的常量<code>#define NULL 0</code></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> * ptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">	ptr = &amp;num;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*ptr = %d \n"</span>, *ptr);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/38.png"></p>
<h2 id="内存动态分配"><a href="#内存动态分配" class="headerlink" title="内存动态分配"></a>内存动态分配</h2><p>C 程序中，不同数据在内存中分配说明：</p>
<p>全局变量：内存中的静态存储区</p>
<p>非静态的局部变量：内存中的动态存储区（stack 栈）</p>
<p>临时使用的数据：建立动态内存分配区域，需要时随时开辟，不需要时及时释放（heap 堆）</p>
<p>根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用）</p>
<p><img src="https://image.woodwhales.cn/053/images/39.png"></p>
<h2 id="内存动态分配的相关函数"><a href="#内存动态分配的相关函数" class="headerlink" title="内存动态分配的相关函数"></a>内存动态分配的相关函数</h2><p> 头文件<code>#Include &lt;stdlib.h&gt;</code>声明了四个关于内存动态分配的函数：</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>函数原型：<code>void * malloc (usigned int size)</code></p>
<p>作用：在内存的 动态存储 区( 堆区)中分配一个长度为<code>size</code>的<strong>连续空间</strong>。</p>
<p>形参<code>size</code>的类型为<strong>无符号整型</strong>，函数返回值是所分配区域的第一个字节的地址，即此函数是一个指针型函数，返回的指针指向该分配域的开头位置。</p>
<p><code>malloc(100);</code>表示开辟 100 字节的临时空间，返回值为其第一个字节的地址。</p>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h3><p>函数原型：<code>void * calloc (unsigned n, unsigned size) </code></p>
<p>作用：在内存的动态存储区中分配<code>n</code>个长度为<code>size</code>的连续空间，这个空间一般比较大，足以保存一个数组。</p>
<p>用 calloc 函数可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size。</p>
<p>函数返回指向所分配域的起始位置的指针，分配不成功，返回NULL。</p>
<p><code>p = calloc(50, 4);</code> 表示开辟<code>50*4</code>个字节临时空间，把起始地址分配给指针变量 p</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>函数原型：<code>void free (void *p) </code></p>
<p>作用：释放变量<code>p</code>所指向的动态空间，使这部分空间能重新被其他变量使用。</p>
<p><code>p</code>是最近一次调用<code>calloc</code>或<code>malloc</code>函数时的函数返回值。</p>
<p>free 函数无返回值</p>
<p><code>free(p);</code>表示释放<code>p</code>所指向的已分配的动态空间</p>
<h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><p>函数原型：<code>void *realloc (void *p, unsigned int size)</code></p>
<p>作用：重新分配<code>malloc</code>或<code>calloc</code>函数获得的动态空间大小，将p指向的动态空间大小改变为<code>size</code>，<code>p</code>的值不变，分配失败返回NULL。</p>
<p><code>realloc(p, 50);</code> 表示将<code>p</code>所指向的已分配的动态空间改为 50 字节。</p>
<h3 id="返回类型说明"><a href="#返回类型说明" class="headerlink" title="返回类型说明"></a>返回类型说明</h3><p>C99 标准把以上的<code>malloc</code>，<code>calloc</code>，<code>realloc</code>函数的基类型定为<code>void</code>类型，这种指针称为无类型指针（typeless pointer），即不指向哪一种具体的类型数据，只表示用来指向一个抽象的类型的数据，即仅提供一个纯地址，而不能指向任何具体的对象。</p>
<h3 id="void指针类型"><a href="#void指针类型" class="headerlink" title="void指针类型"></a>void指针类型</h3><p>C99 允许使用基类型为 void 的指针类型。可以定义一个基类型为 void 的指针变量（即 void * 型变量），它不指向任何类型的数据。请注意：不要把“指向 void 类型”理解为能指向“任何的类型”的数据，而应该理解为“指向空类型”或“不指向确定的类型”的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。例如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;					<span class="comment">// 定义 a 为整型变量</span></span><br><span class="line"><span class="type">int</span> * p1 = &amp;a;				<span class="comment">// p1 指向 int 型变量</span></span><br><span class="line"><span class="type">char</span> * p2;					<span class="comment">// p2 指向 char 型变量</span></span><br><span class="line"><span class="type">void</span> * p3;					<span class="comment">// p3 为无类型指针变量（基类型为 void 型）</span></span><br><span class="line">p3 = (<span class="type">void</span> *)p1;			<span class="comment">// 将 p1 的值转换为 void * 类型，然后赋值给 p3</span></span><br><span class="line">p2 = (<span class="type">char</span> *)p3;			<span class="comment">// 将 p3 的值转换为 char * 类型，然后赋值给 p2</span></span><br><span class="line">prinf(<span class="string">"%d"</span>, *p1); 			<span class="comment">// 合法，输出 a 的值</span></span><br><span class="line">p3 = &amp;a; prinf(<span class="string">"%d"</span>, *p3); 	<span class="comment">// 错误，p3是无指向的，不能指向a</span></span><br></pre></td></tr></tbody></table></figure>

<p>说明：当把 void 指针赋值给不同基类型的指针变量（或相反）时，C99 及以上的编译系统会自动进行转换，不必用户自己强制转换。例如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">p3 = &amp;a;</span><br></pre></td></tr></tbody></table></figure>

<p>相当于<code>p3 = (void *)&amp;a;</code>，赋值后 p3 得到 a 的纯地址，但并不指向 a，不能通过 *p3 输出 a 的值。</p>
<h3 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h3><p>动态创建数组，输入 5 个学生的成绩，另外一个函数检测成绩低于 60 分的，输出不合格的成绩。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> * p,i;</span><br><span class="line">	p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 在堆中开辟 5 个int大小的内存空间，共 5*4 = 20个字节</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++){</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	check(p); <span class="comment">// 遍历int数组，打印不及格的成绩</span></span><br><span class="line">	<span class="built_in">free</span>(p); <span class="comment">// 释放堆内存</span></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> * ptr)</span> {</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n 不及格的成绩有："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">		<span class="keyword">if</span>(ptr[i] &lt; <span class="number">60</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, ptr[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/40.png"></p>
<h3 id="动态分配内存的基本原则"><a href="#动态分配内存的基本原则" class="headerlink" title="动态分配内存的基本原则"></a>动态分配内存的基本原则</h3><p>避免分配大量的小内存块。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大</p>
<p>仅在需要时分配内存。只要 使用完堆上的内存块， 就需要及时释放它（如果使用动态分配内存，需要遵守原则：<strong>谁分配，谁释放</strong>）， 否则可能出现内存泄漏</p>
<p>总是确保释放以分配的内存。在编写分配内存的代码时，就要确定在代码的什么地方释放内存</p>
<p>在释放内存之前，确保不会无意中覆盖堆上已分配的内存地址，否则程序就会出现内存泄漏 。在循环中分配内存时，要特别小心。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体的声明方式：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 {</span></span><br><span class="line">    成员列表;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>注意：结构体名称一般首字母大写，结构体的花括号后面紧跟<code>;</code>分号。</p>
<p>形如：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">    <span class="type">char</span> * name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="type">char</span> group; <span class="comment">// 所在学习小组</span></span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 成绩</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>从叫法上看：有些书上称为成员，有些书说 结构体包含的变量</p>
<p>成员是结构体的一个组成部分，一般是<code>基本数据类型</code>、也可以是<code>数组</code>、<code>指针</code>、<code>结构体</code>等 。</p>
<h3 id="声明细节"><a href="#声明细节" class="headerlink" title="声明细节"></a>声明细节</h3><p>成员声明语法同变量一声明方式一样，示例： <code>数据类型 成员名;</code></p>
<p>字段的类型可以为：基本类型、数组或指针、结构体等。</p>
<p>在创建一个结构体变量后，需要给成员赋值，如果没有赋值就使用可能导致程序异常终止。</p>
<p>不同结构体变量的成员是独立，互不影响，一个结构体变量的成员更改，不影响另外一个。</p>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><p>方式一：先定义结构体，再创建结构体变量</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">  <span class="type">char</span> * name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span> </span><br></pre></td></tr></tbody></table></figure>

<p>方式二：在定义结构体的同时定义结构体变量</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">  <span class="type">char</span> * name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">} stu1, stu2; </span><br></pre></td></tr></tbody></table></figure>

<p>方式三：如果只需要 stu1 和 stu2 两个变量，后面不需要再使用该结构体数据类型去定义其他变量，在定义结构体时可以不给出结构体名称。这种结构体称为匿名结构体。</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="type">char</span> * name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">} stu1, stu2; </span><br></pre></td></tr></tbody></table></figure>

<h3 id="成员值的获取和赋值"><a href="#成员值的获取和赋值" class="headerlink" title="成员值的获取和赋值"></a>成员值的获取和赋值</h3><p>结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标<code>[]</code>获取单个元素，结构体使用点号<code>.</code>获取单个成员。获取结构体成员的一般格式为：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">结构体变量名.成员名;</span><br></pre></td></tr></tbody></table></figure>

<p>赋值操作示例 1：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">  <span class="type">char</span> * name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">} stu1, stu2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line">stu1.name = “woodwhales”;</span><br><span class="line">stu1.age = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>赋值操作示例 2：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> {</span></span><br><span class="line">  <span class="type">char</span> * name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">} stu1 = {<span class="string">"woodwhales"</span>, <span class="number">12</span>}, stu2 = {<span class="string">"king"</span>, <span class="number">15</span>};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu3</span> =</span> {<span class="string">"tim"</span>, <span class="number">16</span>};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu4</span>;</span></span><br><span class="line"><span class="comment">// stu4 = {"tom", 20};  // 不允许这样方式赋值</span></span><br><span class="line">stu4.name = <span class="string">"jack"</span>; <span class="comment">// 结构体变量定义时没有整体赋值，那么只能只用.一个个对成员变量赋值</span></span><br><span class="line">stu4.age = <span class="number">16</span>; <span class="comment">// 结构体变量定义时没有整体赋值，那么只能只用.一个个对成员变量赋值</span></span><br></pre></td></tr></tbody></table></figure>

<p>说明：结构体声明时带不带结构体名称不会影响赋值上述俩种赋值操作。</p>
<h3 id="应用实例-4"><a href="#应用实例-4" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="小狗案例"><a href="#小狗案例" class="headerlink" title="小狗案例"></a>小狗案例</h4><p>编写一个 Dog 结构体，包含 name(char[10])、age(int)、weight(double) 属性</p>
<p>编写一个 say 函数，返回字符串，方法返回信息中包含所有成员值。</p>
<p>在 main 方法中，创建 Dog 结构体变量，调用 say 函数，将调用结果打印输出 。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> {</span></span><br><span class="line">	<span class="type">char</span> * name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">double</span> weight;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">say</span><span class="params">(<span class="keyword">struct</span> Dog dog)</span> {</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> info[<span class="number">50</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(info, <span class="string">"name = %s, age = %d, weight = %2f\n"</span>, dog.name, dog.age, dog.weight);</span><br><span class="line">	dog.name = <span class="string">"小黑"</span>; <span class="comment">// 结构体变量默认是值传递，调用者的结构体不会被影响</span></span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog</span>;</span></span><br><span class="line">	<span class="type">char</span> * info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	dog.name = <span class="string">"旺财"</span>;</span><br><span class="line">	dog.age = <span class="number">5</span>;</span><br><span class="line">	dog.weight = <span class="number">10.5</span>;</span><br><span class="line"></span><br><span class="line">	info = say(dog); <span class="comment">// 结构体变量默认是值传递</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nsay() return = %s"</span>, info);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main() dog.name = %s \n"</span>, dog.name);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/41.png"></p>
<h4 id="景区门票案例"><a href="#景区门票案例" class="headerlink" title="景区门票案例"></a>景区门票案例</h4><p>一个景区根据游人的年龄收取不同价格的门票。</p>
<p>请编写游人结构体(Visitor)，根据年龄段决定能够购买的门票价格并输出</p>
<p>规则：年龄大于18，门票为20元，其它情况免费。</p>
<p>可以循环从控制台输入名字和年龄，打印门票收费情况, 如果名字输入 n，则退出程序。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Visitor</span> {</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">double</span> pay;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为结构体默认是值传递，每次函数被调用就会拷贝一份完整数据，效率较低。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ticket</span><span class="params">(<span class="keyword">struct</span> Visitor * visitor)</span> {</span><br><span class="line">	<span class="keyword">if</span>((*visitor).age &gt; <span class="number">18</span>) {</span><br><span class="line">		(*visitor).pay = <span class="number">20</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		(*visitor).pay = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Visitor</span> <span class="title">visitor</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n 请输入游客的名字："</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, visitor.name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"n"</span>, visitor.name)) {</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n 请输入游客的年龄："</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;visitor.age);</span><br><span class="line">		ticket(&amp;visitor);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n 该游客应付票价为：%.2f\n"</span>, visitor.pay);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n 程序退出"</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/42.png"></p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（Union ）属于 构造类型，它可以包含多个类型不同的成员。和结构体非常类似，但是也有不同的地方。</p>
<p>共用体有时也被称为联合或者联合体，定义格式为：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名 {</span></span><br><span class="line"> 	成员列表;   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而<strong>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</strong></p>
<h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p>方式一：先定义共用体，再创建共用体变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> {</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></tbody></table></figure>

<p>方式二：在定义共用体的同时定义共用体变量</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> {</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">} a, b, c;</span><br></pre></td></tr></tbody></table></figure>

<p>方式三：如果只需要 a、b、c 三个变量，后面不需要再使用该共用体数据类型去定义其他变量，在定义共用体时可以不给出共用体名称。这种共用体称为匿名共用体。</p>
<p>示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line">} a, b, c;</span><br></pre></td></tr></tbody></table></figure>

<p>共用体成员</p>
<h3 id="占用空间细节注意"><a href="#占用空间细节注意" class="headerlink" title="占用空间细节注意"></a>占用空间细节注意</h3><p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data 共用体的包含三个成员，三个成员的空间是共享的，该共用体空间的大小以占用空间最大的成员为准</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> {</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">short</span> m;</span><br><span class="line">};</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">a</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">sizeof</span>(a), <span class="keyword">sizeof</span>(<span class="keyword">union</span> Data));</span><br><span class="line">	</span><br><span class="line">	a.n = <span class="number">0x40</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">	</span><br><span class="line">	a.ch = <span class="string">'9'</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">	</span><br><span class="line">	a.m = <span class="number">0x2059</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">	</span><br><span class="line">	a.n = <span class="number">0x3E25AD54</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d, %c, %d\n"</span>, a.n, a.ch, a.m);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/43.png"></p>
<h3 id="内存占用详解"><a href="#内存占用详解" class="headerlink" title="内存占用详解"></a>内存占用详解</h3><p>上述输出结果的内存示意图：</p>
<p>共用体的占用空间是以占用空间最大的成员为准，因此初始化的共用体内存占用情况为：</p>
<p><img src="https://image.woodwhales.cn/053/images/44.png"></p>
<p>成员变量的占用空间均是从低位对齐，赋值操作也是从低位填充：</p>
<p><img src="https://image.woodwhales.cn/053/images/45.png"></p>
<p>读取共用体中的成员变量，也是根据该成员变量的类型大小，从低位开始读取：</p>
<p><img src="https://image.woodwhales.cn/053/images/46.png"></p>
<p>因此共用体内存状态处于上述图示所示时，依次读取成员变量的值为：</p>
<p>char 类型读取到的十进制数值为：64，对应 ASCII 码表为<code>@</code>符号。</p>
<p>short 类型读取到的十进制数值为：64。</p>
<p>int 类型读取到的十进制数值为：64。</p>
<p>再次对 int 类型的成员变量进行赋值操作：</p>
<p><img src="https://image.woodwhales.cn/053/images/47.png"></p>
<p>再次读取共用体中成员变量的值，图示：</p>
<p><img src="https://image.woodwhales.cn/053/images/48.png"></p>
<p>char 类型读取到的十进制数值为：89，对应 ASCII 码表为<code>Y</code>符号。 </p>
<p>short 类型读取到的十进制数值为：8281。</p>
<p>int 类型读取到的十进制数值为：8281。</p>
<p>再次赋值，次读取：</p>
<p><img src="https://image.woodwhales.cn/053/images/49.png"></p>
<p>其中 short 类型首先读取到的二进制为：<code>1010,1101,0101,0100 </code>，这个二进制对计算机来说是补码，因此计算之前要进行转码，将符号位不变，其他位取反并加 1，得到的值是个正数，再加上负号，就是十进制原码数值。</p>
<p>char 类型读取到的十进制数值为：84，对应 ASCII 码表为<code>T</code>符号。 </p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>现有一张关于学生信息和教师信息的表格：</p>
<p>学生信息包括姓名、编号、性别、职业、分数。</p>
<p>教师的信息包括姓名、编号、性别、职业、教学科目。</p>
<p>请看下面的表格：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>num</th>
<th>gender</th>
<th>profession</th>
<th>score/course</th>
</tr>
</thead>
<tbody><tr>
<td>孙二娘</td>
<td>501</td>
<td>女（f）</td>
<td>学生（s）</td>
<td>90.5</td>
</tr>
<tr>
<td>吴用</td>
<td>302</td>
<td>男（m）</td>
<td>老师（t）</td>
<td>math</td>
</tr>
<tr>
<td>顾大嫂</td>
<td>109</td>
<td>女（f）</td>
<td>老师（t）</td>
<td>english</td>
</tr>
<tr>
<td>林冲</td>
<td>982</td>
<td>男（m）</td>
<td>学生（s）</td>
<td>95.5</td>
</tr>
</tbody></table>
<p>请使用共用体编程完成。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL 2 <span class="comment">//人员总数</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> gender;</span><br><span class="line">	<span class="type">char</span> profession;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span> <span class="comment">// 匿名的共用体</span></span><br><span class="line">		<span class="type">float</span> score;</span><br><span class="line">		<span class="type">char</span> course[<span class="number">20</span>];</span><br><span class="line">	} sc;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">persons</span>[<span class="title">TOTAL</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TOTAL; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"input info : "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s %d %c %c"</span>, persons[i].name, &amp;(persons[i].num),</span><br><span class="line">			&amp;(persons[i].gender), &amp;(persons[i].profession));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(persons[i].profession == <span class="string">'s'</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"请输入该学生的成绩 ： "</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;persons[i].sc.score);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"请输入该老师的课程 ： "</span>);</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%s"</span>, persons[i].sc.course);</span><br><span class="line">		}</span><br><span class="line">		fflush(<span class="built_in">stdin</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nName\t\tNum\t\tGender\t\tProfession\tScore/Course\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TOTAL; i++) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\t\t%d\t\t%c\t\t%c\t\t"</span>, persons[i].name, persons[i].num, persons[i].gender, persons[i].profession);</span><br><span class="line">		<span class="keyword">if</span>(persons[i].profession == <span class="string">'s'</span>) {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, persons[i].sc.score);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, persons[i].sc.course);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/50.png"></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件是数据源（保存数据的地方）的一种，比如大家经常使用的 word 文档，txt 文件，excel 文件等都是文件。文件最主要的作用就是保存数据，它既可以保存一张图片，也可以保持视频，声音等。</p>
<p>文件在程序中是以流的形式来操作的。</p>
<p><img src="https://image.woodwhales.cn/053/images/51.png"></p>
<p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p>
<p>输 入流：数据从数据源（文件）到程序（内存）的路径</p>
<p>输 出流：数据从程序（内存）到数据源（文件）的路径</p>
<p>C 标准库<code>stdio.h</code>该头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出，在开发过程中，可以查询手册。</p>
<h3 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入&amp;输出"></a>输入&amp;输出</h3><p>当我们提到<code>输入</code>时，这意味着要向程序写入一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要写入到程序中。</p>
<p>当我们提到<code>输出</code>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p>
<h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><p><strong>C 语言把所有的设备都当作文件。</strong>所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>设备</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>您的屏幕</td>
</tr>
</tbody></table>
<p><strong>文件指针是访问文件的方式</strong>，我们会讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p>
<p>C 语言中的 I/O （输入/输出）通常使用<code>printf() </code> 和<code>scanf()</code>两个函数。<code>scanf()</code>函数用于从标准输入（键盘）读取并格式化，<code>printf()</code>函数发送格式化输出到标准输出（屏幕）。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 执行 printf() 函数需要该库</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>); <span class="comment">// 显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h3 id="getchar-putchar-函数"><a href="#getchar-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p><code>int getchar(void)</code>函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p><code>int putchar(int c)</code>函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span> {</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">	c = getchar(); <span class="comment">// 接收键盘输入的单一字符</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"\nYou entered: "</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(c); <span class="comment">// 输出键盘输入的字符到屏幕</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	getchar(); <span class="comment">// 过滤键盘输入的回车符号</span></span><br><span class="line">	getchar(); <span class="comment">// 暂停程序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/52.png"></p>
<h3 id="gets-puts-函数"><a href="#gets-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p><code>char *gets(char *s)</code>函数从<code>stdin</code>读取一行到 s 所指向的缓冲区，直到一个终止符或<code>EOF</code>。</p>
<p><code>int puts(const char *s)</code>函数把字符串 s 和一个尾随的换行符写入到<code>stdout</code>。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span> {</span><br><span class="line">	<span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"Enter value :"</span>);</span><br><span class="line">	gets(str); <span class="comment">// 接收键盘输入的一串字符串</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"\nYou entered: "</span>);</span><br><span class="line">	<span class="built_in">puts</span>(str); <span class="comment">// 输出键盘输入的字符串到屏幕</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	getchar(); <span class="comment">// 暂停程序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/53.png"></p>
<h3 id="scanf-和-和-printf-函数"><a href="#scanf-和-和-printf-函数" class="headerlink" title="scanf() 和 和 printf() 函数"></a>scanf() 和 和 printf() 函数</h3><p><code>int scanf(const char *format, ...)</code>函数从标准输入流<code>stdin</code>读取输入，并根据提供的<code>format</code>来浏览输入。</p>
<p><code>int printf(const char *format, ...)</code>函数把输出写入到标准输出流<code>stdout</code>，并根据提供的格式产生输出。</p>
<blockquote>
<p><code>format</code>可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span> {</span><br><span class="line">	<span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"Enter value :"</span>);</span><br><span class="line">	<span class="comment">// 要求出入字符串之后必须有一个空格才能接收一个整型数字，不按照格式输入，那么程序可能会报异常</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, str, &amp;i);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">"\nYou entered: %s, %d"</span>, str, i);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	getchar(); <span class="comment">// 过滤回车</span></span><br><span class="line">	getchar(); <span class="comment">// 暂停程序</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/54.png"></p>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>使用<code>fopen()</code>函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型<code>FILE</code>的一个对象，类型<code>FILE</code>包含了所有用来控制流的必要的信息。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个： </p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。<strong>如果文件存在，则该会被截断为零长度，重新写入。</strong></td>
</tr>
<tr>
<td>a</td>
<td>打开一个文本文件，以<strong>追加模式写入文件</strong>。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody></table>
<p>如果处理的是<strong>二进制文件（图片、视频等）</strong>，则需使用下面的访问模式来取代上面的访问模式：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"rb"</span>, <span class="string">"wb"</span>, <span class="string">"ab"</span>, <span class="string">"rb+"</span>, <span class="string">"r+b"</span>, <span class="string">"wb+"</span>, <span class="string">"w+b"</span>, <span class="string">"ab+"</span>, <span class="string">"a+b"</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>b</code>是指 binary，代表二进制的意思。</p>
<p>综上，对于<code>w</code>或<code>w+</code>模式一定要慎重小心使用。</p>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p> 为了关闭文件，请使用<code>fclose()</code>函数。函数的原型如下： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">( FILE *fp )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果成功关闭文件，<strong>fclose()</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。 </p>
<p><strong>使用完文件（读或写文件）之后，一定要将该文件关闭。</strong></p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p> 把字符写入到流中的最简单的函数： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> c, FILE *fp )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p> 函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, FILE *fp )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>说明：函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用<code>int fprintf(FILE \*fp, const char \*format, ...)</code>函数来写把一个字符串写入到文件中。</p>
<p>代码示例：</p>
<p>以下程序执行之前，D 盘符的根目录下没有一个叫：hello.txt 的文件，以下程序使用了<code>w</code>模式打开并操作文件，那么在指定目录下没有该文件就会创建这个文件。如果该文件已存在，那么就会清空该文件原有的内容。因此谨慎测试本程序。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span> {</span><br><span class="line">	FILE * fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	fp = fopen(<span class="string">"D:\\hello.txt"</span>, <span class="string">"w"</span>); <span class="comment">// w 模式会将已存在的文件内容进行清空！</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">"woodwhales.github.io\n"</span>);</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">"hello world\n"</span>, fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一定要关闭文件</span></span><br><span class="line">	result = fclose(fp);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!result) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件创建并写入成功！\n"</span>);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"文件操作失败！\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出效果：</p>
<p><img src="https://image.woodwhales.cn/053/images/55.png"></p>
<p>写入文件切记要关闭文件，否则文件中新写的内容不会被成功写入文件。</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p> 下面是从文件读取单个字符的最简单的函数： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">( FILE * fp )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。</p>
<p>下面的函数允许您从流中读取一个字符串： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">( <span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>说明：</p>
<p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p>
<p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。</p>
<p>也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个回车字符时，它会停止读取。</p>
<p>代码示例：</p>
<p>以下代码执行之前，在 D 盘符已经存在一个名称叫：hello.txt 的文件，里面存储了一些文本内容。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">	fp = fopen(<span class="string">"D:\\hello.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">	<span class="comment">// 读取文件方式1</span></span><br><span class="line">	<span class="comment">//fscanf(fp, "%s", buff); // 只能读取一行</span></span><br><span class="line">	<span class="comment">//printf("%s\n", buff); // 输出读取到的文件内容</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取文件方式2</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(fgets(buff, <span class="number">1024</span>, fp) != <span class="literal">NULL</span>) { <span class="comment">// 循环读取文件内容，如果读到NULL就结束读取</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>, buff);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fclose(fp);</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<p><img src="https://image.woodwhales.cn/053/images/56.png"></p>
]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>win10重装系统之后的个性化设置</title>
    <url>/2020/02/26/057/</url>
    <content><![CDATA[<p><strong>敬告：重装系统之前一定切记将桌面及C盘中所有重要的文件全部备份到其他盘符中，否则造成数据丢失且很难找回！</strong></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote>
<p>镜像地址：<a href="https://msdn.itellyou.cn/">MSDN, 我告诉你</a></p>
</blockquote>
<p>将下载好的 iso 文件解压，双击运行<code>setup.exe</code>文件即可重新安装操作系统，默认直接安装在 C 盘符。</p>
<p>安装成功之后，C 盘符中会存在一个<code>windows.old</code>的文件夹，将其彻底删除即可。</p>
<h3 id="系统激活"><a href="#系统激活" class="headerlink" title="系统激活"></a>系统激活</h3><p>笔者目前使用到也是从网络中搜索的资源，不具有普适性，只能靠读者自行找法子，这里给出一些可以参考的资源：</p>
<blockquote>
<p>win10数字激活工具：<a href="https://www.tenlonstudio.com/3826.html">https://www.tenlonstudio.com/3826.html</a></p>
<p>Win10 LTSC 2019激活码：<a href="http://www.xitongtiandi.net/wenzhang/key/35844.html">http://www.xitongtiandi.net/wenzhang/key/35844.html</a></p>
<p>win10企业版LTSC永久激活教程：<a href="http://www.xitongtiandi.net/wenzhang/win10/37383.html">http://www.xitongtiandi.net/wenzhang/win10/37383.html</a></p>
</blockquote>
<h2 id="系统个性化设置"><a href="#系统个性化设置" class="headerlink" title="系统个性化设置"></a>系统个性化设置</h2><p>注意以下操作的前提是：该系统是已经激活的状态。</p>
<h3 id="桌面显示”计算机”等图样"><a href="#桌面显示”计算机”等图样" class="headerlink" title="桌面显示”计算机”等图样"></a>桌面显示”计算机”等图样</h3><p>右击桌面的空白处，选择<code>个性化</code>选项，选择<code>主题</code>，点击<code>桌面图标设置</code>：</p>
<img src="https://image.woodwhales.cn/057/images/windows/1.png" style="zoom:75%;">

<p><img src="https://image.woodwhales.cn/057/images/windows/2.png"></p>
<p>勾选要显示的系统图标，并点击<code>确定</code>按钮即可。</p>
<h3 id="显示：文件后缀名及隐藏的文件-文件夹"><a href="#显示：文件后缀名及隐藏的文件-文件夹" class="headerlink" title="显示：文件后缀名及隐藏的文件/文件夹"></a>显示：文件后缀名及隐藏的文件/文件夹</h3><p>按键：<code>win + e</code>，或者双击桌面上的<code>此电脑</code>图标，打开win10资源管理器，在创建的上方选择<code>查看</code>选项卡，勾选必要的选项，如下图所示：</p>
<p><img src="https://image.woodwhales.cn/057/images/windows/3.png"></p>
<h3 id="资源管理器打开时默认显示此电脑（系统盘符）"><a href="#资源管理器打开时默认显示此电脑（系统盘符）" class="headerlink" title="资源管理器打开时默认显示此电脑（系统盘符）"></a>资源管理器打开时默认显示此电脑（系统盘符）</h3><p>按键：<code>win + e</code>，或者双击桌面上的<code>此电脑</code>图标，打开win10资源管理器，在创建的上方点击<code>文件</code>按钮，选择<code>更改文件夹和搜索选项</code>，在<code>常规</code>选项卡中设置”打开文件资源管理器时打开”为”此电脑”，操作完成之后点击<code>确定</code>按钮即可。</p>
<p><img src="https://image.woodwhales.cn/057/images/windows/4.png"></p>
<p><img src="https://image.woodwhales.cn/057/images/windows/5.png"></p>
<h3 id="微软拼音输入法默模式为英文"><a href="#微软拼音输入法默模式为英文" class="headerlink" title="微软拼音输入法默模式为英文"></a>微软拼音输入法默模式为英文</h3><p>右击任务栏上的拼音输入法图标，点击<code>设置</code>选项：</p>
<p><img src="https://image.woodwhales.cn/057/images/windows/6.png"></p>
<p>点击<code>常规</code>选项：</p>
<img src="https://image.woodwhales.cn/057/images/windows/7.png" style="zoom:75%;">

<p>在<code>默认模式</code>中的<code>选择输入法默认模式</code>选择为”英文”即可。</p>
<img src="https://image.woodwhales.cn/057/images/windows/8.png" style="zoom:75%;">

<blockquote>
<p>PS：微软拼音输入法中的中文顿号（、）输入是需要按键<code>回车键</code>上面的<code>反斜杠</code>键位。</p>
</blockquote>
<h3 id="设置日期格式"><a href="#设置日期格式" class="headerlink" title="设置日期格式"></a>设置日期格式</h3><p>点击任务栏上的时间，点击<code>日期和时间设置</code>：</p>
<p><img src="https://image.woodwhales.cn/057/images/windows/9.png"></p>
<p>点击<code>相关设置</code>中的”日期、时间和区域格式设置”：</p>
<img src="https://image.woodwhales.cn/057/images/windows/10.png" style="zoom:75%;">

<p>点击<code>更改数据格式</code>，设置时间显示格式：</p>
<img src="https://image.woodwhales.cn/057/images/windows/11.png" style="zoom:75%;">

<p>以下为笔者的时间格式参考：</p>
<img src="https://image.woodwhales.cn/057/images/windows/12.png" style="zoom:75%;">

<h3 id="关闭添加设备时自动打开播放"><a href="#关闭添加设备时自动打开播放" class="headerlink" title="关闭添加设备时自动打开播放"></a>关闭添加设备时自动打开播放</h3><p>点击开始菜单，选择小齿轮按钮，进入<code>windows设置</code>面板：</p>
<img src="https://image.woodwhales.cn/057/images/windows/13.png" style="zoom:75%;">

<p>点击”设备”选项：</p>
<img src="https://image.woodwhales.cn/057/images/windows/14.png" style="zoom:75%;">

<p>设置关闭自动播放设备功能：</p>
<img src="https://image.woodwhales.cn/057/images/windows/15.png" style="zoom:75%;">

<h3 id="开启剪切板历史记录"><a href="#开启剪切板历史记录" class="headerlink" title="开启剪切板历史记录"></a>开启剪切板历史记录</h3><p>如上节所示，先打开<code>windows设置</code>面板，选择第一个”系统”选项：</p>
<img src="https://image.woodwhales.cn/057/images/windows/16.png" style="zoom:75%;">

<p>点击<code>剪贴板</code>将剪贴板历史记录功能开启，按键<code>win + v</code>就可以看到剪贴板历史记录。</p>
<h3 id="设置哪些文件夹显示在开始菜单上"><a href="#设置哪些文件夹显示在开始菜单上" class="headerlink" title="设置哪些文件夹显示在开始菜单上"></a>设置哪些文件夹显示在开始菜单上</h3><p>系统默认开始菜单上显示了几个小图标，可以自定义：</p>
<p><img src="https://image.woodwhales.cn/057/images/windows/17.png"></p>
<p>右击桌面空白处，选择<code>个性化</code>选项：</p>
<img src="https://image.woodwhales.cn/057/images/windows/18.png" style="zoom:75%;">

<p>在<code>开始</code>选项中点击”选择哪些文件夹显示在开始菜单上”，选择要显示的文件夹即可。</p>
<h3 id="开启夜间模式"><a href="#开启夜间模式" class="headerlink" title="开启夜间模式"></a>开启夜间模式</h3><img src="https://image.woodwhales.cn/057/images/windows/19.png" style="zoom:75%;">

<h3 id="自动整理磁盘"><a href="#自动整理磁盘" class="headerlink" title="自动整理磁盘"></a>自动整理磁盘</h3><p>设置 &gt; 系统 &gt; 存储，打开右侧的<code>存储感知</code>，接下来配置好自动清理频率。到了固定时间，Win10就会自动清除上述位置的垃圾文件。</p>
<img src="https://image.woodwhales.cn/057/images/windows/20.png" style="zoom:75%;">

<h3 id="启动-HDR-播放模式"><a href="#启动-HDR-播放模式" class="headerlink" title="启动 HDR 播放模式"></a>启动 HDR 播放模式</h3><p>HDR是“应用”面板里的一项功能，开启后，可以让视频自动以高动态（HDR）方式播放（通俗理解就是画面细节更丰富了）。这个功能对显示器有要求，如果显示器满足要求就可以开启</p>
<img src="https://image.woodwhales.cn/057/images/windows/21.png" style="zoom:75%;">

<h3 id="上帝模式"><a href="#上帝模式" class="headerlink" title="上帝模式"></a>上帝模式</h3><p>再桌面创建一个文件夹，名称为：<code>上帝模式.{ED7BA470-8E54-465E-825C-99712043E01C}</code>此时图标变成了控制面板的图标，双击打开发现控制面板的选项以列表形式展示：</p>
<img src="https://image.woodwhales.cn/057/images/windows/22.png" style="zoom:75%;">

<h3 id="开启卓越性能模式"><a href="#开启卓越性能模式" class="headerlink" title="开启卓越性能模式"></a>开启卓越性能模式</h3><p>笔者的电源计划本来是没有卓越性能选项的，需要开启一下：Windows PowerShell 以管理员身份打开，输入命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">powercfg -duplicatescheme e9a42b02-d5df-<span class="number">448</span>d-aa00-<span class="number">03</span>f14749eb61</span><br></pre></td></tr></tbody></table></figure>

<p>命令执行成功会提示卓越模式字样。</p>
<img src="https://image.woodwhales.cn/057/images/windows/23.png" style="zoom:75%;">

<h3 id="开始菜单的简易版"><a href="#开始菜单的简易版" class="headerlink" title="开始菜单的简易版"></a>开始菜单的简易版</h3><p>这个功能不需要任何设置，只需要在开始菜单中，右击即可弹出简易版的开始菜单，很简洁干净：</p>
<img src="https://image.woodwhales.cn/057/images/windows/24.png" style="zoom:75%;">

<h3 id="PowerShell-cmd-字体设置"><a href="#PowerShell-cmd-字体设置" class="headerlink" title="PowerShell/cmd 字体设置"></a>PowerShell/cmd 字体设置</h3><p>克隆或者下载：<a href="https://github.com/powerline/fonts%EF%BC%8C%E5%8F%B3%E5%87%BB%60install.ps1%60%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9%22%E4%BB%A5">https://github.com/powerline/fonts，右击`install.ps1`文件选择"以</a> PowerShell 运行”。</p>
<p>安装之后建议重启系统，打开 PowerShell/cmd 窗口，右击菜单窗口设置字体即可。</p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>重装系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Kafka 学习笔记</title>
    <url>/2019/12/01/055/</url>
    <content><![CDATA[<p>像 Kafka 这一类的系统国外有专属的名字叫<code>Messaging System</code>，国内很多文献将其简单翻译成消息系统。但这种直白的翻译并不准确，因为它片面强调了消息主体的作用，而忽视了这类系统引以为豪的消息传递属性，就像引擎一样，具备某种能量转换传输的能力，所以翻译成消息引擎反倒更加贴切。</p>
<h2 id="消息引擎系统"><a href="#消息引擎系统" class="headerlink" title="消息引擎系统"></a>消息引擎系统</h2><p>根据维基百科的定义，<strong>消息引擎系统是一组规范</strong>。企业利用这组规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。</p>
<blockquote>
<p>An <strong>enterprise messaging system</strong> (<strong>EMS</strong>) or messaging system in brief is a set of published enterprise-wide standards that allows organizations to send semantically precise messages between computer systems. </p>
<p><a href="https://en.wikipedia.org/wiki/Enterprise_messaging_system">https://en.wikipedia.org/wiki/Enterprise_messaging_system</a></p>
</blockquote>
<p>上述通俗来说就是：系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。</p>
<p>最基础的消息引擎就是做这点事的！不论是上面哪个版本，它们都提到了两个重要的事实：</p>
<ul>
<li><p>消息引擎传输的对象是消息；</p>
</li>
<li><p>如何传输消息属于消息引擎设计机制的一部分。</p>
</li>
</ul>
<h3 id="常见的消息引擎系统"><a href="#常见的消息引擎系统" class="headerlink" title="常见的消息引擎系统"></a>常见的消息引擎系统</h3><h4 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h4><p><img src="https://image.woodwhales.cn/055/images/1.png"></p>
<p>官网：<a href="http://activemq.apache.org/">http://activemq.apache.org/</a></p>
<p>ActiveMQ 是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 J2EE 应用中间仍然扮演着特殊的地位。</p>
<h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p><img src="https://image.woodwhales.cn/055/images/2.png"></p>
<p>官网：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p>
<p>RabbitMQ 是流行的开源消息队列系统，用 erlang 语言开发。RabbitMQ 是 AMQP（高级消息队列协议）的标准实现。支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<blockquote>
<p>AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
</blockquote>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><img src="https://image.woodwhales.cn/055/images/3.png"></p>
<p>Apache Kafka 官网：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<p>Kafka 是 LinkedIn 开源的高吞吐量的分布式发布-订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据目前归属于 Apache 顶级项目。Apache Kafka 是 Kafka 系列版本中最出名的一个，其他 Kafka 还有 Confluent Kafka、Cloudera/Hortonworks Kafka、CDH/HDP Kafka 等。</p>
<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p><img src="https://image.woodwhales.cn/055/images/4.png"></p>
<p>官网：<a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p>
<p>RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</p>
<h4 id="Pulsar"><a href="#Pulsar" class="headerlink" title="Pulsar"></a>Pulsar</h4><p><img src="https://image.woodwhales.cn/055/images/5.png"></p>
<p>官网：<a href="https://pulsar.apache.org/">https://pulsar.apache.org/</a></p>
<p>Pulsar 是 pub-sub 模式的分布式消息平台，拥有灵活的消息模型和直观的客户端 API。Pulsar 由雅虎开发并于 2016 年开源的下一代消息系统，目前是 Apache 软件基金会的孵化器项目。</p>
<h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><p><img src="https://image.woodwhales.cn/055/images/6.png"></p>
<p>官网地址：<a href="https://zeromq.org/">https://zeromq.org/</a></p>
<p>ZeroMQ 号称最快的消息队列系统，尤其针对大吞吐量的需求场景。ZeroMQ 能够实现 RabbitMQ 不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，技术上的复杂度是对这 MQ 能够应用成功的挑战。ZeroMQ 具有一个独特的非中间件的模式，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序将扮演这个服务器角色。你只需要简单的引用 ZeroMQ 程序库，可以使用 NuGet 安装，然后你就可以愉快的在应用程序之间发送消息了。但是 ZeroMQ 仅提供非持久性的队列，也就是说如果宕机，数据将会丢失。其中，Twitter 的 Storm 0.9.0 以前的版本中默认使用 ZeroMQ 作为数据流的传输（Storm 从 0.9 版本开始同时支持 ZeroMQ 和 Netty 作为传输模块）。</p>
<h4 id="常用消息引擎系统对比"><a href="#常用消息引擎系统对比" class="headerlink" title="常用消息引擎系统对比"></a>常用消息引擎系统对比</h4><h5 id="Kafka-vs-RabbitMQ-vs-Pulsar"><a href="#Kafka-vs-RabbitMQ-vs-Pulsar" class="headerlink" title="Kafka vs. RabbitMQ vs. Pulsar"></a>Kafka vs. RabbitMQ vs. Pulsar</h5><table>
<thead>
<tr>
<th>功能</th>
<th>RabbitMQ</th>
<th>Kafka</th>
<th>Pulsar</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>存储功能</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>特点</td>
<td>富Broker, 傻消费者</td>
<td>傻Broker, 富消费者</td>
<td>傻Broker, 富消费者</td>
<td></td>
</tr>
<tr>
<td>数据私有-Exclusive</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据共享-Shared</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>故障切换-Failover</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>SubScription</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>扩展</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>高吞吐</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>分布式</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据回看</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据备份</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据路由</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td></td>
</tr>
<tr>
<td>生产者</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>消费者</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Stream</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
</tbody></table>
<h5 id="RocketMQ-vs-ActiveMQ-vs-Kafka"><a href="#RocketMQ-vs-ActiveMQ-vs-Kafka" class="headerlink" title="RocketMQ vs. ActiveMQ vs. Kafka"></a>RocketMQ vs. ActiveMQ vs. Kafka</h5><blockquote>
<p>数据来源：<a href="https://rocketmq.apache.org/docs/motivation/">https://rocketmq.apache.org/docs/motivation/</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/055/images/7.png"></p>
<h3 id="消息传输格式"><a href="#消息传输格式" class="headerlink" title="消息传输格式"></a>消息传输格式</h3><p>既然消息引擎是用于在不同系统之间传输消息的，如何设计待传输消息的格式是非常核心且重要的问题：</p>
<p><strong>Kafka 的消息传输格式使用的是：结构化的纯二进制的字节序列。</strong></p>
<h3 id="消息传输协议"><a href="#消息传输协议" class="headerlink" title="消息传输协议"></a>消息传输协议</h3><p>消息设计出来之后还不够，消息引擎系统还要设定具体的传输协议，即我用什么方法把消息传输出去。常见的有两种方法：</p>
<h4 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h4><p>也叫消息队列模型。如果拿上面那个“民间版”的定义来说，那么系统 A 发送的消息只能被系统 B 接收，其他任何系统都不能读取 A 发送的消息。日常生活的例子比如电话客服就属于这种模型：同一个客户呼入电话只能被一位客服人员处理，第二个客服人员不能为该客户服务。</p>
<p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序。</p>
<p><img src="https://image.woodwhales.cn/055/images/01.gif"></p>
<h4 id="发布-订阅模型"><a href="#发布-订阅模型" class="headerlink" title="发布 / 订阅模型"></a>发布 / 订阅模型</h4><p>与上面不同的是，它有一个主题（Topic）的概念，你可以理解成逻辑语义相近的消息容器。该模型也有发送方和接收方，只不过提法不同。发送方也称为发布者（Publisher），接收方称为订阅者（Subscriber）。和点对点模型不同的是，这个模型可能存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，它们都能接收到相同主题的消息。生活中的报纸订阅就是一种典型的发布 / 订阅模型。</p>
<p>在发布-订阅消息系统中，消息被持久化到一个 topic 中。与点对点消息系统不同的是，消费者可以订阅一个或多个 topic，消费者可以消费该 topic 中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。</p>
<p><img src="https://image.woodwhales.cn/055/images/02.gif"></p>
<p><strong>总结：点对点模式中，生产者发送一条消息到queue，只有一个消费者能收到。发布/订阅模式中，发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。</strong>Kafka 同时上述这俩种消息传输模式（协议）。</p>
<h3 id="使用消息系统的好处"><a href="#使用消息系统的好处" class="headerlink" title="使用消息系统的好处"></a>使用消息系统的好处</h3><p>1、解耦</p>
<p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
<p>2、冗余</p>
<p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
<p>3、扩展性</p>
<p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
<p>4、灵活性 &amp; 峰值处理能力</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
<p>5、可恢复性</p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
<p>6、序保证</p>
<p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p>
<p>7、缓冲</p>
<p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p>
<p>8、异步通信</p>
<p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
<p><strong>使用消息引擎系统好处使用简单概括就是削峰填谷、异步解耦</strong>。</p>
<h2 id="认识-Kafka"><a href="#认识-Kafka" class="headerlink" title="认识 Kafka"></a>认识 Kafka</h2><h3 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h3><p>Kafka 在设计之初就旨在提供三个方面的特性：</p>
<ul>
<li>提供一套 API 实现生产者和消费者；</li>
<li>降低网络传输和磁盘存储开销；</li>
<li>实现高伸缩性架构。</li>
</ul>
<p>开源之后的 Kafka 被越来越多的公司应用到它们企业内部的数据管道中，特别是在大数据工程领域，Kafka 在承接上下游、串联数据流管道方面发挥了重要的作用：所有的数据几乎都要从一个系统流入 Kafka 然后再流向下游的另一个系统中。</p>
<p>于是 Kafka 社区于<code>0.10.0.0</code>版本正式推出了流处理组件 Kafka Streams，也正是从这个版本开始，Kafka 正式“变身”为分布式的流处理平台，而不仅仅是消息引擎系统了。今天 Apache Kafka 是和 Apache Storm、Apache Spark 和 Apache Flink 同等级的实时流处理平台。</p>
<p><strong>简言之，Kafka 是消息引擎系统（Messaging System），也是分布式流处理平台（Distributed Streaming Platform），而是能够实现精确一次（Exactly-once）处理语义的实时流处理平台。</strong></p>
<blockquote>
<p>作为流处理平台，Kafka 与其他主流大数据流式计算框架相比，优点如下：</p>
<ol>
<li>更容易实现端到端的正确性（Correctness）：要实现正确性和提供能够推导时间的工具。实现正确性是流处理能够匹敌批处理的基石。</li>
<li>可能助力 Kafka 胜出的第二点是它自己对于流式计算的定位。</li>
</ol>
<p>Kafka 除用于消息引擎和流处理平台，而且还能够被用作分布式存储系统。Kafka 作者之一 Jay Kreps 曾经专门写过一篇文章阐述为什么能把 Kafka 用作<a href="https://www.confluent.io/blog/okay-store-data-apache-kafka/">分布式存储</a>。不过这个功能建议只做了解就好了，目前还从没有谁在实际生产环境中，把 Kafka 当作持久化存储来用 。</p>
</blockquote>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。下图能够帮助你形象化地理解下文提到的术语概念：</p>
<p><img src="https://image.woodwhales.cn/055/images/8.png"></p>
<h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p>Kafka 集群包含一个或多个服务器，服务器节点称为：broker。</p>
<p>broker 存储 topic 的数据。如果某 topic 有 N 个 partition，集群有 N 个 broker，那么每个 broker 存储该 topic 的一个 partition。</p>
<p>如果某 topic 有 N 个partition，集群有（N + M）个broker，那么其中有 N 个 broker 存储该 topic 的一个 partition，剩下的 M 个 broker 不存储该 topic 的 partition 数据。</p>
<p>如果某 topic 有 N 个 partition，集群中 broker 数目少于 N 个，那么一个 broker 存储该 topic 的一个或多个 partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致 Kafka 集群数据不均衡。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>消息：Record。Kafka 是消息引擎嘛，这里的消息就是指 Kafka 处理的主要对象。</p>
<p>对应图中的<code>生产者</code>发送到<code>Broker</code>的消息，绿色虚线表示消息发送方向。</p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</p>
<p>每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。</p>
<p>topic 中的数据分割为一个或多个 partition。每个 topic 至少有一个 partition。每个 partition 中的数据使用多个 segment 文件存储。partition 中的数据是有序的，不同 partition 间的数据丢失了数据的顺序。如果 topic 有多个 partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将 partition 数目设为 1。</p>
<h4 id="消息位移"><a href="#消息位移" class="headerlink" title="消息位移"></a>消息位移</h4><p>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</p>
<p>对应图中<code>生产者</code>发送到<code>Broker</code>的消息的位置。</p>
<h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</p>
<p>对应图中的蓝色消息矩形框。</p>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>生产者：Producer。向主题发布新消息的应用程序。</p>
<p>生产者即数据的发布者，该角色将消息发布到 Kafka 的 topic 中。broker 接收到生产者发送的消息后，broker 将该消息<strong>追加</strong>到当前用于追加数据的 segment 文件中。生产者发送的消息，存储到一个 partition 中，生产者也可以指定数据存储的 partition。</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>消费者：Consumer。从主题订阅新消息的应用程序。</p>
<p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<h4 id="消费者位移"><a href="#消费者位移" class="headerlink" title="消费者位移"></a>消费者位移</h4><p>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。</p>
<p>对应图中的<code>消费者组中的消费者</code>的绿色虚线指向的消息的位置。</p>
<h4 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h4><p>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</p>
<p>每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</p>
<h4 id="重平衡"><a href="#重平衡" class="headerlink" title="重平衡"></a>重平衡</h4><p>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</p>
<blockquote>
<p>如果本章节的术语还是一知半解，建议阅读下文 Kafka 体系架构章节，希望帮助你我更好的理解 Kafka 的核心概念。</p>
</blockquote>
<h4 id="领导者"><a href="#领导者" class="headerlink" title="领导者"></a>领导者</h4><p>领导者：Leader。</p>
<p>每个 partition 有多个副本，其中有且仅有一个作为 Leader，Leader 是当前负责数据的读写的 partition。</p>
<h4 id="追随者"><a href="#追随者" class="headerlink" title="追随者"></a>追随者</h4><p>追随者：Follower。</p>
<p>每个 partition 有多个副本，除了 Leader，剩余的都是 Follower。</p>
<p>Follower 跟随 Leader，所有写请求都通过 Leader 路由，数据变更会广播给所有 Follower，Follower 与 Leader 保持数据同步。如果 Leader 失效，则从 Follower 中选举出一个新的 Leader。当 Follower 与 Leader 挂掉、卡住或者同步太慢，leader 会把这个 follower 从<code>in sync replicas（ISR）</code>列表中删除，重新创建一个 Follower。</p>
<h3 id="Kafka-的种类"><a href="#Kafka-的种类" class="headerlink" title="Kafka 的种类"></a>Kafka 的种类</h3><p>架构师评估流处理平台的时候，框架本身的性能、所提供操作算子（Operator）的丰富程度固然是重要的评判指标，但框架与上下游交互的能力也是非常重要的。能够与之进行数据传输的外部系统越多，围绕它打造的生态圈就越牢固，因而也就有更多的人愿意去使用它，从而形成正向反馈，不断地促进该生态圈的发展。</p>
<p>就 Kafka 而言，<code>Kafka Connect</code>通过一个个具体的连接器（Connector），串联起上下游的外部系统。整个 Kafka 生态圈如下图所示。这张图中的外部系统只是 Kafka Connect 组件支持的一部分而已。目前还有一个可喜的趋势是使用 Kafka Connect 组件的用户越来越多，相信在未来会有越来越多的人开发自己的连接器。</p>
<p><img src="https://image.woodwhales.cn/055/images/9.png"></p>
<p>目前市面上存在多个组织或公司发布不同的 Kafka。如同 Linux 系统一样，由于有不同的公司或组织开发出来 Linux 系统产品有不同的名称，比如我们熟知的 CentOS、RedHat、Ubuntu 等。</p>
<h4 id="Apache-Kafka"><a href="#Apache-Kafka" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h4><p>自 Kafka 开源伊始，它便在 Apache 基金会孵化并最终毕业成为顶级项目，它也被称为社区版 Kafka。 Apache Kafka 是后面其他所有 Kafka 产品的基础。也就是说，后面提到的发行版要么是原封不动地继承了 Apache Kafka，要么是在此之上扩展了新功能。</p>
<h4 id="Confluent-Kafka"><a href="#Confluent-Kafka" class="headerlink" title="Confluent Kafka"></a>Confluent Kafka</h4><p>Confluent 公司专注于提供基于 Kafka 的企业级流处理解决方案，该公司主要从事商业化 Kafka 工具开发，并在此基础上发布了 Confluent Kafka。Confluent Kafka 提供了一些 Apache Kafka 没有的高级特性，比如跨数据中心备份、Schema 注册中心以及集群监控工具等。</p>
<p>Confluent Kafka 是由 Confluent 公司出品，该公司主要从事商业化 Kafka 工具开发，并在此基础上发布了 Confluent Kafka。Confluent Kafka 提供了一些 Apache Kafka 没有的高级特性，比如跨数据中心备份、Schema 注册中心以及集群监控工具等。</p>
<h4 id="Cloudera-Hortonworks-Kafka"><a href="#Cloudera-Hortonworks-Kafka" class="headerlink" title="Cloudera/Hortonworks Kafka"></a>Cloudera/Hortonworks Kafka</h4><p>Cloudera 提供的 CDH 和 Hortonworks 提供的 HDP 是非常著名的大数据平台，里面集成了目前主流的大数据框架，能够帮助用户实现从分布式存储、集群调度、流处理到机器学习、实时数据库等全方位的数据处理。不管是 CDH 还是 HDP 里面都集成了 Apache Kafka，因此我把这两款产品中的 Kafka 称为 CDH Kafka 和 HDP Kafka。</p>
<h4 id="产品比较"><a href="#产品比较" class="headerlink" title="产品比较"></a>产品比较</h4><h5 id="Apache-Kafka-1"><a href="#Apache-Kafka-1" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h5><ul>
<li><p><strong>优势：迭代速度快，社区响应度高，使用它可以让你有更高的把控度。</strong></p>
<p>它现在依然是开发人数最多、版本迭代速度最快的 Kafka。</p>
</li>
<li><p><strong>劣势：仅提供基础核心组件，缺失一些高级的特性。</strong></p>
<p>仅仅提供最最基础的组件，特别是对于前面提到的 Kafka Connect 而言，社区版 Kafka 只提供一种连接器，在实际使用过程中需要自行编写代码实现。另外没有提供任何监控框架或工具。</p>
<p>好消息是目前有一些开源的监控框架可以帮助用于监控 Kafka（比如 Kafka manager）。</p>
</li>
</ul>
<blockquote>
<p>如果仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么推荐使用 Apache Kafka。</p>
</blockquote>
<h5 id="Confluent-Kafka-1"><a href="#Confluent-Kafka-1" class="headerlink" title="Confluent Kafka"></a>Confluent Kafka</h5><ul>
<li><p><strong>优势：集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证。</strong></p>
<p>Confluent Kafka 目前分为免费版和企业版两种。</p>
<p>免费版：和 Apache Kafka 非常相像，除了常规的组件之外，还包含 Schema 注册中心和 REST proxy 两大功能。能帮助开发者集中管理 Kafka 消息格式以实现数据前向 / 后向兼容。免费版包含了更多的连接器，它们都是 Confluent 公司开发并认证过的。</p>
<p>企业版：用开放 HTTP 接口的方式允许你通过网络访问 Kafka 的各种功能。拥有强大的跨数据中心备份和集群监控功能。</p>
<p>多个数据中心之间数据的同步以及对集群的监控历来是 Kafka 的痛点，Confluent Kafka 企业版提供了强大的解决方案帮助开发者“干掉”它们。</p>
</li>
<li><p><strong>劣势：相关文档资料不全，普及率较低，没有太多可供参考的范例。</strong></p>
<p>Confluent 公司暂时没有发展国内业务的计划，相关的资料以及技术支持都很欠缺，很多国内 Confluent Kafka 使用者甚至无法找到对应的中文文档，因此目前 Confluent Kafka 在国内的普及率是比较低的。</p>
</li>
</ul>
<blockquote>
<p>一言以蔽之，如果需要用到 Kafka 的一些高级特性，那么推荐使用 Confluent Kafka。</p>
</blockquote>
<h5 id="CDH-HDP-Kafka"><a href="#CDH-HDP-Kafka" class="headerlink" title="CDH/HDP Kafka"></a>CDH/HDP Kafka</h5><ul>
<li><p><strong>优势：大数据云公司提供的 Kafka，内嵌 Apache Kafka。操作简单，节省运维成本。</strong></p>
<p>通过便捷化且非常友好的界面操作将 Kafka 的安装、运维、管理、监控全部统一在控制台中，通常不需要进行任何配置就能有效地监控 Kafka。</p>
</li>
<li><p><strong>劣势：缺陷在于把控度低，演进速度较慢。</strong></p>
<p>由于监控封装得太好了，以至于使用者对下层的 Kafka 集群一无所知。并且发布周期和 Apache Kafka 更新周期不同步。</p>
</li>
</ul>
<blockquote>
<p>简单来说，如果需要快速地搭建消息引擎系统，或者需要搭建的是多框架构成的数据平台且 Kafka 只是其中一个组件，那么推荐使用这些大数据云公司提供的 Kafka。</p>
</blockquote>
<h3 id="Kafka-体系架构"><a href="#Kafka-体系架构" class="headerlink" title="Kafka 体系架构"></a>Kafka 体系架构</h3><p><img src="https://image.woodwhales.cn/055/images/03.gif"></p>
<p>如上图所示，一个典型的 Kafka 体系架构包括若干 Producer（可以是服务器日志，业务数据，页面前端产生的 page view 等等），若干 broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干 Consumer (Group)，以及一个 Zookeeper 集群。</p>
<ul>
<li><p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 consumer group 发生变化时进行 rebalance。</p>
</li>
<li><p>Producer 使用 push（推）模式将消息发布到 broker。</p>
</li>
<li><p>Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</p>
</li>
</ul>
<p><strong>名词解释</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Broker</td>
<td>消息中间件处理节点，一个 Kafka 节点就是一个 broker，一个或者多个 Broker 可以组成一个 Kafka 集群</td>
</tr>
<tr>
<td>Topic</td>
<td>Kafka 根据 topic 对消息进行归类，发布到 Kafka 集群的每条消息都需要指定一个 topic</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向 Broker 发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从 Broker 读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个 Consumer 属于一个特定的 Consumer Group，一条消息可以发送到多个不同的 Consumer</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个 topic 可以分为多个 partition，每个 partition 内部是有序的</td>
</tr>
</tbody></table>
<p>由上述概念可以了解到：</p>
<ul>
<li><p>n 个 Broker 组成一个 Kafka 集群，通常一台机器部署一个 Kafka 实例，一个实例挂了其他实例仍可以使用，体现了Kafka 的高可用性。</p>
</li>
<li><p>一个 partition 拥有多个 副本，并且这些副本在的其他 broker 上，体现强容灾能力。</p>
</li>
<li><p>partition 在机器磁盘上以 log 体现，采用顺序追加日志的方式添加新消息，实现高吞吐量。</p>
</li>
</ul>
<h3 id="Topic（主题）-Partition（分区）"><a href="#Topic（主题）-Partition（分区）" class="headerlink" title="Topic（主题） &amp; Partition（分区）"></a>Topic（主题） &amp; Partition（分区）</h3><p>Kafka 中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到 Kafka 集群中的每一条消息都要指定一个主题），而消息者负责订阅主题并进行消费。</p>
<p>主题是逻辑上的概念，主题的物理层面就是分区，一个分区只属于单个主题，很多时候把分区称为主题分区（Topic-Partition）。</p>
<p>一个 topic 可以认为一个一类消息，每个 topic 将被分成多个 partition，每个 partition 在存储层面是 append log文 件。任何发布到此 partition 的消息都会被追加到 log 文件的尾部，每条消息在文件中的位置称为 offset(偏移量)，offset 为一个 long 型的数字，它是消息在分区中的唯一标识，Kafka 通过它来保证消息在分区的顺序性，不过 offset 并不跨越分区，也就是说，Kafka 保证的是分区有序而不是主题有序。</p>
<blockquote>
<p>每条消息都被 append 到 partition 中，是<strong>顺序写磁盘</strong>，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证）。</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/055/images/10.png"></p>
<p>每一条消息被发送到 broker 中，会根据 partition 规则选择被存储到哪一个 partition。如果 partition 规则设置的合理，所有消息可以均匀分布到不同的 partition 里，这样就实现了水平扩展。（如果一个 topic 对应一个文件，那这个文件所在的机器 I/O 将会成为这个 topic 的性能瓶颈，而 partition 解决了这个问题）。在创建 topic 时可以在<code>$KAFKA_HOME/config/server.properties</code>中指定这个 partition 的数量（如下所示），当然可以在 topic 创建之后去修改 partition 的数量。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The default number of <span class="built_in">log</span> partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">parallelism <span class="keyword">for</span> consumption, but this will also result <span class="keyword">in</span> more files across</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the brokers.</span></span><br><span class="line">num.partitions=4</span><br></pre></td></tr></tbody></table></figure>

<p>默认值是：1，在生产环境注意一定要设置合理值。</p>
<p>简言之，为提升 Kafka 接收消息的吞量，将消息的主题设置成了分区的物理概念，这些分区都属于同一个主题，对外接收该主题的消息。</p>
<p>在发送一条消息时，可以指定这个消息的 key，producer 根据这个 key 和 partition 机制来判断这个消息发送到哪个 partition。partition 机制可以通过指定 producer 的<code>partition.class</code>这一参数来指定，该class必须实现<code>kafka.producer.Partitioner</code>接口。</p>
<p><img src="https://image.woodwhales.cn/055/images/04.gif"></p>
<p>上面动态图表示的是将产生相同主题的消息轮询发送到不同的该主题的主题分区中。</p>
<h3 id="Replication（分区的副本）"><a href="#Replication（分区的副本）" class="headerlink" title="Replication（分区的副本）"></a>Replication（分区的副本）</h3><p>Kafka 的高可靠性的保障来源于其健壮的副本（replication）策略。通过调节其副本相关参数，可以使得 Kafka 在性能和可靠性之间运转的游刃有余。Kafka 从 0.8.x 版本开始提供 partition 级别的复制，replication 的数量可以在<code>$KAFKA_HOME/config/server.properties</code>中配置（<code>default.replication.refactor</code>）。</p>
<p>为了提高消息的可靠性，Kafka 每个 topic 的 partition 有 N 个副本（replicas），其中 N（大于等于1）是 topic 的复制因子（replica fator）的个数。Kafka 通过多副本机制实现故障自动转移，当 Kafka 集群中一个 broker 失效情况下仍然保证服务可用。在 Kafka 中发生复制时确保 partition 的日志能有序地写到其他节点上，N 个 replicas 中，其中一个 replica 为 leader，其他都为 follower，leader 处理 partition 的所有读写请求，与此同时，follower 会被动定期地去复制 leader上的数据。</p>
<p>如下图所示，Kafka 集群中有 4 个 broker，某 topic 有 3 个 partition，且复制因子即副本个数也为 3：</p>
<p><img src="https://image.woodwhales.cn/055/images/05.gif"></p>
<p>Kafka 提供了数据复制算法保证，如果 leader 发生故障或挂掉，一个新 leader 被选举并被接受客户端的消息成功写入。Kafka 确保从同步副本列表中选举一个副本为 leader，或者说 follower 追赶 leader 数据。leader 负责维护和跟踪<code>ISR（In-Sync Replicas的缩写，表示副本同步队列）</code>中所有 follower 滞后的状态。当 producer 发送一条消息到 broker 后，leader 写入消息并复制到所有 follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的 follower 限制，重要的是快速检测慢副本，如果follower “落后”太多或者失效，leader 将会把它从 ISR 中删除。</p>
<blockquote>
<p>默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都有一个唯一的 leader，为了确保消息的可靠性，通常应用中将其值（由 broker 的参数<code>offsets.topic.replication.factor</code>指定）大小设置为大于 1，比如 3。</p>
</blockquote>
<h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>ISR、OSR、AR</p>
<p>ISR（In-Sync Replicas）是指副本同步队列。副本数对 Kafka 的吞吐率是有一定的影响，但极大的增强了可用性。</p>
<p><img src="https://image.woodwhales.cn/055/images/06.gif"></p>
<ul>
<li>分区中的所有副本（replicas）统称为<code>Assigned Replicas</code>，即<code>AR</code>。</li>
<li>所有与 leader 副本保持一定程度同步的副本（包括 leader 副本在内）组成<code>ISR</code>（In-Sync Replicas），因此 ISR 是 AR 中的一个子集。</li>
<li>leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当 follower 副本落后太多或者失效时，leader 副本会把 follower 剔除出<code>ISR</code>。</li>
<li>从 ISR 列表中被剔除的 follower 副本会存入<code>OSR（Outof-Sync Replicas）</code>列表，新加入的 follower 也会先存放在<code>OSR</code>中。</li>
<li>如果 OSR 集合中有 follower 副本“追上”了 leader 副本，那么 leader 副本会把它从 OSR 集合中转移到 ISR 集合中。</li>
<li>当 leader 副本发生故障时，只有在 ISR 集合中的副本才有资格被选举为新的 leader，而在 OSR 集合中的副本则没有任何机会。默认会从 ISR 集合中选择第一个 follower 副本当新的 leader 副本。</li>
<li><code>AR = ISR + OSR</code>，正常情况下，所有的 follower 副本都应该与 leader 副本保持一定程度的同步，即 AR = ISR，OSR 集合为空。</li>
</ul>
<h4 id="follower-进入-ISR-列表条件"><a href="#follower-进入-ISR-列表条件" class="headerlink" title="follower 进入 ISR 列表条件"></a>follower 进入 ISR 列表条件</h4><p>能够进入 ISR 列表中的条件是可以进行参数配置的：</p>
<p><strong>replica.lag.time.max.ms 默认值：10000，单位为：毫秒</strong></p>
<p>该配置表示如果一个 follower 在有一个时间窗口内（默认值为 10 秒）没有发送任意 fetch 请求，leader 就会把这个 follower 从 ISR（in-sync replicas）移除，并存入 OSR 集合。</p>
<blockquote>
<p>Kafka 0.9.0.0版本后移除了<code>replica.lag.max.messages</code>参数，只保留了<code>replica.lag.time.max.ms</code>作为 ISR 中副本管理的参数。官方文档说明参见：<a href="http://kafka.apache.org/090/documentation.html#upgrade_9_breaking">http://kafka.apache.org/090/documentation.html#upgrade_9_breaking</a></p>
<p><img src="https://image.woodwhales.cn/055/images/11.png"></p>
<p>Kafka 0.9.0.0版本后移除了 replica.lag.max.messages 参数，只保留了 replica.lag.time.max.ms 作为 ISR 中副本管理的参数。为什么这样做呢？</p>
<p>replica.lag.max.messages 表示当前某个副本落后 leader 的消息数量超过了这个参数的值，那么 leader 就会把 follower 从 ISR 中删除。</p>
<p>假设设置 replica.lag.max.messages = 4，那么如果 producer 一次传送至 broker 的消息数量都小于 4 条时，因为在 leader 接受到 producer 发送的消息之后而 follower 副本开始拉取这些消息之前，follower 落后 leader 的消息数不会超过 4 条消息，故此没有 follower 移出 ISR，所以这时候 replica.lag.max.message 的设置似乎是合理的。</p>
<p>但是 producer 发起瞬时高峰流量，producer 一次发送的消息超过 4 条时，也就是超过 replica.lag.max.messages，此时 follower 都会被认为是与 leader 副本不同步了，从而被踢出了 ISR。</p>
<p>但实际上这些 follower 都是存活状态的且没有性能问题。那么在之后追上 leader，并被重新加入了 ISR。于是就会出现它们不断地剔出 ISR 然后重新回归 ISR，这无疑增加了无谓的性能损耗。</p>
<p>而且这个参数是 broker 全局的。设置太大了，影响真正“落后” follower 的移除；设置的太小了，导致 follower 的频繁进出。无法给定一个合适的 replica.lag.max.messages 的值，故此，新版本的 Kafka 移除了这个参数。</p>
</blockquote>
<p>值得注意的是：ISR 列表中包括：leader 和 follower。</p>
<h4 id="Unclean-领导者选举（Unclean-Leader-Election）"><a href="#Unclean-领导者选举（Unclean-Leader-Election）" class="headerlink" title="Unclean 领导者选举（Unclean Leader Election）"></a>Unclean 领导者选举（Unclean Leader Election）</h4><p>当 leader 的所有副本都被剔除到了 OSR 列表中，此时 ISR 列表中只剩下 leader 了，此时 leader 自己“挂了”，那么 ISR 集合为空。此时该怎么选举 leader 呢？</p>
<p><strong>Kafka 把所有不在 ISR 中的存活副本都称为非同步副本。</strong>通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程称为 Unclean 领导者选举。</p>
<p>Broker 端参数<code>unclean.leader.election.enable</code>控制是否允许 Unclean 领导者选举。</p>
<h4 id="丢失数据风险"><a href="#丢失数据风险" class="headerlink" title="丢失数据风险"></a>丢失数据风险</h4><p>场景：</p>
<p>1、follower2 不在 ISR 中，但正在努力“赶上”。</p>
<p><img src="https://image.woodwhales.cn/055/images/12.png"></p>
<p>2、ISR 中所有副本意外“挂掉”。</p>
<p><img src="https://image.woodwhales.cn/055/images/13.png"></p>
<p>3、开启了 Unclean 领导者选举，所以 follower2 成了新的 leader。</p>
<p><img src="https://image.woodwhales.cn/055/images/14.png"></p>
<p>4、原来在 ISR 里的副本都成了新 leader 的 follower，需要重新加入 ISR 中，“超长”部分被截取了，导致数据不一致。</p>
<p><img src="https://image.woodwhales.cn/055/images/15.png"></p>
<p>如上图所示，新的 follower 副本需要删除消息 4 和消息 5，之后才能与新的 leader 副本进行同步。之后新的 follower 副本和新的 leader 副本组成了新的 ISR 集合，参考下图。</p>
<p><img src="https://image.woodwhales.cn/055/images/16.png"></p>
<p>原本客户端已经成功的写入了消息 4 和消息 5，而在发生日志截断之后就意味着这 2 条消息就丢失了，并且新的 follower 副本和新的 leader 副本之间的消息也不一致。</p>
<p>开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。</p>
<blockquote>
<p>从 Kafka 0.11.0.0 版本开始<code>unclean.leader.election.enable</code>参数的默认值由原来的<code>true</code>改为<code>false</code>。</p>
<p>原文参见：</p>
<p><a href="http://kafka.apache.org/documentation/#upgrade_1100_notable">http://kafka.apache.org/documentation/#upgrade_1100_notable</a></p>
<p>Unclean leader election is now disabled by default. The new default favors durability over availability. Users who wish to to retain the previous behavior should set the broker config <code>unclean.leader.election.enable</code> to <code>true</code>.</p>
</blockquote>
<p>读者可以根据你的实际业务场景决定是否开启 Unclean 领导者选举。但是笔者强烈建议不要开启它，毕竟我们还可以通过其他的方式来提升高可用性。</p>
<h3 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h3><p>Kafka 中消息是以 topic 进行分类的，生产者通过 topic 向 Kafka broker 发送消息，消费者通过 topic 读取数据。</p>
<p>然而 topic 在物理层面又能以 partition 为分组，一个 topic 可以分成若干个 partition，那么 topic 以及 partition 又是怎么存储的呢？partition 还可以细分为 segment，一个 partition 物理上由多个 segment 组成，那么这些 segment 又是什么呢？</p>
<h4 id="Parition"><a href="#Parition" class="headerlink" title="Parition"></a>Parition</h4><p>为了便于说明问题，假设这里只有一个 Kafka 集群，且这个集群只有一个 Kafka broker，即只有一台物理机。在这个 Kafka broker 中配置（默认配置）：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A comma separated list of directories under <span class="built_in">which</span> to store <span class="built_in">log</span> files</span></span><br><span class="line">log.dirs=/tmp/kafka-logs</span><br></pre></td></tr></tbody></table></figure>

<p>以此来设置 Kafka 消息文件存储目录，与此同时创建一个<code>topic：my-topic</code>，partition 的数量为 3：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic my-topic</span><br></pre></td></tr></tbody></table></figure>

<p>那么我们此时可以在<code>/tmp/kafka-logs</code>目录中可以看到生成了 3 个目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">drwxr-xr-x 2 root root 4096 Apr 10 16:10 my-topic-0</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 10 16:10 my-topic-1</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 10 16:10 my-topic-2</span><br></pre></td></tr></tbody></table></figure>

<p>在 Kafka 文件存储中，同一个 topic 下有多个不同的 partition，每个 partiton 为一个目录，partition 的名称规则为：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">topic名称 + 有序序号</span><br></pre></td></tr></tbody></table></figure>

<p>第一个序号从 0 开始计，最大的序号为 partition 数量减 1，partition 是实际物理上的概念，而 topic 是逻辑上的概念。</p>
<p><img src="https://image.woodwhales.cn/055/images/07.gif"></p>
<h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>如果就以 partition 为最小存储单位，我们可以想象当 Kafka producer 不断发送消息，必然会引起 partition 文件的无限扩张，这样对于消息文件的维护以及已经被消费的消息的清理带来严重的影响，所以这里以 segment 为单位又将 partition 细分。</p>
<ul>
<li>每个 partition（目录）相当于一个巨型文件被平均分配到多个大小相等的 segment（段）数据文件中（每个 segment 文件中消息数量不一定相等）这种特性也方便 old segment 的删除，即方便已被消费的消息的清理，提高磁盘的利用率。</li>
<li>每个 partition 只需要支持顺序读写就行，segment 的文件生命周期由服务端配置参数（log.segment.bytes，log.roll.{ms,hours} 等若干参数）决定。</li>
</ul>
<h5 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h5><p>segment 文件由两部分组成，分别为<code>.index</code>文件和<code>.log</code>文件，分别表示为 segment 索引文件和数据文件。这两个文件的命令规则为：</p>
<h5 id="文件名规则"><a href="#文件名规则" class="headerlink" title="文件名规则"></a>文件名规则</h5><p>partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset值，数值大小为 64 位（long 大小），20 位数字字符长度，没有数字用 0 填充。</p>
<p>实验：创建一个主题仅包含 1 个分区 ，设置每个 segment 大小为 500MB，并启动 producer 向 Kafka broker 写入大量数据，如下图所示 segment 文件列表形象说明了上述两个规则：</p>
<p><img src="https://image.woodwhales.cn/055/images/17.png"></p>
<p>以上述图中一对<code>segment file</code>文件为例，说明<code>segment</code>中<code>.index</code>和<code>.log</code> 文件的对应关系物理结构如下：</p>
<p><img src="https://image.woodwhales.cn/055/images/18.png"></p>
<p>上述图中索引文件存储大量元数据，数据文件存储大量消息，<strong>索引文件（.index）中元数据指向对应数据文件中 message 的物理偏移地址</strong>。 </p>
<p>其中以索引文件中元数据<code>[3, 497]</code>为例，依次在数据文件中表示第 3 个 message（在全局 partiton 表示第 368772 个 message）、以及该消息的物理偏移地址为 497。</p>
<h5 id="如何从-partition-中通过-offset-查找-message-呢？"><a href="#如何从-partition-中通过-offset-查找-message-呢？" class="headerlink" title="如何从 partition 中通过 offset 查找 message 呢？"></a>如何从 partition 中通过 offset 查找 message 呢？</h5><p>以上图为例，读取 offset = 368777 的消息。</p>
<ul>
<li><p>第一步：查找 segment 文件</p>
<p>其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000368769.index（起始偏移为：368769 + 1 = 368770），而第三个文件为00000000000000737337.index（起始偏移为 737337 + 1 = 737338），所以这个 offset = 368777 就落到了第二个文件之中。</p>
<p>其他后续文件可以依次类推，以其实偏移量命名并排列这些文件，然后根据<strong>二分查找法</strong>就可以快速定位到具体文件位置。</p>
<p>其次根据 00000000000000368769.index 文件中的 [8，1325] 定位到 00000000000000368769.log 文件中的1325的位置进行读取。</p>
</li>
<li><p>第二步：通过 segment file 查找 message。</p>
<p>通过第一步定位到 segment file，当 offset=368776 时，依次定位到00000000000000368769.index 的元数据（[8，1686]）物理位置（1686）和 00000000000000368769.log 的物理偏移地址（1686），然后再通过 00000000000000368769.log 顺序查找直到 offset=368776 为止。</p>
</li>
</ul>
<blockquote>
<p>要是读取 offset=368777 的消息，从 00000000000000368769.log 文件中的 1325 的位置进行读取，那么怎么知道何时读完本条消息，否则就读到下一条消息的内容了？</p>
<p>这个就需要联系到消息的物理结构了，消息都具有固定的物理结构，包括：</p>
<p>offset（8 Bytes）</p>
<p>消息体的大小（4 Bytes）</p>
<p>crc32（4 Bytes）</p>
<p>magic（1 Byte）</p>
<p>attributes（1 Byte）</p>
<p>key length（4 Bytes）</p>
<p>key（K Bytes）</p>
<p>payload（N Bytes）</p>
<p>等等字段，可以确定一条消息的大小，即读取到哪里截止。</p>
</blockquote>
<h3 id="HW-LEO"><a href="#HW-LEO" class="headerlink" title="HW &amp; LEO"></a>HW &amp; LEO</h3><h4 id="LEO（Log-End-Offset）"><a href="#LEO（Log-End-Offset）" class="headerlink" title="LEO（Log End Offset）"></a>LEO（Log End Offset）</h4><p>LEO 是日志末端位移 Log End Offset 的缩写，它标识当前日志文件中下一条待写入消息的 offset。LEO 的大小相当于当前日志分区中最后一条消息的 offset 值加 1。分区 ISR 集合中的每个副本都会维护自身的 LEO。</p>
<p><img src="https://image.woodwhales.cn/055/images/08.gif"></p>
<p>HW（High Watermark）</p>
<p>HW 俗称高水位，High Watermark 的缩写，取一个 partition 对应的 ISR 中最小的 LEO 作为 HW，它标识了一个特定的消息偏移量（offset）。</p>
<p>consumer 最多只能消费到 HW 所在的位置之前的消息。另外每个 replica 都有HW，leader 和 follower 各自负责更新自己的 HW 的状态。更精确表述为：consumer无法消费分区下leader副本中位移值大于<strong>分区 HW</strong>的任何消息。这里需要特别注意<strong>分区 HW 就是 leader 副本的 HW 值</strong>。</p>
<p>对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步后更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。对于来自内部 broker 的读取请求，没有 HW 的限制。</p>
<p><img src="https://image.woodwhales.cn/055/images/19.png"></p>
<p>对于 HW 机制有存在丢失数据的风险，因此在 Kafka 0.11 引入了<code>leader epoch</code>来取代 HW 值。感兴趣的读者可以移步至：<a href="https://www.cnblogs.com/huxi2b/p/7453543.html">Kafka水位(high watermark)与leader epoch的讨论</a>，该文章细致了讲述了 leader 副本和 follower 副本之前的 HW 及 LEO 的更新触发时机。</p>
<h3 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><p>当 producer 向 leader 发送数据时，可以通过<code>request.required.acks</code>参数来设置数据可靠性的级别：</p>
<ul>
<li>1（默认）：这意味着 producer 在 ISR 中的 leader 已成功收到数据并得到确认。如果 leader 宕机了，则会丢失数据。</li>
<li>0：这意味着 producer 无需等待来自 broker 的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li>
<li>-1：producer 需要等待 ISR中 的所有 follower 都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当 ISR 中只有 leader 时（前面 ISR 那一节讲到，ISR 中的成员由于某些情况会增加也会减少，最少就只剩一个leader），这样就变成了<code>acks=1</code>的情况。</li>
</ul>
<p>因此，<strong>如果要提高数据的可靠性，在设置<code>request.required.acks=-1</code>的同时，也要<code>min.insync.replicas</code>这个参数（可以在 broker 或者 topic 层面进行设置）)的配合，这样才能发挥最大的功效。</strong></p>
<blockquote>
<p><code>min.insync.replicas</code>这个参数设定 ISR 中的最小副本数是多少，默认值为 1。</p>
<p>当且仅当<code>request.required.acks</code>参数设置为<code>-1</code>时，此参数才生效。</p>
<p>如果 ISR 中的副本数少于<code>min.insync.replicas</code>配置的数量时，客户端会返回异常：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h5 id="request-required-acks-1"><a href="#request-required-acks-1" class="headerlink" title="request.required.acks=1"></a>request.required.acks=1</h5><p>producer 发送数据到 leader，leader 写本地日志成功，返回客户端成功；此时 ISR 中的副本还没有来得及拉取该消息，leader 就宕机了，那么此次发送的消息就会丢失。</p>
<p><img src="https://image.woodwhales.cn/055/images/20.png"></p>
<h5 id="request-required-acks-1-1"><a href="#request-required-acks-1-1" class="headerlink" title="request.required.acks=-1"></a>request.required.acks=-1</h5><p>同步的发送模式（Kafka默认为同步，即<code>producer.type=sync</code>），<code>replication.factor&gt;=2</code>且<code>min.insync.replicas&gt;=2</code>的情况下，不会丢失数据。</p>
<p>有两种典型情况。<code>acks=-1</code>的情况下（如无特殊说明，以下 acks 都表示为参数<code>request.required.acks</code>），数据发送到 leader，ISR 的 follower 全部完成数据同步后，leader 此时挂掉，那么会选举出新的 leader，数据不会丢失。</p>
<p><img src="https://image.woodwhales.cn/055/images/21.png"></p>
<p>acks=-1 的情况下，数据发送到 leader 后 ，部分 ISR 的副本同步，leader 此时挂掉。比如 follower1 和 follower2 都有可能变成新的 leader，producer 端会得到返回异常，producer 端会重新发送数据，数据可能会重复。</p>
<p><img src="https://image.woodwhales.cn/055/images/22.png"></p>
<p>当然上图中如果在 leader crash 的时候，follower2 还没有同步到任何数据，而且 follower2 被选举为新的 leader 的话，这样消息就不会重复。</p>
<p>综上：</p>
<p>producer 在同步的发送模式下（kafka默认），<code>replication.factor&gt;=2</code>且<code>min.insync.replicas&gt;=2</code>的情况下，不会丢失数据。</p>
<p>producer 在异步的发送模式下，设置<code>request.required.acks=-1</code>参数，可以保证不丢失数据，但可能存在发送重复数据风险。</p>
<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><p>对于消息的可靠性，很多人都会忽视消费端的重要性，如果一条消息成功地写入 Kafka，并且也被 Kafka 完好的保存，而在消费时，由于某些疏忽造成没有消费到这条消息，那么对于应用来说，这条消息也是丢失的。</p>
<p><code>enable.auto.commit</code>参数的默认值是 true，及开启自动位移提交的功能。对于高可靠性要求的应用来说，这种默认提交位移方式是不可取的，因此需要将<code>enable.auto.commit</code>参数设置为 false 来执行手动位移提交。</p>
<p>手动提交位移建议遵循一个原则：<strong>如果消息没有成功被消费，那么就不能提交对应的消费位移。</strong>对高可靠要求的应用来说，宁愿重复消费也不应该因为消费异常而导致消息丢失。</p>
<blockquote>
<p>有时候，由于应用解析消息的异常，可能导致部分消息一直不能成功被消费，那么这时候为了不影响整体消费的进度，可以将这类消息暂存到死信队列中，以便后续故障排查。</p>
<p>死信队列：由于某些原因消息无法被正确地投递，为了确保消息不会被无故地丢弃，一般将其置于一个特殊角色的队列，这个队列一般称为死信队列。</p>
</blockquote>
<h3 id="Java-API-生产端"><a href="#Java-API-生产端" class="headerlink" title="Java API - 生产端"></a>Java API - 生产端</h3><h4 id="KafkaProducer-实例"><a href="#KafkaProducer-实例" class="headerlink" title="KafkaProducer 实例"></a>KafkaProducer 实例</h4><p>apache 提供了工具类，方便开发者设置配置参数：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">initConfig</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9999"</span>);</span><br><span class="line">    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">    props.put(ProducerConfig.CLIENT_ID_CONFIG, <span class="string">"producer.client.id.demo"</span>);</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testKafkaProducer</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> initConfig();</span><br><span class="line">    KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(properties);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>KafkaProducer 是线程安全的，可以在多个线程中共享单个 KafkaProducer 实例，也可以将 KafkaProducer 实例进行池化来供其他线程调用。一般选用<code>public KafkaProducer(Properties properties)</code>这个构造方法来创建 KafkaProducer 实例。</p>
<h4 id="ProducerRecord-对象"><a href="#ProducerRecord-对象" class="headerlink" title="ProducerRecord 对象"></a>ProducerRecord 对象</h4><p>ProducerRecord 的构造方法有很多种：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, Integer partition, Long timestamp, K key, V value, Iterable&lt;Header&gt; headers)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, Integer partition, Long timestamp, K key, V value)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, Integer partition, K key, V value, Iterable&lt;Header&gt; headers)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, Integer partition, K key, V value)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, K key, V value)</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProducerRecord</span><span class="params">(String topic, V value)</span>；</span><br></pre></td></tr></tbody></table></figure>

<p>第一种构造函数最丰富，开发者可以自定义很多消息对象附属信息。最后一种最简单，只需要 topic 和 value 即可。</p>
<h4 id="消息发送的方式"><a href="#消息发送的方式" class="headerlink" title="消息发送的方式"></a>消息发送的方式</h4><p>KafkaProducer 的 send() 方法并非是 void 类型，而是<code>Future&lt;RecordMetadata&gt; </code>类型，send() 方法有 2 个重载方法，具体定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Asynchronously send a record to a topic，异步发送消息</span></span><br><span class="line">Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Asynchronously send a record to a topic，异步发送消息带回调</span></span><br><span class="line">Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="发后即忘（fire-and-forget）"><a href="#发后即忘（fire-and-forget）" class="headerlink" title="发后即忘（fire and forget）"></a>发后即忘（fire and forget）</h5><p>这种模式只管往 Kafka 发送消息而不关系消息是否正确到达，这种性能最高，但是可靠性最差，因为一旦发生不可重试异常的时候，就会造成消息丢失：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">producer.send(record);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="同步发送（sync）"><a href="#同步发送（sync）" class="headerlink" title="同步发送（sync）"></a>同步发送（sync）</h5><p>利用返回的 Future 对象实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">} <span class="keyword">catch</span> (ExecutionException | InterruptedException exception) {</span><br><span class="line">    exception.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>send() 方法本身是异步的，该方法返回的 Future 对象可以使调用方稍后获得发送的结果。上述代码就是直接链式调用了 get() 方法来阻塞等嗲 kafka 的响应，直到消息发送成功或者发生异常。</p>
<p>也可以不直接调用 get() 方法，比如下面这种也是同步发送方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    Future&lt;RecordMetadata&gt; future = producer.send(record);</span><br><span class="line">    <span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> metadata.topic();</span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> metadata.offset();</span><br><span class="line"></span><br><span class="line">} <span class="keyword">catch</span> (ExecutionException | InterruptedException exception) {</span><br><span class="line">    exception.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样可以获取一个 RecordMetadata 对象，在 RecordMetadata 对象里包含了消息的一些元数据信息，比如当前消息的主题、分区号、分区中的偏移量（offset）、时间戳等。</p>
<p>另外，sned() 方法的返回类型是 Future 类型，开发者可以使用 Java 语言层面的技巧来丰富应用的实现，比如使用 Future 中的 get(long timeout, TimeUnit unit) 方法实现可超时的阻塞。</p>
<p>同步发送不会像“发后即忘”的方式直接造成消息的丢失，但是这种方式的性能会很差，需要阻塞等待本条消息发送完之后才能发送下一条。</p>
<h5 id="异步发送（async）"><a href="#异步发送（async）" class="headerlink" title="异步发送（async）"></a>异步发送（async）</h5><p>在开发中最常用的方式就是使用 send() 方法中带回调信息的异步发送：即指定一个 Callback 的回调函数，kafka 在返回响应时调用该函数来实现异步的发送确认：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> {</span><br><span class="line">        <span class="keyword">if</span>(exception != <span class="literal">null</span>) {</span><br><span class="line">            exception.printStackTrace();</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"The offset of the record we just sent is: "</span> + metadata.offset());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>注意上述代码中，onCompletion() 方法的俩个参数是互斥的：</p>
<ul>
<li>消息发送成功时，metadata 不为 null 而 exception 为 null</li>
<li>消息发送失败时，metadata 为 null 而 exception 不为 null</li>
</ul>
<p>对于同一个分区来说，如果消息 record1 于 record2 之前发送，那么 KafkaProducer 可以保证对应的 callback1 在 callback2 之前调用，也就是说，回调函数的调用可以保证同一个分区内有序。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">producer.send(record1, callback1);</span><br><span class="line">producer.send(record2, callback2);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="关闭资源"><a href="#关闭资源" class="headerlink" title="关闭资源"></a>关闭资源</h4><p>KafkaProducer 发送完一批消息之后，注意及时关闭资源，KafkaProducer 提供了俩个 close() 方法，第二个是带超时时间的关闭资源方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">(<span class="type">long</span> timeout, TimeUnit timeUnit)</span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h4><p>KafkaProducer 一般会发生两种类型的异常：可重试异常和不可重试异常。</p>
<h4 id="可重试异常"><a href="#可重试异常" class="headerlink" title="可重试异常"></a>可重试异常</h4><p>常见有：NetWorkException、 LeaderNotAvailableException、UnknownTopicOrPartitionException、UnknownTopicOrPartitionException、NotCoordinatorException 等。下图展示了 kafka 可以重试的异常，只有超过重试阀值的时候才会给开发者抛出异常。</p>
<p><img src="https://image.woodwhales.cn/055/images/23.png"></p>
<p>可重试异常的配套参数为：<code>retries</code>，只要在规定的重试次数内自行恢复的，就会抛出异常。retries 参数默认值为 0，配置参考：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Java-API-消费端"><a href="#Java-API-消费端" class="headerlink" title="Java API - 消费端"></a>Java API - 消费端</h3><h4 id="poll-方法"><a href="#poll-方法" class="headerlink" title="poll() 方法"></a>poll() 方法</h4><p>Kafka 中的消费是基于拉模式的。代码形如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">		…</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码可以看出，Kafka 中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用 poll() 方法，而 poll() 方法返回的是所订阅的主题（分区）上的一组消息。</p>
<p>对于 poll() 方法而言：</p>
<ul>
<li><p>如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空。</p>
</li>
<li><p>如果订阅的所有分区中都没有可供消费的消息，那么 poll() 方法返回为空的消息集合。</p>
</li>
</ul>
<p>poll() 方法的具体定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title function_">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>timeout 参数表示超时时间参数，用来控制 poll() 方法的阻塞时间，在消费者的缓冲区里没有可用数据时会发成阻塞。</p>
<h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><p>消费端对于自动提交存在丢失数据的风险，本章节不再举代码示例。重点关注手动提交方式。</p>
<p>手动提交可以细分为同步提交和异步提交，对应 kafkaConsumer 中的<code>commitSync()</code>和<code>commitAsync()</code>两种类型的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitSync</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>同步提交的简单用法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"consumer.client.id.demo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置手动提交消息偏移</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"false"</span>);</span><br><span class="line"></span><br><span class="line">props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">"my-topic"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">            <span class="comment">// do some logical processing</span></span><br><span class="line">        }</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">    Log.error(<span class="string">"occur exception"</span>, exception);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    consumer.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码示例中，拉取到的消息是批量的，消费过程是按顺序一条条消息做相应的逻辑处理，然后对整个消息集做同步提交。等待全部消费完毕，再手动提交本批次的偏移量。针对上面的示例可以修改为批量处理 + 批量提交的方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">minBatchSize</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">List&lt;ConsumerRecord&lt;String, String&gt;&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">            buffer.add(record);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize) {</span><br><span class="line">            <span class="comment">// do some logical processing with buffer</span></span><br><span class="line">            consumer.commitSync();</span><br><span class="line">            buffer.clear();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">    Log.error(<span class="string">"occur exception"</span>, exception);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    consumer.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码示例中，将拉取到的消息缓存到 buffer，等积累到足够多的时候，也就是示例中大于等于 200 个消息时候，再做相应的处理，最后再做批量提交。</p>
<p>以上两个同步提交示例都存在重复消费的问题，如果程序在消费完数据，但还没来得及提交位移的时候出现了崩溃，那么待恢复之后只能从上一次位移提交的地方拉取消息，由此在俩次位移提交的窗口中出现了重复消费的现象。</p>
<p>consumer.commitSync() 方法会根据 poll() 方法拉取最新位移来进行提交，只要没有发生不可恢复的错误，它就会阻塞消费者线程直至位移提交完成。对于不可恢复的错误，比如 CommitFailedException、WakeupException 等，我们可以将其捕获并做针对性处理。</p>
<p>对于 commitSync() 无参方法，它提交消费位移的频率和拉取批次消息、处理批次消息的频率是一样的，如果需要更细粒度的提交，就需要使用带参数的 commitSync() 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commitSync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>该方法提供了一个 offset 参数，用来提交指定分区的位移。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">            <span class="comment">// do some logical processing</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> record.offset();</span><br><span class="line">            <span class="type">TopicPartition</span> <span class="variable">partition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">            consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(offset + <span class="number">1</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">    log.error(<span class="string">"occur exception"</span>, exception);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    consumer.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="按照分区消费并提交位移"><a href="#按照分区消费并提交位移" class="headerlink" title="按照分区消费并提交位移"></a>按照分区消费并提交位移</h5><p>实际应用很少会每消费一条消息就提交一次消费位移。因为同步提交本身就很性能，加上一条条阻塞式提交，性能会更低。更多时候是根据分区的粒度划分提交位移的界限。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TopicPartition partition : records.partitions()) {</span><br><span class="line"></span><br><span class="line">            List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">                <span class="comment">// do some logical processing</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastConsumerOffset</span> <span class="operator">=</span> partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line"></span><br><span class="line">            consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(lastConsumerOffset + <span class="number">1</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (Exception exception) {</span><br><span class="line">    log.error(<span class="string">"occur exception"</span>, exception);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    consumer.close();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>异步提交使用 commitAsync() 方法，该方法在执行的时候消费者线程不会被阻塞，该方法有 3 个重载方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">commitAsync</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commitAsync</span><span class="params">(OffsetCommitCallback callback)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commitAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二个和第三个方法里的回调函数和生产端发送回调函数类似：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) {</span><br><span class="line">        <span class="comment">// do some logical processing</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() {</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> {</span><br><span class="line">            <span class="keyword">if</span>(exception == <span class="literal">null</span>) {</span><br><span class="line">                System.out.println(offsets) ;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                log.error(<span class="string">"occur exception"</span>, exception);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意：异步提交消费位移发生异常的时候，使用回调函数捕获提交异常，如果做重试提交，那么会可能产生重复消费问题。比如：第一个异步提交位移在某一时刻失败了，此时第二个异步提交位移提交了新的位移，由于有重试的机制，那么第一个位移（相比第二个位移是旧的）提交之后，第三次消费的时候，又是从第一次消费处开始消费。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/entry/590c2d9061ff4b006239098e">消息队列技术介绍</a></p>
<p><a href="http://jm.taobao.org/2016/04/01/kafka-vs-rabbitmq-vs-rocketmq-message-send-performance/?utm_source=tuicool&amp;utm_medium=referral">Kafka、RabbitMQ、RocketMQ消息中间件的对比 —— 消息发送性能</a></p>
<p><a href="http://www.imooc.com/learn/856">Java消息中间件</a></p>
<p><a href="https://www.jianshu.com/p/9455ef87ae74">10分钟搞懂：95%的程序员都拎不清的分布式消息队列中间件</a></p>
<p><a href="https://blog.csdn.net/wqc19920906/article/details/82193316">消息中间件（一）MQ详解及四大MQ比较</a></p>
<p><a href="https://www.cnblogs.com/yinzhengjie/p/9986554.html">Kafka各个版本差异汇总</a></p>
<p><a href="http://www.jasongj.com/2015/03/10/KafkaColumn1/">Kafka设计解析（一）- Kafka背景及架构介绍</a></p>
<p><a href="https://blog.csdn.net/liyiming2017/article/details/82875068">Kafka的时代已经过去了，未来是Pulsar的吗？</a></p>
<p><a href="https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1">Thorough Introduction to Apache Kafka</a></p>
<p><a href="https://insidebigdata.com/2018/04/12/developing-deeper-understanding-apache-kafka-architecture/">Developing a Deeper Understanding of Apache Kafka Architecture</a></p>
<p><a href="https://www.confluent.io/blog/apache-kafka-for-service-architectures/">Using Apache Kafka as a Scalable, Event-Driven Backbone for Service Architectures</a></p>
<p><a href="https://www.iteblog.com/archives/2232.html">Apache Kafka消息格式的演变(0.7.x~0.10.x)</a></p>
<p><a href="https://www.iteblog.com/archives/2250.html">Kafka消息时间戳及压缩消息对时间戳的处理</a></p>
<p><a href="https://blog.csdn.net/u013256816/article/details/71091774">kafka数据可靠性深度解读</a></p>
<p><a href="https://www.iteblog.com/archives/2235.html">图解Apache Kafka消息偏移量的演变(0.7.x~0.10.x)</a></p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9004509.html">Kafka学习之路 （一）Kafka的简介</a></p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9004593.html">Kafka学习之路 （二）Kafka的架构</a></p>
<p><a href="https://www.cnblogs.com/qingyunzong/p/9004703.html">Kafka学习之路 （三）Kafka的高可用</a></p>
<p><a href="https://www.infoq.cn/article/depth-interpretation-of-kafka-data-reliability">Kafka 数据可靠性深度解读</a></p>
<p><a href="https://kaimingwan.com/post/framworks/kafka/kafkagao-ke-yong-yuan-li">kafka高可用原理</a></p>
<p><a href="https://jzwdsb.github.io/2019/02/kafka_partition_leader_election/">kafka 高可用</a></p>
<p><a href="https://www.cnblogs.com/huxi2b/p/7453543.html">Kafka水位(high watermark)与leader epoch的讨论</a></p>
<p><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html">Kafka文件存储机制那些事</a></p>
<p><a href="https://blog.csdn.net/u013256816/article/details/80790185">Kafka参数图鉴——unclean.leader.election.enable</a></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 5.7 绿色安装(for windows)</title>
    <url>/2020/02/27/058/</url>
    <content><![CDATA[<blockquote>
<p><strong>开源 &gt; 闭源</strong></p>
<p>开源软件，即使有后门或流氓行为，也比较容易被发现</p>
<p><strong>非营利组织 &gt; 商业公司</strong></p>
<p>对于大型商业公司，收集用户信息会带来商业利益，所以商业公司有收集隐私的热情</p>
</blockquote>
<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><h3 id="官方下载地址"><a href="#官方下载地址" class="headerlink" title="官方下载地址"></a>官方下载地址</h3><p>MySQL 所有版本</p>
<blockquote>
<p><a href="https://downloads.mysql.com/archives/">https://downloads.mysql.com/archives/</a></p>
</blockquote>
<p>MySQL 社区免费版 </p>
<blockquote>
<p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
</blockquote>
<p>因为 mysql 涉及到信息数据安全问题，可以对下载文件进行 MD5 验证：</p>
<p><img src="https://image.woodwhales.cn/058/images/1.png"></p>
<p><strong>windows 系统 cmd 验证命令</strong></p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">certutil -hashfile D:\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip MD5</span><br><span class="line">certutil -hashfile D:\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip SHA1</span><br><span class="line">certutil -hashfile D:\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip SHA256</span><br></pre></td></tr></tbody></table></figure>

<p><strong>linux 系统 md5 验证命令</strong></p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">md5sum mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip</span><br><span class="line">sha1sum mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip</span><br><span class="line">sha256sum mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">17</span>-winx64.zip</span><br></pre></td></tr></tbody></table></figure>

<h3 id="官方安装文件"><a href="#官方安装文件" class="headerlink" title="官方安装文件"></a>官方安装文件</h3><p>zip包安装文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/windows-install-archive.html">https://dev.mysql.com/doc/refman/5.7/en/windows-install-archive.html</a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="解压-MySQL-安装包"><a href="#解压-MySQL-安装包" class="headerlink" title="解压 MySQL 安装包"></a>解压 MySQL 安装包</h3><p>使用压缩工具解压 MySQL 安装包，解压工具推荐：<a href="https://www.7-zip.org/download.html">7-Zip</a></p>
<p><img src="https://image.woodwhales.cn/058/images/2.png"></p>
<p><em>解压建议：解压目录全为英文且不带空格。</em></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在系统的环境变量中增加<code>MYSQL_HOME</code>系统变量：</p>
<img src="https://image.woodwhales.cn/058/images/3.png" style="zoom:75%;">

<p>将上面创建的系统变量配置到<code>PATH</code>环境变量中：</p>
<img src="https://image.woodwhales.cn/058/images/4.png" style="zoom:75%;">

<h3 id="创建数据存在目录"><a href="#创建数据存在目录" class="headerlink" title="创建数据存在目录"></a>创建数据存在目录</h3><p>在 MySQL 安装目录下创建名称为<code>data</code>的文件夹，用于存放数据库数据。</p>
<img src="https://image.woodwhales.cn/058/images/5.png" style="zoom:75%;">

<h3 id="创建用户配置文件"><a href="#创建用户配置文件" class="headerlink" title="创建用户配置文件"></a>创建用户配置文件</h3><p>在 MySQL 安装目录下找到<code>my-default.ini</code>文件 ，复制一份到当前目录下，并修改文件名为<code>my.ini</code> ，用文本编辑器编辑这个新的文件。</p>
<p>如果没有<code>my-default.ini</code>文件，则在当前目录下，创建一个名称为<code>my.ini</code>的配置文件：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span> </span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=C:\programs\mysql-<span class="number">5.7</span>.<span class="number">27</span></span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=C:\programs\mysql-<span class="number">5.7</span>.<span class="number">27</span>\data</span><br><span class="line"><span class="comment"># 开启Binlog</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br><span class="line"><span class="attr">binlog_format</span>=ROW</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 设置mysql服务端默认字符集</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4</span><br><span class="line"><span class="attr">collation-server</span>=utf8mb4_unicode_ci</span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8mb4'</span></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br></pre></td></tr></tbody></table></figure>

<p>以上配置中<code>basedir</code>和<code>datadir</code>必须配置，并且配置成当前 MySQL 的解压路径。</p>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h3 id="初始化MySQL服务"><a href="#初始化MySQL服务" class="headerlink" title="初始化MySQL服务"></a>初始化MySQL服务</h3><p>继续上步骤执行命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\programs\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">27</span>\bin    # 切换到 MySQL 安装目录的 bin 文件夹下</span><br><span class="line"></span><br><span class="line">mysqld --initialize --user=mysql --console</span><br></pre></td></tr></tbody></table></figure>

<p>执行成功之后，会看到 root 用户的初始化密码：</p>
<p><img src="https://image.woodwhales.cn/058/images/6.png"></p>
<p>以上命令执行成功之后，在 data 数据文件夹中也存在了 MySQL 数据文件：</p>
<h3 id="安装MySQL服务"><a href="#安装MySQL服务" class="headerlink" title="安装MySQL服务"></a>安装MySQL服务</h3><p>在系统开始菜单中找到<code>cmd</code>程序，右击选择<code>以管理员身份运行</code>运行程序，进入 dos 窗口，执行命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"># MySQL 服务安装</span><br><span class="line">mysqld install MySQL --defaults-file="C:\programs\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">27</span>\my.ini"    </span><br></pre></td></tr></tbody></table></figure>

<p>提示：”Service successfully installed.”，则表示初始化成功：</p>
<p><img src="https://image.woodwhales.cn/058/images/8.png"></p>
<h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><p>使用 dos 命令行启动 MySQL 服务，注意要使用<strong>管理员身份</strong>运行 dos 窗口：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysql # 启动 MySQL 服务</span><br><span class="line"><span class="built_in">net</span> stop mysql # 禁用 MySQL 服务</span><br><span class="line">sc delete mysql # 删除 MySQL 服务</span><br></pre></td></tr></tbody></table></figure>

<h3 id="更新初始化密码"><a href="#更新初始化密码" class="headerlink" title="更新初始化密码"></a>更新初始化密码</h3><p>使用初始化 MySQL 服务章节中的初始化密码登录MySQL服务：</p>
<p><img src="https://image.woodwhales.cn/058/images/9.png"></p>
<p>执行更新密码命令并刷新权限即可：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> password=password('新密码');</span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/058/images/10.png"></p>
<h2 id="修改-root-权限密码（忘记密码）"><a href="#修改-root-权限密码（忘记密码）" class="headerlink" title="修改 root 权限密码（忘记密码）"></a>修改 root 权限密码（忘记密码）</h2><p>步骤1：关闭正在运行的 MySQL 服务</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> stop mysql</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：打开DOS窗口，转到<code>mysql\bin</code>目录</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\programs\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">27</span>\bin</span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：开启登录跳过权限验证，执行以下命令并回车</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">mysqld --skip-grant-tables</span><br></pre></td></tr></tbody></table></figure>

<p><code>--skip-grant-tables</code>的意思是启动MySQL服务的时候跳过权限表认证。  </p>
<p>注意：该窗口光标处于不可用状态，保持窗口不动。</p>
<p>步骤4：再开启新的 dos 窗口，直接登录mysql</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\programs\mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">27</span>\bin</span><br><span class="line">mysql -uroot -p  # 直接回车进入mysql</span><br><span class="line"></span><br><span class="line">&gt; use mysql;</span><br><span class="line">&gt; update user <span class="built_in">set</span> authentication_string=password("新密码") where user="root";</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">&gt; update mysql.user <span class="built_in">set</span> authentication_string=password('新密码') where user='root';</span><br></pre></td></tr></tbody></table></figure>

<p>步骤5：刷新权限</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p>步骤6：关闭所有 dos 窗口，启动 mysql 服务。</p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>mysql5.7安装</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Layui ThymeLeaf 一点点学习心得</title>
    <url>/2019/12/21/056/</url>
    <content><![CDATA[<h3 id="ThymeLeaf-环境配置"><a href="#ThymeLeaf-环境配置" class="headerlink" title="ThymeLeaf 环境配置"></a>ThymeLeaf 环境配置</h3><blockquote>
<p>ThymeLeaf 官网：<a href="https://www.thymeleaf.org/">https://www.thymeleaf.org/</a></p>
<p>文档：<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html</a></p>
<p>本站文档：<a href="https://image.woodwhales.cn/056/thymeleaf-3.0.pdf">thymeleaf-3.0.pdf</a></p>
</blockquote>
<p>pom 依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>导入 tymeleaf 依赖之后，配置  tymeleaf 参数，在 application.yml 配置文件中配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">thymeleaf:</span> <span class="comment"># thymeleaf配置</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span> <span class="comment"># 不缓存</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span> <span class="comment"># 默认后缀就是 .html</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Controller-配置注意事项"><a href="#Controller-配置注意事项" class="headerlink" title="Controller 配置注意事项"></a>Controller 配置注意事项</h4><p>注意如果一个 controller 需要映射页面，那么不要使用 @RestController 注解，而是使用 @Controller 注解，参见下图示例：</p>
<p><img src="https://image.woodwhales.cn/056/images/02.png"></p>
<h4 id="html-标签注意事项"><a href="#html-标签注意事项" class="headerlink" title="html 标签注意事项"></a>html 标签注意事项</h4><h5 id="使用-thymeleaf-插件"><a href="#使用-thymeleaf-插件" class="headerlink" title="使用 thymeleaf 插件"></a>使用 thymeleaf 插件</h5><p>如果使用的开发工具是 STS（<a href="https://spring.io/tools3/sts/all%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%8B">https://spring.io/tools3/sts/all），那么可以离线安装一下</a> thymeleaf 插件，在页面编写的时候可以有 thymeleaf 标签提示。</p>
<blockquote>
<p>插件官网：<a href="https://www.thymeleaf.org/eclipse-plugin-update-site/">https://www.thymeleaf.org/eclipse-plugin-update-site/</a></p>
<p>离线安装包下载地址：<a href="https://github.com/thymeleaf/thymeleaf-extras-eclipse-plugin/releases">https://github.com/thymeleaf/thymeleaf-extras-eclipse-plugin/releases</a></p>
</blockquote>
<h5 id="增加-xmlns-配置"><a href="#增加-xmlns-配置" class="headerlink" title="增加 xmlns 配置"></a>增加 xmlns 配置</h5><p>注意在页面的  标签中增加 xmlns，指定为：<a href="http://www.thymeleaf.org,否则/">http://www.thymeleaf.org，否则</a> STS 中 thymeleaf  插件无法自动提示标签：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></tbody></table></figure>

<h5 id="设置不解析-javascript-语句块"><a href="#设置不解析-javascript-语句块" class="headerlink" title="设置不解析 javascript 语句块"></a>设置不解析 javascript 语句块</h5><p>thymeleaf 将 js 代码中的二维数组，当做了自己的标签，进行解析，因此访问页面的时候会出现：<code>Could not parse as expression</code>异常。解决方案就是只需要在 javascript 标签上加<code>th:inline="none"</code>标签即可：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">th:inline</span>=<span class="string">"none"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Layui-环境配置"><a href="#Layui-环境配置" class="headerlink" title="Layui 环境配置"></a>Layui 环境配置</h3><blockquote>
<p>layui 官网：<a href="https://www.layui.com/">https://www.layui.com/</a></p>
<p>文档：<a href="https://www.layui.com/demo/">https://www.layui.com/demo/</a></p>
</blockquote>
<p>本工程使用 jar 包形式引入 layui 工程：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- layui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>layui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jquery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- droped webjars version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>webjars-locator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>增加 layui 的同时，还要增加俩个其他的辅助 jar 包：</p>
<ul>
<li><p>增加 <a href="https://jquery.com/">jquery</a>，因为 layui 依赖了 jq。</p>
</li>
<li><p>增加去掉 webjars 版本号，当在工程里引用 webjars 目录下的静态文件时不需要指定版本号。</p>
<p>形如：</p>
<p><img src="https://image.woodwhales.cn/056/images/01.png"></p>
</li>
</ul>
<h3 id="x-admin-配置"><a href="#x-admin-配置" class="headerlink" title="x-admin 配置"></a>x-admin 配置</h3><blockquote>
<p>x-admin 官网：<a href="http://x.xuebingsi.com/index/down/index.html">http://x.xuebingsi.com/index/down/index.html</a></p>
<p>在线示例：<a href="http://x.xuebingsi.com/x-admin/v2.2/">http://x.xuebingsi.com/x-admin/v2.2/</a></p>
</blockquote>
<h4 id="引入到-springboot-工程"><a href="#引入到-springboot-工程" class="headerlink" title="引入到 springboot 工程"></a>引入到 springboot 工程</h4><p>本示例使用后台模板为：x-admin，将下载好压缩包解压，得到：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">─X-admin</span><br><span class="line">   ├─css</span><br><span class="line">   ├─fonts</span><br><span class="line">   ├─images</span><br><span class="line">   ├─js</span><br><span class="line">   └─lib</span><br><span class="line">       └─layui</span><br><span class="line">           ├─css</span><br><span class="line">           │  └─modules</span><br><span class="line">           │      ├─laydate</span><br><span class="line">           │      │  └─default</span><br><span class="line">           │      └─layer</span><br><span class="line">           │          └─default</span><br><span class="line">           ├─font</span><br><span class="line">           ├─images</span><br><span class="line">           │  └─face</span><br><span class="line">           └─lay</span><br><span class="line">               └─modules</span><br></pre></td></tr></tbody></table></figure>

<p>在项目的<code>static</code>和<code>templates</code>文件目录下创建<code>xadmin</code>文件夹： </p>
<p>将 js 、images、css、fonts 目录拷贝至：<code>/src/main/resources/static/xadmin</code>目录下，</p>
<p>将所有 html 页面拷贝至：<code>src/main/resources/templates/xadmin</code>目录下：</p>
<p>注意：这里不需要拷贝 lib 目录了，因为上文已经引入了 layui 的 jar 包了</p>
<p><img src="https://image.woodwhales.cn/056/images/04.png"></p>
<h4 id="页面映射路径注意事项"><a href="#页面映射路径注意事项" class="headerlink" title="页面映射路径注意事项"></a>页面映射路径注意事项</h4><p>本示例将模板放在了 xadmin 目录下，所以首页路径映射是下面这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping("/xadmin")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XAdminController</span> {</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping({"/index.html", "/"})</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"xadmin/index"</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@GetMapping("welcome.html")</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">welcome</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"xadmin/welcome"</span>;</span><br><span class="line">	}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略的代码 ……</span></span><br><span class="line">        </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="静态资源访问路径注意事项"><a href="#静态资源访问路径注意事项" class="headerlink" title="静态资源访问路径注意事项"></a>静态资源访问路径注意事项</h4><p>x-admin 模板对静态文件引用使用的是相对路径，因此需要更改一下：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./lib/layui/layui.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">修改为：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/webjars/layui/layui.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了保持项目“干净”，每个文件末尾有个下文这样的 js 脚本，可以删除掉：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="keyword">var</span> _hmt = _hmt || []; (<span class="keyword">function</span>(<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="language-javascript">        hm.<span class="property">src</span> = <span class="string">"https://hm.baidu.com/hm.js?b393d153aeb26b46e9431fabaf0f6190"</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(hm, s);</span></span><br><span class="line"><span class="language-javascript">      })();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="xm-select-下拉多选"><a href="#xm-select-下拉多选" class="headerlink" title="xm-select 下拉多选"></a>xm-select 下拉多选</h3><blockquote>
<p>官网地址：<a href="https://maplemei.gitee.io/xm-select/#/component/install">https://maplemei.gitee.io/xm-select/#/component/install</a></p>
</blockquote>
<p>本示例运行效果：</p>
<p><img src="https://image.woodwhales.cn/056/images/05.png"></p>
<p><img src="https://image.woodwhales.cn/056/images/06.png"></p>
<p>html 页面位置：<code>src/main/resources/templates/xadmin/admin-add.html</code></p>
<p>在城市字段位置增加了下拉多选框：</p>
<p><img src="https://image.woodwhales.cn/056/images/07.png"></p>
<p>注意在页面中引入 xm-select 插件脚本：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./js/xm-select.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/056/images/11.png"></p>
<p>js 脚本渲染：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>({</span><br><span class="line">    <span class="attr">url</span>: <span class="string">'/city/listAll'</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">'get'</span>,</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">'json'</span>,</span><br><span class="line">    <span class="attr">contentType</span>:<span class="string">"application/json"</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">        xmSelect.<span class="title function_">render</span>({</span><br><span class="line">            <span class="attr">el</span>: <span class="string">'#cityList'</span>,</span><br><span class="line">            <span class="attr">filterable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">paging</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pageSize</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">size</span>: <span class="string">'medium'</span>,</span><br><span class="line">            <span class="attr">data</span>: res.<span class="property">data</span></span><br><span class="line">        });</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>后台数据响应文件位置：<code>org.woodwhales.layui.controller.CityController.listAll()</code></p>
<h3 id="批量创建（批量提交）"><a href="#批量创建（批量提交）" class="headerlink" title="批量创建（批量提交）"></a>批量创建（批量提交）</h3><p>本示例运行效果：</p>
<p><img src="https://image.woodwhales.cn/056/images/08.png"></p>
<p><img src="https://image.woodwhales.cn/056/images/09.png"></p>
<p>动态效果图：</p>
<p><img src="https://image.woodwhales.cn/056/images/01.gif"></p>
<p>由于批量操作基本上是对“同一类”用户进行批量创建，因此他们的同一类是角色，因此点击“+”按钮的时候，新增的行会取前一行的角色的值。</p>
<p>批量提交之后，后台会将本批次提交的结果再响应回来，创建成功的记录有“userId”，创建失败的有失败原因提示。</p>
<p>html 页面位置：<code>src/main/resources/templates/xadmin/admin-batch-add.html</code></p>
<p>在页面中定义一个表格 div：</p>
<p><img src="https://image.woodwhales.cn/056/images/10.png"></p>
<p>js 脚本控制：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">$(<span class="string">"#addTable"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">    $(<span class="string">'#submitBtn'</span>).<span class="title function_">removeAttr</span>(<span class="string">"disabled"</span>);</span><br><span class="line">    <span class="keyword">var</span> oldData = table.<span class="property">cache</span>[<span class="string">"baseInfo"</span>];</span><br><span class="line">    <span class="keyword">var</span> tempRoleTypeList = oldData[oldData.<span class="property">length</span>-<span class="number">1</span>].<span class="property">roleTypeList</span>;</span><br><span class="line">    <span class="keyword">var</span> tempData = {<span class="attr">name</span>: <span class="string">""</span>, <span class="attr">email</span>: <span class="string">""</span>, <span class="attr">mobile</span>: <span class="string">""</span>, <span class="attr">roleTypeList</span>: tempRoleTypeList};</span><br><span class="line">    tableData.<span class="title function_">push</span>(tempData);</span><br><span class="line">    oldData.<span class="title function_">push</span>(tempData);</span><br><span class="line">    table.<span class="title function_">reload</span>(<span class="string">'baseInfo'</span>,{</span><br><span class="line">        data : oldData</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#deleteLastLine"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>){		</span><br><span class="line">    <span class="keyword">var</span> oldData = table.<span class="property">cache</span>[<span class="string">"baseInfo"</span>];</span><br><span class="line">    <span class="keyword">delete</span> oldData[oldData.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(oldData.<span class="property">length</span> == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">var</span> tempData = {<span class="attr">name</span>: <span class="string">""</span>, <span class="attr">email</span>: <span class="string">""</span>, <span class="attr">mobile</span>: <span class="string">""</span>, <span class="attr">roleTypeList</span>: <span class="string">""</span>};</span><br><span class="line">        oldData[<span class="number">0</span>] = tempData;</span><br><span class="line">        table.<span class="title function_">reload</span>(<span class="string">'baseInfo'</span>,{</span><br><span class="line">            data : oldData</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    table.<span class="title function_">reload</span>(<span class="string">'baseInfo'</span>,{</span><br><span class="line">        data : oldData</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#clearTable"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> oldData = table.<span class="property">cache</span>[<span class="string">"baseInfo"</span>];</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt; oldData.<span class="property">length</span>; i++) {</span><br><span class="line">        <span class="keyword">delete</span> oldData[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> tempData = {<span class="attr">name</span>: <span class="string">""</span>, <span class="attr">email</span>: <span class="string">""</span>, <span class="attr">mobile</span>: <span class="string">""</span>, <span class="attr">roleTypeList</span>: <span class="string">""</span>};</span><br><span class="line">    oldData[<span class="number">0</span>] = tempData;</span><br><span class="line">    table.<span class="title function_">reload</span>(<span class="string">'baseInfo'</span>,{</span><br><span class="line">        data : oldData</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#submitBtn"</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">    <span class="keyword">var</span> brachData = table.<span class="property">cache</span>[<span class="string">"baseInfo"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> requestData = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; brachData.<span class="property">length</span>; i++) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">isEmpty</span>(brachData[i].<span class="property">name</span>)</span><br><span class="line">           || <span class="title function_">isEmpty</span>(brachData[i].<span class="property">email</span>)</span><br><span class="line">           || <span class="title function_">isEmpty</span>(brachData[i].<span class="property">mobile</span>)</span><br><span class="line">           || <span class="title function_">isEmpty</span>(brachData[i].<span class="property">roleTypeList</span>)) {</span><br><span class="line">            layer.<span class="title function_">alert</span>(<span class="string">'数据列表不允许存在空值！'</span>, {<span class="attr">icon</span>: <span class="number">5</span>});</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        requestData[i] = {</span><br><span class="line">            <span class="string">'name'</span>:brachData[i].<span class="property">name</span>,</span><br><span class="line">            <span class="string">'email'</span>:brachData[i].<span class="property">email</span>,</span><br><span class="line">            <span class="string">'mobile'</span>:brachData[i].<span class="property">mobile</span>,</span><br><span class="line">            <span class="string">'roleTypeList'</span>:brachData[i].<span class="property">roleTypeList</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    $.<span class="title function_">ajax</span>({</span><br><span class="line">        <span class="attr">url</span>: <span class="string">'/user/batchCreate'</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'post'</span>,</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">'json'</span>,</span><br><span class="line">        <span class="attr">contentType</span>:<span class="string">"application/json"</span>,</span><br><span class="line">        <span class="attr">async</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">cache</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">data</span>:<span class="title class_">JSON</span>.<span class="title function_">stringify</span>({<span class="string">'batch'</span> : requestData}),</span><br><span class="line"></span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">            <span class="keyword">var</span> tableHtml = <span class="string">'&lt;div style="padding:10px;"&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;div class="layui-form"&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;table class="layui-table" lay-skin="row"&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;thead&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;tr&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;姓名&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;邮箱&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;手机号&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;角色&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;用户帐号&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;th&gt;失败原因&lt;/th&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;/tr&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;/thead&gt;'</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;res.<span class="property">data</span>.<span class="property">length</span>; i++) {</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>[i]);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>[i].<span class="property">name</span>);</span><br><span class="line">                <span class="keyword">var</span> tempTr = <span class="string">'&lt;tr&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">name</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">email</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">mobile</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">roleTypeList</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">userId</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;td&gt;'</span> + res.<span class="property">data</span>[i].<span class="property">errorMsg</span> + <span class="string">'&lt;/td&gt;'</span>;</span><br><span class="line">                tempTr += <span class="string">'&lt;/tr&gt;'</span>;</span><br><span class="line"></span><br><span class="line">                tableHtml += tempTr;</span><br><span class="line">            }</span><br><span class="line">            tableHtml += <span class="string">'&lt;/table&gt;&lt;/div&gt;'</span>;</span><br><span class="line">            tableHtml += <span class="string">'&lt;div&gt;'</span>;</span><br><span class="line"></span><br><span class="line">            layer.<span class="title function_">open</span>({</span><br><span class="line">                <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">area</span>: [<span class="string">'100%'</span>, <span class="string">'100%'</span>],</span><br><span class="line">                <span class="attr">shade</span>: <span class="number">0.6</span>, <span class="comment">//遮罩透明度</span></span><br><span class="line">                <span class="attr">title</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">fixed</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">closeBtn</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">maxmin</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">resize</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">shadeClose</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">anim</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">content</span>: tableHtml</span><br><span class="line">            });</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">data</span>) {</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>另外，为了判断表格中的数据全部不允许为空，定义了判断字符串是否为空函数：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) {</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">"undefined"</span> || obj == <span class="literal">null</span> || obj == <span class="string">""</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>后台数据响应文件位置：<code>org.woodwhales.layui.controller.UserController.batchCreate(BatchCreateRequestBody)</code></p>
<h3 id="动态加载复选框"><a href="#动态加载复选框" class="headerlink" title="动态加载复选框"></a>动态加载复选框</h3><p>本示例运行效果：</p>
<p><img src="https://image.woodwhales.cn/056/images/12.png"></p>
<p><img src="https://image.woodwhales.cn/056/images/13.png"></p>
<p>html 页面位置：<code>/springboot-layui-tymeleaf-demo/src/main/resources/templates/xadmin/admin-edit.html</code></p>
<p>在页面中的“角色”字段位置增加自定义的复选框 div：</p>
<p><img src="https://image.woodwhales.cn/056/images/14.png"></p>
<p>js 脚本渲染：</p>
<p>注意使用  jq 改变了原始 div 的元素属性，一定要记得刷新表单：<code>form.render();</code></p>
<figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">    <span class="comment">// 获取角色信息列表（数据字典）</span></span><br><span class="line">    $.<span class="title function_">ajax</span>({</span><br><span class="line">        <span class="attr">url</span>: <span class="string">'/roleType/listAll'</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'get'</span>,</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">'json'</span>,</span><br><span class="line">        <span class="attr">contentType</span>:<span class="string">"application/json"</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">            <span class="keyword">var</span> roleTypeList = res.<span class="property">data</span>;</span><br><span class="line">            <span class="comment">// 获取 checkbox 父 div，遍历追加元素，最后刷新表单</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;roleTypeList.<span class="property">length</span>;i++) {</span><br><span class="line">                <span class="keyword">var</span> tmepHtml = <span class="string">'&lt;input type="checkbox" name="roleTypeCheckBox" value="'</span>+roleTypeList[i].<span class="property">id</span>+<span class="string">'" lay-skin="primary" title="'</span>+roleTypeList[i].<span class="property">name</span>+<span class="string">'"&gt;'</span></span><br><span class="line">                $(<span class="string">"#roleTypeList"</span>).<span class="title function_">append</span>(tmepHtml);     		        		</span><br><span class="line">            }</span><br><span class="line">            form.<span class="title function_">render</span>();</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    $.<span class="title function_">ajax</span>({</span><br><span class="line">        <span class="attr">url</span>: <span class="string">'/user/userId_1'</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'get'</span>,</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">'json'</span>,</span><br><span class="line">        <span class="attr">contentType</span>:<span class="string">"application/json"</span>,</span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">            <span class="keyword">var</span> roleTypeList = res.<span class="property">data</span>.<span class="property">roleTypeList</span>;</span><br><span class="line">            <span class="comment">// 遍历所有的checkbox（数据字典），</span></span><br><span class="line">            <span class="comment">// 将每一个元素和用户数据对象中的所属角色匹配，</span></span><br><span class="line">            <span class="comment">// 匹配到了就设置已选中，最后刷新表单</span></span><br><span class="line">            $(<span class="string">"input[name='roleTypeCheckBox']"</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">i</span>){</span><br><span class="line">                <span class="keyword">var</span> roleTypeId = $(<span class="variable language_">this</span>).<span class="title function_">val</span>();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'roleTypeId'</span>, roleTypeId);</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;roleTypeList.<span class="property">length</span>; i++) {</span><br><span class="line">                    <span class="keyword">if</span>(roleTypeList[i].<span class="property">id</span> == roleTypeId) {</span><br><span class="line">                        $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">"checked"</span>,<span class="string">"''"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            form.<span class="title function_">render</span>();</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">res</span>) {</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>后台数据响应文件位置：</p>
<ul>
<li><p>角色类型数据字典：<code>org.woodwhales.layui.controller.RoleRTypeController.listAll()</code></p>
</li>
<li><p>用户详情：<code>org.woodwhales.layui.controller.UserController.queryUserById(String)</code></p>
</li>
</ul>
<p>源码 github  地址：<a href="https://github.com/woodwhales/springboot-layui-tymeleaf-demo.git">springboot-layui-tymeleaf-demo</a></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title>STS 常用设置</title>
    <url>/2020/02/27/059/</url>
    <content><![CDATA[<p>使用 eclipse 开发工具的小伙伴们，建议使用 Spring Tools（俗称 STS），这是 spring 组织对 eclipse 进行了再封装，集成了 springboot 插件，比原生的 eclipse 好用一些：<a href="https://spring.io/tools/">https://spring.io/tools/</a></p>
<p><img src="https://image.woodwhales.cn/059/images/1.png"></p>
<p>以下所有配置设置没有特殊说明，都是在 windows -&gt; preferences 窗口中设置。</p>
<h2 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h2><p>General &gt; Apperance &gt; Colors and Fonts &gt; Basic &gt; Text Font，点击右边的<code>Edit</code>编辑按钮，设置字体大小。</p>
<img src="https://image.woodwhales.cn/059/images/2.png" style="zoom:75%;">

<h2 id="编码字符集"><a href="#编码字符集" class="headerlink" title="编码字符集"></a>编码字符集</h2><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><p>General &gt; Workspace，在<code>Text file encoding</code>选项中，选择<code>UTF-8</code>。</p>
<img src="https://image.woodwhales.cn/059/images/3.png" style="zoom:75%;">

<p>笔者因为在<code>eclipse.ini</code>文件中配置了一行参数：<code>-Dfile.encoding=UTF-8</code>，所以默认就是 UTF-8。</p>
<img src="https://image.woodwhales.cn/059/images/4.png" style="zoom:75%;">

<h3 id="JSP-文件"><a href="#JSP-文件" class="headerlink" title="JSP 文件"></a>JSP 文件</h3><p>Web &gt; JSP Files，设置<code>Encoding</code>为：UTF-8。</p>
<img src="https://image.woodwhales.cn/059/images/5.png" style="zoom:75%;">

<h3 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h3><p>General &gt; Content Types &gt; Text，在<code>Default encoding</code>文本框中手动填写：UTF-8，之后点击<code>Update</code>按钮。</p>
<img src="https://image.woodwhales.cn/059/images/6.png" style="zoom:75%;">

<p>注意，要检查<code>Text</code> 下拉项下的所有<code>Default encoding</code> 是不是都是 UTF-8，默认情况下，会存在一些选项不是 UTF-8，因此要特别细心检查一遍。</p>
<h2 id="开启自动导包"><a href="#开启自动导包" class="headerlink" title="开启自动导包"></a>开启自动导包</h2><p>Java &gt; Editor &gt; Save Actions，勾选<code>Organize impots</code>。</p>
<img src="https://image.woodwhales.cn/059/images/7.png" style="zoom:75%;">

<h2 id="设置-tab为-4-个空格缩进"><a href="#设置-tab为-4-个空格缩进" class="headerlink" title="设置 tab为 4 个空格缩进"></a>设置 tab为 4 个空格缩进</h2><p>在阿里《Java 开发手册》中，强制要求禁用 tab，使用 4 个字符来替代 tab。</p>
<blockquote>
<p>《Java 开发手册》</p>
<p>【强制】采用 4 个空格缩进，禁止使用 tab 字符。<br>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use<br>tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</p>
</blockquote>
<p>General &gt; Editors &gt; Text Editors，勾选中<code>insert space for tabs</code>。</p>
<img src="https://image.woodwhales.cn/059/images/8.png" style="zoom:75%;">

<h2 id="设置换行符为Unix格式"><a href="#设置换行符为Unix格式" class="headerlink" title="设置换行符为Unix格式"></a>设置换行符为Unix格式</h2><p>在阿里《Java 开发手册》中强制要求换行符使用 Unix 格式。</p>
<blockquote>
<p>《Java 开发手册》</p>
<p>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不<br>要使用 Windows 格式。</p>
</blockquote>
<img src="https://image.woodwhales.cn/059/images/16.png" style="zoom:75%;">

<h2 id="自动补齐提示"><a href="#自动补齐提示" class="headerlink" title="自动补齐提示"></a>自动补齐提示</h2><h3 id="Java-文件自动补齐"><a href="#Java-文件自动补齐" class="headerlink" title="Java 文件自动补齐"></a>Java 文件自动补齐</h3><p>Java &gt; Editor &gt; Content Assist，在<code>Auto activation triggers for Java</code>文本框中填写：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></tbody></table></figure>

<img src="https://image.woodwhales.cn/059/images/10.png" style="zoom:75%;">

<h3 id="XML-文件自动补齐"><a href="#XML-文件自动补齐" class="headerlink" title="XML 文件自动补齐"></a>XML 文件自动补齐</h3><p>XML &gt; XML Files &gt; Editor &gt; Content Assist，在<code>prompt when these characters are insrted</code>文本框中填写：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">&lt;=: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></tbody></table></figure>

<img src="https://image.woodwhales.cn/059/images/11.png" style="zoom:75%;">

<h3 id="JavaScript-文件自动补齐"><a href="#JavaScript-文件自动补齐" class="headerlink" title="JavaScript 文件自动补齐"></a>JavaScript 文件自动补齐</h3><p>JavaScript &gt; Editor &gt; Content Assist，勾选开启自动提示，并填写：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></tbody></table></figure>

<img src="https://image.woodwhales.cn/059/images/14.png" style="zoom:75%;">

<p>HTML 文件自动补齐</p>
<p>Web &gt; HTML Files &gt; Content Assist，在<code>prompt when these characters are insrted</code>文本框中填写：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">&lt;=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/059/images/15.png"></p>
<h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><h3 id="代码自动补齐"><a href="#代码自动补齐" class="headerlink" title="代码自动补齐"></a>代码自动补齐</h3><p>Genernal &gt; Keys，设置<code>Content Assist</code>的快捷键为：Alt + Z。</p>
<img src="https://image.woodwhales.cn/059/images/12.png" style="zoom:75%;">

<h3 id="快速开启资源选择菜单"><a href="#快速开启资源选择菜单" class="headerlink" title="快速开启资源选择菜单"></a>快速开启资源选择菜单</h3><p>Genernal &gt; Keys，设置<code>Show Source Quick Menu</code>的快捷键为：Alt + S。</p>
<img src="https://image.woodwhales.cn/059/images/13.png" style="zoom:75%;">

<h2 id="常用插件安装"><a href="#常用插件安装" class="headerlink" title="常用插件安装"></a>常用插件安装</h2><h3 id="Java-Decompiler-Eclipse"><a href="#Java-Decompiler-Eclipse" class="headerlink" title="Java Decompiler Eclipse"></a>Java Decompiler Eclipse</h3><blockquote>
<p>插件官方地址：<a href="http://java-decompiler.github.io/%EF%BC%88%E5%9B%BD%E5%86%85%E5%8F%AF%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%EF%BC%89">http://java-decompiler.github.io/（国内可能访问不到）</a></p>
<p>插件下载地址：<a href="https://github.com/java-decompiler/jd-eclipse/releases">https://github.com/java-decompiler/jd-eclipse/releases</a></p>
<p>本站下载地址：</p>
<p>插件版：<a href="https://image.woodwhales.cn/059/jd-eclipse-2.0.0.zip">jd-eclipse-2.0.0.zip</a></p>
<p>windows桌面版：<a href="https://image.woodwhales.cn/059/jd-gui-windows-1.6.6.zip">jd-gui-windows-1.6.6.zip</a></p>
</blockquote>
<p>安装步骤，点击 Help &gt; Install New Software，添加 zip 文件：</p>
<img src="https://image.woodwhales.cn/059/images/17.png" style="zoom:75%;">

<p>名称填写：<code>JD-Eclipse Update Site</code>，点击<code>next</code>进行安装。</p>
<blockquote>
<p>如果不能点击 next 按钮，将 zip 包解压，将 plugins 文件中的 jar 包拷贝到 STS 的 plugins 文件中即可。</p>
</blockquote>
<p>再配置 class 文件默认使用该插件打开：General &gt; Editors &gt; File Associations，分别选中<code>.class</code>、<code>.class without source</code>，再选中下面<code>JD Class File Viewer</code>，再点击<code>Default</code>按钮，设置其为默认。</p>
<img src="https://image.woodwhales.cn/059/images/21.png" style="zoom:75%;">

<h3 id="ER-Master"><a href="#ER-Master" class="headerlink" title="ER Master"></a>ER Master</h3><blockquote>
<p>官方安装教程：<a href="http://ermaster.sourceforge.net/">http://ermaster.sourceforge.net/</a></p>
<p>最新插件下载：<a href="https://sourceforge.net/projects/ermaster/files/">https://sourceforge.net/projects/ermaster/files/</a></p>
<p>本站下载地址：<a href="https://image.woodwhales.cn/059/org.insightech.er_1.0.0.v20150619-0219.jar">org.insightech.er_1.0.0.v20150619-0219.jar</a></p>
</blockquote>
<p>安装步骤：将 jar 文件拷贝到<code>plugins</code>文件夹中，重启 eclipse 即可。</p>
<p>使用步骤：</p>
<p>步骤1：创建er文件。</p>
<img src="https://image.woodwhales.cn/059/images/18.png" style="zoom:75%;">

<p>步骤2：链接数据库</p>
<img src="https://image.woodwhales.cn/059/images/19.png" style="zoom:75%;">

<h2 id="国内镜像替换"><a href="#国内镜像替换" class="headerlink" title="国内镜像替换"></a>国内镜像替换</h2><p>中科大镜像官方教程：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/eclipse">https://lug.ustc.edu.cn/wiki/mirrors/help/eclipse</a></p>
<blockquote>
<p>以 Luna 为例，点击 <code>Help</code>→<code>Install New Software...</code>→<code>Available Software Sites</code> 可以看到所有的更新源，将其中的<code>download.eclipse.org</code>全部替换成<code>mirrors.ustc.edu.cn/eclipse</code>即可。</p>
</blockquote>
<img src="https://image.woodwhales.cn/059/images/22.png" style="zoom:75%;">]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>STS设置</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 常用设置</title>
    <url>/2020/03/03/060/</url>
    <content><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>导入包,自动修正：Alt + 回车</p>
<p>查找类：Ctrl + N</p>
<p>查找文件：Ctrl + Shift + N</p>
<p>格式化代码：Ctrl + Alt + L</p>
<p>优化导入的类和包：Ctrl + Alt + O</p>
<p>生成代码（如 getter，setter 方法，构造函数等）：Alt + Insert</p>
<p>最近更改的代码：Ctrl + E 或者 Alt + Shift + C</p>
<p>替换文本：Ctrl + R</p>
<p>查找文本：Ctrl + F</p>
<p>自动补全代码：Ctrl + Shift +Space</p>
<p>代码提示：Ctrl + 空格</p>
<p>类名或接口名提示：Ctrl + Alt + Space</p>
<p>方法参数提示：Ctrl + P</p>
<p>查找类中的方法或变量：Ctrl + Shift + Alt + N</p>
<p>对比最近修改的代码：Alt + Shift + C</p>
<p>重构-重命名：Shift + F6</p>
<p>当前行代码移动：Ctrl + Shift + 上键/下键</p>
<p>看到当前方法的声明：Alt＋Q</p>
<p>删除行：Ctrl + X </p>
<p>复制行：Ctrl + D</p>
<p>注释：Ctrl + / 或 Ctrl + Shift + / （// 或者/<em>…</em>/ ）</p>
<p>自动代码：Ctrl + J </p>
<p>最近打开的文件：Ctrl + E</p>
<p>显示类结构图：Ctrl + H</p>
<p>显示注释文档：Ctrl + Q</p>
<p>查找代码所在位置：Alt + F1</p>
<p>快速打开或隐藏工程面板：Alt + 1</p>
<p>返回至上次浏览的位置：Ctrl + Alt + left/right</p>
<p>切换代码视图：Alt+ left/right</p>
<p>在方法间快速移动定位：Alt + Up/Down</p>
<p>高亮错误或警告快速定位：F2 或 Shift + F2</p>
<p>代码标签输入完成后，按Tab，生成代码。</p>
<p>选中文本，按 Ctrl + Shift + F7 ，高亮显示所有该文本，按 Esc 高亮消失。</p>
<p>Ctrl + W 选中代码，连续按会有其他效果</p>
<p>选中文本，按 Alt + F3 ，逐个往下查找相同文本，并高亮显示。</p>
<p>Ctrl + Up/Down 光标跳转到第一行或最后一行下</p>
<p>Ctrl+B 快速打开光标处的类或方法</p>
<p>跳到大括号的开头结尾：Ctrl＋[ 或 ]</p>
<p>跳转到上次编辑的地方：Ctrl＋Shift＋Backspace</p>
<p>显示当前文件的结构：Ctrl＋F12</p>
<p>查询当前元素在当前文件中的引用，然后按 F3 可以选择：Ctrl＋F7</p>
<blockquote>
<p>重命名文件、方法、属性等（Rename）：Shift + F6</p>
<p>查看当前类的所有子类：ctrl + H</p>
<p>查看当前方法被谁调：Ctrl + Alt + H</p>
<p>查看当前类的所有方法：Alt+7</p>
<p>重构类、方法（Change Signarture）：Ctrl + F6</p>
<p>提取当前选择为变量（Extract Variable）：Ctrl + Alt + V</p>
<p>提取当前选择为类的私有属性（Extract Field）：Ctrl + Alt + F</p>
<p>提取当前选择为常量（Extract Constant）：Ctrl + Alt + C</p>
<p>提取当前选择为方法（Extract Method）：Ctrl + Alt + M</p>
<p>提取当前选择为方法参数（Extract Parameter）：Ctrl + Alt + P</p>
<p>提取代码块至 if、try 等结构中（Surround With）：Ctrl + Alt + T</p>
<p>创建模块文件等（New）：Ctrl + Alt + N</p>
<p>创建测试用例（Test）：Ctrl + Shift + T</p>
<p>重构菜单（Refactor for this）：Ctrl + T</p>
<p>重构：Ctrl + Shift + Alt + T</p>
</blockquote>
<h2 id="IDEA和Eclipse常用快捷键对比"><a href="#IDEA和Eclipse常用快捷键对比" class="headerlink" title="IDEA和Eclipse常用快捷键对比"></a>IDEA和Eclipse常用快捷键对比</h2><table>
<thead>
<tr>
<th>Eclipse</th>
<th>IDEA</th>
<th>英文描述</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+shift+r</td>
<td>ctrl+shift+n</td>
<td>Navigate-&gt;File</td>
<td>找工作空间的文件</td>
</tr>
<tr>
<td>ctrl+shift+t</td>
<td>ctrl+n</td>
<td>Navigate-&gt;Class</td>
<td>找类定义</td>
</tr>
<tr>
<td>ctrl+shift+g</td>
<td>alt+f7</td>
<td>Edit-&gt;Find-&gt;Find Usages</td>
<td>查找方法在哪里调用.变量在哪里被使用</td>
</tr>
<tr>
<td>ctrl+t</td>
<td>ctrl+t</td>
<td>Other-&gt;Hierarchy Class</td>
<td>看类继承结构</td>
</tr>
<tr>
<td>ctrl+o</td>
<td>ctrl+f12</td>
<td>Navigate-&gt;File Structure</td>
<td>搜索一个类里面的方法</td>
</tr>
<tr>
<td>shift+alt+z</td>
<td>ctrl+alt+t</td>
<td>Code-&gt;Surround With</td>
<td>生成常见的代码块</td>
</tr>
<tr>
<td>shift+alt+l</td>
<td>ctrl+alt+v</td>
<td>Refactor-&gt;Extract-&gt;Variable</td>
<td>抽取变量</td>
</tr>
<tr>
<td>shift+alt+m</td>
<td>ctrl+alt+m</td>
<td>Refactor-&gt;Extract-&gt;Method</td>
<td>抽取方法</td>
</tr>
<tr>
<td>alt+左箭头</td>
<td>ctrl+alt+左箭头</td>
<td>Navigate-&gt;Back</td>
<td>回退上一个操作位置</td>
</tr>
<tr>
<td>alt+右箭头</td>
<td>ctrl+alt+右键头</td>
<td>Navigate-&gt;Forward</td>
<td>前进上一个操作位置</td>
</tr>
<tr>
<td>ctrl+home</td>
<td>ctrl+home</td>
<td>Move Caret to Text Start</td>
<td>回到类最前面</td>
</tr>
<tr>
<td>ctrl+end</td>
<td>ctrl+end</td>
<td>Move Caret to Text End</td>
<td>回到类最后面</td>
</tr>
<tr>
<td>ctrl+e</td>
<td>ctrl+e</td>
<td>View-&gt;Recent Files</td>
<td>最近打开的文件</td>
</tr>
<tr>
<td>alt+/</td>
<td>ctrl+space</td>
<td>Code-&gt;Completion-&gt;Basic</td>
<td>提示变量生成</td>
</tr>
<tr>
<td>ctrl+1</td>
<td>alt+enter</td>
<td>Other-&gt;Show Intention Actions</td>
<td>提示可能的操作</td>
</tr>
<tr>
<td>ctrl+h</td>
<td>ctrl+shift+f</td>
<td>Find in Path</td>
<td>全局搜索</td>
</tr>
<tr>
<td>alt+上/下箭头</td>
<td>alt+shift+上/下箭头</td>
<td>Code-&gt;Move Line Up/Down</td>
<td>移动一行代码</td>
</tr>
<tr>
<td>ctrl+/</td>
<td>ctrl+/</td>
<td>Other-&gt;Fix doc comment</td>
<td>方法注释</td>
</tr>
<tr>
<td>ctrl+alt+s</td>
<td>alt+insert</td>
<td>Generate</td>
<td>生成getter,setter,tostring等</td>
</tr>
</tbody></table>
<h2 id="IDEA启动时不自动打开项目"><a href="#IDEA启动时不自动打开项目" class="headerlink" title="IDEA启动时不自动打开项目"></a>IDEA启动时不自动打开项目</h2><p>Settings &gt; Apprearance &amp; Behavior &gt; System Settings</p>
<p><img src="https://image.woodwhales.cn/060/images/3.png"></p>
<h2 id="字符集统一为UTF-8"><a href="#字符集统一为UTF-8" class="headerlink" title="字符集统一为UTF-8"></a>字符集统一为UTF-8</h2><p><img src="https://image.woodwhales.cn/060/images/5.png"></p>
<h2 id="鼠标悬浮提示"><a href="#鼠标悬浮提示" class="headerlink" title="鼠标悬浮提示"></a>鼠标悬浮提示</h2><p>IDEA 新版本设置</p>
<p><img src="https://image.woodwhales.cn/060/images/03.png"></p>
<p>IDEA 旧版设置</p>
<p><img src="https://image.woodwhales.cn/060/images/4.png"></p>
<h2 id="忽略显示与工程无关的文件"><a href="#忽略显示与工程无关的文件" class="headerlink" title="忽略显示与工程无关的文件"></a>忽略显示与工程无关的文件</h2><p>IDEA 新版设置</p>
<p><code>Ignore files and folders</code> 选项卡中点击小加号或者小减号添加或者删除要忽略展示的文件</p>
<p><img src="https://image.woodwhales.cn/060/images/02.png"></p>
<p>IDEA 旧版本设置</p>
<p>在<code>Ignore files and folders</code>文本框原始有些默认的忽略显示文件：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">*.hprof<span class="comment">;*.pyc;*.pyo;*.rbc;*.yarb;*~;.DS_Store;.git;.hg;.svn;CVS;__pycache__;_svn;vssver.scc;vssver2.scc;</span></span><br></pre></td></tr></tbody></table></figure>

<p>将下面配置全部覆盖默认配置：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">*.hprof<span class="comment">;*.pyc;*.pyo;*.rbc;*.yarb;*~;.DS_Store;.git;.hg;.svn;CVS;__pycache__;_svn;vssver.scc;vssver2.scc;.classpath;.factorypath;.project;*.iml;target;.idea;.settings;</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/060/images/7.png"></p>
<h2 id="自动导包-删除无用的包"><a href="#自动导包-删除无用的包" class="headerlink" title="自动导包/删除无用的包"></a>自动导包/删除无用的包</h2><p><img src="https://image.woodwhales.cn/060/images/6.png"></p>
<p>Add unambiguous imports on the fly：快速添加明确的导入。</p>
<p>Optimize imports on the fly：快速优化导入，优化的意思即自动帮助删除无用的导入。</p>
<h2 id="集成-javap"><a href="#集成-javap" class="headerlink" title="集成 javap"></a>集成 javap</h2><p><code>Settings-&gt;Tools-&gt;External Tools</code> 添加一个扩展工具：</p>
<img src="https://image.woodwhales.cn/060/images/1.png" style="zoom:75%;">

<ul>
<li>Program 需要指定你 JDK 目录中 javap 的位置</li>
<li>Arguments 是扩展工具带的参与， <code>-c $FileNameWithoutExtension$.class</code>，所以需要配置这个样子，可以点击右侧<code>Insert Macro…</code>查看所有关联项</li>
<li>Working directory 要配置到 class 的输出目录，包括项目目录和 package 目录，所以内容是 <code>$OutputPath$/$FileDirRelativeToSourcepath$</code></li>
</ul>
<p><img src="https://image.woodwhales.cn/060/images/2.png"></p>
<blockquote>
<p>使用方法</p>
<p>在源码文件中右击，选择：<code>Extenral Tools</code>，选择刚才创建的<code>Show Byte Code</code>扩展，即可在 IDEA 的控制台中显示当前源码的字节码文件的反编译信息。</p>
</blockquote>
<h2 id="IDEA菜单显示工具栏"><a href="#IDEA菜单显示工具栏" class="headerlink" title="IDEA菜单显示工具栏"></a>IDEA菜单显示工具栏</h2><p><img src="https://image.woodwhales.cn/060/images/8.png"></p>
<h2 id="包结构目录层次显示"><a href="#包结构目录层次显示" class="headerlink" title="包结构目录层次显示"></a>包结构目录层次显示</h2><p>点击项目资源管理器上的小齿轮，不勾选 Flatten Packages：</p>
<p><img src="https://image.woodwhales.cn/060/images/9.png"></p>
<h2 id="maven-配置统一"><a href="#maven-配置统一" class="headerlink" title="maven 配置统一"></a>maven 配置统一</h2><p>File &gt; Other Settings &gt; Preferences for New，这样对每个新建的项目都是使用这个统一配置，如果配置的是 File &gt; Settings 仅仅对本工程有效。</p>
<p><img src="https://image.woodwhales.cn/060/images/10.png"></p>
<h2 id="开启自动编译"><a href="#开启自动编译" class="headerlink" title="开启自动编译"></a>开启自动编译</h2><p>在 IDEA 当中自动编译默认是关闭状态，需要手动打开，注意设置界面是：File &gt; Other Settings &gt; Preferences for New：</p>
<p><img src="https://image.woodwhales.cn/060/images/11.png"></p>
<h2 id="内存使用量实时显示"><a href="#内存使用量实时显示" class="headerlink" title="内存使用量实时显示"></a>内存使用量实时显示</h2><p>IDEA 新版本</p>
<p>右击 IDEA 工作区的最下方状态栏，勾选<code>Memory Indicator</code> 选项</p>
<p><img src="https://image.woodwhales.cn/060/images/01.png"></p>
<p>IDEA 旧版本</p>
<p><img src="https://image.woodwhales.cn/060/images/12.png"></p>
<h2 id="显示多行Tab"><a href="#显示多行Tab" class="headerlink" title="显示多行Tab"></a>显示多行Tab</h2><p>当我们打开的标签页多了的时候，默认的会隐藏在右侧，当我们需要的时候在右侧找到后再打开。IDEA 是支持多行显示的，这样在大屏幕的显示器上也不用总去点击右侧的去找刚才打开过的文件了（其实通过 Ctril + E 也可以找到刚才打开过的文件）。具体开关位置在：File &gt; Settings &gt; Editor &gt; General &gt; Editor Tabs：</p>
<p><img src="https://image.woodwhales.cn/060/images/13.png"></p>
<h2 id="显示行号和方法间的分隔符"><a href="#显示行号和方法间的分隔符" class="headerlink" title="显示行号和方法间的分隔符"></a>显示行号和方法间的分隔符</h2><p><img src="https://image.woodwhales.cn/060/images/14.png"></p>
<h2 id="显示参数提示"><a href="#显示参数提示" class="headerlink" title="显示参数提示"></a>显示参数提示</h2><p><img src="https://image.woodwhales.cn/060/images/04.png"></p>
<h2 id="开启代码提示忽略大小写"><a href="#开启代码提示忽略大小写" class="headerlink" title="开启代码提示忽略大小写"></a>开启代码提示忽略大小写</h2><p>比如我想写 Date 类，当在 IDEA 里输入”da”时，如果 IDEA 没有设置”忽略大小写提示”，那么 IDEA 不会给你提示，只有当你输入”Da”时才会出现提示，因此对于笔者这种懒人是必须要开启忽略大小写提示的：</p>
<p><img src="https://image.woodwhales.cn/060/images/15.png"></p>
<h2 id="DEBUG-设置"><a href="#DEBUG-设置" class="headerlink" title="DEBUG 设置"></a>DEBUG 设置</h2><p>windows 系统下设置</p>
<p><img src="https://image.woodwhales.cn/060/images/19.png"></p>
<h2 id="设置自定义代码模板"><a href="#设置自定义代码模板" class="headerlink" title="设置自定义代码模板"></a>设置自定义代码模板</h2><p>创建自定义模板组</p>
<p><img src="https://image.woodwhales.cn/060/images/20.png"></p>
<p>创建名称为：MyTempalte 的模板组，并在该模板组下创建模板：</p>
<p><img src="https://image.woodwhales.cn/060/images/21.png"></p>
<p>以创建 try 异常模板为例：</p>
<img src="https://image.woodwhales.cn/060/images/22.png" style="zoom:67%;">

<p>模板代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    $END$</span><br><span class="line">} <span class="keyword">catch</span>(Exception exception) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置Java代码的注释风格"><a href="#设置Java代码的注释风格" class="headerlink" title="设置Java代码的注释风格"></a>设置Java代码的注释风格</h2><p>IDEA 单行默认注释的时候，”//“在行的最开头：</p>
<p><img src="https://image.woodwhales.cn/060/images/18.png"></p>
<p>根据个人习惯，可以设置成”//“在代码的最开头：</p>
<p><img src="https://image.woodwhales.cn/060/images/17.png"></p>
<h2 id="更多参考资料"><a href="#更多参考资料" class="headerlink" title="更多参考资料"></a>更多参考资料</h2><p>IntelliJ IDEA 简体中文专题教程：<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IntelliJ-IDEA-Tutorial</a></p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>IDEA设置</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀字体集锦</title>
    <url>/2020/03/04/061/</url>
    <content><![CDATA[<blockquote>
<p>如果源码包无法下载，请移步：<a href="https://github.com/woodwhales/woodwhales-fonts/releases">https://github.com/woodwhales/woodwhales-fonts/releases</a></p>
</blockquote>
<h2 id="source-code-pro"><a href="#source-code-pro" class="headerlink" title="source code pro"></a>source code pro</h2><p>源地址：<a href="https://github.com/adobe-fonts/source-code-pro/releases/">https://github.com/adobe-fonts/source-code-pro/releases/</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@source-code-pro/source-code-pro-2.030R-ro-1.050R-it.7z">source-code-pro-2.030R-ro-1.050R-it.7z</a></p>
<h2 id="source-sans-pro"><a href="#source-sans-pro" class="headerlink" title="source sans pro"></a>source sans pro</h2><p>源地址：<a href="https://github.com/adobe-fonts/source-sans-pro/releases">https://github.com/adobe-fonts/source-sans-pro/releases</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@source-sans-pro-1/source-sans-pro-3.006R.7z">source-sans-pro-3.006R.7z</a></p>
<h2 id="酷站字体库"><a href="#酷站字体库" class="headerlink" title="酷站字体库"></a>酷站字体库</h2><p>源地址：<a href="https://www.zcool.com.cn/special/zcoolfonts/#4thpage">https://www.zcool.com.cn/special/zcoolfonts/#4thpage</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@zcool/zcool.7z">zcool.7z</a></p>
<h2 id="OPPO-Sans字体"><a href="#OPPO-Sans字体" class="headerlink" title="OPPO Sans字体"></a>OPPO Sans字体</h2><p>源地址：<a href="https://www.coloros.com/">https://www.coloros.com/</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@opposans/font-opposans.7z">font-opposans.7z</a></p>
<h2 id="思源字体"><a href="#思源字体" class="headerlink" title="思源字体"></a>思源字体</h2><p>源地址：<a href="https://github.com/adobe-fonts/source-han-sans/blob/master/README-CN.md">https://github.com/adobe-fonts/source-han-sans/blob/master/README-CN.md</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@source-han-sans-Hei/%E6%80%9D%E6%BA%90%E9%BB%91%E4%BD%93.7z">思源黑体.7z</a>，<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@source-han-sans-Song/%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93.7z">思源宋体.7z</a></p>
<h2 id="胡晓波字体"><a href="#胡晓波字体" class="headerlink" title="胡晓波字体"></a>胡晓波字体</h2><p>源地址：<a href="https://huxiaobo.zcool.com.cn/">https://huxiaobo.zcool.com.cn/</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@huxiaobo/%E8%83%A1%E6%99%93%E6%B3%A2%E5%85%8D%E8%B4%B9%E5%AD%97.7z">胡晓波免费字.7z</a></p>
<h2 id="阿里惠普体"><a href="#阿里惠普体" class="headerlink" title="阿里惠普体"></a>阿里惠普体</h2><p>源地址：<a href="https://alibabafont.taobao.com/wow/alibabafont/act/alifont">https://alibabafont.taobao.com/wow/alibabafont/act/alifont</a></p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@AlibabaSans/AlibabaSans.7z">AlibabaSans.7z</a></p>
<h2 id="阿里汉仪智能黑体"><a href="#阿里汉仪智能黑体" class="headerlink" title="阿里汉仪智能黑体"></a>阿里汉仪智能黑体</h2><p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@AlibabaHanYi/%E9%98%BF%E9%87%8C%E6%B1%89%E4%BB%AA%E6%99%BA%E8%83%BD%E9%BB%91%E4%BD%93.7z">阿里汉仪智能黑体.7z</a></p>
<h2 id="庞门正道字体"><a href="#庞门正道字体" class="headerlink" title="庞门正道字体"></a>庞门正道字体</h2><p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@pang/%E5%BA%9E%E9%97%A8%E6%AD%A3%E9%81%93.7z">庞门正道.7z</a></p>
<h2 id="其他字体"><a href="#其他字体" class="headerlink" title="其他字体"></a>其他字体</h2><p>演示斜黑体、锐字真言体、联盟起艺卢帅正锐黑体</p>
<p>本站地址：<a href="https://fastly.jsdelivr.net/gh/woodwhales/woodwhales-fonts@other-fonts/other-fonts.7z">other-fonts.7z</a></p>
]]></content>
      <categories>
        <category>字体集锦</category>
      </categories>
      <tags>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title>构建工具maven及gradle的安装及IDE配置</title>
    <url>/2020/03/14/062/</url>
    <content><![CDATA[<h2 id="maven-构建工具"><a href="#maven-构建工具" class="headerlink" title="maven 构建工具"></a>maven 构建工具</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><blockquote>
<p>下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
</blockquote>
<p>下载二进制安装文件：</p>
<p><img src="https://image.woodwhales.cn/062/images/1.png"></p>
<p>将下载好的 zip 压缩包解压到自己想要存放的地方，笔者使用了 C 盘符保存：</p>
<p><img src="https://image.woodwhales.cn/062/images/2.png"></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>计算机 &gt; 右击属性 &gt; 高级系统设置 &gt; 环境变量，在<code>环境变量</code>里创建变量名为：<code>M2_HOME</code>的系统变量，值就是上一步的安装文件路径：</p>
<p><img src="https://image.woodwhales.cn/062/images/3.png"></p>
<p>并在<code>Path</code>环境变量中配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">M2_HOME%\bin</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/062/images/9.png"></p>
<p>在 cmd 窗口中运行命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></tbody></table></figure>

<p>显示 maven 版本信息表示环境配置成功：</p>
<p><img src="https://image.woodwhales.cn/062/images/4.png"></p>
<h3 id="仓库路径配置"><a href="#仓库路径配置" class="headerlink" title="仓库路径配置"></a>仓库路径配置</h3><p>回到 maven 安装目录，进入<code>conf</code>文件目录下，使用编辑器打开<code>settings.xml</code>文件：</p>
<p>大约在 50 行左右，增加<code>&lt;localRepository&gt;</code>配置，使用自定义的maven仓库路径，笔者使用了 D 盘符的路径：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果不配置，就会使用<code>${user.home}/.m2/repository</code>，这样会占用 C 盘符内存，在官方注释里也说的很清楚：</p>
<img src="https://image.woodwhales.cn/062/images/5.png" style="zoom:75%;">

<h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>还是继续上一步的编辑<code>settings.xml</code>文件，找到<code>&lt;mirrors&gt;</code>节点，配置以下镜像：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>google<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云谷歌仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/google<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>apache snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云Apache仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/apache-snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云spring仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>spring-plugin<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云spring插件仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>保险起见，在<code>${user.home}</code>目录下的<code>.m2</code>文件目录（如果没有这个文件夹就自己手动创建出来）下，把上述配置好的<code>settings.xml</code>配置文件拷贝一份到本目录，防止没有配置 maven 的 IDE 去这个默认目录找配置文件，找不到就使用这个默认仓库地址，并且还没有镜像配置，创建工程会很耗时。</p>
<p><img src="https://image.woodwhales.cn/062/images/15.png"></p>
<h2 id="gradle-构建工具"><a href="#gradle-构建工具" class="headerlink" title="gradle 构建工具"></a>gradle 构建工具</h2><h3 id="下载安装-1"><a href="#下载安装-1" class="headerlink" title="下载安装"></a>下载安装</h3><blockquote>
<p>下载地址：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p>
</blockquote>
<p>下载二进制安装文件：</p>
<p><img src="https://image.woodwhales.cn/062/images/6.png"></p>
<p>将下载好的 zip 压缩包解压到自己想要存放的地方，笔者使用了 C 盘符保存：</p>
<p><img src="https://image.woodwhales.cn/062/images/7.png"></p>
<h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><p>计算机 &gt; 右击属性 &gt; 高级系统设置 &gt; 环境变量，在<code>环境变量</code>里创建变量名为：<code>GRADLE_HOME</code>的系统变量，值就是上一步的安装文件路径：</p>
<p><img src="https://image.woodwhales.cn/062/images/8.png"></p>
<p>并在<code>Path</code>环境变量中配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">GRADLE_HOME%\bin</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/062/images/10.png"></p>
<p>在 cmd 窗口中运行命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gradle -v</span><br></pre></td></tr></tbody></table></figure>

<p>显示 gradle 版本信息表示环境配置成功：</p>
<p><img src="https://image.woodwhales.cn/062/images/11.png"></p>
<h3 id="仓库路径配置-1"><a href="#仓库路径配置-1" class="headerlink" title="仓库路径配置"></a>仓库路径配置</h3><p>笔者是使用 maven 居多，所以配置 gradle 的仓库路径和 maven 相同，这样节省内存空间。</p>
<p>在系统环境变量里新增一个<code>GRADLE_USER_HOME</code> 变量，并配置成 maven 仓库地址即可：</p>
<img src="https://image.woodwhales.cn/062/images/12.png" style="zoom:75%;">

<h3 id="镜像配置-1"><a href="#镜像配置-1" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>由于配置了自定义的 gradle 安装目录，所以镜像配置文件需要配置到环境变量的<code>GRADLE_USER_HOME</code>配置的路径中，创建<code>init.gradle</code>文件，并把以下配置粘贴进并保存：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line">allprojects {</span><br><span class="line">    repositories {</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven { name <span class="string">"Alibaba"</span> ; url <span class="string">"https://maven.aliyun.com/repository/public"</span> } </span><br><span class="line">        maven { name <span class="string">"Bstek"</span> ; url <span class="string">"https://nexus.bsdn.org/content/groups/public/"</span> } </span><br><span class="line">        mavenCentral()</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    buildscript {</span><br><span class="line">        repositories {</span><br><span class="line">            maven { name <span class="string">"Alibaba"</span> ; url <span class="string">'https://maven.aliyun.com/repository/public'</span> } </span><br><span class="line">            maven { name <span class="string">"Bstek"</span> ; url <span class="string">'https://nexus.bsdn.org/content/groups/public/'</span> } </span><br><span class="line">            maven { name <span class="string">"M2"</span> ; url <span class="string">'https://plugins.gradle.org/m2/'</span> }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>保险起见，在<code>${user.home}</code>目录下的<code>.gradle</code>文件目录下（如果没有这个文件夹就自己手动创建出来），把上述配置好的<code>init.gradle</code>配置文件拷贝一份到本目录，防止没有配置 gradle 的 IDE 去这个默认目录找配置文件，找不到就使用这个默认仓库地址，并且还没有镜像配置，创建工程会很耗时。</p>
<p><img src="https://image.woodwhales.cn/062/images/14.png"></p>
<h2 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h2><h3 id="STS-Eclipse-配置"><a href="#STS-Eclipse-配置" class="headerlink" title="STS/Eclipse 配置"></a>STS/Eclipse 配置</h3><p>配置 maven 安装路径：</p>
<img src="https://image.woodwhales.cn/062/images/16.png" style="zoom:75%;">

<p>配置 maven 配置文件及仓库路径：</p>
<img src="https://image.woodwhales.cn/062/images/17.png" style="zoom:75%;">

<h3 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h3><p>配置 maven 安装、配置文件及仓库路径：</p>
<img src="https://image.woodwhales.cn/062/images/20.png" style="zoom:70%;">

<p>为了防止构建项目太慢，可以配置以下参数到图示中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">-DarchetypeCatalog=internal</span><br></pre></td></tr></tbody></table></figure>

<img src="https://image.woodwhales.cn/062/images/21.png" style="zoom:70%;">

<h2 id="gradle-配置"><a href="#gradle-配置" class="headerlink" title="gradle 配置"></a>gradle 配置</h2><h3 id="STS-Eclipse-配置-1"><a href="#STS-Eclipse-配置-1" class="headerlink" title="STS/Eclipse 配置"></a>STS/Eclipse 配置</h3><p>配置 gradle 安装路径及仓库路径：</p>
<img src="https://image.woodwhales.cn/062/images/18.png" style="zoom:75%;">

<h3 id="IDEA-配置-1"><a href="#IDEA-配置-1" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h3><p>配置 gradle 仓库路径：</p>
<p><img src="https://image.woodwhales.cn/062/images/19.png"></p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>构建工具设置</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义 spring-boot-starter</title>
    <url>/2020/03/15/063/</url>
    <content><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h4><p>一个完整的 Spring Boot Starter 一般包含以下核心组件：</p>
<ul>
<li><strong>autoconfigure</strong> 模块：包含自动配置的代码</li>
<li><strong>starter</strong> 模块：提供对 <strong>autoconfigure</strong> 模块的依赖，以及一些其它的依赖</li>
</ul>
<p>（PS：如果不需要区分这两个概念的话，也可以将自动配置代码模块与依赖管理模块合并成一个模块）</p>
<p>简而言之，其他服务需要启动器的时候，只需要引入一个 starter 就够了</p>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>Spring Boot 提供的 starter 是以<code>spring-boot-starter-xxx</code>的方式命名。官方建议自定义的 starter 使用<code>xxx-spring-boot-starter</code>命名规则。以区分 Spring Boot生态提供的 starter。</p>
<h3 id="工程架构说明"><a href="#工程架构说明" class="headerlink" title="工程架构说明"></a>工程架构说明</h3><p>根据上俩节的描述，用一张图来描述，就是要自己编写：红色的<code>woodwhales-spring-boot-autoconfigure </code>和粉色的<code>woodwhales-spring-boot-starter </code>，将 woodwhales-spring-boot-starter 工程打包成 jar 供其他工程依赖使用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">node "自定义 spring-boot-starter" {</span><br><span class="line">[woodwhales-spring-boot-starter] as starter #Pink</span><br><span class="line">[woodwhales-spring-boot-autoconfigure] as autoconfigure #Tomato</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">node "其他工程" {</span><br><span class="line">[spring-boot-starter-web] as web</span><br><span class="line">[xxx-spring-boot-starter] as myStarter</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">starter -left-&gt; autoconfigure</span><br><span class="line">myStarter .down.&gt; () pom: pom 依赖自定义starter</span><br><span class="line"></span><br><span class="line">pom -left-&gt; starter</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure>

<h3 id="工程结构准备"><a href="#工程结构准备" class="headerlink" title="工程结构准备"></a>工程结构准备</h3><p>笔者使用 IDEA 开发工具演示，使用 STS 4 也可以。</p>
<blockquote>
<p>开发工具的常用配置参见这俩篇博文：<a href="https://woodwhales.cn/2020/03/03/060/">IDEA 常用设置</a>和<a href="https://woodwhales.cn/2020/02/27/059/">STS 常用设置</a></p>
</blockquote>
<p>在自己喜欢的地方创建一个名称为<code>woodwhles-spring-boot-starter</code>的空工程目录：</p>
<img src="https://image.woodwhales.cn/063/images//1.png" style="zoom:75%;">
在空工程中添加新的工程模块：

<p><img src="https://image.woodwhales.cn/063/images//3.png"></p>
<h3 id="woodwhales-spring-boot-starter-工程搭建"><a href="#woodwhales-spring-boot-starter-工程搭建" class="headerlink" title="woodwhales-spring-boot-starter 工程搭建"></a>woodwhales-spring-boot-starter 工程搭建</h3><p>创建一个干净的 maven 工程：</p>
<img src="https://image.woodwhales.cn/063/images//4.png" style="zoom:75%;">

<p>指定工程的目录及 maven 坐标信息：</p>
<img src="https://image.woodwhales.cn/063/images//5.png" alt="5" style="zoom:75%;">

<p>创建成功之后空工程中多了一个<code>woodwhles-spring-boot-starter</code>的模块：</p>
<img src="https://image.woodwhales.cn/063/images//6.png" style="zoom:75%;">

<h3 id="woodwhales-spring-boot-autoconfigure-工程搭建"><a href="#woodwhales-spring-boot-autoconfigure-工程搭建" class="headerlink" title="woodwhales-spring-boot-autoconfigure 工程搭建"></a>woodwhales-spring-boot-autoconfigure 工程搭建</h3><p>继续在空工程中创建模块，这次使用 Spring Initializr 快速创建 autoconfigure 工程：</p>
<img src="https://image.woodwhales.cn/063/images//7.png" style="zoom:75%;">

<p>指定好 maven 坐标信息及工程名：</p>
<img src="https://image.woodwhales.cn/063/images//8.png" style="zoom:75%;">

<p>只添加<code>spring-boot-configuration-processor</code>依赖：</p>
<img src="https://image.woodwhales.cn/063/images//9.png" style="zoom:75%;">

<p>最后注意检查当前工程是不是被创建在空工程中：</p>
<img src="https://image.woodwhales.cn/063/images//10.png" style="zoom:75%;">

<p>woodwhales-spring-boot-autoconfigure 工程中将无用的文件删除：</p>
<img src="https://image.woodwhales.cn/063/images//11.png" style="zoom:75%;">

<p>再将 woodwhales-spring-boot-autoconfigure 工程中 pom 依赖中的构建工具插件及 spring-boot-starter-test 依赖删除：</p>
<img src="https://image.woodwhales.cn/063/images//12.png" style="zoom:75%;">

<p>最后在 woodwhales-spring-boot-starter 工程中引入 woodwhales-spring-boot-autoconfigure 工程依赖：</p>
<img src="https://image.woodwhales.cn/063/images//13.png" style="zoom:75%;">

<p>上述的工程环境准备好之后，开始编写对应的配置文件或者业务代码。</p>
<p>为了编译不会报警告，可以增加 jdk 版本和字符集约束：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="编写业务配置类-HelloProperties"><a href="#编写业务配置类-HelloProperties" class="headerlink" title="编写业务配置类 HelloProperties"></a>编写业务配置类 HelloProperties</h3><p>定义自定义配置类，这个配置类可以读取到引用了本自定义 starter 的工程中的配置信息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 17:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties("woodwhales.hello")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrefix</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrefix</span><span class="params">(String prefix)</span> {</span><br><span class="line">        <span class="built_in">this</span>.prefix = prefix;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuffix</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuffix</span><span class="params">(String suffix)</span> {</span><br><span class="line">        <span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编写业务类-HelloService"><a href="#编写业务类-HelloService" class="headerlink" title="编写业务类 HelloService"></a>编写业务类 HelloService</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 17:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloService</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloService</span><span class="params">(HelloProperties helloProperties)</span> {</span><br><span class="line">        <span class="built_in">this</span>.helloProperties = helloProperties;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> {</span><br><span class="line">        Objects.requireNonNull(helloProperties, <span class="string">"读取用户配置文件失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s - %s - %s"</span>, helloProperties.getPrefix(), name, helloProperties.getSuffix());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="编写自动注入配置类-HelloServiceAutoConfiguration"><a href="#编写自动注入配置类-HelloServiceAutoConfiguration" class="headerlink" title="编写自动注入配置类 HelloServiceAutoConfiguration"></a>编写自动注入配置类 HelloServiceAutoConfiguration</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">// 只有是web应用才生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceAutoConfiguration</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">helloService</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>(helloProperties);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><strong>@Configuration</strong></p>
<p><code>@Configuration</code>注解的作用等同于 xml 中的<code>&lt;beans&gt;</code>标签</p>
<p><strong>@EnableConfigurationProperties</strong></p>
<p><code>@EnableConfigurationProperties</code>注解是用来开启对 3 步骤中<code>@ConfigurationProperties</code>注解配置 Bean 的支持。也就是<code>@EnableConfigurationProperties</code>注解告诉 Spring Boot 能支持<code>@ConfigurationProperties</code>。</p>
<p>当然了，也可以在<code>@ConfigurationProperties</code>注解的类上添加<code>@Configuration</code>或者<code>@Component</code>注解。</p>
</blockquote>
<h3 id="自动配置类装配生效"><a href="#自动配置类装配生效" class="headerlink" title="自动配置类装配生效"></a>自动配置类装配生效</h3><p>要想上述的步骤能生效就要在<code>resources</code>文件目录下创建<code>META-INF</code>文件夹，再创建名称为<code>spring.factories</code>的配置文件，将上述的自动注入配置类配置到 spring boot 中：</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.woodwhales.starter.HelloServiceAutoConfiguration</span></span><br></pre></td></tr></tbody></table></figure>

<p>最终效果如图：</p>
<img src="https://image.woodwhales.cn/063/images//14.png" style="zoom:75%;">

<h3 id="打包与测试"><a href="#打包与测试" class="headerlink" title="打包与测试"></a>打包与测试</h3><p>先将<code>woodwhales-spring-boot-autoconfigure</code>工程打包安装到本地 maven 仓库，再打包安装<code>woodwhales-spring-boot-starter</code>，编写简单的web工程测试：</p>
<p>引入依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.woodwhales.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>woodwhales-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>配置文件配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">woodwhales:</span></span><br><span class="line">  <span class="attr">hello:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">hi</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">woodwhales's</span> <span class="string">blog</span></span><br></pre></td></tr></tbody></table></figure>

<p>控制层测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.starter.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter-test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 18:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/{name}")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@PathVariable(name = "name")</span> String name)</span> {</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>postman 测试成功：</p>
<p><img src="https://image.woodwhales.cn/063/images//15.png"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>自定义启动器一般应用场景：动态数据源、登录模块、基于AOP技术实现日志切面等。</p>
<h4 id="日志记录服务"><a href="#日志记录服务" class="headerlink" title="日志记录服务"></a>日志记录服务</h4><p>由于日志需要使用到日志打印，所以需要引入一些其他工具，方便开发：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="comment">&lt;!-- 防止将spring-boot-starter-web依赖传递到其他模块中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="comment">&lt;!-- 防止将lombok依赖传递到其他模块中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.58<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span><span class="comment">&lt;!-- 防止将fastjson依赖传递到其他模块中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>对上述的启动器进行升级改造：增加自定义的<code>@MyLog</code>注解，实现业务工程在对应的方法上使用这个注解就能打印日志：</p>
<h5 id="编写-MyLog-注解"><a href="#编写-MyLog-注解" class="headerlink" title="编写 @MyLog 注解"></a>编写 @MyLog 注解</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 18:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法描述</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="编写-MyLogInterceptor-拦截器"><a href="#编写-MyLogInterceptor-拦截器" class="headerlink" title="编写 MyLogInterceptor 拦截器"></a>编写 MyLogInterceptor 拦截器</h5><p>拦截器拦截请求，并获取方法上的注解信息，如果使用了 @MyLog 注解，那么就打印日志：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 18:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTimeThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> method.getAnnotation(MyLog.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(myLog)) {</span><br><span class="line">            <span class="comment">// 记录方法执行起始时间</span></span><br><span class="line">            startTimeThreadLocal.set(System.currentTimeMillis());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();</span><br><span class="line">        <span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> method.getAnnotation(MyLog.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(myLog)) {</span><br><span class="line">            <span class="comment">//  获取方法执行起始时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> startTimeThreadLocal.get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">expendTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  打印参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">requestUri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">"#"</span> + method.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodDesc</span> <span class="operator">=</span> myLog.desc();</span><br><span class="line">            <span class="type">String</span> <span class="variable">parameters</span> <span class="operator">=</span> JSON.toJSONString(request.getParameterMap());</span><br><span class="line">            log.info(<span class="string">"\n描述：{}\n路径: {}\n方法: {}\n参数：{}\n耗时：{}"</span>, methodDesc, requestUri, methodName, parameters, expendTime);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="拦截器装配"><a href="#拦截器装配" class="headerlink" title="拦截器装配"></a>拦截器装配</h5><p>将拦截器注入 InterceptorRegistry 中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: woodwhales-spring-boot-starter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.3.14 18:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> {</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyLogInterceptor</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="将自动配置类装配生效"><a href="#将自动配置类装配生效" class="headerlink" title="将自动配置类装配生效"></a>将自动配置类装配生效</h5><p><code>spring.factories</code>配置文件中增加</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.woodwhales.starter.HelloServiceAutoConfiguration,\</span><br><span class="line">org.woodwhales.starter.log.MyLogAutoConfiguration</span><br></pre></td></tr></tbody></table></figure>

<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>日志打印：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">2020-03-14 20:18:09.679  INFO 3820 --- <span class="section">[0.0-8083-exec-2]</span> o.w.starter.log.MyLogInterceptor         : 描述：查询用户</span><br><span class="line">2020-03-14 20:18:09.680  INFO 3820 --- <span class="section">[0.0-8083-exec-2]</span> o.w.starter.log.MyLogInterceptor         : 路径：/user/list/</span><br><span class="line">2020-03-14 20:18:09.680  INFO 3820 --- <span class="section">[0.0-8083-exec-2]</span> o.w.starter.log.MyLogInterceptor         : 方法：org.woodwhales.starter.controller.UserController<span class="comment">#list</span></span><br><span class="line">2020-03-14 20:18:09.680  INFO 3820 --- <span class="section">[0.0-8083-exec-2]</span> o.w.starter.log.MyLogInterceptor         : 参数：{}</span><br><span class="line">2020-03-14 20:18:09.680  INFO 3820 --- <span class="section">[0.0-8083-exec-2]</span> o.w.starter.log.MyLogInterceptor         : 耗时：2</span><br></pre></td></tr></tbody></table></figure>

<p>这个日志打印没有打印请求体数据，如果想看支持打印请求数据的日志的代码，请移步到：</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>spring-boot-starter</tag>
      </tags>
  </entry>
  <entry>
    <title>xshell安装激活及常用设置</title>
    <url>/2020/03/18/064/</url>
    <content><![CDATA[<blockquote>
<p>Xshell/Xftp/XshellPlus 官方其实有两种 .exe 文件，一个是用于试用的，在注册的时候不能直接输入密钥。<br>而另一个是为注册用户提供的 .exe 文件，在注册的时候可以输入密钥，直接可以激活了。</p>
</blockquote>
<h3 id="下载注册版安装包"><a href="#下载注册版安装包" class="headerlink" title="下载注册版安装包"></a>下载注册版安装包</h3><p>到 Xshell/Xftp/XshellPlus/ 官网页面 <a href="https://www.netsarang.com/zh/all-downloads/">https://www.netsarang.com/zh/all-downloads/</a></p>
<p>点击 Download 并填写一些信息，试用版的下载链接就会发至邮箱(可试用一次性邮箱)。</p>
<p>当然发到你邮箱的链接还不是真正的下载地址，你需要复制到浏览器打开，然后它就会开始下载，这个时候复制的下载地址才有效。</p>
<p>将下载地址复制下来，并在 .exe 之前加上字母 r。</p>
<p>笔者下载的试用版本下载地址是：<a href="https://cdn.netsarang.net/d97f3218/XshellPlus-6.0.0027.exe">https://cdn.netsarang.net/d97f3218/XshellPlus-6.0.0027.exe</a></p>
<p>修改之后注册版本下载地址是：<a href="https://cdn.netsarang.net/d97f3218/XshellPlus-6.0.0027r.exe">https://cdn.netsarang.net/d97f3218/XshellPlus-6.0.0027r.exe</a></p>
<blockquote>
<p>注册版文件下载地址：<a href="https://github.com/woodwhales/woodwhales-images-store/blob/007.64.1/064/XshellPlus-6.0.0027r.exe.7z">XshellPlus-6.0.0027r.exe.7z</a></p>
</blockquote>
<h3 id="清除注册表信息"><a href="#清除注册表信息" class="headerlink" title="清除注册表信息"></a>清除注册表信息</h3><p>使用 cmd 窗口执行清除 NetSarang 注册信息命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">REG DELETE HKEY_CURRENT_USER\Software\NetSarang /f</span><br></pre></td></tr></tbody></table></figure>

<h3 id="添加本地-dns-配置"><a href="#添加本地-dns-配置" class="headerlink" title="添加本地 dns 配置"></a>添加本地 dns 配置</h3><p>C:\Windows\System32\drivers\etc\hosts：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">127.0.0.1 activate.navicat.com</span><br><span class="line">127.0.0.1 activate.netsarang.com</span><br><span class="line">127.0.0.1 sales.netsarang.com</span><br><span class="line">127.0.0.1 transact.netsarang.com</span><br><span class="line">127.0.0.1 up.netsarang.com </span><br><span class="line">127.0.0.1 update.netsarang.com</span><br><span class="line">127.0.0.1 www.netsarang.com</span><br><span class="line">127.0.0.1 www.netsarang.co.kr</span><br></pre></td></tr></tbody></table></figure>

<p>添加之后，要刷新本机DNS</p>
<p>cmd 窗口运行：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></tbody></table></figure>

<p>注意配置好本地 dns 之后，就不能访问官网了。</p>
<h3 id="生成激活码"><a href="#生成激活码" class="headerlink" title="生成激活码"></a>生成激活码</h3><p>下载生成激活码工具：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/happymeter/XKeygen.git</span><br><span class="line">cd XKeygen/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Xmanager<span class="string">' : 0, '</span>Xshell<span class="string">' : 1, '</span>Xlpd<span class="string">' : 2, '</span>Xfile<span class="string">' : 3, '</span>Xftp<span class="string">' : 4,'</span>Xmanager 3D<span class="string">' : 5, '</span>Xmanager Enterprise<span class="string">' : 6; '</span>XshellPlus<span class="string">' : 7</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">例如 XshellPlus 生成激活码：</span></span></span><br><span class="line">python3 XKeygen.py -p 7</span><br></pre></td></tr></tbody></table></figure>

<p>如果不想下载程序的，注册版 XshellPlus（含 xshell 和 xftp）可以直接使用下面的激活码：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">181026-117436-999927</span><br><span class="line">181026-117882-999023</span><br><span class="line">181026-117366-999559</span><br><span class="line">181026-117435-999567</span><br><span class="line">181026-117938-999735</span><br></pre></td></tr></tbody></table></figure>

<p>打开软件，点击帮助菜单选择关于选项，看到如下信息，表示安装成功：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">woodwhales</span><br><span class="line">License Type: Xshell Plus  (Registered)</span><br><span class="line">Number of Licenses: 999</span><br><span class="line">Issue Date: 10/26/2018</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><p>笔者使用了官方提供的 monokai 主题 ，下载地址：<a href="https://github.com/netsarang/Xshell-ColorScheme/blob/master/collection/monokai.xcs">https://github.com/netsarang/Xshell-ColorScheme/blob/master/collection/monokai.xcs</a>，如果不想下载文件，可以在本地创建一个 monokai.xcs 文本文件，把下面的配置粘贴进去并保存。</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[monokai]</span></span><br><span class="line"><span class="attr">text</span>=f1ebeb</span><br><span class="line">text(bold)=f1ebeb</span><br><span class="line"><span class="attr">background</span>=<span class="number">272822</span></span><br><span class="line"><span class="attr">black</span>=<span class="number">48483</span>e</span><br><span class="line">black(bold)=76715e</span><br><span class="line"><span class="attr">red</span>=dc2566</span><br><span class="line">red(bold)=fa2772</span><br><span class="line"><span class="attr">green</span>=<span class="number">8</span>fc029</span><br><span class="line">green(bold)=a7e22e</span><br><span class="line"><span class="attr">yellow</span>=d4c96e</span><br><span class="line">yellow(bold)=e7db75</span><br><span class="line"><span class="attr">blue</span>=<span class="number">55</span>bcce</span><br><span class="line">blue(bold)=66d9ee</span><br><span class="line"><span class="attr">magenta</span>=<span class="number">9358</span>fe</span><br><span class="line">magenta(bold)=ae82ff</span><br><span class="line"><span class="attr">cyan</span>=<span class="number">56</span>b7a5</span><br><span class="line">cyan(bold)=66efd5</span><br><span class="line"><span class="attr">white</span>=acada1</span><br><span class="line">white(bold)=cfd0c2</span><br><span class="line"><span class="section">[Names]</span></span><br><span class="line"><span class="attr">name0</span>=monokai</span><br><span class="line"><span class="attr">count</span>=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>工具 &gt; 配色方案，导入即可。</p>
<h3 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h3><h4 id="鼠标右击粘贴"><a href="#鼠标右击粘贴" class="headerlink" title="鼠标右击粘贴"></a>鼠标右击粘贴</h4><p>工具 &gt; 选项，设置鼠标右击为粘贴鼠标剪切板中的内容：</p>
<p><img src="https://image.woodwhales.cn/064/1.png"></p>
<h4 id="快速命令工具"><a href="#快速命令工具" class="headerlink" title="快速命令工具"></a>快速命令工具</h4><p>查看 &gt; 快速命令，勾选快速命令。在主窗口下方出现快速命令栏：</p>
<p><img src="https://image.woodwhales.cn/064/2.png"></p>
<p>设置常用的命令：工具 &gt; 快速命令集，在默认快速命令集合中添加命令：</p>
<p><img src="https://image.woodwhales.cn/064/3.png"></p>
<blockquote>
<p>注意，字串中如果有回车，那么点击命令按钮时就会执行了。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>xshell</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper window环境安装、集成为windows服务、单机伪集群搭建</title>
    <url>/2020/04/06/065/</url>
    <content><![CDATA[<blockquote>
<p>提示 zookeeper 是 java 程序，所以安装之前需要安装 JDK，JDK 安装的教程网络上很多，本文不再赘述。注意的是系统环境变量中的 JDK 目录的值一定是：JAVA_HOME。  </p>
</blockquote>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>官网地址：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p>
<p>安装包下载地址：<a href="https://zookeeper.apache.org/releases.html#download">https://zookeeper.apache.org/releases.html#download</a></p>
<p>如果官网下载速度慢可以使用国内镜像下载地址：<a href="http://mirrors.hust.edu.cn/apache/zookeeper/">http://mirrors.hust.edu.cn/apache/zookeeper/</a></p>
<p>笔者选择最新版本的 zookeeper 安装包：</p>
<img src="https://image.woodwhales.cn/065/images/01.png" style="zoom:70%;">

<p>镜像地址选择想要的版本下载：</p>
<img src="https://image.woodwhales.cn/065/images/02.png" style="zoom:70%;">

<p>注意下载的是<code>.tar.gz</code>文件。</p>
<p>下载好的安装包名称为：apache-zookeeper-3.6.0-bin.tar.gz</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>将上述安装包放到指定的文件目录，并使用解压缩工具解压这个安装包：首选解压 gz 包之后得到 tar 包，继续解压 tar包得到 apache-zookeeper-3.6.0-bin 文件目录，进入该目录得到 apache-zookeeper-3.6.0-bin 目录结构如下：</p>
<img src="https://image.woodwhales.cn/065/images/03.png" style="zoom:70%;">

<p>在上述的文件目录中创建 data 和 log 文件夹，并复制 conf 文件夹中的 zoo_sample.cfg 文件名称为：zoo.cfg，使用文本编辑器打开该文件，并设置数据保存目录为刚才创建的 data 文件夹目录：</p>
<img src="https://image.woodwhales.cn/065/images/04.png" style="zoom:70%;">

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>在安装目录的 bin 目录下，将<code>zkServer.cmd</code>拖拽到 cmd 命令窗口中，回车执行即可启动 zookeeper：</p>
<img src="https://image.woodwhales.cn/065/images/05.png" style="zoom:70%;">

<p>启动过程没有异常信息提示，启动成功之后，光标不停闪烁：</p>
<img src="https://image.woodwhales.cn/065/images/06.png" style="zoom:70%;">

<p>只要这个 cmd 窗口不关闭，zookeeper 服务就会一直启用着。zookeeper 服务默认启动的是 2181 端口。</p>
<h3 id="客户端图形化工具"><a href="#客户端图形化工具" class="headerlink" title="客户端图形化工具"></a>客户端图形化工具</h3><h4 id="ZooInspector"><a href="#ZooInspector" class="headerlink" title="ZooInspector"></a>ZooInspector</h4><p>下载地址：<a href="https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</a></p>
<p>本博客下载地址：<a href="https://image.woodwhales.cn/065/ZooInspector.zip">ZooInspector.zip</a></p>
<p>下载完后解压压缩包，在 build 文件夹目录中找到：zookeeper-dev-ZooInspector.jar。使用 java -jar 命令启动该 jar 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar zookeeper-dev-ZooInspector.jar</span><br></pre></td></tr></tbody></table></figure>

<p>启动可视化客户端工具：</p>
<img src="https://image.woodwhales.cn/065/images/07.png" style="zoom:70%;">

<p>将上述客户端解压的文件目录放到一个固定位置，在 buid 文件目录中创建一个<code>ZooInspector.cmd</code>文件，文件内容为：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">java -jar zookeeper-dev-ZooInspector.jar</span><br></pre></td></tr></tbody></table></figure>

<p>将这个<code>ZooInspector.cmd</code>文件创建快捷方式到桌面，并设置个图标，双击运行即可：</p>
<p><img src="https://image.woodwhales.cn/065/images/08.png"></p>
<h4 id="zktools"><a href="#zktools" class="headerlink" title="zktools"></a>zktools</h4><p>本站下载地址：<a href="https://image.woodwhales.cn/065/zktools.zip">zktools.zip</a></p>
<img src="https://image.woodwhales.cn/065/images/15.png" style="zoom:70%;">

<h3 id="集成-zookeeper-到-windows-服务"><a href="#集成-zookeeper-到-windows-服务" class="headerlink" title="集成 zookeeper 到 windows 服务"></a>集成 zookeeper 到 windows 服务</h3><p>下载的 Zookeeper 是 .cmd 的批处理命令运行的，默认没有提供以 windows 服务的方式运行的方案，因此可以下载 prunsrv 来作为 zookeeper 的服务管理。将 zookeeper 做成 windows 服务，避免每次关闭后，再启动还需要使用 cmd。</p>
<h4 id="下载-prunsrv"><a href="#下载-prunsrv" class="headerlink" title="下载 prunsrv"></a>下载 prunsrv</h4><p>下载地址：<a href="http://archive.apache.org/dist/commons/daemon/binaries/windows/">http://archive.apache.org/dist/commons/daemon/binaries/windows/</a></p>
<p>目前最新版本是 1.2.2，找到对应的安装：commons-daemon-1.2.2-bin-windows.zip，</p>
<blockquote>
<p>本站下载地址：<a href="https://image.woodwhales.cn/065/commons-daemon-1.2.2-bin-windows.zip">commons-daemon-1.2.2-bin-windows.zip</a></p>
</blockquote>
<p>解压 zip 文件，复制 prunmgr.exe、prunsrv.exe 到 ZooKeeper 安装路径的 bin 目录下。注意：如果你的操作系统是 64 位的，则复制 amd64 目录下的 prunsrv.exe。 </p>
<img src="https://image.woodwhales.cn/065/images/09.png" style="zoom:70%;">

<h4 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h4><img src="https://image.woodwhales.cn/065/images/10.png" style="zoom:70%;">

<h5 id="安装服务脚本"><a href="#安装服务脚本" class="headerlink" title="安装服务脚本"></a>安装服务脚本</h5><p>在 ZooKeeper 根目录下创建服务安装脚本：<code>zkServiceInstall.bat</code></p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">CD</span> /d %~dp0</span><br><span class="line"><span class="built_in">SET</span> ZK_HOME=<span class="variable">%CD%</span></span><br><span class="line"><span class="built_in">SET</span> ZK_DATA_DIR=<span class="variable">%ZK_HOME%</span>\data</span><br><span class="line"><span class="built_in">SET</span> ZK_LOG_DIR=<span class="variable">%ZK_HOME%</span>\log</span><br><span class="line"><span class="built_in">SET</span> ZK_SERVICE_NAME=zookeeper</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> <span class="variable">%ZK_DATA_DIR%</span> <span class="built_in">mkdir</span> <span class="variable">%ZK_DATA_DIR%</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exist</span> <span class="variable">%ZK_LOG_DIR%</span> <span class="built_in">mkdir</span> <span class="variable">%ZK_LOG_DIR%</span></span><br><span class="line"> </span><br><span class="line">:: 安装ZooKeeper的Windows服务</span><br><span class="line"><span class="variable">%ZK_HOME%</span>\bin\prunsrv.exe "//IS//<span class="variable">%ZK_SERVICE_NAME%</span>" ^</span><br><span class="line">--DisplayName="<span class="variable">%ZK_SERVICE_NAME%</span>" ^</span><br><span class="line">--Description="<span class="variable">%ZK_SERVICE_NAME%</span>" ^</span><br><span class="line">--Startup=auto ^</span><br><span class="line">--StartMode=exe ^</span><br><span class="line">--StartPath=<span class="variable">%ZK_HOME%</span> ^</span><br><span class="line">--StartImage=<span class="variable">%ZK_HOME%</span>\bin\zkServer.<span class="built_in">cmd</span> ^</span><br><span class="line">--StopPath=<span class="variable">%ZK_HOME%</span>\ ^</span><br><span class="line">--StopImage=<span class="variable">%ZK_HOME%</span>\zkServerStop.bat ^</span><br><span class="line">--StopMode=exe ^</span><br><span class="line">--StopTimeout=<span class="number">5</span> ^</span><br><span class="line">--LogPath=<span class="variable">%ZK_LOG_DIR%</span> ^</span><br><span class="line">--LogPrefix=zookeeper-wrapper ^</span><br><span class="line">--PidFile=zookeeper.pid ^</span><br><span class="line">--LogLevel=Info ^</span><br><span class="line">--StdOutput=auto ^</span><br><span class="line">--StdError=auto</span><br><span class="line"> </span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="删除服务脚本"><a href="#删除服务脚本" class="headerlink" title="删除服务脚本"></a>删除服务脚本</h5><p>在 ZooKeeper 根目录下创建服务卸载脚本：<code>zkServiceRemove.bat</code></p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off </span><br><span class="line"></span><br><span class="line"><span class="built_in">CD</span> /d <span class="variable">%~dp0</span></span><br><span class="line"><span class="variable">%</span><span class="built_in">CD</span>%\bin\prunsrv.exe //DS//zookeeper</span><br></pre></td></tr></tbody></table></figure>

<h5 id="停止服务脚本"><a href="#停止服务脚本" class="headerlink" title="停止服务脚本"></a>停止服务脚本</h5><p>在 ZooKeeper 根目录下创建服务停止脚本：<code>zkServerStop.bat</code></p>
<blockquote>
<p>无法使用 net stop zookeeper 命令停止服务，只能暴力杀死进程来停止服务。</p>
</blockquote>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"> </span><br><span class="line"><span class="built_in">setlocal</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">CD</span> /d %~dp0</span><br><span class="line"> </span><br><span class="line">:: 以杀进程的方式停止ZooKeeper服务</span><br><span class="line"><span class="built_in">SET</span> /p zkPID=&lt;<span class="variable">%CD%</span>\log\zookeeper.pid</span><br><span class="line"><span class="built_in">taskkill</span> /PID <span class="variable">%zkPID%</span> /T /F</span><br><span class="line"> </span><br><span class="line"><span class="built_in">endlocal</span></span><br></pre></td></tr></tbody></table></figure>

<h5 id="脚本使用说明"><a href="#脚本使用说明" class="headerlink" title="脚本使用说明"></a>脚本使用说明</h5><p>以上三个脚本必须以管理员身份运行，首先运行 zkServiceInstall.bat 文件，再 win + r 寻找 services.msc 服务，找到<code>zookeeper</code>服务右击启动服务，或者使用<code>net start zookeeper</code>启动服务。</p>
<p>停止服务，执行 zkServerStop.bat 文件。</p>
<p>如果想删除服务，必须先停止服务（执行 zkServerStop.bat 文件），才能删除服务，即执行 zkServiceRemove.bat 文件。</p>
<h3 id="zookeeper-服务配置参数说明"><a href="#zookeeper-服务配置参数说明" class="headerlink" title="zookeeper 服务配置参数说明"></a>zookeeper 服务配置参数说明</h3><p>zookeeper 默认参考配置文件：zoo_sample.cfg</p>
<ul>
<li><p>tickTime：心跳间隔，这个时间作为 zookeeper 服务器之间或 zookeeper 服务器与客户端服务器维持心跳的时间间隔，即每隔 tickTime 时间就会发送一个心跳。</p>
</li>
<li><p>initLimit：这个配置项是用来配置 zookeeper 接受客户端（这里所说的客户端不是用户连接 zookeeper 服务器的客户端，而是 zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5 x 2000 毫秒 = 10 秒</p>
</li>
<li><p>syncLimit：这个配置项表示 Leader 与 Follower 之间发送消息，请求和相应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2 x 2000 毫秒 = 4 秒</p>
</li>
<li><p>dataDir：zookeeper 存储数据的目录，默认情况下，zookeeper 的日志问价也会保存至该目录</p>
</li>
<li><p>clientPort：客户端连接zookeeper的端口号</p>
</li>
<li><p>server.A = B：C：D：</p>
<ul>
<li>A 是一个整形数字，表示服务器下标。</li>
<li>B 是这个服务器的 ip 地址。</li>
<li>C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口。</li>
<li>D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>
</ul>
</li>
</ul>
<h3 id="单机伪分布式搭建"><a href="#单机伪分布式搭建" class="headerlink" title="单机伪分布式搭建"></a>单机伪分布式搭建</h3><p>伪分布式安装就是在同一台pc上安装，安装时使用同一个zookeeper包，多个配置文件分别配置为不同的端口。我这里配置 3 个伪服务。</p>
<h4 id="复制-3-份配置文件"><a href="#复制-3-份配置文件" class="headerlink" title="复制 3 份配置文件"></a>复制 3 份配置文件</h4><p>将 zookeeper 默认参考配置文件，即 zoo_sample.cfg 文件复制三份，并命名为：zoo1.cfg、zoo2.cfg、zoo3.cfg</p>
<img src="https://image.woodwhales.cn/065/images/11.png" style="zoom:70%;">

<h4 id="创建-3-份-data-及-log-目录"><a href="#创建-3-份-data-及-log-目录" class="headerlink" title="创建 3 份 data 及 log 目录"></a>创建 3 份 data 及 log 目录</h4><p>在 zookeeper 根目录创建三份 data 及 log 目录，笔者为了方便管理，均创建在了<code>Cluster</code>目录下：</p>
<img src="https://image.woodwhales.cn/065/images/12.png" style="zoom:70%;">

<p>并在 data1，data2，data3 文件夹中创建<code>myid</code>文件，文件内容依次为：1，2，3</p>
<img src="https://image.woodwhales.cn/065/images/13.png" style="zoom:70%;">

<h4 id="修改-3-份配置文件"><a href="#修改-3-份配置文件" class="headerlink" title="修改 3 份配置文件"></a>修改 3 份配置文件</h4><p>分别对 zoo1.cfg、zoo2.cfg、zoo3.cfg 文件中的 data、log、端口号进行设置：</p>
<p>zoo1.cfg：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initLimit</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\data1</span><br><span class="line"><span class="attr">dataLogDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\logs1</span><br><span class="line"></span><br><span class="line"><span class="attr">clientPort</span>=<span class="number">2181</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.1</span>=localhost:<span class="number">2887</span>:<span class="number">3887</span></span><br><span class="line"><span class="attr">server.2</span>=localhost:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="attr">server.3</span>=localhost:<span class="number">2889</span>:<span class="number">3889</span></span><br></pre></td></tr></tbody></table></figure>

<p>zoo2.cfg：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initLimit</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\data2</span><br><span class="line"><span class="attr">dataLogDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\logs2</span><br><span class="line"></span><br><span class="line"><span class="attr">clientPort</span>=<span class="number">2182</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.1</span>=localhost:<span class="number">2887</span>:<span class="number">3887</span></span><br><span class="line"><span class="attr">server.2</span>=localhost:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="attr">server.3</span>=localhost:<span class="number">2889</span>:<span class="number">3889</span></span><br></pre></td></tr></tbody></table></figure>

<p>zoo3.cfg：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initLimit</span>=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\data3</span><br><span class="line"><span class="attr">dataLogDir</span>=C:\\programs\\apache-zookeeper-<span class="number">3.6</span>.<span class="number">0</span>-bin\\cluster\\logs3</span><br><span class="line"></span><br><span class="line"><span class="attr">clientPort</span>=<span class="number">2183</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.1</span>=localhost:<span class="number">2887</span>:<span class="number">3887</span></span><br><span class="line"><span class="attr">server.2</span>=localhost:<span class="number">2888</span>:<span class="number">3888</span></span><br><span class="line"><span class="attr">server.3</span>=localhost:<span class="number">2889</span>:<span class="number">3889</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>假设把配置文件表示为：zoo{num}.cfg，server.{num}=ip/domain:Port1:Port2</p>
<p>其中 num：表示数字表示第几号服务器；ip/domain ：是服务器域名或者 ip 地址。</p>
<p>Port1：表示这个服务器和集群中的 Leader 服务器交换信息的端口。</p>
<p> Port2：表示万一集群中的Leader服务器挂了，需要一个端口重新进行选举，选出一个新的Leader，这个端口就是用来执行选举时服务器相互通信的端口。</p>
<p>由于我们是伪集群，所以 ip 或者域名是一样的，所以要分配不同的端口号。</p>
</blockquote>
<h4 id="复制-3-份启用服务脚本"><a href="#复制-3-份启用服务脚本" class="headerlink" title="复制 3 份启用服务脚本"></a>复制 3 份启用服务脚本</h4><p>将默认的启动文件复制三份，并命名为：zkServer1.cmd、zkServer2.cmd、zkServer3.cmd</p>
<img src="https://image.woodwhales.cn/065/images/14.png" style="zoom:70%;">

<p>分别修改上述启动脚本，设置成上述的启动配置脚本：</p>
<p>zkServer1.cmd：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">setlocal</span></span><br><span class="line"><span class="keyword">call</span> "%~dp0zkEnv.<span class="built_in">cmd</span>"</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br><span class="line"><span class="built_in">set</span> ZOO_LOG_FILE=zookeeper-<span class="variable">%USERNAME%</span>-server-<span class="variable">%COMPUTERNAME%</span>.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOCFG=C:\programs\apache-zookeeper-<span class="number">3</span>.<span class="number">6</span>.<span class="number">0</span>-bin\conf\zoo1.cfg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> on</span><br><span class="line"><span class="keyword">call</span> <span class="variable">%JAVA%</span> "-Dzookeeper.log.<span class="built_in">dir</span>=<span class="variable">%ZOO_LOG_DIR%</span>" "-Dzookeeper.root.logger=<span class="variable">%ZOO_LOG4J_PROP%</span>" "-Dzookeeper.log.file=<span class="variable">%ZOO_LOG_FILE%</span>" "-XX:+HeapDumpOnOutOfMemoryError" "-XX:OnOutOfMemoryError=<span class="built_in">cmd</span> /c <span class="built_in">taskkill</span> /pid <span class="variable">%%%</span>%p /t /f" -cp "<span class="variable">%CLASSPATH%</span>" <span class="variable">%ZOOMAIN%</span> "<span class="variable">%ZOOCFG%</span>" %*</span><br><span class="line"></span><br><span class="line"><span class="built_in">endlocal</span></span><br></pre></td></tr></tbody></table></figure>

<p>zkServer2.cmd：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">setlocal</span></span><br><span class="line"><span class="keyword">call</span> "%~dp0zkEnv.<span class="built_in">cmd</span>"</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br><span class="line"><span class="built_in">set</span> ZOO_LOG_FILE=zookeeper-<span class="variable">%USERNAME%</span>-server-<span class="variable">%COMPUTERNAME%</span>.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOCFG=C:\programs\apache-zookeeper-<span class="number">3</span>.<span class="number">6</span>.<span class="number">0</span>-bin\conf\zoo2.cfg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> on</span><br><span class="line"><span class="keyword">call</span> <span class="variable">%JAVA%</span> "-Dzookeeper.log.<span class="built_in">dir</span>=<span class="variable">%ZOO_LOG_DIR%</span>" "-Dzookeeper.root.logger=<span class="variable">%ZOO_LOG4J_PROP%</span>" "-Dzookeeper.log.file=<span class="variable">%ZOO_LOG_FILE%</span>" "-XX:+HeapDumpOnOutOfMemoryError" "-XX:OnOutOfMemoryError=<span class="built_in">cmd</span> /c <span class="built_in">taskkill</span> /pid <span class="variable">%%%</span>%p /t /f" -cp "<span class="variable">%CLASSPATH%</span>" <span class="variable">%ZOOMAIN%</span> "<span class="variable">%ZOOCFG%</span>" %*</span><br><span class="line"></span><br><span class="line"><span class="built_in">endlocal</span></span><br></pre></td></tr></tbody></table></figure>

<p>zkServer3.cmd：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">setlocal</span></span><br><span class="line"><span class="keyword">call</span> "%~dp0zkEnv.<span class="built_in">cmd</span>"</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOMAIN=org.apache.zookeeper.server.quorum.QuorumPeerMain</span><br><span class="line"><span class="built_in">set</span> ZOO_LOG_FILE=zookeeper-<span class="variable">%USERNAME%</span>-server-<span class="variable">%COMPUTERNAME%</span>.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> ZOOCFG=C:\programs\apache-zookeeper-<span class="number">3</span>.<span class="number">6</span>.<span class="number">0</span>-bin\conf\zoo3.cfg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> on</span><br><span class="line"><span class="keyword">call</span> <span class="variable">%JAVA%</span> "-Dzookeeper.log.<span class="built_in">dir</span>=<span class="variable">%ZOO_LOG_DIR%</span>" "-Dzookeeper.root.logger=<span class="variable">%ZOO_LOG4J_PROP%</span>" "-Dzookeeper.log.file=<span class="variable">%ZOO_LOG_FILE%</span>" "-XX:+HeapDumpOnOutOfMemoryError" "-XX:OnOutOfMemoryError=<span class="built_in">cmd</span> /c <span class="built_in">taskkill</span> /pid <span class="variable">%%%</span>%p /t /f" -cp "<span class="variable">%CLASSPATH%</span>" <span class="variable">%ZOOMAIN%</span> "<span class="variable">%ZOOCFG%</span>" %*</span><br><span class="line"></span><br><span class="line"><span class="built_in">endlocal</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="博文参考"><a href="#博文参考" class="headerlink" title="博文参考"></a>博文参考</h3><p><a href="https://www.cnblogs.com/zlslch/p/8561791.html">Windows里如何正确安装Zookeeper以服务运行</a></p>
<p><a href="https://juejin.im/post/5dbbd5946fb9a020361de82b">Windows下以后台服务的方式配置ZooKeeper</a></p>
<p><a href="https://www.jianshu.com/p/2ee2adbe819c">Windows 下 Zookeeper 单机模式和伪分布式模式安装</a></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>kakfa 快速入门（windows 环境）</title>
    <url>/2020/04/07/066/</url>
    <content><![CDATA[<blockquote>
<p>关于 kafka 的详细原理，请参见：<a href="https://woodwhales.cn/2019/12/01/055/">Apache Kafka 学习笔记</a></p>
</blockquote>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><blockquote>
<p>kafka 官网地址：<a href="http://kafka.apache.org/">http://kafka.apache.org/</a></p>
<p>kafka 下载地址：<a href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p>
</blockquote>
<p>本文选择的版本是：<code>kafka_2.11-2.3.1</code></p>
<p><img src="https://image.woodwhales.cn/066/images/1.png"></p>
<blockquote>
<p>kafka 的版本命令规则为：kafka-A-B.tgz</p>
<p>A 表示编译 Kafka 源代码的 Scala 编译器版本。</p>
<p>B 表示 kafka 真正的发行版本号</p>
<p>这里 B 要特别说明一下，在 kafka 1.0.0 版本之后，B 的版本命名规则正式从 4 位演进到 3 位。</p>
<p>比如上图中的：2.3.1，前面的 2 表示大版本号，即 Major Version；中间的 3 表示小版本号或次版本号，即 Minor Version；最后的 1 表示修订版本号，也就是 Patch 号。</p>
</blockquote>
<h3 id="安装（windows-环境）"><a href="#安装（windows-环境）" class="headerlink" title="安装（windows 环境）"></a>安装（windows 环境）</h3><h4 id="创建数据保存目录"><a href="#创建数据保存目录" class="headerlink" title="创建数据保存目录"></a>创建数据保存目录</h4><p>将下载好的 kafka_2.11-2.3.1.tgz 安装包解压，将 kafka_2.11-2.3.1 文件目录方法固定位置，在其根目录下创建一个名称为<code>logs</code>的文件夹。</p>
<p><img src="https://image.woodwhales.cn/066/images/2.png"></p>
<h4 id="配置-server-properties"><a href="#配置-server-properties" class="headerlink" title="配置 server.properties"></a>配置 server.properties</h4><p>进入 config 文件夹，使用文本编辑器打开 server.properties，修改<code>log.dirs</code>默认配置为上述创建数据保存目录：</p>
<p><img src="https://image.woodwhales.cn/066/images/3.png"></p>
<blockquote>
<p>官网文档：<a href="http://kafka.apache.org/23/documentation.html#quickstart">http://kafka.apache.org/23/documentation.html#quickstart</a></p>
</blockquote>
<p>启动 kafka 的前提是需要搭建 zookeeper 服务，笔者已经安装过了，这里不再赘述，具体可参见：<a href="https://woodwhales.cn/2020/04/06/065/">zookeeper window环境安装、集成为windows服务、单机伪集群搭建</a>。</p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>windows 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></tbody></table></figure>

<p>linux 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></tbody></table></figure>

<p>控制台提示如下字样，表示启动成功：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[2020-04-07 09:44:12,747]</span> INFO <span class="section">[SocketServer brokerId=0]</span> Started data-plane processors for 1 acceptors (kafka.network.SocketServer)</span><br><span class="line"><span class="section">[2020-04-07 09:44:12,749]</span> INFO Kafka version: 2.3.1 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line"><span class="section">[2020-04-07 09:44:12,749]</span> INFO Kafka commitId: 18a913733fb71c01 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line"><span class="section">[2020-04-07 09:44:12,749]</span> INFO Kafka startTimeMs: 1586223852747 (org.apache.kafka.common.utils.AppInfoParser)</span><br><span class="line"><span class="section">[2020-04-07 09:44:12,751]</span> INFO <span class="section">[KafkaServer id=0]</span> started (kafka.server.KafkaServer)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h4><p>windows 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></tbody></table></figure>

<p>linux 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></tbody></table></figure>

<p>创建成功之后，控制台没有任何提示。使用如下命令可以查看已存在的主题列表：</p>
<p>windows 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --list --bootstrap-server localhost:9092</span><br></pre></td></tr></tbody></table></figure>

<p>linux 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></tbody></table></figure>

<p>下图可以看到已成功创建一个主题：</p>
<p><img src="https://image.woodwhales.cn/066/images/4.png"></p>
<p>值得注意的是，服务端控制台显示的日志已经可以看出主题创建成功：</p>
<p><img src="https://image.woodwhales.cn/066/images/5.png"></p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>kafka 自带命令行工具，可以把控制台的标准输入流通过以行的形式发送到 kafka 集群。</p>
<p>windows 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic test</span><br></pre></td></tr></tbody></table></figure>

<p>linux 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br></pre></td></tr></tbody></table></figure>

<p>此时，控制状态为光标闪烁，输入一些字符串到控制台：</p>
<p><img src="https://image.woodwhales.cn/066/images/6.png"></p>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>kafka 自带命令行工具，可以自动消费 kafka 集群中的消息并发送到标准控制台：</p>
<p>windows 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></tbody></table></figure>

<p>linux 运行脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></tbody></table></figure>

<p>当消费者启动好之后，可以看到控制台自动打印上述生产者对 test 主题发送的历史消息：</p>
<p><img src="https://image.woodwhales.cn/066/images/7.png"></p>
<p>为啥能接收到历史消息呢？因为在启动消费者的时候参数中带了<code>--from-beginning</code>，如果不带这个参数，那么只会接收当前消费者启动时刻之后，生产者发送到该主题的消息。再启动一个不带接收历史消息的消费者：</p>
<p><img src="https://image.woodwhales.cn/066/images/8.png"></p>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 搭建 FTP 服务器</title>
    <url>/2020/04/21/067/</url>
    <content><![CDATA[<h3 id="开启-FTP-服务"><a href="#开启-FTP-服务" class="headerlink" title="开启 FTP 服务"></a>开启 FTP 服务</h3><p>控制面板 &gt; 卸载程序 &gt; 启用或关闭 windows 服务</p>
<p><img src="https://image.woodwhales.cn/067/images/01.png"></p>
<p>勾选图中的 windows 服务，并应用：</p>
<p><img src="https://image.woodwhales.cn/067/images/02.png"></p>
<p>注意上图中的<code>ftp服务器</code>和<code>IIS管理控制台</code>一定要勾选上。</p>
<h3 id="创建-FTP-服务"><a href="#创建-FTP-服务" class="headerlink" title="创建 FTP 服务"></a>创建 FTP 服务</h3><p>控制面板 &gt; 管理工具，或者右击计算机 &gt; 管理 &gt; 服务和应用程序，双击”Internet信息服务（IIS）管理器”，添加FTP站点</p>
<p><img src="https://image.woodwhales.cn/067/images/03.png"></p>
<p>上图中的”Default Web Site”可以选中并删除掉。</p>
<h4 id="设置站点名称及存储路径"><a href="#设置站点名称及存储路径" class="headerlink" title="设置站点名称及存储路径"></a>设置站点名称及存储路径</h4><img src="https://image.woodwhales.cn/067/images/04.png" style="zoom:75%;">

<h4 id="绑定IP"><a href="#绑定IP" class="headerlink" title="绑定IP"></a>绑定IP</h4><img src="https://image.woodwhales.cn/067/images/05.png" style="zoom:75%;">

<p>注意：指定端口号要记住，后面要在防火墙的出入口规则需要配置。</p>
<h4 id="设置身份验证和权限"><a href="#设置身份验证和权限" class="headerlink" title="设置身份验证和权限"></a>设置身份验证和权限</h4><img src="https://image.woodwhales.cn/067/images/06.png" style="zoom:75%;">

<p>如果勾选的是<code>基本</code>，而不是<code>匿名</code>，则访问 ftp 服务的时候需要使用账号密码登陆，账号名为：administrator。</p>
<blockquote>
<p>administrator 账号的用户名和密码可右击计算机 &gt; 管理 &gt; 本地用户和组 &gt; 用户 &gt; administrator &gt; 右击修改密码设置即可。</p>
</blockquote>
<p>创建好 ftp 站点之后，点击 ftp 图标，可以看到图形化的更能菜单，可以对上述的配置进行重新修改或增加配置：</p>
<img src="https://image.woodwhales.cn/067/images/07.png" style="zoom:75%;">

<p>“FTP 身份验证”里可以看到身份验证配置详情，”FTP授权规则”里可以看到授权配置详情。</p>
<p>浏览器访问ftp服务：ftp://本机IP，即可查看到当前 ftp 服务配置的物理路径下载的所有文件内容，笔者这个 ftp 服务器里还没有文件，所以显示为空：</p>
<img src="https://image.woodwhales.cn/067/images/08.png" style="zoom:75%;">

<h3 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h3><h4 id="创建-windows-用户账号"><a href="#创建-windows-用户账号" class="headerlink" title="创建 windows 用户账号"></a>创建 windows 用户账号</h4><p>在”本地用户和组”选项中的”用户”文件夹，右击创建新用户：</p>
<img src="https://image.woodwhales.cn/067/images/09.png" style="zoom:75%;">

<p>创建用户，并设置密码：</p>
<img src="https://image.woodwhales.cn/067/images/10.png" style="zoom:75%;">

<p>此时，windows 系统里多了一个名称为：woodwhales-ftp 的用户账号。</p>
<p>创建好的用户默认被划分到了 Users 组里，可以手动将这个用户从组里删除：</p>
<img src="https://image.woodwhales.cn/067/images/13.png" style="zoom:75%;">

<p>双击组中，删除掉用户即可。</p>
<h4 id="FTP-授权设置"><a href="#FTP-授权设置" class="headerlink" title="FTP 授权设置"></a>FTP 授权设置</h4><p>点击 ftp 按钮，编辑权限，在安全选项卡里编辑设置，上述为创建好的用户：</p>
<img src="https://image.woodwhales.cn/067/images/11.png" style="zoom:75%;">

<p>点击添加 &gt; 高级 &gt; 立即查找，找到上述创建的用户，并添加进来，设置完全控制：</p>
<img src="https://image.woodwhales.cn/067/images/12.png" style="zoom:75%;">

<p>如果需要其他用户，设置其他权限，重新执行上述俩个步骤操作即可。</p>
<h4 id="身份验证设置"><a href="#身份验证设置" class="headerlink" title="身份验证设置"></a>身份验证设置</h4><p>设置身份验证：</p>
<img src="https://image.woodwhales.cn/067/images/14.png" style="zoom:75%;">

<p>开启基本身份验证，关闭匿名身份验证：</p>
<img src="https://image.woodwhales.cn/067/images/15.png" style="zoom:75%;">

<h4 id="设置授权规则"><a href="#设置授权规则" class="headerlink" title="设置授权规则"></a>设置授权规则</h4><p>设置授权规则：</p>
<img src="https://image.woodwhales.cn/067/images/17.png" style="zoom:75%;">

<p>删除所有用户权限，右侧点击”添加允许规则”，设置上述创建的 windows 用户：</p>
<img src="https://image.woodwhales.cn/067/images/16.png" style="zoom:75%;">

<p>此时再次使用浏览器访问 ftp 服务，需要输入用户名和密码：</p>
<img src="https://image.woodwhales.cn/067/images/18.png" style="zoom:75%;">]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年的第一次青年危机</title>
    <url>/2020/05/06/068/</url>
    <content><![CDATA[<h4 id="2020-年的上半场"><a href="#2020-年的上半场" class="headerlink" title="2020 年的上半场"></a>2020 年的上半场</h4><h5 id="今年的第一次微信公众号发文"><a href="#今年的第一次微信公众号发文" class="headerlink" title="今年的第一次微信公众号发文"></a>今年的第一次微信公众号发文</h5><p>好久不没有在微信公众号里写文章了，笔者之前多次在文章中暗示，如果想要良好的阅读体验应该到我的个人博客上，那里会发布最新的博文动态。</p>
<blockquote>
<p>woodwhale’s blog | <a href="https://woodwhales.cn/">https://woodwhales.cn/</a> </p>
</blockquote>
<p>之所以很久没有打理本公众号，主要原因在于从停更到现在，写的文章都是偏技术性，文中多包含大段的程序代码，不适宜在公众号排版发表。如果把大量精力耗费在公众号的精致排版上，有点捡了芝麻丢了西瓜。</p>
<p>随着笔者码龄的加深，愈加理解体会很久之前看到左耳朵耗子的一篇博文：<a href="https://coolshell.cn/articles/17391.html">为什么我不在微信公众号上写文章</a>，耗子叔总结到：<strong>写文章就是为了分享和影响，我会借助社交网络，但不会寄宿在社交网络上，更不会被社交网络所绑架。</strong></p>
<p>那时候微信公众号逐渐大火，笔者也忍不住加入其中，以当时的认知不能全部理解其中的观点，但是对这位大牛的博文一直保持敬畏之心，在自己维护公众号时也在慢慢体会其中的观点。</p>
<p>从 2016 年到现在，笔者也发文了 120+ 的博文，对现在的我来说，越发能理解微信终归是一种网络社交工具，它终究不够 open 得彻底，所以应该把它当作和电视、报纸一样的一种获取信息的媒介，而不应把它作为我们生活中形影不离的“唯一”。</p>
<p>微信曾是笔者获取信息的唯一，现在微信只是获取信息的一小部分，真正获取信息的方式，还是要靠强大的搜索引擎。希望阅读本文的读者们也能慢慢扩大自己的信息接收途径。</p>
<blockquote>
<p>这里还是要感谢自己做了自己喜欢做的事情，在编程过程中，需要大量使用到信息搜索，这才有机会逼迫自己接触到更广阔的信息源。</p>
</blockquote>
<h5 id="第一次青年危机"><a href="#第一次青年危机" class="headerlink" title="第一次青年危机"></a>第一次青年危机</h5><p>众所周知，疫情当头之下，今年的全球经济形势都在大幅衰减，无一幸免，诸多企业为了求生存也在做着积极的避难准备，比如裁员。</p>
<p>笔者在职的公司也赶上了这波裁员浪潮，不过主因不是因为经济收益不佳，而是颠覆性的组织架构调整，波及范围之广，让大伙们均始料未及。</p>
<p>五一之前的问卷调查暗示这波动作很大，今天果然不幸中招。即使做好了最坏打算的心理准备，收到消息之后，还是心里有些不是滋味，心里安慰自己说还是我太年轻，经历太少，人生总得经历点挫折。</p>
<p>对 93 年生的人，此时的年纪说小不小，说大不大，正在逐渐步入中年大叔的阵营。正值特殊时期，赶上了这波裁员浪潮，心里越发觉得自己的中年危机即将到来，感叹自己少壮不努力，老大徒伤悲。妻子安慰道你现在哪里是少壮，你顶多是“少”未努力，不是现在还有“壮”嘛。</p>
<p>是的，我不是中年危机，是青年危机到了。</p>
<h4 id="2020-年的下半场"><a href="#2020-年的下半场" class="headerlink" title="2020 年的下半场"></a>2020 年的下半场</h4><h5 id="每个人都是超级英雄"><a href="#每个人都是超级英雄" class="headerlink" title="每个人都是超级英雄"></a>每个人都是超级英雄</h5><p>2020 年即将进入下半场，早上做地铁的时候阅读了 tinyfool 大佬的书<a href="https://book.douban.com/subject/26874593/">《技巧：如何用一年时间获得十年的经验》</a>，看了他的自序，里面是他现在对于过去的一些反思，因为自己不想随波逐流，所以没有走原本可以想象到未来几十年的人生轨迹，而是按照自己的节奏，走了另一条属于自己成长的路，点明了<strong>每个人都是超级英雄：我们的伟业不是改变世界，而是持续地改变自己，push（推动）自己到新的limit（限度），寻找并扩展自己的边界，而改变世界这样的小事情，只是我们前进中的副产品而已。</strong></p>
<p>是的，要做自己的超级英雄，扩展自己的边界，让自己再成长得快一点，这样才能减缓自己未来的中年危机。我承认，懒于维护公众号，哦不，懒于维护比较碎碎念的博文，是在放弃自己一种成长的机会，这里再次拾起来自己关于非技术的事物的思考，并在博客和微信公众号之间做最大可能的同步。</p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>随笔杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装与入门</title>
    <url>/2020/05/28/069/</url>
    <content><![CDATA[<p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。</p>
<h2 id="安装-Docker-CE（centos-7）"><a href="#安装-Docker-CE（centos-7）" class="headerlink" title="安装 Docker-CE（centos 7）"></a>安装 Docker-CE（centos 7）</h2><blockquote>
<p>Docker CE 安装官方文档参考：</p>
<ul>
<li><p>centos 环境：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
</li>
<li><p>windows 环境：<a href="https://docs.docker.com/docker-for-windows/install/">https://docs.docker.com/docker-for-windows/install/</a></p>
</li>
</ul>
<p>注意：docker 要求 centos 系统必须是 centos 7 版本以上，windows 系统必须是 win10 专业版、企业版或教育版。</p>
</blockquote>
<h3 id="卸载旧的-docker"><a href="#卸载旧的-docker" class="headerlink" title="卸载旧的 docker"></a>卸载旧的 docker</h3><p>如果系统中存在老版本的 docker ，可以使用下面命令卸载旧的 docker：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum remove docker \</span></span><br><span class="line"><span class="language-bash">                  docker-client \</span></span><br><span class="line"><span class="language-bash">                  docker-client-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-common \</span></span><br><span class="line"><span class="language-bash">                  docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><blockquote>
<p>yum 阿里云镜像设置：<a href="https://developer.aliyun.com/mirror/centos">https://developer.aliyun.com/mirror/centos</a></p>
</blockquote>
<p>步骤1：安装 docker 软件依赖的工具</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：设置 docker 安装源，使用阿里云镜像安装源：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：设置 yum 使用最快的安装源</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></tbody></table></figure>

<p>步骤4：执行下面命令，安装 docker-ce</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></tbody></table></figure>

<p>安装成功之后，控制台提示类似如下信息：</p>
<p><img src="https://image.woodwhales.cn/069/images/01.png"></p>
<h3 id="docker-服务相关命令"><a href="#docker-服务相关命令" class="headerlink" title="docker 服务相关命令"></a>docker 服务相关命令</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl start docker.service	 			# 启动docker服务</span><br><span class="line">systemctl stop docker.service	 			# 停止docker服务</span><br><span class="line">systemctl restart docker.service 			# 重启docker服务</span><br><span class="line"></span><br><span class="line">systemctl status docker.service	 			# 查看docker服务运行状态</span><br><span class="line"></span><br><span class="line">systemctl enable docker.service	 			# 设置开机自动启动docker服务</span><br><span class="line">systemctl disable docker.service 			# 设置禁止开机自动启动docker服务</span><br><span class="line"></span><br><span class="line">systemctl is-enabled docker.service        	# 查看docker服务是否自启动</span><br><span class="line">systemctl list-dependencies docker.service 	# 列出docker服务层级和依赖关系</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他命令</span></span><br><span class="line">systemctl list-units --type=service    		# 列出系统所有服务的启动情况</span><br><span class="line">systemctl list-unit-files|grep enabled 		# 列出所有自启动服务</span><br></pre></td></tr></tbody></table></figure>

<h3 id="设置阿里云容器镜像代理"><a href="#设置阿里云容器镜像代理" class="headerlink" title="设置阿里云容器镜像代理"></a>设置阿里云容器镜像代理</h3><p>访问：<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a></p>
<p>注意的是，上述地址需要注册阿里云账号，并开通：容器镜像服务。</p>
<p>按照阿里云文档选择对应的操作系统脚本执行，即可设置阿里云镜像加速服务：</p>
<p><img src="https://image.woodwhales.cn/069/images/02.png"></p>
<p>拉取 docker 镜像并运行：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull hello-world</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></tbody></table></figure>

<p>运行效果界面如下：</p>
<p><img src="https://image.woodwhales.cn/069/images/03.png"></p>
<h2 id="Docker-的基本概念"><a href="#Docker-的基本概念" class="headerlink" title="Docker 的基本概念"></a>Docker 的基本概念</h2><p><code>Docker</code> 中包括三个基本的概念：</p>
<ul>
<li><code>Image</code>(镜像)</li>
<li><code>Container</code>(容器)</li>
<li><code>Repository</code>(仓库)</li>
</ul>
<p><img src="https://image.woodwhales.cn/069/images/04.png"></p>
<p>镜像是 <code>Docker</code> 运行容器的前提，仓库是存放镜像的场所，可见镜像更是 <code>Docker</code> 的核心。</p>
<h3 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image (镜像)"></a>Image (镜像)</h3><blockquote>
<p>docker 官网镜像地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
</blockquote>
<p><code>Docker</code> 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>镜像<code>（Image）</code>就是一堆只读层<code>（read-only layer）</code>的统一视角，也许这个定义有些难以理解，下面的这张图能够帮助读者理解镜像的定义。</p>
<p><img src="https://image.woodwhales.cn/069/images/05.png"></p>
<p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code> 内部的实现细节，并且能够在主机的文件系统上访问到。统一文件系统 <code>(union file system)</code> 技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。我们可以在图片的右边看到这个视角的形式。</p>
<h3 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container (容器)"></a>Container (容器)</h3><p>容器 <code>(container)</code> 的定义和镜像 <code>(image)</code> 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p><img src="https://image.woodwhales.cn/069/images/06.png"></p>
<p>由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。</p>
<h3 id="Repository-仓库"><a href="#Repository-仓库" class="headerlink" title="Repository (仓库)"></a>Repository (仓库)</h3><p><code>Docker</code> 仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> (仓库注册服务器)就是这样的服务。有时候会把仓库 <code>(Repository)</code> 和仓库注册服务器 <code>(Registry)</code> 混为一谈，并不严格区分。<code>Docker</code> 仓库的概念跟 <code>Git</code> 类似，注册服务器可以理解为 <code>GitHub</code> 这样的托管服务。实际上，一个 <code>Docker Registry</code> 中可以包含多个仓库 <code>(Repository)</code> ，每个仓库可以包含多个标签 <code>(Tag)</code>，每个标签对应着一个镜像。所以说，镜像仓库是 <code>Docker</code> 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p>
<p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签.。</p>
<p>仓库又可以分为两种形式：</p>
<ul>
<li><code>public</code>(公有仓库)</li>
<li><code>private</code>(私有仓库)</li>
</ul>
<p><code>Docker Registry</code> 公有仓库是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>除了使用公开服务外，用户还可以在本地搭建私有 <code>Docker Registry</code> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code> 镜像，可以直接使用做为私有 <code>Registry</code> 服务。当用户创建了自己的镜像之后就可以使用 <code>push</code> 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 <code>pull</code> 下来就可以了。</p>
<p>我们主要把 <code>Docker</code> 的一些常见概念如 <code>Image</code> ， <code>Container</code> ， <code>Repository</code> 做了详细的阐述，也从传统虚拟化方式的角度阐述了 <code>docker</code> 的优势，我们从下图可以直观地看到 <code>Docker</code> 的架构：</p>
<p><img src="https://image.woodwhales.cn/069/images/07.png"></p>
<p><code>Docker</code> 使用 <code>C/S</code> 结构，即<strong>客户端/服务器</strong>体系结构。 <code>Docker</code> 客户端与 <code>Docker</code> 服务器进行交互，Docker服务端负责构建、运行和分发 <code>Docker</code> 镜像。 <code>Docker</code> 客户端和服务端可以运行在一台机器上，也可以通过 <code>RESTful</code> 、 <code>stock</code> 或网络接口与远程 <code>Docker</code> 服务端进行通信。</p>
<p><img src="https://image.woodwhales.cn/069/images/08.png"></p>
<p>这张图展示了 <code>Docker</code> 客户端、服务端和 <code>Docker</code> 仓库（即 <code>Docker Hub</code> 和 <code>Docker Cloud</code> ），默认情况下<code>Docker</code> 会在 <code>Docker</code> 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 <code>Git</code> ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Docker容器信息"><a href="#Docker容器信息" class="headerlink" title="Docker容器信息"></a>Docker容器信息</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker version	# 查看docker容器版本</span><br><span class="line">docker info  	# 查看docker容器信息</span><br><span class="line">docker --help	# 查看docker容器帮助</span><br></pre></td></tr></tbody></table></figure>

<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><blockquote>
<p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p>
</blockquote>
<h4 id="镜像查看"><a href="#镜像查看" class="headerlink" title="镜像查看"></a>镜像查看</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker images				# 列出本地images</span><br><span class="line">docker images -a			# 含中间映像层</span><br><span class="line">docker images -q			# 只显示镜像ID</span><br><span class="line">docker images -qa   		# 含中间映像层</span><br><span class="line">docker images --digests		# 显示镜像摘要信息(DIGEST列)</span><br><span class="line">docker images --no-trunc	# 显示镜像完整信息</span><br><span class="line">docker history -H redis		# 显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID</span><br></pre></td></tr></tbody></table></figure>

<h4 id="镜像搜索"><a href="#镜像搜索" class="headerlink" title="镜像搜索"></a>镜像搜索</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker search mysql						# 搜索仓库MySQL镜像</span><br><span class="line">docker search --filter=stars=600 mysql	# --filter=stars=600：只显示 starts&gt;=600 的镜像</span><br><span class="line">docker search --no-trunc mysql			# --no-trunc 显示镜像完整 DESCRIPTION 描述</span><br><span class="line">docker search  --automated mysql		# --automated ：只列出 AUTOMATED=OK 的镜像</span><br></pre></td></tr></tbody></table></figure>

<h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull redis			# 下载Redis官方最新镜像，相当于：docker pull redis:latest</span><br><span class="line">docker pull -a redis		# 下载仓库所有Redis镜像</span><br><span class="line">docker pull bitnami/redis	# 下载私人仓库镜像</span><br></pre></td></tr></tbody></table></figure>

<h4 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker rmi redis					# 单个镜像删除，相当于：docker rmi redis:latest</span><br><span class="line">docker rmi -f redis					# 强制删除(针对基于镜像有运行的容器进程)</span><br><span class="line">docker rmi -f redis tomcat nginx	# 多个镜像删除，不同镜像间以空格间隔</span><br><span class="line">docker rmi -f $(docker images -q)	# 删除本地全部镜像</span><br></pre></td></tr></tbody></table></figure>

<h3 id="镜像操作-1"><a href="#镜像操作-1" class="headerlink" title="镜像操作"></a>镜像操作</h3><blockquote>
<p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p>
</blockquote>
<h4 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run -i -t --name mycentos	# 新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span><br><span class="line">docker run -d mycentos				# 后台启动容器，参数：-d  已守护方式启动容器</span><br><span class="line">docker start redis					# 启动一个或多个已经被停止的容器</span><br><span class="line">docker restart redis				# 重启容器</span><br></pre></td></tr></tbody></table></figure>



<h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker ps				# 查看正在运行的容器</span><br><span class="line">docker ps -q			# 查看正在运行的容器的ID</span><br><span class="line">docker ps -a			# 查看正在运行+历史运行过的容器</span><br><span class="line">docker ps -s			# 显示运行容器总文件大小</span><br><span class="line">docker ps -l			# 显示最近创建容器</span><br><span class="line">docker ps -n 3			# 显示最近创建的3个容器</span><br><span class="line">docker ps --no-trunc 	# 不截断输出</span><br><span class="line">docker inspect redis	# 获取镜像redis的元信息</span><br><span class="line">docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' redis # 获取正在运行的容器redis的 IP</span><br></pre></td></tr></tbody></table></figure>

<h4 id="容器的停止与删除"><a href="#容器的停止与删除" class="headerlink" title="容器的停止与删除"></a>容器的停止与删除</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker stop redis					# 停止一个运行中的容器</span><br><span class="line">docker kill redis					# 杀掉一个运行中的容器</span><br><span class="line">docker rm redis						# 删除一个已停止的容器</span><br><span class="line">docker rm -f redis					# 删除一个运行中的容器</span><br><span class="line">docker rm -f $(docker ps -a -q)		# 删除多个容器</span><br><span class="line">docker ps -a -q | xargs docker rm 	# 删除多个容器</span><br><span class="line">docker rm -l db 					# -l 移除容器间的网络连接，连接名为 db</span><br><span class="line">docker rm -v redis					# -v 删除容器，并删除容器挂载的数据卷</span><br></pre></td></tr></tbody></table></figure>



<p>#  ##查看docker容器信息 docker info ##查看docker容器帮助 docker –help</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.im/post/5d4522c1f265da03e05af5f5">10分钟快速掌握Docker必备基础知识</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a></p>
<p><a href="https://yeasy.gitbook.io/docker_practice/">Docker — 从入门到实践</a></p>
<p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9789130.html">这可能是最为详细的Docker入门吐血总结</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法的Java实现（两种实现+增强实现）</title>
    <url>/2020/07/05/070/</url>
    <content><![CDATA[<h2 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h2><p>LRU 全称是 Least Recently Used，即最近最久未使用的意思。</p>
<p>LRU算法的设计原则是：<strong>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。</strong>也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p>
<h2 id="LRU-接口设计"><a href="#LRU-接口设计" class="headerlink" title="LRU 接口设计"></a>LRU 接口设计</h2><p>有了上面的设计原则，就可以得出设计一个带有 LRU 功能的缓存，应该具备以下功能：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LruCache</span>&lt;K, V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入数据</span></span><br><span class="line"><span class="comment">     * 当容器满的时候，将最久访问的数据从容器中移除，</span></span><br><span class="line"><span class="comment">     * 并将新加入的数据放入容器中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定元素从容器中移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存当前已存有效数据的容量大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前缓存容器的最大可缓存容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>说明：在实现 LRU 算法容器过程中，对参数校验笔者使用到了 guava 工具包：<a href="https://mvnrepository.com/artifact/com.google.guava/guava">https://mvnrepository.com/artifact/com.google.guava/guava</a></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现1：利用-LinkedHashMap-实现"><a href="#实现1：利用-LinkedHashMap-实现" class="headerlink" title="实现1：利用 LinkedHashMap 实现"></a>实现1：利用 LinkedHashMap 实现</h2><p>在 Java 中，LinkedHashMap 天然实现了 LRU 算法，因此我们可以设计一个 Cache 对象，内部自己维护一个 LinkedHashMap 容器，重写掉 removeEldestEntry() 方法即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 21:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用LinkedHashMap实现带LRU的缓存</span></span><br><span class="line"><span class="comment"> * 本类不是一个线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapLruCache</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">LruCache</span>&lt;K, V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLruLinkedHashMapCache&lt;K, V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.put(key, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cache.get(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.remove(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.clear();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cache.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.limit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cache.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InternalLruLinkedHashMapCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InternalLruLinkedHashMapCache</span><span class="params">(<span class="type">int</span> limit)</span> {</span><br><span class="line">            <span class="built_in">super</span>(limit, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.size() &gt; <span class="built_in">this</span>.limit;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMapLruCache</span><span class="params">(<span class="type">int</span> limit)</span> {</span><br><span class="line">        Preconditions.checkArgument(limit &gt; <span class="number">0</span>, <span class="string">"this limit must big than zero."</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">InternalLruLinkedHashMapCache</span>&lt;&gt;(limit);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么 LinkedHashMapLruCache 不直接继承 LinkedHashMap，而是在内部维护一个静态内部类呢？因为保证接口实现的“纯洁性”，LinkedHashMapLruCache 的使用者随便继承使用或直接使用，也只能使用上述定义的缓存接口中的方法，而不会使用到 LinkedHashMap 的方法。</p>
<p>上述这种实现很简单，完全依靠 LinkedHashMap 来维护缓存数据，重点在于内部类 InternalLruLinkedHashMapCache 一定要重写 removeEldestEntry() 方法，当达到容器容量满时，触发 LinkedHashMap 对最久访问数据的移除。</p>
<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LruCache;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LinkedHashMapLruCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 21:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用LinkedHashMap实现带LRU的缓存测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapLruCacheExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        LruCache&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMapLruCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于使用了一次 2，因此原本 2 是最老的，现在是 3 是最老的</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{1=1, 2=2, 3=3}</span><br><span class="line">{2=2, 3=3, 4=4}</span><br><span class="line">2</span><br><span class="line">{3=3, 4=4, 2=2}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出结果符合预期。</p>
<h2 id="实现2：利用-LinkedList-HashMap-实现"><a href="#实现2：利用-LinkedList-HashMap-实现" class="headerlink" title="实现2：利用 LinkedList + HashMap 实现"></a>实现2：利用 LinkedList + HashMap 实现</h2><p>上面一种实现完全利用 Java 自带的 LinkedHashMap 容器实现，如果不允许使用 LinkedHashMap，则需要自己实现 LinkedHashMap 类似的功能：LinkedList + HashMap</p>
<p>使用 LinkedList 维护着缓存中元素的 key，保证key的顺序就可以真正的数据存放在 HashMap 中。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 21:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用LinkedList+HashMap实现带LRU的缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListLruCache</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">LruCache</span>&lt;K, V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;K&gt; keys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;K, V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListLruCache</span><span class="params">(<span class="type">int</span> limit)</span> {</span><br><span class="line">        Preconditions.checkArgument(limit &gt; <span class="number">0</span>, <span class="string">"the limit big than zero."</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.keys = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;K&gt; ();</span><br><span class="line">        <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(limit);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        Preconditions.checkNotNull(key, <span class="string">"this key must nut null"</span>);</span><br><span class="line">        Preconditions.checkNotNull(value, <span class="string">"this value must nut null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) {</span><br><span class="line">            keys.remove(key);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span>(cache.size() &gt;= limit) {</span><br><span class="line">                <span class="type">K</span> <span class="variable">firstKey</span> <span class="operator">=</span> keys.getFirst();</span><br><span class="line">                keys.removeFirst();</span><br><span class="line">                cache.remove(firstKey);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        keys.addLast(key);</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> keys.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(!exist) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        keys.addLast(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span> {</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exist</span> <span class="operator">=</span> keys.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(exist) {</span><br><span class="line">            cache.remove(key);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">        keys.clear();</span><br><span class="line">        cache.clear();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> keys.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.limit;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        builder.append(<span class="string">"{"</span>);</span><br><span class="line">        builder.append(keys.stream().map(key -&gt; key + <span class="string">"="</span> + cache.get(key)).collect(Collectors.joining(<span class="string">","</span>)));</span><br><span class="line">        builder.append(<span class="string">"}"</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LinkedListLruCache;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LruCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 21:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用LinkedList+HashMap实现带LRU的缓存测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListLruCacheExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        LruCache&lt;String, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedListLruCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"4"</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于使用了一次 2，因此原本 2 是最老的，现在是 3 是最老的</span></span><br><span class="line">        System.out.println(cache.get(<span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{1=1,2=2,3=3}</span><br><span class="line">{2=2,3=3,4=4}</span><br><span class="line">2</span><br><span class="line">{3=3,4=4,2=2}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现3：软引用缓存（增强版缓存）"><a href="#实现3：软引用缓存（增强版缓存）" class="headerlink" title="实现3：软引用缓存（增强版缓存）"></a>实现3：软引用缓存（增强版缓存）</h2><p>上述两种实现的容器，缓存中的对象都是强引用，可能会存在一种极端情况：当开发者在内存中使用了大量的缓存，而这些缓存中的内容一旦“满员”，那么这个缓存容器就会维护着大量的强引用对象，这些对象会一直得不到垃圾回收。从而导致堆内存溢出（OOM）。</p>
<blockquote>
<p>Java 中的引用有四种：强引用、软引用、弱引用、幻影（虚）引用。</p>
</blockquote>
<p>软引用会在内存快要 OOM 的时候被 GC 回收。因此我们可以利用这个特性，对缓存中的数据做软引用，而不是使用强引用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.5 00:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用软引用对缓存进行增强</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapSoftReferencesLruCache</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">LruCache</span>&lt;K, V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLruLinkedHashMapCache&lt;K, V&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InternalLruLinkedHashMapCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, SoftReference&lt;V&gt;&gt; {</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InternalLruLinkedHashMapCache</span><span class="params">(<span class="type">int</span> limit)</span> {</span><br><span class="line">            <span class="built_in">super</span>(limit, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, SoftReference&lt;V&gt;&gt; eldest)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.size() &gt; <span class="built_in">this</span>.limit;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashMapSoftReferencesLruCache</span><span class="params">(<span class="type">int</span> limit)</span> {</span><br><span class="line">        Preconditions.checkArgument(limit &gt; <span class="number">0</span>, <span class="string">"this limit must big than zero."</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">InternalLruLinkedHashMapCache</span>&lt;&gt;(limit);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.put(key, <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(value));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> {</span><br><span class="line">        SoftReference&lt;V&gt; softReference = <span class="built_in">this</span>.cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(softReference)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> softReference.get();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.remove(key);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.cache.clear();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.cache.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">limit</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.limit;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述实现是在实现1的基础上做了一点点变动，即 LinkedHashMap 中存储的数据对象是 SoftReference<v>。</v></p>
<p>单元测试：</p>
<blockquote>
<p>测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LinkedHashMapLruCache;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LinkedHashMapSoftReferencesLruCache;</span><br><span class="line"><span class="keyword">import</span> org.woodwhales.guava.lru.LruCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.5 00:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用软引用对缓存进行增强测试</span></span><br><span class="line"><span class="comment"> * 测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMapSoftReferencesLruCacheTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        testSoftReferencesCache();</span><br><span class="line">        <span class="comment">//testStrongReferenceCache();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当使用了带软引用的缓存的时候，相比强引用缓存，在不频繁写入缓存情况下，很难出现OOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSoftReferencesCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        LruCache&lt;String, <span class="type">byte</span>[]&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMapSoftReferencesLruCache</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) {</span><br><span class="line">            cache.put(String.valueOf(i), <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>]);</span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i + <span class="string">" was cached"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置了最大堆内存是 128M</span></span><br><span class="line"><span class="comment">     * 每次创建对象并缓存，则增加 2M 内存，因此在大约缓存第60次的时候，就会出现OOM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStrongReferenceCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        LruCache&lt;String, <span class="type">byte</span>[]&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMapLruCache</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) {</span><br><span class="line">            cache.put(String.valueOf(i), <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>]);</span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i + <span class="string">" was cached"</span>);</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述单元测试中，由于设置了堆内存最大上限，因此在使用强引用的缓存时，堆内存会被缓存不断地占满，最终导致堆内存全部被占满，即每 500 毫秒创建 2MB 的内存在堆中，堆的最大容量是 128 MB，因此当循环到达 60 次左右的会出现 OOM。而软引用缓存中，当堆内存不够的时候，创建新的对象到堆的频率不够快，GC 来得及回收掉部分软引用对象，那么循环会一直进行下去，不会出现 OOM。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LRU算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的四种引用</title>
    <url>/2020/07/05/071/</url>
    <content><![CDATA[<p>在Java中除了基础的数据类型以外，其它的都为引用类型。从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序更加灵活的控制对象的生命周期。这四种级别由高到低依次为：<strong>强引用、软引用、弱引用和虚引用</strong>。 （虚引用又称为幻影引用）</p>
<blockquote>
<p>一般情况下平时开发中基本上只用到强引用类型，而其他的引用类型较少用，但是它们依旧很重要，作为 Javaer 必须掌握清楚。</p>
</blockquote>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>我们平日里面的用到的new了一个对象就是强引用，例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></tbody></table></figure>

<p>上述Object这类对象就具有强引用，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。</p>
<p>值得注意的是：如果想中断或者回收强引用对象，可以显式地将引用赋值为<code>null</code>，这样的话 JVM 就会在合适的时间，进行垃圾回收。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试强引用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因为不断的创建 MyReference 对象，而这些对象是强引用，一直在被 list 维护着，</span></span><br><span class="line"><span class="comment"> * 所以在程序运行期间，就算发生垃圾回收，也不会将list维护的强引用对象回收，</span></span><br><span class="line"><span class="comment"> * 因此堆内存会不断被占用，直到内存溢出。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStrongReferences</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    List&lt;MyReference&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> index++;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">MyReference</span>(currentIndex));</span><br><span class="line">        System.out.println(<span class="string">"the index = "</span> + index + <span class="string">" MyReference inserted to list"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReference</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyReference</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java回收该类的一个对象时，就会调用这个已经被重写的finalize()方法。</span></span><br><span class="line"><span class="comment">     * 标记当前对象在下一次GC的时候会被垃圾回收，如果不想被回收，那么可以重写这个方法，拯救这个对象和 root 强关联。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        System.out.println(<span class="string">"index = [ "</span>+ index +<span class="string">"] will be GC"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>如果一个对象只具有软引用，那么它的性质属于可有可无的那种。如果此时内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>当内存不足时，软引用对象被回收时，reference.get()为null，此时软引用对象的作用已经发挥完毕，这时将其添加进<strong>ReferenceQueue 队列中</strong>。</p>
<p>如果要判断哪些软引用对象已经被清理：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">SoftReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((ref = (SoftReference) queue.poll()) != <span class="literal">null</span>) {</span><br><span class="line">    <span class="comment">//清除软引用对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当内存快要耗尽时，GC 会回收掉软引用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：由于内存占用太快，导致当内存快要耗尽时，GC还没来得及回收掉软引用时，也会出现OOM异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSoftReferences</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    List&lt;SoftReference&lt;MyReference&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> index++;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyReference</span>(currentIndex)));</span><br><span class="line">        System.out.println(<span class="string">"the index = "</span> + index + <span class="string">" MyReference inserted to list"</span>);</span><br><span class="line">        <span class="comment">//TimeUnit.MILLISECONDS.sleep(500);</span></span><br><span class="line">        <span class="comment">// 当设置吃内存的速度慢一点的时候，即软引用在GC时来得及回收，那么内存会一直有新的空间可以使用，OOM 的情况能得到缓解</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>如果一个对象具有弱引用，那其的性质也是可有可无的状态。</p>
<p>而弱引用和软引用的区别在于：弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间充足与否，都会回收它的内存。</p>
<p>同样的弱引用也可以和引用队列一起使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚引用测试</span></span><br><span class="line"><span class="comment"> * 测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 虚引用比软引用更脆弱，只要有GC时，虚引用就会被回收</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakReferences</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    List&lt;WeakReference&lt;MyReference&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> index++;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyReference</span>(currentIndex)));</span><br><span class="line">        System.out.println(<span class="string">"the index = "</span> + index + <span class="string">" MyReference inserted to list"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</p>
<p>注意：虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。</p>
<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幻影引用</span></span><br><span class="line"><span class="comment"> * 测试时，注意设置JVM参数：-Xms128m -Xmx128m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 幻影引用必须配合 ReferenceQueue 使用，</span></span><br><span class="line"><span class="comment"> * 因为使用 PhantomReference 对象本身是拿不到该具体实例，当这个幻影引用被回收时，就会放到 ReferenceQueue 队列中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最佳实践：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@See</span> org.apache.commons.io.FileCleaningTracker</span></span><br><span class="line"><span class="comment"> *      org.apache.commons.io.FileCleaningTracker.Tracker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPhantomReferences</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">MyReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyReference</span>(index);</span><br><span class="line">    <span class="type">ReferenceQueue</span> <span class="variable">referenceQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="type">MyPhantomReference</span> <span class="variable">phantomReferences</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyPhantomReference</span>(reference, referenceQueue, index);</span><br><span class="line"></span><br><span class="line">    reference = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待真正GC一下， 保证虚引用被回收</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// phantomReferences.get() 拿不到对象</span></span><br><span class="line">    System.out.println(phantomReferences.get());</span><br><span class="line">    <span class="comment">// 虚引用被回收会进入 ReferenceQueue 队列中</span></span><br><span class="line">    <span class="type">Reference</span> <span class="variable">object</span> <span class="operator">=</span> referenceQueue.remove();</span><br><span class="line">    ((MyPhantomReference)object).doAction();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyPhantomReference</span> <span class="keyword">extends</span> <span class="title class_">PhantomReference</span>&lt;Object&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyPhantomReference</span><span class="params">(Object referent, ReferenceQueue&lt;? <span class="built_in">super</span> Object&gt; queue, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="built_in">super</span>(referent, queue);</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAction</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"index = [ "</span>+ index +<span class="string">"] will be GC"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>对于强引用，平时在编写代码时会经常使用。</p>
</li>
<li><p>而其他三种类型的引用，使用得最多就是软引用和弱引用，这两种既有相似之处又有区别，他们都来描述非必须对象。</p>
</li>
<li><p>被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java引用</category>
      </categories>
      <tags>
        <tag>Java 的四种引用</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava EventBus 使用介绍及自实现详解</title>
    <url>/2020/07/06/072/</url>
    <content><![CDATA[<p>使用 guava 工具，先在 pom 中引入依赖：<a href="https://mvnrepository.com/artifact/com.google.guava/guava/">https://mvnrepository.com/artifact/com.google.guava/guava/</a></p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Guava-EventBus-的使用"><a href="#Guava-EventBus-的使用" class="headerlink" title="Guava EventBus 的使用"></a>Guava EventBus 的使用</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>先编写监听者：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoogleEventBusListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"GoogleEventBusListener.method1, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(Integer event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"GoogleEventBusListener.method2, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>再创建 EventBus 对象，将上述监听者注册到 EventBus 对象实例中，调用 post() 发送消息即可：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: EventBus 简单示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEventBusExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听器注册到 eventBus</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">GoogleEventBusListener</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        eventBus.post(<span class="string">"this message from eventBus"</span>);</span><br><span class="line">        eventBus.post(<span class="number">200</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>EventBus 构造函数中，如果不显示指定名称，则使用：default 作为默认名称。</p>
<p><strong>注意：消息类型必须是包装类型，不能是基本数据类型。</strong></p>
<h3 id="多个监听者存在继承关系"><a href="#多个监听者存在继承关系" class="headerlink" title="多个监听者存在继承关系"></a>多个监听者存在继承关系</h3><p>当只注册监听器中的父类中也监听了某些消息的时候，父类的监听方法也会执行。如果父类的监听方法被子类覆盖监听，则只执行子类监听器的方法。</p>
<p>类监听器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 父类监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FatherListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"FatherListener.accept, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(String event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"FatherListener.consume, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>子类监听器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildListener</span> <span class="keyword">extends</span> <span class="title class_">FatherListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ChildListener.accept, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeTask</span><span class="params">(String event)</span> {</span><br><span class="line">        System.out.println(<span class="string">"ChildListener.consumeTask, event = "</span> + event);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注册监听器并发送消息：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多个监听器监听消息</span></span><br><span class="line"><span class="comment"> * 当只注册监听器中的父类中也监听了某些消息的时候，父类的监听方法也会执行。</span></span><br><span class="line"><span class="comment"> * 如果父类的监听方法被子类覆盖监听，则只执行子类监听器的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleListenerExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">        <span class="comment">// 监听器注册到 eventBus</span></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">ChildListener</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        eventBus.post(<span class="string">"this message from eventBus"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ChildListener.accept, event = this message from eventBus</span><br><span class="line">ChildListener.consumeTask, event = this message from eventBus</span><br><span class="line">FatherListener.consume, event = this message from eventBus</span><br></pre></td></tr></tbody></table></figure>

<h3 id="多个事件存在继承关系"><a href="#多个事件存在继承关系" class="headerlink" title="多个事件存在继承关系"></a>多个事件存在继承关系</h3><p>event 如果有父类，此时某个监听器监听的event是这个基类，那么消息是这个子类的时候，该监听父类的监听器方法也会执行。</p>
<p>父类事件对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 父类事件对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitEvent</span> {</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FruitEvent</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FruitEvent</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>子类事件对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 子类事件对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleEvent</span> <span class="keyword">extends</span> <span class="title class_">FruitEvent</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppleEvent</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AppleEvent</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>监听器对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 一个监听子类对象，一个监听父类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptFruitEvent</span><span class="params">(FruitEvent fruitEvent)</span> {</span><br><span class="line">        System.out.println(<span class="string">"SimpleListener.acceptFruitEvent =&gt; fruitEvent "</span> + fruitEvent);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acceptAppleEvent</span><span class="params">(AppleEvent appleEvent)</span> {</span><br><span class="line">        System.out.println(<span class="string">"SimpleListener.acceptAppleEvent =&gt; appleEvent "</span> + appleEvent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: event 如果有父类，此时某个监听器监听的event是这个基类，</span></span><br><span class="line"><span class="comment"> * 那么消息是这个子类的时候，该监听父类的监听器方法也会执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleEventExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">SimpleListener</span>());</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">AppleEvent</span>(<span class="string">"apple"</span>));</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="keyword">new</span> <span class="title class_">FruitEvent</span>(<span class="string">"fruit"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">SimpleListener.acceptAppleEvent =&gt; appleEvent {"name":"apple"}</span><br><span class="line">SimpleListener.acceptFruitEvent =&gt; fruitEvent {"name":"apple"}</span><br><span class="line">SimpleListener.acceptFruitEvent =&gt; fruitEvent {"name":"fruit"}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>多个监听器同时监听相同消息，其中一个监听器有异常，那么不会影响其他监听器消费消息。可以在EventBus构造函数中传入一个异常处理器，当监听器有异常抛出时，会执行这个异常处理器。</p>
<blockquote>
<p>思考点：如果异常处理很长时间，会不会导致后面的监听器等待执行？</p>
</blockquote>
<p>异常处理器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Throwables;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.SubscriberExceptionContext;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.SubscriberExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubscriberExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">SubscriberExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleException</span><span class="params">(Throwable exception, SubscriberExceptionContext context)</span> {</span><br><span class="line">        System.out.println(<span class="string">"======== handleException start ========="</span>);</span><br><span class="line">        System.out.println(<span class="string">"exception =&gt; "</span> + Throwables.getStackTraceAsString(exception));</span><br><span class="line">        System.out.println(<span class="string">"EventBus =&gt; "</span> + context.getEventBus());</span><br><span class="line">        System.out.println(<span class="string">"Subscriber =&gt; "</span> + context.getSubscriber().getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"SubscriberMethod =&gt; "</span> + context.getSubscriberMethod());</span><br><span class="line">        System.out.println(<span class="string">"======== handleException end ========="</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>监听器对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(Integer sum)</span> {</span><br><span class="line">        System.out.println(<span class="string">"MyListener.method1 =&gt; "</span> + sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(Integer sum)</span> {</span><br><span class="line">        System.out.println(<span class="string">"MyListener.method2 =&gt; "</span> + sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(Integer sum)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sum / <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"MyListener.method3 =&gt; "</span> + sum);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 22:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 多个监听器同时监听相同消息，其中一个监听器有异常，那么不会影响其他监听器消费消息</span></span><br><span class="line"><span class="comment"> * 可以在EventBus构造函数中传入一个异常处理器，当监听器有异常抛出时，会执行这个异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思考点：如果异常处理很长时间，会不会导致后面的监听器等待执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionListenerExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(<span class="keyword">new</span> <span class="title class_">MySubscriberExceptionHandler</span>());</span><br><span class="line"></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">MyListener</span>());</span><br><span class="line"></span><br><span class="line">        eventBus.post(Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">MyListener.method2 =&gt; 2147483647</span><br><span class="line">MyListener.method1 =&gt; 2147483647</span><br><span class="line">======== handleException start =========</span><br><span class="line">exception =&gt; java.lang.ArithmeticException: / by zero</span><br><span class="line">	…… // 打印日志栈信息</span><br><span class="line"></span><br><span class="line">EventBus =&gt; EventBus{default}</span><br><span class="line">Subscriber =&gt; org.woodwhales.guava.eventbus.demo4.MyListener</span><br><span class="line">SubscriberMethod =&gt; public void org.woodwhales.guava.eventbus.demo4.MyListener.method3(java.lang.Integer)</span><br><span class="line">======== handleException end =========</span><br></pre></td></tr></tbody></table></figure>

<h3 id="DeadEvent-实现类型"><a href="#DeadEvent-实现类型" class="headerlink" title="DeadEvent 实现类型"></a>DeadEvent 实现类型</h3><p>监听器监听 DeadEvent 类型事件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.DeadEvent;</span><br><span class="line"><span class="keyword">import</span> com.google.common.eventbus.Subscribe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 23:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadEventListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(DeadEvent deadEvent)</span> {</span><br><span class="line">        System.out.println(<span class="string">"DeadEventListener.handle deadEvent =&gt; "</span> + deadEvent);</span><br><span class="line">        System.out.println(<span class="string">"DeadEventListener.handle event =&gt; "</span> + deadEvent.getEvent());</span><br><span class="line">        System.out.println(<span class="string">"DeadEventListener.handle source =&gt; "</span> + deadEvent.getSource());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>单元测试：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.eventbus.EventBus;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.2 23:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 监听DeadEvent消息类型，那么可以从这个DeadEvent对象中获取事件源和eventBus</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadEventExample</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">EventBus</span> <span class="variable">eventBus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventBus</span>(<span class="string">"DEAD-EVENT-BUS"</span>);</span><br><span class="line"></span><br><span class="line">        eventBus.register(<span class="keyword">new</span> <span class="title class_">DeadEventListener</span>());</span><br><span class="line"></span><br><span class="line">        eventBus.post(<span class="string">"message"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>日志输出：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">DeadEventListener.handle deadEvent =&gt; DeadEvent{source=EventBus{DEAD-EVENT-BUS}, event=message}</span><br><span class="line">DeadEventListener.handle event =&gt; message</span><br><span class="line">DeadEventListener.handle source =&gt; EventBus{DEAD-EVENT-BUS}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="自实现-EventBus"><a href="#自实现-EventBus" class="headerlink" title="自实现 EventBus"></a>自实现 EventBus</h2><h3 id="Bus-接口设计"><a href="#Bus-接口设计" class="headerlink" title="Bus 接口设计"></a>Bus 接口设计</h3><p>自己实现一个 EventBus 前需要先设计好需要多少功能，即多核心少接口：将监听者注册bus，将监听者从bus中移除，发送消息，发送带有主题的消息，获取当前 bus 名称等：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 13:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Bus 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyBus</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册到 bus</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber 订阅者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从bus中取消注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(Object subscriber)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event, String topic)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭bus</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前bus名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getBusName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Bus-接口实现"><a href="#Bus-接口实现" class="headerlink" title="Bus 接口实现"></a>Bus 接口实现</h3><p>实现 Bus 接口，重要的是怎么来保存注册到中的监听者，怎么在消息发布者调用 post() 发布消息的时候，根据消息的类型找到对应的要监听的方法并执行，如果有异常处理器，则执行异常处理器。</p>
<p>MyEventBus 实现 MyBus 接口，在其类中增加以下属性：MyEventBus 的构造函数仅仅是设置属性的入口，消息存储和消息消费，均由 MyRegistry 和 MyDispatcher 来执行。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventBus</span> <span class="keyword">implements</span> <span class="title class_">MyBus</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MyRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRegistry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String busName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_BUS_NAME</span> <span class="operator">=</span> <span class="string">"DEFAULT"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_TOPIC</span> <span class="operator">=</span> <span class="string">"default-topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyDispatcher dispatcher;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEventBus</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_BUS_NAME, <span class="literal">null</span>, MyDispatcher.SEQ_EXECUTOR_SERVICE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEventBus</span><span class="params">(MyEventExceptionHandler eventExceptionHandler)</span> {</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_BUS_NAME, eventExceptionHandler, MyDispatcher.SEQ_EXECUTOR_SERVICE);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEventBus</span><span class="params">(String busName, MyEventExceptionHandler eventExceptionHandler, Executor executor)</span> {</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(busName) || busName.isEmpty()) {</span><br><span class="line">            busName = DEFAULT_BUS_NAME;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">this</span>.busName = busName;</span><br><span class="line">        <span class="built_in">this</span>.dispatcher = MyDispatcher.newDispatcher(executor, eventExceptionHandler);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Object subscriber)</span> {</span><br><span class="line">        <span class="built_in">this</span>.registry.bind(subscriber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(Object subscriber)</span> {</span><br><span class="line">        <span class="built_in">this</span>.unRegister(subscriber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event)</span> {</span><br><span class="line">        <span class="built_in">this</span>.post(event, DEFAULT_TOPIC);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">(Object event, String topic)</span> {</span><br><span class="line">        <span class="built_in">this</span>.dispatcher.dispatch(<span class="built_in">this</span>, registry, event, topic);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.dispatcher.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBusName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.busName;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Dispatcher-实现"><a href="#Dispatcher-实现" class="headerlink" title="Dispatcher 实现"></a>Dispatcher 实现</h3><p>Dispatcher 用于执行消息消费，因此对于 Dispatcher，它需要直到要消费的消息信息及异常处理器：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 14:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 消息执行器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDispatcher</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyEventExceptionHandler eventExceptionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">SEQ_EXECUTOR_SERVICE</span> <span class="operator">=</span> SeqExecutorService.INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">PER_THREAD_EXECUTOR_SERVICE</span> <span class="operator">=</span> PerThreadExecutorService.INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyDispatcher</span><span class="params">(Executor executorService, MyEventExceptionHandler eventExceptionHandler)</span> {</span><br><span class="line">        <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">        <span class="built_in">this</span>.eventExceptionHandler = eventExceptionHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(MyBus bus, MyRegistry registry, Object event, String topic)</span> {</span><br><span class="line">        ConcurrentLinkedQueue&lt;MySubscriber&gt; subscribers = registry.scanSubscriber(topic);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(subscribers)) {</span><br><span class="line">            <span class="keyword">if</span>(Objects.nonNull(eventExceptionHandler)) {</span><br><span class="line">                eventExceptionHandler.handle(<span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">"The topic [%s] not bind yet"</span>, topic)),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DefaultMyContext</span>(bus.getBusName(), <span class="literal">null</span>, event));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的监听者，拿到对应的事件参数对象，比对消息的事件类型和监听者参数事件类型是否一致</span></span><br><span class="line">        subscribers.stream().filter(subscriber -&gt; !subscriber.isDisabled())</span><br><span class="line">                .filter(subscriber -&gt; {</span><br><span class="line">                    <span class="type">Method</span> <span class="variable">subscribeMethod</span> <span class="operator">=</span> subscriber.getSubscribeMethod();</span><br><span class="line">                    Class&lt;?&gt; parameterTypeClass = subscribeMethod.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">return</span> parameterTypeClass.isAssignableFrom(event.getClass());</span><br><span class="line">                })</span><br><span class="line">                .forEach(subscriber -&gt; invokeRealSubscribe(bus, subscriber, event));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeRealSubscribe</span><span class="params">(MyBus bus, MySubscriber subscriber, Object event)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">subscribeMethod</span> <span class="operator">=</span> subscriber.getSubscribeMethod();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">subscribeObject</span> <span class="operator">=</span> subscriber.getSubscribeObject();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.executorService.execute(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                subscribeMethod.invoke(subscribeObject, event);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(<span class="built_in">this</span>.eventExceptionHandler)) {</span><br><span class="line">                    <span class="built_in">this</span>.eventExceptionHandler.handle(e, <span class="keyword">new</span> <span class="title class_">DefaultMyContext</span>(bus.getBusName(), subscriber, event));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyDispatcher <span class="title function_">newDispatcher</span><span class="params">(Executor executorService, MyEventExceptionHandler eventExceptionHandler)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDispatcher</span>(executorService, eventExceptionHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyDispatcher <span class="title function_">newSeqDispatcher</span><span class="params">(MyEventExceptionHandler eventExceptionHandler)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDispatcher</span>(SEQ_EXECUTOR_SERVICE, eventExceptionHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyDispatcher <span class="title function_">newPerThreadDispatcher</span><span class="params">(MyEventExceptionHandler eventExceptionHandler)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDispatcher</span>(PER_THREAD_EXECUTOR_SERVICE, eventExceptionHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span>(executorService <span class="keyword">instanceof</span> ExecutorService) {</span><br><span class="line">            ((ExecutorService) executorService).shutdown();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SeqExecutorService</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SeqExecutorService</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqExecutorService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">            command.run();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PerThreadExecutorService</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PerThreadExecutorService</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerThreadExecutorService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> {</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(command).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultMyContext</span> <span class="keyword">implements</span> <span class="title class_">MyEventContext</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String busName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MySubscriber subscriber;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object event;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DefaultMyContext</span><span class="params">(String busName, MySubscriber subscriber, Object event)</span> {</span><br><span class="line">            <span class="built_in">this</span>.busName = busName;</span><br><span class="line">            <span class="built_in">this</span>.subscriber = subscriber;</span><br><span class="line">            <span class="built_in">this</span>.event = event;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getSource</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.busName;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getSubscriberObject</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> Objects.nonNull(subscriber) ? subscriber.getSubscribeObject() : <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Method <span class="title function_">getSubscribeMethod</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> Objects.nonNull(subscriber) ? subscriber.getSubscribeMethod() : <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getEvent</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.event;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="MyRegistry-实现"><a href="#MyRegistry-实现" class="headerlink" title="MyRegistry 实现"></a>MyRegistry 实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 14:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 已订阅bus的订阅者容器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRegistry</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ConcurrentLinkedQueue&lt;MySubscriber&gt;&gt; subscriberContainer = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt; ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object subscriber)</span> {</span><br><span class="line">        List&lt;Method&gt; subscriberMethods = getSubscriberMethods(subscriber);</span><br><span class="line">        subscriberMethods.forEach(method -&gt; tireSubscriber(subscriber, method));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tireSubscriber</span><span class="params">(Object subscriber, Method method)</span> {</span><br><span class="line">        <span class="type">MySubscribe</span> <span class="variable">mySubscribe</span> <span class="operator">=</span> method.getDeclaredAnnotation(MySubscribe.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> mySubscribe.topic();</span><br><span class="line">        subscriberContainer.computeIfAbsent(topic, key -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;());</span><br><span class="line">        subscriberContainer.get(topic).add(<span class="keyword">new</span> <span class="title class_">MySubscriber</span>(subscriber, method));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Method&gt; <span class="title function_">getSubscriberMethods</span><span class="params">(Object subscriber)</span> {</span><br><span class="line">        List&lt;Method&gt; methods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        <span class="keyword">while</span> (Objects.nonNull(subscriberClass)) {</span><br><span class="line">            Method[] declaredMethods = subscriberClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">            Arrays.stream(declaredMethods).filter(method -&gt;</span><br><span class="line">                method.isAnnotationPresent(MySubscribe.class) &amp;&amp;</span><br><span class="line">                        method.getParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                        method.getModifiers() == Modifier.PUBLIC</span><br><span class="line">            ).forEach(methods::add);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前 subscriber 的父类</span></span><br><span class="line">            subscriberClass = subscriberClass.getSuperclass();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methods;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unBind</span><span class="params">(Object subscriber)</span> {</span><br><span class="line">        subscriberContainer.forEach((key, queue) -&gt; {</span><br><span class="line">            queue.forEach(subscriberItem -&gt; {</span><br><span class="line">                <span class="keyword">if</span>(subscriberItem.getSubscribeObject() == subscriber) {</span><br><span class="line">                    subscriberItem.setDisabled(<span class="literal">false</span>);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据topic获取已经绑定的监听对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ConcurrentLinkedQueue&lt;MySubscriber&gt; <span class="title function_">scanSubscriber</span><span class="params">(<span class="keyword">final</span> String topic)</span> {</span><br><span class="line">        <span class="keyword">return</span> subscriberContainer.get(topic);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="EventExceptionHandler-异常处理器"><a href="#EventExceptionHandler-异常处理器" class="headerlink" title="EventExceptionHandler 异常处理器"></a>EventExceptionHandler 异常处理器</h3><p>当有异常发生时，用户可以自己实现异常处理器接口，当有异常发生时会回调该接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 14:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyEventExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 event 异常处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Throwable cause, MyEventContext eventContext)</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="消息上下文对象"><a href="#消息上下文对象" class="headerlink" title="消息上下文对象"></a>消息上下文对象</h3><p>异常产生，需要告知消费者，产生异常的相关上下文：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 14:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyEventContext</span> {</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getSource</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getSubscriberObject</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Method <span class="title function_">getSubscribeMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getEvent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Subscribe-监听器注解"><a href="#Subscribe-监听器注解" class="headerlink" title="Subscribe 监听器注解"></a>Subscribe 监听器注解</h3><p>监听器注解用于标记要监听并执行的方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 15:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义监听器订阅方法注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MySubscribe {</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">topic</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">"default-topic"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="监听者信息对象"><a href="#监听者信息对象" class="headerlink" title="监听者信息对象"></a>监听者信息对象</h3><p>为了便于管理监听者对象，需要对监听者的信息进行封装，并存储到 MyRegistry 的 ConcurrentHashMap&lt;&gt; 容器中：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@projectName</span>: guava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 20.7.4 15:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 监听者信息对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubscriber</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subscribeObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method subscribeMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">disabled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySubscriber</span><span class="params">(Object subscribeObject, Method subscribeMethod)</span> {</span><br><span class="line">        <span class="built_in">this</span>.subscribeObject = subscribeObject;</span><br><span class="line">        <span class="built_in">this</span>.subscribeMethod = subscribeMethod;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSubscribeObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> subscribeObject;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">getSubscribeMethod</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> subscribeMethod;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDisabled</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> disabled;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisabled</span><span class="params">(<span class="type">boolean</span> disabled)</span> {</span><br><span class="line">        <span class="built_in">this</span>.disabled = disabled;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自实现一个简单的 EventBus，要涉及到以下核心组件：</p>
<p><img src="https://image.woodwhales.cn/072/images/01.png"></p>
<h3 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h3><h4 id="MyBus"><a href="#MyBus" class="headerlink" title="MyBus"></a>MyBus</h4><p>通过构造器接收监听者（使用 @MySubscribe 注解了某些方法）和自定义异常处理器（自实现了 MyEventExceptionHandler 接口）</p>
<h4 id="MyEventExceptionHandler"><a href="#MyEventExceptionHandler" class="headerlink" title="MyEventExceptionHandler"></a>MyEventExceptionHandler</h4><p>用于消息过程出现异常时，处理异常</p>
<h4 id="MyEventContext"><a href="#MyEventContext" class="headerlink" title="MyEventContext"></a>MyEventContext</h4><p>异常处理过程中，将产生异常的数据封装起来</p>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h4 id="MyEventBus"><a href="#MyEventBus" class="headerlink" title="MyEventBus"></a>MyEventBus</h4><p>MyBus 接口的实现类，其内部维护了 MyDispatcher 和 MyRegistry。</p>
<h4 id="MyDispatcher"><a href="#MyDispatcher" class="headerlink" title="MyDispatcher"></a>MyDispatcher</h4><p>用于真正指定消费逻辑，内部维护了 MyEventExceptionHandler 实现（从 MyEventBus 构造器传入的）。</p>
<h4 id="MyRegistry"><a href="#MyRegistry" class="headerlink" title="MyRegistry"></a>MyRegistry</h4><p>用于对所有加了 @MySubscribe 注解的监听者信息进行管理，包括注册和注销。</p>
<h4 id="MySubscriber"><a href="#MySubscriber" class="headerlink" title="MySubscriber"></a>MySubscriber</h4><p>对注册的监听者信息进行封装，方便 MyRegistry 存储，也方便 MyDispatcher 消费执行。</p>
<h3 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h3><h4 id="MySubscribe"><a href="#MySubscribe" class="headerlink" title="MySubscribe"></a>MySubscribe</h4><p>提供要监听消息的方法注解标记。</p>
]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机安装 centos 7 系统</title>
    <url>/2020/07/28/073/</url>
    <content><![CDATA[<h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><p>centos官方地址：<a href="https://www.centos.org/">https://www.centos.org/</a></p>
<p>阿里云镜像：<a href="https://mirrors.aliyun.com/centos/">https://mirrors.aliyun.com/centos/</a></p>
<p>网易云镜像：<a href="http://mirrors.163.com/centos/">http://mirrors.163.com/centos/</a></p>
<p>笔者推荐：centos 7 版本</p>
<h2 id="vmware-网络配置"><a href="#vmware-网络配置" class="headerlink" title="vmware 网络配置"></a>vmware 网络配置</h2><h3 id="步骤1：打开虚拟网络编辑器"><a href="#步骤1：打开虚拟网络编辑器" class="headerlink" title="步骤1：打开虚拟网络编辑器"></a>步骤1：打开虚拟网络编辑器</h3><img src="https://image.woodwhales.cn/073/images/01.png" style="zoom:80%;">

<h3 id="步骤2：选择设置NAT模式"><a href="#步骤2：选择设置NAT模式" class="headerlink" title="步骤2：选择设置NAT模式"></a>步骤2：选择设置<code>NAT</code>模式</h3><img src="https://image.woodwhales.cn/073/images/02.png" style="zoom:80%;">

<p>点击<code>更改设置</code>进行网络设置。</p>
<p>笔者设置的配置为：</p>
<p>子网IP：192.168.100.0</p>
<p>子网掩码：255.255.255.0</p>
<p>网关IP：192.168.100.2</p>
<img src="https://image.woodwhales.cn/073/images/03.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/04.png" style="zoom:80%;">

<h3 id="步骤3：设置-VMnet8-网卡网络配置"><a href="#步骤3：设置-VMnet8-网卡网络配置" class="headerlink" title="步骤3：设置 VMnet8 网卡网络配置"></a>步骤3：设置 VMnet8 网卡网络配置</h3><img src="https://image.woodwhales.cn/073/images/05.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/06.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/07.png" style="zoom:80%;">

<p>笔者设置了阿里云的 DNS 中的 223.6.6.6 或者 223.5.5.5。</p>
<h2 id="虚拟机网络设置"><a href="#虚拟机网络设置" class="headerlink" title="虚拟机网络设置"></a>虚拟机网络设置</h2><p>安装 centos 之后，设置虚拟机的网络</p>
<img src="https://image.woodwhales.cn/073/images/34.png" style="zoom:80%;">

<h2 id="安装-centos"><a href="#安装-centos" class="headerlink" title="安装 centos"></a>安装 centos</h2><h3 id="虚拟机配置"><a href="#虚拟机配置" class="headerlink" title="虚拟机配置"></a>虚拟机配置</h3><img src="https://image.woodwhales.cn/073/images/08.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/09.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/10.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/11.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/12.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/13.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/14.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/15.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/16.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/17.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/18.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/19.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/20.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/21.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/22.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/23.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/24.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/25.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/26.png" style="zoom:80%;">

<h3 id="设置centos网络"><a href="#设置centos网络" class="headerlink" title="设置centos网络"></a>设置centos网络</h3><img src="https://image.woodwhales.cn/073/images/27.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/28.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/29.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/30.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/31.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/32.png" style="zoom:80%;">

<img src="https://image.woodwhales.cn/073/images/33.png" style="zoom:80%;">

<h2 id="设置阿里云镜像"><a href="#设置阿里云镜像" class="headerlink" title="设置阿里云镜像"></a>设置阿里云镜像</h2><p>阿里云镜像地址：<a href="https://developer.aliyun.com/mirror/centos">https://developer.aliyun.com/mirror/centos</a></p>
<p>最小安装版的 centos 系统没有任何常用工具，如 ifconfig、wget 等。</p>
<h3 id="使用-yum-安装："><a href="#使用-yum-安装：" class="headerlink" title="使用 yum 安装："></a>使用 yum 安装：</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y net-tools</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></tbody></table></figure>

<h3 id="步骤1：备份"><a href="#步骤1：备份" class="headerlink" title="步骤1：备份"></a>步骤1：备份</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></tbody></table></figure>

<h3 id="步骤2：替换镜像配置"><a href="#步骤2：替换镜像配置" class="headerlink" title="步骤2：替换镜像配置"></a>步骤2：替换镜像配置</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></tbody></table></figure>

<h3 id="步骤3：生成缓存"><a href="#步骤3：生成缓存" class="headerlink" title="步骤3：生成缓存"></a>步骤3：生成缓存</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></tbody></table></figure>

<h3 id="步骤4：其他"><a href="#步骤4：其他" class="headerlink" title="步骤4：其他"></a>步骤4：其他</h3><p>非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></tbody></table></figure>



]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 环境安装 confluence 详解</title>
    <url>/2020/08/02/074/</url>
    <content><![CDATA[<blockquote>
<p>confluence 官方安装指南：<a href="https://confluence.atlassian.com/alldoc/confluence-documentation-directory-12877996.html">https://confluence.atlassian.com/alldoc/confluence-documentation-directory-12877996.html</a></p>
<p>confluence 官方安装环境要求指南：<a href="https://confluence.atlassian.com/doc/system-requirements-126517514.html">https://confluence.atlassian.com/doc/system-requirements-126517514.html</a></p>
</blockquote>
<p>笔者安装的 confluence 版本为 6.13.3：<a href="https://bitbucket.org/atlassian/confluence_docs/downloads/Confluence_6-13-0_CompleteGuide.pdf">https://bitbucket.org/atlassian/confluence_docs/downloads/Confluence_6-13-0_CompleteGuide.pdf</a></p>
<blockquote>
<p>安装建议：笔者使用的centos为 VMware 虚拟机环境搭建的，设置内存大小为 2G，依然运行有“卡顿”现象，如果可用内存小于 2GB，不建议安装使用 confluence。</p>
</blockquote>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="MySQL-软件"><a href="#MySQL-软件" class="headerlink" title="MySQL 软件"></a>MySQL 软件</h2><p>笔者使用的 MySQL 版本为：5.7.31，使用 docker 安装：</p>
<blockquote>
<p>MySQL 官方 docker 镜像地址：<a href="https://hub.docker.com/_/mysql?tab=tags">https://hub.docker.com/_/mysql?tab=tags</a></p>
</blockquote>
<p>拉取 MySQL 5.7.13 镜像：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull mysql:5.7.31</span><br></pre></td></tr></tbody></table></figure>

<h2 id="MySQL-驱动"><a href="#MySQL-驱动" class="headerlink" title="MySQL 驱动"></a>MySQL 驱动</h2><blockquote>
<p>官方 MySQL 驱动：<a href="https://downloads.mysql.com/archives/c-j/">https://downloads.mysql.com/archives/c-j/</a></p>
<p>maven 仓库里下载 MySQL 驱动 ：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">https://mvnrepository.com/artifact/mysql/mysql-connector-java</a></p>
</blockquote>
<p>笔者使用的驱动版本为：mysql-connector-java-5.1.48.jar</p>
<p>因为官网文档已经说明了：<a href="https://confluence.atlassian.com/conf613/database-jdbc-drivers-964961299.html">https://confluence.atlassian.com/conf613/database-jdbc-drivers-964961299.html</a></p>
<p><img src="https://image.woodwhales.cn/074/images/01.png"></p>
<h3 id="代理包"><a href="#代理包" class="headerlink" title="代理包"></a>代理包</h3><p>笔者使用的代理包为：atlassian-agent.jar</p>
<blockquote>
<p>代理包官方下载地址：</p>
<p><a href="https://gitee.com/pengzhile/atlassian-agent">https://gitee.com/pengzhile/atlassian-agent</a></p>
<p><a href="https://zhile.io/2018/12/20/atlassian-license-crack.html">https://zhile.io/2018/12/20/atlassian-license-crack.html</a></p>
</blockquote>
<h2 id="下载-confluence-软件"><a href="#下载-confluence-软件" class="headerlink" title="下载 confluence 软件"></a>下载 confluence 软件</h2><blockquote>
<p>官方下载地址：<a href="https://www.atlassian.com/software/confluence/download-archives">https://www.atlassian.com/software/confluence/download-archives</a></p>
</blockquote>
<p>笔者使用的 confluence 版本为：atlassian-confluence-6.13.3-x64</p>
<p>也是直接在浏览器访问：<a href="https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-%7Bversion%7D.bin">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-{version}.bin</a> 下载 confluence 安装文件。</p>
<p>形如：<a href="https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-6.13.3-x64.bin">https://product-downloads.atlassian.com/software/confluence/downloads/atlassian-confluence-6.13.3-x64.bin</a></p>
<h2 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h2><p>上述拉取 MySQL 镜像之后，查看本地 docker 镜像：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/074/images/02.png"></p>
<h3 id="创建临时-MySQL-容器"><a href="#创建临时-MySQL-容器" class="headerlink" title="创建临时 MySQL 容器"></a>创建临时 MySQL 容器</h3><p>先创建临时 MySQL 容器</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run --rm --name mysqlTemp -it -v /usr/local/mysql/:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456 {IMAGE ID} /bin/bash </span><br></pre></td></tr></tbody></table></figure>

<p>上述命令中：{IMAGE ID} 替换成上图中的 IMAGE ID。</p>
<p>上述命令参数说明：</p>
<ul>
<li><p><code>-- rm</code></p>
<p>退出后就删除该容器</p>
</li>
<li><p><code>-v /usr/local/mysql/:/var/lib/ mysql</code> </p>
<p>装主机目录/usr/local/mysql/映射Docker中的/var/lib/mysql目录</p>
</li>
<li><p><code>-it</code> </p>
<p>交互模式</p>
</li>
<li><p><code>/bin/bash</code> </p>
<p>进入 bash 命令模式</p>
</li>
</ul>
<p>上述命令执行成功之后，就进入了 docker 容器内部。查看 my.cnf 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/mysql/my.cnf</span><br></pre></td></tr></tbody></table></figure>

<p>出现形如下图的内容：</p>
<p><img src="https://image.woodwhales.cn/074/images/03.png"></p>
<p>如果是完整的 my.cnf 文件，直接把该 my.cnf 复制到 docker 容器外面去。如果不是，则需要把 includedir 目录一起复到主机。</p>
<h3 id="从容器中获取-MySQL-配置文件到宿主机"><a href="#从容器中获取-MySQL-配置文件到宿主机" class="headerlink" title="从容器中获取 MySQL 配置文件到宿主机"></a>从容器中获取 MySQL 配置文件到宿主机</h3><p>把 docker 中的 /etc/mysql/my.cnf 文件拷贝到 docker 的/var/lib/mysql 目录中：及主机的 /usr/local/mysql/ 目录中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /etc/mysql/my.cnf /var/lib/mysql</span><br></pre></td></tr></tbody></table></figure>

<p>把 docker 中 includedir 目录复制出去</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp -R /etc/mysql/conf.d/ /var/lib/mysql/conf.d</span><br></pre></td></tr></tbody></table></figure>

<p>退出 bash，docker 中临时用的 mysqlTemp 会被删除。此时查看主机中的 /usr/local/mysql/ 目录下有 mysql 所有的配置文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@node04 ~]# ls /usr/local/mysql/</span><br><span class="line">conf.d  my.cnf</span><br></pre></td></tr></tbody></table></figure>

<h3 id="修改宿主机-MySQL-配置"><a href="#修改宿主机-MySQL-配置" class="headerlink" title="修改宿主机 MySQL 配置"></a>修改宿主机 MySQL 配置</h3><p>修改 MySQL 配置，在 my.cnf 文件中增加配置：</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">collation-server</span>=utf8_bin</span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="attr">max_allowed_packet</span>=<span class="number">512</span>M</span><br><span class="line"><span class="attr">innodb_log_file_size</span>=<span class="number">2</span>GB</span><br><span class="line"><span class="attr">transaction-isolation</span>=READ-COMMITTED</span><br><span class="line"><span class="attr">binlog_format</span>=row</span><br></pre></td></tr></tbody></table></figure>

<h3 id="创建-MySQL-容器"><a href="#创建-MySQL-容器" class="headerlink" title="创建 MySQL 容器"></a>创建 MySQL 容器</h3><p>改完之后，创建正式的 mysql 容器：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf -v /usr/local/mysql/conf.d:/etc/mysql/conf.d --restart=always -d {IMAGE ID}</span><br></pre></td></tr></tbody></table></figure>

<p>{IMAGE ID} 表示 MySQL 镜像的镜像 ID。</p>
<p>如果 my.cnf 是完整的配置，这里不需要映射 conf.d 和 mysql.conf.d 这俩个目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql/my.cnf:/etc/mysql/my.cnf -d {IMAGE ID}</span><br></pre></td></tr></tbody></table></figure>

<p>参数说明：</p>
<ul>
<li><p><code>--name</code></p>
<p>  容器名称</p>
</li>
<li><p><code>-p</code></p>
<p>  端口映射</p>
</li>
<li><p><code>-v</code></p>
<p>  配置文件映射：将 宿主机上修改的自定义配置文件，映射到 容器中</p>
</li>
<li><p><code>-e</code></p>
<p>  MYSQL_ROOT_PASSWORD 设置root密码</p>
</li>
<li><p><code>-d</code></p>
<p>  守护进程模式运行</p>
</li>
</ul>
<h1 id="安装-confluence"><a href="#安装-confluence" class="headerlink" title="安装 confluence"></a>安装 confluence</h1><p>将下载好的 confluence 安装包、MySQL 驱动、代理包都上传到 centos 上，笔者自己创建了 /data/confluence 目录：</p>
<p><img src="https://image.woodwhales.cn/074/images/04.png"></p>
<p>上图中：atlassian-agent-v1.2.3.tar.gz 文件使用：tar -zxvf atlassian-agent-v1.2.3.tar.gz 命令解压即可的得到：atlassian-agent-v1.2.3 文件目录。</p>
<h2 id="添加运行权限"><a href="#添加运行权限" class="headerlink" title="添加运行权限"></a>添加运行权限</h2><p>刚上传的 confluence 安装包需要添加运行权限：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod +x atlassian-confluence-6.13.3-x64.bin</span><br></pre></td></tr></tbody></table></figure>

<p>运行文件得到下面的内容，需要注意的是Confluence的安装路径，<br>默认程序：/opt/atlassian/confluence<br>默认数据：/var/atlassian/application-data/confluence</p>
<h2 id="安装-confluence-1"><a href="#安装-confluence-1" class="headerlink" title="安装 confluence"></a>安装 confluence</h2><p>运行 atlassian-confluence-6.13.3-x64.bin：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./atlassian-confluence-6.13.3-x64.bin</span><br></pre></td></tr></tbody></table></figure>

<p>运行日志如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@node04 confluence]# ./atlassian-confluence-6.13.3-x64.bin </span><br><span class="line">Unpacking JRE ...</span><br><span class="line">Starting Installer ...</span><br><span class="line"></span><br><span class="line">This will install Confluence 6.13.3 on your computer.</span><br><span class="line">OK [o, Enter], Cancel [c]</span><br><span class="line">o</span><br><span class="line">Click Next to continue, or Cancel to exit Setup.</span><br><span class="line"></span><br><span class="line">Choose the appropriate installation or upgrade option.</span><br><span class="line">Please choose one of the following:</span><br><span class="line">Express Install (uses default settings) [1], </span><br><span class="line">Custom Install (recommended for advanced users) [2, Enter], </span><br><span class="line">Upgrade an existing Confluence installation [3]</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">See where Confluence will be installed and the settings that will be used.</span><br><span class="line">Installation Directory: /opt/atlassian/confluence </span><br><span class="line">Home Directory: /var/atlassian/application-data/confluence </span><br><span class="line">HTTP Port: 8090 </span><br><span class="line">RMI Port: 8000 </span><br><span class="line">Install as service: Yes </span><br><span class="line">Install [i, Enter], Exit [e]</span><br><span class="line">i</span><br><span class="line"></span><br><span class="line">Extracting files ...</span><br><span class="line">                                                                           </span><br><span class="line"></span><br><span class="line">Please wait a few moments while we configure Confluence.</span><br><span class="line"></span><br><span class="line">Installation of Confluence 6.13.3 is complete</span><br><span class="line">Start Confluence now?</span><br><span class="line">Yes [y, Enter], No [n]</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Installation of Confluence 6.13.3 is complete</span><br><span class="line">Finishing installation ...</span><br></pre></td></tr></tbody></table></figure>

<p>安装完成之后：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -tunlp | grep 8090</span></span><br><span class="line">tcp6       0      0 :::8090                 :::*                    LISTEN      2573/java</span><br></pre></td></tr></tbody></table></figure>

<p>Confluence 日志文件位置：/opt/atlassian/confluence/logs/catalina.out</p>
<h2 id="启动-confluence"><a href="#启动-confluence" class="headerlink" title="启动 confluence"></a>启动 confluence</h2><h3 id="windows-环境"><a href="#windows-环境" class="headerlink" title="windows 环境"></a>windows 环境</h3><p>进入到服务管理的界面（我的电脑 -&gt; 右键 -&gt; 管理 -&gt; 服务或者services.msc）找到confluence 的服务，在这里启动关闭服务。</p>
<h3 id="linux-环境"><a href="#linux-环境" class="headerlink" title="linux 环境"></a>linux 环境</h3><h4 id="root-权限"><a href="#root-权限" class="headerlink" title="root 权限"></a>root 权限</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要管理员权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭服务</span></span><br><span class="line">service confluence stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务</span></span><br><span class="line">service confluence start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要管理员权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭服务</span></span><br><span class="line">/etc/init.d/confluence stop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务</span></span><br><span class="line">/etc/init.d/confluence start</span><br></pre></td></tr></tbody></table></figure>

<h4 id="非-root-权限"><a href="#非-root-权限" class="headerlink" title="非 root 权限"></a>非 root 权限</h4><p>如果不是 root 用户安装的话，confluence 这个服务可能不会被注册到 service 上，所以上面的方法都不能用。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">非root用户安装,以我的安装路径为例：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭服务</span></span><br><span class="line">/opt/atlassian/confluence/bin/stop-confluence.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务</span></span><br><span class="line">/opt/atlassian/confluence/bin/start-confluence.sh</span><br></pre></td></tr></tbody></table></figure>

<p>笔者安装的环境是 linux，启动日志如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@node04 confluence]# service confluence start</span><br><span class="line">Warning: confluence.service changed on disk. Run 'systemctl daemon-reload' to reload units.</span><br><span class="line"></span><br><span class="line">To run Confluence in the foreground, start the server with start-confluence.sh -fg</span><br><span class="line">executing using dedicated user: confluence</span><br><span class="line">If you encounter issues starting up Confluence, please see the Installation guide at http://confluence.atlassian.com/display/DOC/Confluence+Installation+Guide</span><br><span class="line"></span><br><span class="line">Server startup logs are located in /opt/atlassian/confluence/logs/catalina.out</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">Using Java: /opt/atlassian/confluence/jre//bin/java</span><br><span class="line">2020-08-01 15:23:57,626 INFO [main] [atlassian.confluence.bootstrap.SynchronyProxyWatchdog] A Context element for ${confluence.context.path}/synchrony-proxy is found in /opt/atlassian/confluence/conf/server.xml. No further action is required</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">Using CATALINA_BASE:   /opt/atlassian/confluence</span><br><span class="line">Using CATALINA_HOME:   /opt/atlassian/confluence</span><br><span class="line">Using CATALINA_TMPDIR: /opt/atlassian/confluence/temp</span><br><span class="line">Using JRE_HOME:        /opt/atlassian/confluence/jre/</span><br><span class="line">Using CLASSPATH:       /opt/atlassian/confluence/bin/bootstrap.jar:/opt/atlassian/confluence/bin/tomcat-juli.jar</span><br><span class="line">Using CATALINA_PID:    /opt/atlassian/confluence/work/catalina.pid</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></tbody></table></figure>

<p>上述日志可以看出，运行日志在：/opt/atlassian/confluence/logs/catalina.out 文件中。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在 /opt/atlassian/confluence/bin/setenv.sh 文件中增加如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /opt/atlassian/confluence/bin/setenv.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 <span class="built_in">export</span> CATALINA_OPTS 上方增加如下代码</span></span><br><span class="line">CATALINA_OPTS="-javaagent:/data/confluence/atlassian-agent.jar ${CATALINA_OPTS}"</span><br></pre></td></tr></tbody></table></figure>

<p>笔者的代理包路径是：/data/confluence/atlassian-agent.jar，读者可以更换成自己的代理包位置。</p>
<blockquote>
<p>本站下载：</p>
<ul>
<li>v1.2.3：<a href="https://image.woodwhales.cn/074/atlassian-agent-v1.2.3.tar.gz">atlassian-agent-v1.2.3.tar.gz</a></li>
<li>v1.3.1：<a href="https://image.woodwhales.cn/074/atlassian-agent-v1.3.1.7z">atlassian-agent-v1.3.1.7z</a></li>
</ul>
</blockquote>
<p>再次启动 confluence，查看启动日志，看到<code>=== agent working ===</code>字样，表示代理成功。也可以使用命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ps aux | grep javaagent</span><br></pre></td></tr></tbody></table></figure>

<p>检查代理是否成功。</p>
<h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>笔者使用的环境是虚拟机中的环境，因此直接把防火墙关闭了，如果需要开放某个具体的端口，参考下面的命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙状态</span></span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启防火墙：</span></span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙：</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙：</span></span><br><span class="line">systemctl restart firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动：</span></span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启开机启动：</span></span><br><span class="line">systemctl enable firewalld.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙所有开放的端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开放8090端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8090/tcp --permanent   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置立即生效</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看监听的端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</span></span><br><span class="line">netstat -lnpt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查端口被哪个进程占用</span></span><br><span class="line">netstat -lnpt |grep 8090</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看进程的详细信息</span></span><br><span class="line">ps 进程号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">中止进程</span></span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></tbody></table></figure>

<h3 id="激活设置"><a href="#激活设置" class="headerlink" title="激活设置"></a>激活设置</h3><p>启动 confluence 之后，浏览器输入 ip:8090 打开 confluence 的配置页面，第一次访问浏览器出现初始化配置页面，笔者选择中文环境，选择产品安装，出现如下界面：</p>
<p><img src="https://image.woodwhales.cn/074/images/05.png"></p>
<p>上图中的服务器 ID 很关键，一定要记录好。</p>
<p>当你试着执行 java -jar /data/confluence/atlassian-agent.jar 时应该可以看到输出的KeyGen参数帮助。由于此处是破解confluence,选择conf即可，具体命令如下：</p>
<p>将server ID复制（-m 邮箱 -n 用户名 -o 公司名 -s SERVER ID）</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar /data/confluence/atlassian-agent.jar -p conf -m woodwhales@163.com -n woodwhales -o https://woodwhales.cn/ -s AAAA-BBBB-CCCC-DDDD</span><br></pre></td></tr></tbody></table></figure>

<h3 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h3><p>选择 MySQL 数据库，需要安装 MySQL 驱动：</p>
<p>将下载的 mysql-connector-java-5.1.42-bin.jar 复制到 /opt/atlassian/confluence/confluence/WEB-INF/lib 目录并重启服务：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /data/confluence/mysql-connector-java-5.1.42.jar /opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br><span class="line">service confluence restart</span><br></pre></td></tr></tbody></table></figure>

<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="时区设置"><a href="#时区设置" class="headerlink" title="时区设置"></a>时区设置</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /opt/atlassian/confluence/bin/catalina.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Register custom URL handlers 处增加一行配置</span></span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Duser.timezone=Asia/Shanghai"</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置JVM运行内存参数"><a href="#设置JVM运行内存参数" class="headerlink" title="设置JVM运行内存参数"></a>设置JVM运行内存参数</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /opt/atlassian/confluence/bin/setenv.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 Xms 和 Xmx 参数</span></span><br><span class="line">CATALINA_OPTS="-Xms4096m -Xmx8192m -XX:+UseG1GC ${CATALINA_OPTS}"</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置数据库连接池参数"><a href="#设置数据库连接池参数" class="headerlink" title="设置数据库连接池参数"></a>设置数据库连接池参数</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /var/atlassian/application-data/confluence/confluence.cfg.xml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改数据库连接池参数</span></span><br><span class="line"> &lt;property name="hibernate.c3p0.acquire_increment"&gt;10&lt;/property&gt;         #默认为1</span><br><span class="line">    &lt;property name="hibernate.c3p0.idle_test_period"&gt;100&lt;/property&gt;</span><br><span class="line">    &lt;property name="hibernate.c3p0.max_size"&gt;60&lt;/property&gt;</span><br><span class="line">    &lt;property name="hibernate.c3p0.max_statements"&gt;60&lt;/property&gt;         #默认为0</span><br><span class="line">    &lt;property name="hibernate.c3p0.min_size"&gt;20&lt;/property&gt;</span><br><span class="line">    &lt;property name="hibernate.c3p0.timeout"&gt;120&lt;/property&gt;               #默认为30</span><br></pre></td></tr></tbody></table></figure>

<h2 id="数据链接-useSSL-配置"><a href="#数据链接-useSSL-配置" class="headerlink" title="数据链接 useSSL 配置"></a>数据链接 useSSL 配置</h2><p>由于使用了 MySQL 5.7.31，所以数据库链接配置必须显示设置 useSSL</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">&lt;property name="hibernate.connection.url"&gt;jdbc:mysql://127.0.0.1:3306/confluence?useSSL=false&lt;/property&gt;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="卸载-confluence"><a href="#卸载-confluence" class="headerlink" title="卸载 confluence"></a>卸载 confluence</h1><p>confluence 默认安装路径为 /opt/atlassian/confluence/：</p>
<p>到安装路径下，运行 uninstall：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">/opt/atlassian/confluence/uninstall</span><br></pre></td></tr></tbody></table></figure>

<p>然后手动删除两个路径的文件</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -rf /var/atlassian/</span><br><span class="line">rm -rf /opt/atlassian/confluence/</span><br></pre></td></tr></tbody></table></figure>

<p>另，进入 /etc/init.d/ 删除多余的 confluence 开机启动项</p>
<blockquote>
<p>windows上也是这么卸载的，但是在Windows上的话需要重启电脑。</p>
</blockquote>
<h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><p>官方插件市场：<a href="https://marketplace.atlassian.com/">https://marketplace.atlassian.com/</a></p>
<h2 id="Gliffy-Diagrams"><a href="#Gliffy-Diagrams" class="headerlink" title="Gliffy Diagrams"></a>Gliffy Diagrams</h2><p>官方安装指南：<a href="https://support.gliffy.com/hc/en-us/articles/217895178-Confluence-Plugin-Installation-Update-Instructions-">https://support.gliffy.com/hc/en-us/articles/217895178-Confluence-Plugin-Installation-Update-Instructions-</a></p>
<p>插件下载地址：<a href="https://marketplace.atlassian.com/plugins/com.gliffy.integration.confluence/versions">https://marketplace.atlassian.com/plugins/com.gliffy.integration.confluence/versions</a></p>
<h2 id="Balsamiq-Wireframes"><a href="#Balsamiq-Wireframes" class="headerlink" title="Balsamiq Wireframes"></a>Balsamiq Wireframes</h2><p>插件下载地址：<a href="https://marketplace.atlassian.com/apps/256/balsamiq-wireframes-confluence-server/version-history">https://marketplace.atlassian.com/apps/256/balsamiq-wireframes-confluence-server/version-history</a></p>
<h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><p>插件下载地址：<a href="https://marketplace.atlassian.com/apps/41025/plantuml-for-confluence/version-history">https://marketplace.atlassian.com/apps/41025/plantuml-for-confluence/version-history</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liangfu.wang/2020/01/22/CentOS-7-6-%E5%AE%89%E8%A3%85-Confluence-7-2/">https://liangfu.wang/2020/01/22/CentOS-7-6-安装-Confluence-7-2/</a></p>
<p><a href="https://www.tracymc.cn/archives/1507">https://www.tracymc.cn/archives/1507</a></p>
]]></content>
      <categories>
        <category>confluence</category>
      </categories>
      <tags>
        <tag>confluence</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 源码（spring-5.2.9.RELEASE）编译及 IDEA 环境搭建</title>
    <url>/2020/10/04/075/</url>
    <content><![CDATA[<h2 id="安装包及环境准备"><a href="#安装包及环境准备" class="headerlink" title="安装包及环境准备"></a>安装包及环境准备</h2><h3 id="下载-spring-framework-源码"><a href="#下载-spring-framework-源码" class="headerlink" title="下载 spring-framework 源码"></a>下载 spring-framework 源码</h3><p><a href="https://github.com/spring-projects/spring-framework">spring-framework</a> 源码仓库在 github 平台维护，读者可以自行搜索如何将 github 仓库源码克隆至 gitee 平台。</p>
<blockquote>
<p>笔者已经克隆一版，偷懒的读者可以直接拉取：<a href="https://gitee.com/woodwhales/spring-framework.git">https://gitee.com/woodwhales/spring-framework.git</a></p>
</blockquote>
<p><strong>警告！</strong>：spring-framework 源码存放的文件目录，一定不要含有特殊字符、汉字、空格等，以免编译失败。</p>
<p>使用 git 命令或者 source tree 工具等切换代码分支的 tag 为：5.2.9.RELEASE</p>
<p><img src="https://image.woodwhales.cn/075/images/01.png"></p>
<p>切换成功之后，在项目根目录中的<code>gradle.properties</code>文件中显示了 5.2.9 版本：</p>
<p><img src="https://image.woodwhales.cn/075/images/02.png"></p>
<h3 id="gradle-下载与安装"><a href="#gradle-下载与安装" class="headerlink" title="gradle 下载与安装"></a>gradle 下载与安装</h3><p>移步至笔者的博文：<a href="https://woodwhales.cn/2020/03/14/062/#gradle-%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">构建工具maven及gradle的安装及IDE配置</a></p>
<h2 id="gadle-编译配置"><a href="#gadle-编译配置" class="headerlink" title="gadle 编译配置"></a>gadle 编译配置</h2><h3 id="步骤一：build-gradle"><a href="#步骤一：build-gradle" class="headerlink" title="步骤一：build.gradle"></a>步骤一：build.gradle</h3><p>在项目根目中找到<code>build.gradle</code>文件，在大约 <strong>280</strong> 行处的 repositories 配置里增加：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line">maven { url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> }</span><br><span class="line">maven { url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span>}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/075/images/03.png"></p>
<h3 id="步骤二：settings-gradle"><a href="#步骤二：settings-gradle" class="headerlink" title="步骤二：settings.gradle"></a>步骤二：settings.gradle</h3><p>在项目根目中找到<code>settings.gradle</code>文件，在第 <strong>2</strong> 行处的 pluginManagement 配置里增加：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line">maven { url <span class="string">'https://maven.aliyun.com/repository/gradle-plugin'</span> }</span><br><span class="line">maven { url <span class="string">"https://maven.aliyun.com/repository/public"</span> }</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/075/images/04.png"></p>
<h3 id="步骤三：gradle-properties"><a href="#步骤三：gradle-properties" class="headerlink" title="步骤三：gradle.properties"></a>步骤三：gradle.properties</h3><p>修改<code>gradle.properties</code>文件，设置<code>org.gradle.jvmargs</code>参数值为：-Xmx2048M</p>
<figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">version</span>=<span class="string">5.2.9.RELEASE</span></span><br><span class="line"><span class="comment">## 设置此参数主要是编译下载包会占用大量的内存，可能会内存溢出</span></span><br><span class="line"><span class="attr">org.gradle.jvmargs</span>=<span class="string">-Xmx2048M</span></span><br><span class="line"><span class="comment">## 开启 Gradle 缓存</span></span><br><span class="line"><span class="attr">org.gradle.caching</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 开启并行编译</span></span><br><span class="line"><span class="attr">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 启用新的孵化模式</span></span><br><span class="line"><span class="attr">org.gradle.configureondemand</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 开启守护进程 通过开启守护进程，下一次构建的时候，将会连接这个守护进程进行构建，而不是重新fork一个gradle构建进程</span></span><br><span class="line"><span class="attr">org.gradle.daemon</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/075/images/05.png"></p>
<h2 id="IDEA-环境编译"><a href="#IDEA-环境编译" class="headerlink" title="IDEA 环境编译"></a>IDEA 环境编译</h2><p>在项目根目录下，右键选择：Git Bash Here，打开 Git Bash 窗口。</p>
<blockquote>
<p>笔者安装了 git 工具，读者也可打开 windows terminal 程序或者 cmd 程序，执行命令为：</p>
<p>gradlew :spring-oxm:compileTestJava</p>
</blockquote>
<p>执行如下命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></tbody></table></figure>

<p>命令，当出现如下字样时：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">Downloading https://services.gradle.org/distributions/gradle-<span class="number">6</span>.<span class="number">6</span>.<span class="number">1</span>-bin.zip</span><br><span class="line">..</span><br></pre></td></tr></tbody></table></figure>

<p>按 ctrl + c 停止该下载任务，将 gradle 包地址在浏览器中输入，浏览器会自动下载 gradle 包。</p>
<p>将下载好的 gradle 包放到：%GRADLE_USER_HOME%\wrapper\dists\gradle-6.6.1-bin\du4tvj86lhti6iga1v8h7pckb 文件夹目录下。在这个文件夹里有：上述下载任务时创建的，进入该目录下，将里面的未下载完成文件删除。</p>
<blockquote>
<p>GRADLE_USER_HOME 是在系统的环境变量里配置的，笔者配置的值就是maven本地仓库的根目录。</p>
</blockquote>
<p>再次执行<code>./gradlew :spring-oxm:compileTestJavaa</code>命令编译源码。</p>
<p><img src="https://image.woodwhales.cn/075/images/06.png"></p>
<p>编译成功之后，使用 IDEA 导入项目即可。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="文件目录问题"><a href="#文件目录问题" class="headerlink" title="文件目录问题"></a>文件目录问题</h3><p>如果读者按照上述步骤严格执行，一般不会出现编译失败问题。如果出现如下错误，很可能由于 spring 源码所在目录有问题。</p>
<p>笔者在两台电脑中执行了上述相同操作，一个成功，一个失败。让笔者郁闷很久，笔者一度怀疑编译失败的电脑操作系统出现了问题，特此重装了系统，结果还是编译失败。细细琢磨之后严重怀疑是源码存放目录的问题，果不其然，因此笔者在上述 “下载 spring-framework 源码” 章节里重点标注了警告提醒。</p>
<p><img src="https://image.woodwhales.cn/075/images/07.png"></p>
<h3 id="AnnotationCacheAspect-找不到符号"><a href="#AnnotationCacheAspect-找不到符号" class="headerlink" title="AnnotationCacheAspect 找不到符号"></a>AnnotationCacheAspect 找不到符号</h3><p><img src="https://image.woodwhales.cn/075/images/08.png"></p>
<p>这是因为 AnnotationCacheAspect.aj 不是java文件需要另外的aspectj进行处理，可以按照以下步骤解决这个问题</p>
<ul>
<li>下载aspectj，对应链接：<a href="https://www.eclipse.org/downloads/download.php?file=/tools/aspectj/aspectj-1.9.5.jar">https://www.eclipse.org/downloads/download.php?file=/tools/aspectj/aspectj-1.9.5.jar</a></li>
<li>安装aspectj</li>
</ul>
<p>执行 java -jar aspectj-1.9.5.jar 将 aspectj-1.9.5.jar 安装到本地某个目录。并在 IDEA 中安装 Aspectj weaver 插件。</p>
<p>详细参见：<a href="https://www.cnblogs.com/qubo520/p/13264036.html?utm_source=tuicool">https://www.cnblogs.com/qubo520/p/13264036.html?utm_source=tuicool</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/qubo520/p/13264036.html">https://www.cnblogs.com/qubo520/p/13264036.html</a></p>
<p><a href="https://www.cnblogs.com/liuyangfirst/p/13526619.html">https://www.cnblogs.com/liuyangfirst/p/13526619.html</a></p>
<p><a href="https://gitee.com/zhong96/spring-framework-analysis">https://gitee.com/zhong96/spring-framework-analysis</a></p>
<p><a href="https://gitee.com/zhong96/spring-framework-analysis/blob/master/docs/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md">https://gitee.com/zhong96/spring-framework-analysis/blob/master/docs/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md</a></p>
]]></content>
      <categories>
        <category>Spring 源码</category>
      </categories>
      <tags>
        <tag>Spring 源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio Code（vsCode） 下 C/C++ 环境搭建</title>
    <url>/2020/10/04/076/</url>
    <content><![CDATA[<blockquote>
<p>本文教程参考官方文档：<a href="https://code.visualstudio.com/docs/cpp/config-mingw">https://code.visualstudio.com/docs/cpp/config-mingw</a></p>
</blockquote>
<h2 id="安装-Visual-Studio-Code"><a href="#安装-Visual-Studio-Code" class="headerlink" title="安装 Visual Studio Code"></a>安装 Visual Studio Code</h2><p>Visual Studio Code 下载地址：<a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a></p>
<p>安装插件：<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++</a></p>
<img src="https://image.woodwhales.cn/076/images/01.png" style="zoom: 50%;">

<p>安装插件：<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a></p>
<img src="https://image.woodwhales.cn/076/images/17.png" style="zoom: 50%;">

<p>安装插件：<a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a></p>
<img src="https://image.woodwhales.cn/076/images/02.png" style="zoom:50%;">

<h2 id="安装-Mingw-w64"><a href="#安装-Mingw-w64" class="headerlink" title="安装 Mingw-w64"></a>安装 Mingw-w64</h2><p>MinGW-w64 下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p>
<p>可以下载在线安装器：MinGW-W64-install.exe，笔者下载的是完整版，省得在线安装缓慢。</p>
<img src="https://image.woodwhales.cn/076/images/03.png" style="zoom:67%;">

<p>下载好的安装包名为：x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z，使用 7-Zip 解压缩工具解压该安装包。进入解压后的文件目录，里面 mingw64 文件目录，将其剪切到指定的不含空格及中文目录下。</p>
<p>配置系统环境变量：<code>Mingw-w64</code></p>
<img src="https://image.woodwhales.cn/076/images/04.png" style="zoom:50%;">

<p>将创建好的环境变量配置到 Path 中：<code>%Mingw-w64%\bin</code></p>
<img src="https://image.woodwhales.cn/076/images/05.png" style="zoom:50%;">

<p>配置好 Mingw-w64 系统环境变量之后，打开 cmd 或者 windows terminal 终端窗口，执行如下命令可可以查看 gcc/g++ 编译器版本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者执行</span></span><br><span class="line">g++ -v</span><br></pre></td></tr></tbody></table></figure>

<p>出现版本信息则表示 Mingw-w64 安装成功：</p>
<img src="https://image.woodwhales.cn/076/images/06.png" style="zoom: 50%;">

<h2 id="Visual-Studio-Code-常用设置"><a href="#Visual-Studio-Code-常用设置" class="headerlink" title="Visual Studio Code 常用设置"></a>Visual Studio Code 常用设置</h2><h3 id="Visual-Studio-Code-设置自动保存"><a href="#Visual-Studio-Code-设置自动保存" class="headerlink" title="Visual Studio Code 设置自动保存"></a>Visual Studio Code 设置自动保存</h3><p>在设置中，找到文件，设置失去焦点自动保存：</p>
<p><img src="https://image.woodwhales.cn/076/images/07.png"></p>
<h3 id="Code-Runner-插件配置"><a href="#Code-Runner-插件配置" class="headerlink" title="Code Runner 插件配置"></a>Code Runner 插件配置</h3><p>防止运行 code runner 插件时，出现：vscode 中出现无法在只读编辑器中编辑问题，设置如下：</p>
<img src="https://image.woodwhales.cn/076/images/08.png" style="zoom:50%;">

<img src="https://image.woodwhales.cn/076/images/09.png" style="zoom:50%;">

<p>解决中文乱码问题：</p>
<p>步骤1：点击 vsCode 设置：</p>
<img src="https://image.woodwhales.cn/076/images/22.png" style="zoom:50%;">

<p>步骤2：搜索 code-runner 扩展设置，找到 <code>Executor Map</code>配置：</p>
<img src="https://image.woodwhales.cn/076/images/23.png" style="zoom:50%;">

<p>步骤3：在<code>code-runner.executorMap</code>配置项中对 C、C++ 添加<code>&amp;&amp; chcp 65001</code>参数：</p>
<img src="https://image.woodwhales.cn/076/images/24.png" style="zoom:50%;">

<h3 id="C-C-插件配置"><a href="#C-C-插件配置" class="headerlink" title="C/C++ 插件配置"></a>C/C++ 插件配置</h3><p>按下<code>Ctrl + Shift + P</code>键位，输入<code>c/c++</code>，选择：<code>C/C++:Edit Configurations(UI)</code></p>
<img src="https://image.woodwhales.cn/076/images/18.png" style="zoom:50%;">

<p>更改编译器路径和 IntelliSense 模式：</p>
<img src="https://image.woodwhales.cn/076/images/19.png" style="zoom:50%;">

<p>下滑设置 c、c++ 的标准：</p>
<img src="https://image.woodwhales.cn/076/images/20.png" style="zoom:50%;">

<p>设置完成后，我们可以看到，在<code>.vscode</code>文件夹下自动生成了<code>c_cpp_properties.json</code>文件：</p>
<img src="https://image.woodwhales.cn/076/images/21.png" style="zoom:50%;">



<h2 id="运行-C-文件"><a href="#运行-C-文件" class="headerlink" title="运行 C 文件"></a>运行 C 文件</h2><p>步骤1：使用 vsCode 创建一个 mian.c 文件：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"woodwhales.cn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<img src="https://image.woodwhales.cn/076/images/10.png" style="zoom: 50%;">

<p>步骤2：创建配置任务文件：在 “Terminal” 菜单中选择 “配置任务”</p>
<img src="https://image.woodwhales.cn/076/images/11.png" style="zoom: 50%;">

<p>点击 “C/C++”，vsCode 自动生成配置文件：</p>
<img src="https://image.woodwhales.cn/076/images/12.png" style="zoom:50%;">

<img src="https://image.woodwhales.cn/076/images/13.png" style="zoom: 50%;">

<p>步骤3：执行 C 文件：</p>
<ul>
<li>方式1：右击鼠标，选择 Run Code 进行程序执行</li>
</ul>
<img src="https://image.woodwhales.cn/076/images/14-1.png" style="zoom: 50%;">

<ul>
<li>方式2：</li>
</ul>
<p>也可以点击按钮执行：</p>
<img src="https://image.woodwhales.cn/076/images/14-2.png" style="zoom:50%;">

<p>程序执行成功可以在控制台看见输出结果：</p>
<img src="https://image.woodwhales.cn/076/images/14-3.png" style="zoom:50%;">

<p>步骤5：生成可执行文件：ctrl + shift + B</p>
<img src="https://image.woodwhales.cn/076/images/15.png" style="zoom:50%;">

<h2 id="Debug-配置"><a href="#Debug-配置" class="headerlink" title="Debug 配置"></a>Debug 配置</h2><p>在<code>Run</code>菜单项中选择<code>Add Configration</code>：</p>
<img src="https://image.woodwhales.cn/076/images/25.png" style="zoom:50%;">

<p>选择<code>C++(GDB/LLDB)</code>：</p>
<img src="https://image.woodwhales.cn/076/images/26.png" style="zoom:50%;">

<p>此时，会生成一个<code>launch.json</code>文件，但是它的内容是空的。</p>
<p>此时，再次重复上述操作，在<code>configurations</code>配置项中输入字母 C，在快捷选项中选择：<code>C/C++：(gdb)Launch</code>：</p>
<img src="https://image.woodwhales.cn/076/images/28.png" style="zoom:50%;">

<p>默认配置如下：</p>
<img src="https://image.woodwhales.cn/076/images/29.png" style="zoom:50%;">

<p>修改上述参数配置模板</p>
<ul>
<li><p>修改点1</p>
<ul>
<li>文件：launch.json</li>
<li>参数项：configurations.name</li>
<li>参数值：Debug</li>
<li>说明：配置名称</li>
</ul>
</li>
<li><p>修改点2</p>
<ul>
<li>文件：launch.json</li>
<li>参数项：configurations.program</li>
<li>参数值：${fileDirname}/${fileBasenameNoExtension}.exe</li>
<li>说明：可执行程序路径</li>
</ul>
</li>
<li><p>修改点3</p>
<ul>
<li>文件：launch.json</li>
<li>参数项：configurations.externalConsole</li>
<li>参数值：true</li>
<li>说明：true 表示从外部终端执行，false表示从 VsCode的集成终端执行，可随自己喜好配置</li>
</ul>
</li>
<li><p>修改点4</p>
<ul>
<li>文件：launch.json</li>
<li>参数项：configurations.miDebuggerPath</li>
<li>参数值：C:\programs\mingw64\bin\gdb.exe</li>
<li>说明：gdb.exe  文件路径</li>
</ul>
</li>
<li><p>修改点5</p>
<ul>
<li>文件：launch.json</li>
<li>参数项：configurations.preLaunchTask</li>
<li>参数值：task_g++</li>
<li>说明：这项在默认模板中没有，需要手动添加出来。调试会话开始前要运行的任务，指定任务名称，必须和修改点 6 保持一致</li>
</ul>
</li>
<li><p>修改点6</p>
<ul>
<li>文件：tasks.json</li>
<li>参数项：tasks.label</li>
<li>参数值：task_g++</li>
<li>说明：和修改点5的参数值保持一致</li>
</ul>
</li>
</ul>
<p>上述配置修改点如图：</p>
<img src="https://image.woodwhales.cn/076/images/30.png" style="zoom:50%;">

<p>创建测试文件 test.c ：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>, b=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c=a+b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>先对需要 debug 的地方打上断点，再按键 F5 或者点击 Debug 图标对程序进行 debug 调试：</p>
<img src="https://image.woodwhales.cn/076/images/31.png" style="zoom:50%;">

<img src="https://image.woodwhales.cn/076/images/32.png" style="zoom:50%;">

<p>debug 调试页面如下：</p>
<img src="https://image.woodwhales.cn/076/images/33.png" style="zoom:50%;">]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>vsCode C/C++ 环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>手写业务数据处理小工具</title>
    <url>/2020/11/17/077/</url>
    <content><![CDATA[<blockquote>
<p>本文源码可运行的 JDK 版本要求：JDK 1.8 +</p>
<p>本文源码参见：<a href="https://github.com/woodwhales/woodwhales-common">https://github.com/woodwhales/woodwhales-common</a></p>
</blockquote>
<p>一般在业务开发中，开发者会先通过 ORM 框架查询数据库数据得到数据的 List 集合，再该业务数据集合做如下处理：</p>
<h3 id="List-集合转-Map-集合"><a href="#List-集合转-Map-集合" class="headerlink" title="List 集合转 Map 集合"></a>List 集合转 Map 集合</h3><blockquote>
<p>按照 List 集合元素中某个属性将 List 集合转 Map 集合</p>
</blockquote>
<p>在 JDK 1.8 版本中可以使用 stream 快速将 list 转 map：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种 直接返回user本身</span></span><br><span class="line">Map&lt;Long, User&gt; map = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 Function中有一个static方法identity 返回本身</span></span><br><span class="line">Map&lt;Long, User&gt; map = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果list中的age存在相同的时候,转化map的时候就会出错Duplicate key</span></span><br><span class="line"><span class="comment">// toMap的重载,定义key2覆盖key1的值</span></span><br><span class="line">Map&lt;Integer, Users&gt; map3 = list.stream().collect(Collectors.toMap(Users::getId, Function.identity(), (key1,key2) -&gt; key2));</span><br></pre></td></tr></tbody></table></figure>

<p>笔者利用上述代码进行二次封装，简化了判空及转 map 时填写 .stream().collect… 等重复的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTool</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list 转 map 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 数据源集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMapper map 集合中的 key 获取规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> valueMapper map 集合中的 value 获取规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; map 集合中的 key 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;S&gt; 数据源集合中元素的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; map 集合中的 value 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, S, T&gt; Map&lt;K,T&gt; <span class="title function_">toMap</span><span class="params">(List&lt;S&gt; source,</span></span><br><span class="line"><span class="params">                                           Function&lt;? <span class="built_in">super</span> S, ? extends K&gt; keyMapper,</span></span><br><span class="line"><span class="params">                                           Function&lt;? <span class="built_in">super</span> S, ? extends T&gt; valueMapper)</span> {</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == source || source.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> source.stream().collect(Collectors.toMap(keyMapper, valueMapper));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码参见：<a href="https://github.com/woodwhales/woodwhales-common/blob/master/src/main/java/org/woodwhales/business/DataTool.java">src/main/java/org/woodwhales/business/DataTool.java</a></p>
<h3 id="List-集合分组"><a href="#List-集合分组" class="headerlink" title="List 集合分组"></a>List 集合分组</h3><blockquote>
<p>List 集合按照某种规则进行分组</p>
</blockquote>
<p>在 JDK 1.8 版本中可以使用 stream 快速将 list 分组：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;User&gt;&gt; group = list.stream().collect(Collectors.groupingBy(User::getType));</span><br></pre></td></tr></tbody></table></figure>

<p>笔者利用上述代码进行二次封装，简化了判空及转 map 时填写 .stream().collect… 等重复的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTool</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 list 集合分组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 数据源集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classifier 分组规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; map 集合中的 key 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;S&gt; map 集合中的 value 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, S&gt; Map&lt;K, List&lt;S&gt;&gt; <span class="title function_">groupingBy</span><span class="params">(List&lt;S&gt; source,</span></span><br><span class="line"><span class="params">                                                    Function&lt;? <span class="built_in">super</span> S, ? extends K&gt; classifier)</span> {</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == source || source.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> source.stream().collect(Collectors.groupingBy(classifier));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码参见：<a href="https://github.com/woodwhales/woodwhales-common/blob/master/src/main/java/org/woodwhales/business/DataTool.java">src/main/java/org/woodwhales/business/DataTool.java</a></p>
<h3 id="业务数据去重"><a href="#业务数据去重" class="headerlink" title="业务数据去重"></a>业务数据去重</h3><blockquote>
<p>List 集合按照指定属性去重（其中可能存在要去重的属性不存在，即“无效的”数据）。</p>
</blockquote>
<p>利用 Map 集合存入元素方法 put() 的特性：已存在则返回旧的元素，不存在则返回空。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTool</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对集合数据进行去重器</span></span><br><span class="line"><span class="comment">     * 非线程安全</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 数据源集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deduplicateInterface 去重器接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; 去重属性的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 数据源集合中元素的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, T&gt; DeduplicateResult&lt;T&gt; <span class="title function_">deduplicate</span><span class="params">(List&lt;T&gt; source,</span></span><br><span class="line"><span class="params">                                                          DeduplicateInterface&lt;K, T&gt; deduplicateInterface)</span> {</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == source || source.size() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeduplicateResult</span>&lt;T&gt;(source, emptyList(), emptyList(), emptyList());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;K, T&gt; container =  <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 无效的数据集合</span></span><br><span class="line">        List&lt;T&gt; invalidList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 重复的数据集合</span></span><br><span class="line">        List&lt;T&gt; repetitiveList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (T data : source) {</span><br><span class="line">            <span class="keyword">if</span> (!deduplicateInterface.isValid(data)) {</span><br><span class="line">                invalidList.add(data);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">K</span> <span class="variable">deduplicatedKey</span> <span class="operator">=</span> deduplicateInterface.getDeduplicatedKey(data);</span><br><span class="line">                <span class="type">T</span> <span class="variable">putData</span> <span class="operator">=</span> container.put(deduplicatedKey, data);</span><br><span class="line">                <span class="keyword">if</span>(Objects.nonNull(putData)) {</span><br><span class="line">                    repetitiveList.add(putData);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已去重的数据集合</span></span><br><span class="line">        List&lt;T&gt; deduplicatedList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(container.values());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeduplicateResult</span>&lt;T&gt;(source, invalidList, deduplicatedList, repetitiveList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码参见：<a href="https://github.com/woodwhales/woodwhales-common/blob/master/src/main/java/org/woodwhales/business/DataTool.java">src/main/java/org/woodwhales/business/DataTool.java</a></p>
<h3 id="枚举转-map-集合"><a href="#枚举转-map-集合" class="headerlink" title="枚举转 map 集合"></a>枚举转 map 集合</h3><blockquote>
<p>根据枚举中某个属性进行枚举转 map 集合。</p>
</blockquote>
<p>利用 EnumSet 类的 allOf() 方法，可以根据枚举的 Class 类型获取该枚举的所有枚举实例。当拿到集合枚举数据就可以使用 stream 进行集合转 map。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTool</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举转 map 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceEnumClass 数据源枚举 Class类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyMapper map 集合中的 key 获取规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; map 集合中的 key 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; map 集合中的 value 类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; Map&lt;K, T&gt; <span class="title function_">enumMap</span><span class="params">(Class&lt;T&gt; sourceEnumClass,</span></span><br><span class="line"><span class="params">                                                         Function&lt;? <span class="built_in">super</span> T, ? extends K&gt; keyMapper)</span> {</span><br><span class="line">        EnumSet&lt;T&gt; enumSet = EnumSet.allOf(sourceEnumClass);</span><br><span class="line">        <span class="keyword">return</span> enumSet.stream().collect(Collectors.toMap(keyMapper, Function.identity()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码参见：<a href="https://github.com/woodwhales/woodwhales-common/blob/master/src/main/java/org/woodwhales/business/DataTool.java">src/main/java/org/woodwhales/business/DataTool.java</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java小工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 工程常见开发技巧</title>
    <url>/2020/12/26/078/</url>
    <content><![CDATA[<h2 id="service-层参数-Valid-校验"><a href="#service-层参数-Valid-校验" class="headerlink" title="service 层参数 @Valid 校验"></a>service 层参数 @Valid 校验</h2><p>在 Spring Boot 工程中，一般开发中会 controller 层的接口参数的请求体对象属性中增加注解校验。在 service 层中，也可以对其进行 @Valid 注解校验：</p>
<p>在 service 接口实现类中增加 @Validated 注解，并在需要校验参数实体前增加 @Valid 注解即可。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Valid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-26 17:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TempServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TempService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> TempData tempData)</span> {</span><br><span class="line">        System.out.println(tempData);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参数实体对象</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> woodwhales</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-12-26 17:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TempData</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>controller 调用时，springboot 自动帮我们做了属性校验：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TempService tempService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping("/temp")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">temp</span><span class="params">()</span> {</span><br><span class="line">        tempService.save(<span class="keyword">new</span> <span class="title class_">TempData</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>







]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数定义、函数参数定义、函数相关变量知识点总结</title>
    <url>/2021/02/16/079/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[输入参数]</span>):</span><br><span class="line">    函数体</span><br><span class="line">    [<span class="keyword">return</span> xxx]</span><br></pre></td></tr></tbody></table></figure>

<p>上述<code>输入参数</code>表示的是形式参数，简称形参</p>
<p>调用函数的调用者传入的数值，称为实际参数，简称实参。实参的位置是函数的调用处。</p>
<h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><h4 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h4><p>根据形参对应的位置进行实参传递</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x='</span>, x, <span class="string">'y='</span>, y)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置实参</span></span><br><span class="line"><span class="built_in">print</span>(calc(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></tbody></table></figure>

<h4 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h4><p>根据形参名称进行实参传递</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x='</span>, x, <span class="string">'y='</span>, y)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字实参</span></span><br><span class="line"><span class="built_in">print</span>(calc(y=<span class="number">40</span>, x=<span class="number">30</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>函数的参数传递——可变实参与不可变实参</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    arg1 = <span class="number">10</span></span><br><span class="line">    arg2.append(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> arg1, arg2</span><br><span class="line"></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun(a, b))  <span class="comment"># 输出(10, [1, 2, 3, 4, 10])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出20</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[1, 2, 3, 4, 10]</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述代码中，fun() 函数中的形参 arg1 的作用域只在函数体内，fun() 函数中的形参 arg2 是数组的地址，因此操作数组地址对应的数组内容，则影响所有使用到该数组地址的地方。</p>
<p>使用图解描述上述的现象：</p>
<img src="https://image.woodwhales.cn/079/images/01.png" style="zoom:80%;">

<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ol>
<li><p>如果函数没有返回值，return 可以省略不写。如果调用者一定要接受没有返回值的函数，则返回<code>None</code>。</p>
</li>
<li><p>函数的返回值，如果是 1 个，直接返回类型。</p>
</li>
<li><p>函数的返回值，如果是多个，返回的数据类型为元组。</p>
</li>
</ol>
<p>无返回值，示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg1, arg2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment"># 没有返回值的函数，返回 None</span></span><br></pre></td></tr></tbody></table></figure>

<p>只有一个返回值，示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    list1 = [arg1, arg2]</span><br><span class="line">    <span class="keyword">return</span> list1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment"># 输出 [10, 20]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fun(<span class="number">10</span>, <span class="number">20</span>))) <span class="comment"># 输出 &lt;class 'list'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>多个返回值，示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="keyword">return</span> arg1, arg2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fun(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment"># 输出 (10, 20)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(fun(<span class="number">10</span>, <span class="number">20</span>))) <span class="comment"># 输出 &lt;class 'tuple'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n</span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(power(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment"># 输出 27</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, n=<span class="number">2</span></span>):</span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(power(<span class="number">3</span>))  <span class="comment"># 输出 9</span></span><br></pre></td></tr></tbody></table></figure>

<p>设置默认参数时，有几点要注意：</p>
<ul>
<li><p>必选参数在前，默认参数在后，否则Python的解释器会报错。</p>
</li>
<li><p>如何设置默认参数：当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</p>
</li>
</ul>
<h3 id="个数可变的位置参数"><a href="#个数可变的位置参数" class="headerlink" title="个数可变的位置参数"></a>个数可变的位置参数</h3><ul>
<li><p>定义函数时，可能无法事先确定传递的位置实参的个数时，使用可变的位置参数</p>
</li>
<li><p>使用<code>*</code>定义个数可变的位置形参</p>
</li>
<li><p>结果为一个元组</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># (1, 2, 3)</span></span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果想把 list 中每一个元素传入 fun() 函数中，则需要在 list 变量之前加<code>*</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(args))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">fun(*list1)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># (4, 5, 6, 7)</span></span><br><span class="line"><span class="comment"># &lt;class 'tuple'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="个数可变的关键字参数"><a href="#个数可变的关键字参数" class="headerlink" title="个数可变的关键字参数"></a>个数可变的关键字参数</h3><ul>
<li>定义函数时，可能无法事先确定传递的关键字实参的个数时，使用可变的关键字参数</li>
<li>使用<code>**</code>定义个数可变的关键字形参</li>
<li>结果为一个字典</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">**kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(kw)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(kw))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># {'a': 1, 'b': 2, 'c': 3}</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果想把 dict 中每一个元素传入 fun() 函数中，则需要在 dict 变量之前加<code>**</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">**kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(kw)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(kw))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dict1 = {<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">3</span>}</span><br><span class="line">fun(**dict1)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># {'a': 1, 'b': 2, 'c': 3}</span></span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">x, y, *, name, age</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x'</span>, x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'y'</span>, y)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'name='</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'age='</span>, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">fun(10, 20, 'woodwhales', 40)</span></span><br><span class="line"><span class="string">上述这种调用方式会报错，因为 fun() 函数的最后俩个参数指定了 name 和 age</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">fun(<span class="number">10</span>, <span class="number">20</span>, name=<span class="string">'woodwhales'</span>, age=<span class="number">20</span>)</span><br><span class="line">fun(<span class="number">10</span>, <span class="number">20</span>, age=<span class="number">20</span>, name=<span class="string">'woodwhales'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, args, city, job)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="多种参数的组合"><a href="#多种参数的组合" class="headerlink" title="多种参数的组合"></a>多种参数的组合</h3><p>在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<p>比如定义一个函数，包含上述若干种参数：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a, b, c=<span class="number">0</span>, *args, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="函数体外的变量"><a href="#函数体外的变量" class="headerlink" title="函数体外的变量"></a>函数体外的变量</h3><p>函数体之外的变量可以作用于函数体内外：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">name = <span class="string">'woodwhales.cn'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'name='</span>, name)</span><br><span class="line"></span><br><span class="line">fun() <span class="comment"># 输出 name= woodwhales.cn</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数体内的变量"><a href="#函数体内的变量" class="headerlink" title="函数体内的变量"></a>函数体内的变量</h3><p>函数体内的变量只作用于函数体内，称为局部变量。如果想让函数体内的变量能在函数体之外被使用到，则需要给局部变量前面加<code>global</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    name = <span class="string">'woodwhales'</span></span><br><span class="line"></span><br><span class="line">fun() <span class="comment"># 注意想使用全局变量时，需要调用一次函数</span></span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment"># 输出 woodwhales</span></span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python函数</tag>
      </tags>
  </entry>
  <entry>
    <title>centos 7 环境编译 openJDK 8 JVM 源码</title>
    <url>/2021/09/10/080/</url>
    <content><![CDATA[<h2 id="centos-7-环境编译-openJDK-8-JVM-源码"><a href="#centos-7-环境编译-openJDK-8-JVM-源码" class="headerlink" title="centos 7 环境编译 openJDK 8 JVM 源码"></a>centos 7 环境编译 openJDK 8 JVM 源码</h2><h3 id="centos-7-系统"><a href="#centos-7-系统" class="headerlink" title="centos 7 系统"></a>centos 7 系统</h3><p>官方镜像下载列表：<a href="https://www.centos.org/download/mirrors/">https://www.centos.org/download/mirrors/</a></p>
<p><img src="https://image.woodwhales.cn/080/images/01.png"></p>
<blockquote>
<p>笔者下载的是 CentOS-7-x86_64-DVD-2009.iso，下载地址：<a href="http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso">http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso</a></p>
<p>centos 7 安装至 VMware 教程可参见笔者的博文：<a href="https://woodwhales.cn/2020/07/28/073/">虚拟机安装 centos 7 系统</a></p>
</blockquote>
<h3 id="openJDK-8-源码包"><a href="#openJDK-8-源码包" class="headerlink" title="openJDK 8 源码包"></a>openJDK 8 源码包</h3><p>openJDK 源码全部使用 Mercurial 管理，网址为：<a href="https://hg.openjdk.java.net/">https://hg.openjdk.java.net/</a></p>
<p>选择 jdk8u</p>
<p><img src="https://image.woodwhales.cn/080/images/02.png"></p>
<p>部署文档：</p>
<p><img src="https://image.woodwhales.cn/080/images/03.png"></p>
<p>从上述图片中可以看到并没有源码，需要讲该项目下载下来，并执行 get_source.sh 文件。笔者尝试了多次，均不能成功下载源码。建议使用如下方式下载，访问：<a href="https://jdk.java.net/">https://jdk.java.net/</a></p>
<p><img src="https://image.woodwhales.cn/080/images/04.png"></p>
<p><img src="https://image.woodwhales.cn/080/images/05.png"></p>
<blockquote>
<p>笔者下载地址：<a href="https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-src-b04-14_jan_2020.zip">https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-src-b04-14_jan_2020.zip</a></p>
</blockquote>
<h3 id="JDK-1-7-安装包"><a href="#JDK-1-7-安装包" class="headerlink" title="JDK 1.7 安装包"></a>JDK 1.7 安装包</h3><p>官方要求编译 jdk8 源码需要使用到 jdk7，因此需要下载 jdk7：</p>
<p>官方地址：<a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html</a></p>
<p>镜像地址：<a href="https://mirrors.huaweicloud.com/java/jdk/">https://mirrors.huaweicloud.com/java/jdk/</a></p>
<p>笔者下载的版本为：<a href="https://mirrors.huaweicloud.com/java/jdk/7u80-b15/">https://mirrors.huaweicloud.com/java/jdk/7u80-b15/</a></p>
<p><img src="https://image.woodwhales.cn/080/images/06.png"></p>
<h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><p>将上述下载好的：openJDK 8 源码包（openjdk-8u41-src-b04-14_jan_2020.zip）和 JDK 1.7 安装包（jdk-7u80-linux-x64.tar.gz）上传至 centos 系统。</p>
<blockquote>
<p>笔者在系统根目录下创建了 <code>/data</code> 文件目录，上述俩个文件均上传至此目录，后续操作均在此目录下完成。</p>
<p>由于 centos 是最小安装，没有相关 unzip 解压工具，执行如下命令安装 unzip 工具：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y unzip</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>执行如下命令，将上述俩个压缩包进行解压：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf /data/jdk-7u80-linux-x64.tar.gz</span><br><span class="line">unzip /data/openjdk-8u41-src-b04-14_jan_2020.zip</span><br></pre></td></tr></tbody></table></figure>

<p>得到<code>/data/jdk1.7.0_80</code>文件目录和<code>/data/openjdk</code>文件目录：</p>
<p><img src="https://image.woodwhales.cn/080/images/08.png"></p>
<h3 id="安装依赖工具"><a href="#安装依赖工具" class="headerlink" title="安装依赖工具"></a>安装依赖工具</h3><p>使用 yum 包管理器安装下述相关工具：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 c 语言开发相关编译器及调试器</span></span><br><span class="line">yum install -y gcc</span><br><span class="line">yum install -y gcc-c++</span><br><span class="line">yum install -y gdb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装编译 JVM 相关依赖</span></span><br><span class="line">yum install -y cups</span><br><span class="line">yum install -y cups-devel</span><br><span class="line">yum groupinstall -y "Development Tools"</span><br><span class="line">yum install -y libXtst-devel libXt-devel libXrender-devel</span><br><span class="line">yum install -y freetype</span><br><span class="line">yum install -y freetype-devel</span><br><span class="line">yum install -y alsa-lib-devel</span><br><span class="line">yum install -y fontconfig-devel</span><br></pre></td></tr></tbody></table></figure>

<p>进入<code>/data/openjdk</code> 文件目录、设置 configure 为可执行文件，再执行预编译：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd /data/openjdk</span><br><span class="line"></span><br><span class="line">chmod +x ./configure</span><br><span class="line"></span><br><span class="line">./configure --with-boot-jdk=/data/jdk1.7.0_80/ --with-target-bits=64 --with-debug-level=release</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>参数含义：</p>
<p>–with-boot-jdk-jvmargs：指定 boot-jdk 目录</p>
<p>–with-target-bits：系统的位数：32 或者 64</p>
<p>–with-debug-level：可选择：release, fastdebug, or slowdebug</p>
</blockquote>
<p>上述命令执行成功，会提示如下信息：</p>
<p><img src="https://image.woodwhales.cn/080/images/09.png"></p>
<p>上述步骤完成之后，使用 make 工具编译 JVM：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make all</span><br></pre></td></tr></tbody></table></figure>

<p>编译预计半小时，其中出现警告不需要处理，直到出现如下信息表示编译成功：</p>
<p><img src="https://image.woodwhales.cn/080/images/10.png"></p>
<p>自己编译好的 JDK 就在<code>/data/openjdk/build/linux-x86_64-normal-server-release/jdk</code>目录下：</p>
<p><img src="https://image.woodwhales.cn/080/images/12.png"></p>
<p>查看 jdk 版本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">/data/openjdk/build/linux-x86_64-normal-server-release/jdk/bin/java -version</span><br></pre></td></tr></tbody></table></figure>

<p>从版本信息中可以看到自已编译的版本信息：</p>
<p><img src="https://image.woodwhales.cn/080/images/11.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM 源码</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析String#intern</title>
    <url>/2021/09/15/081/</url>
    <content><![CDATA[<h3 id="String-intern-方法简述"><a href="#String-intern-方法简述" class="headerlink" title="String#intern() 方法简述"></a>String#intern() 方法简述</h3><p>String#intern() 方法的官方注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">     * class {<span class="doctag">@code</span> String}.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this {<span class="doctag">@code</span> String} object as determined by</span></span><br><span class="line"><span class="comment">     * the {<span class="doctag">@link</span> #equals(Object)} method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this {<span class="doctag">@code</span> String} object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this {<span class="doctag">@code</span> String} object is returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It follows that for any two strings {<span class="doctag">@code</span> s} and {<span class="doctag">@code</span> t},</span></span><br><span class="line"><span class="comment">     * {<span class="doctag">@code</span> s.intern() == t.intern()} is {<span class="doctag">@code</span> true}</span></span><br><span class="line"><span class="comment">     * if and only if {<span class="doctag">@code</span> s.equals(t)} is {<span class="doctag">@code</span> true}.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">     * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">     *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>String#intern 是一个 native 方法，注释大意为：如果常量池中存在当前字符串，就会直接返回当前字符串对象引用。如果常量池中没有此字符串，会将此字符串放入常量池中后，再将其字符串对象引用返回。</p>
<h3 id="字符串常量池（String-pool-或-String-Literal-pool）"><a href="#字符串常量池（String-pool-或-String-Literal-pool）" class="headerlink" title="字符串常量池（String pool 或 String Literal pool）"></a>字符串常量池（String pool 或 String Literal pool）</h3><p>字符串常量池，或许叫全局字符串池更容易了解它的功能，这个池子里存储的内容是：类加载（验证，准备阶段）完成之后在堆中生成字符串对象实例的引用值，因此 String pool 中存的是引用值而不是具体的实例对象，具体的实例对象存放在堆中开辟的一块空间（具体来说是在运行时常量池中）。</p>
<p>在 HotSpot VM 里实现 String pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串的引用（也就是我们常说的用双引号括起来的字符串对象实例的引用，而不是驻留字符串实例本身），因此在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了“驻留字符串”的身份。</p>
<p><strong>这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</strong></p>
<blockquote>
<p>  字符串常量池由一个固定容量的 hashmap 实现，每个元素包含相同 hash 值的字符串列表。</p>
<p>  在早期的 java 6 中它是一个常量，从 Java 6u30 以后变成了可配置的，你需要通过<code>-XX:StringTableSize=N</code>来设置字符串常量池中 map 的大小。为了性能考虑请确保它是一个<strong>质数</strong>。</p>
<p>  在 Java 6 到 7u40 中 -XX:StringTableSize 参数的默认值是 1009。在 Java 7u40 以后默认值为 60013（java 8 仍然支持此参数设置以兼容 Java 7）。</p>
</blockquote>
<h3 id="Class-文件常量池-Class-constant-pool"><a href="#Class-文件常量池-Class-constant-pool" class="headerlink" title="Class 文件常量池( Class constant pool )"></a>Class 文件常量池( Class constant pool )</h3><p>程序员编写好的 Java 文件需要编译成 Class 文件，再由 JVM 加载运行，注意的是，每一个类都会生成对应的一个 Class 文件，Class 文件中的存储的信息格式十分严格，Class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池( Constant pool table )，用于存放编译器生成的各种字面量( Literal )和符号引用( Symbolic References )。</p>
<p>字面量就是我们所说的常量概念，如文本字符串、被声明为 final 的常量值等。</p>
<p>符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用不同：直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"木鲸鱼"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>反编译上述代码，执行<code>javap -verbose Test</code>，查看 Class 文件编译内容结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">13</span>         <span class="comment">// java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">14</span>            <span class="comment">// 木鲸鱼</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">15</span>            <span class="comment">// Test</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">6</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">7</span> = Utf8               Code</span><br><span class="line">   #<span class="number">8</span> = Utf8               LineNumberTable</span><br><span class="line">   #<span class="number">9</span> = Utf8               main</span><br><span class="line">  #<span class="number">10</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">11</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">12</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">13</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// "&lt;init&gt;":()V</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               木鲸鱼</span><br><span class="line">  #<span class="number">15</span> = Utf8               Test</span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/Object</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String 木鲸鱼</span></span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">3</span></span><br><span class="line">}</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></tbody></table></figure>

<p>当<code>Test.java</code>文件被编译之后，也就会生成了上述的 Class 文件内容，可以看到其中保存了<code>"木鲸鱼"</code>的字面量在 Class 文件常量池（Constant pool）中。</p>
<p>具体存储的方式是：<code>"木鲸鱼"</code>字面量会拆分成<code>CONSTANT_Utf8</code>和<code>CONSTANT_String</code>，前者是一个指针，指向一个<code>Symbol类型</code>的 C++ 对象，内容是跟 Class 文件同样格式的 UTF-8 编码的字符串，后者表示的是常量的类型，它持有一个<code>index</code>，这个<code>index</code>可以指向另一个常量池（运行时常量池）中类型为<code>CONSTANT_Utf8</code>的常量。</p>
<p><strong>重要概念说明：</strong></p>
<p>Class 文件常量池中不仅仅存储着字符串的字面量，它可以存储着 14 种常量类型的项目表，比如上面反编译结果中的<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_Class_info</code>、<code>CONSTANT_NameAndType_info</code>、<code>CONSTANT_String_info</code>、<code>CONSTANT_Utf8_info</code>都是常量类型表，分别存储着不同的信息，它们之间的关系如图：</p>
<p><img src="https://image.woodwhales.cn/081/images/01.png"></p>
<p>这里再多说一下和字符串字面量相关的两个常量类型表：</p>
<p>symbol 对象的符号引用，在未解析的时候状态为<code>CONSTANT_UnresolvedString</code>，解析成功之后将转变为<code>CONSTANT_internString</code></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">CONSTANT_String_info {  </span><br><span class="line">    u1 tag; <span class="comment">// 常量池项目类型标志，其中 CONSTANT_String_info 的 tag 为：8</span></span><br><span class="line">    u2 index; <span class="comment">// 指向字符串字面量的索引</span></span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p><code>CONSTANT_Utf8_info</code>字符串字面量属于 Class 常量池项目中的字符串项目类型</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info {  </span><br><span class="line">  u1 tag;  <span class="comment">// 常量池项目类型标志，其中 CONSTANT_Utf8_info 的 tag 为：1</span></span><br><span class="line">  u1 length; <span class="comment">// UTF-8编码的字符串长度（字节单位）</span></span><br><span class="line">  u2 bytes_length;  <span class="comment">// UTF-8编码的字符串长度（字节单位）</span></span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p>从上面反编译的结果可以看出：常量池中的第 4 项是<code>CONSTANT_String_info</code>类型的信息，指向了常量池中的第 14 项的项目内容，即类型为<code>CONSTANT_Utf8_info</code>的字面量内容。</p>
<h3 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h3><p>当 Java 文件被编译成 Class 文件之后，其文件中就会生成上面所说的 Class 文件常量池，那么这个 Class 文件常量池是用来干什么的呢？</p>
<p>JVM 在执行某个类的时候，必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段。当某个类加载到 JVM 内存之后，JVM 就会将这个类中的 Class 文件常量池中的内容存放到运行时常量池中。由此可知，运行时常量池也是每个类都有一个。</p>
<p>上个概念已经解释：Class 文件常量池中存的是字面量和符号引用，也就是说 Class 文件常量池存的并不是对象的实例，而是对象的符号引用值。当被加载完成字面量和符号引用经过解析（resolve）之后，也就是把符号引用替换为直接引用，Class 文件常量池中字面量内容才正式被 JVM 使用，解析完成之后就会去查询全局字符串池（上述 HotSpot VM 中的 StringTable），以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<p>讲到这里，不知道读者有没有意识到上述两个常量池的明显区别：Class 文件常量池是在编译之后就已经确定好了内容及内存大小，因此它是静态的常量池，而运行时常量池相对于 Class文件常量池 的另外一个重要特征是<strong>具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也允许新的常量放入池中，这种特性被开发人员利用比较多的就是 String 对象的 intern() 方法。</p>
<blockquote>
<p>  在 JDK 7 中，运行时常量池已经在 Java 堆上分配内存，执行 String#intern() 方法时，JVM 会检查当前常量池中是否存在调用 intern() 方法的 String 对象是否，如果常量池已经存在该字符串，则直接返回字符串引用，否则复制该字符串对象的引用到常量池中并返回，所以在 JDK 7 中，可以重新考虑使用intern方法，减少 String 对象所占的内存空间。</p>
</blockquote>
<h3 id="运行时常量池和-Class-文件常量池-及-全局常量池的关系"><a href="#运行时常量池和-Class-文件常量池-及-全局常量池的关系" class="headerlink" title="运行时常量池和 Class 文件常量池 及 全局常量池的关系"></a>运行时常量池和 Class 文件常量池 及 全局常量池的关系</h3><p>以下引用 1，引用 2 摘自：《请问，jvm实现读取class文件常量池信息是怎样呢？》<a href="http://hllvm.group.iteye.com/group/topic/26412">http://hllvm.group.iteye.com/group/topic/26412</a> ；引用 3 摘自：《运行时常量池与Class文件常量池的区别》<a href="http://hllvm.group.iteye.com/group/topic/40008">http://hllvm.group.iteye.com/group/topic/40008</a></p>
<blockquote>
<p>  各个类型的常量是混在一起放在常量池（运行时常量池）里的，跟 Class 文件里的基本上一样。</p>
<p>  最不同的是在这个运行时常量池里，symbol 是在类之间共享的；而在 Class 文件的常量池里每个 Class 文件都有自己的一份 symbol 内容，没共享。</p>
</blockquote>
<p>以上述表述中可以得知：Class 文件常量池中的字面量内容（symbol 内容），会在类加载完毕之后，就会进入该类的运行时常量池中，并且这份 symbol 内容是全局通用的。</p>
<blockquote>
<p>  这些 Utf8 常量在 HotSpot VM 里以 symbolOopDesc 对象（下面简称 symbol 对象）来表现；它们可以通过一个全局的 SymbolTable 对象找到。注意：constantPool 对象并不“包含”这些 symbol 对象，而只是引用着它们而已；或者说，constantPool 对象只存了对 symbol 对象的引用，而没有存它们的内容。</p>
</blockquote>
<p><em>@Rednaxelafx 提到的 SymbolTable 就是全局字符串常量池，因为 StringTable 里存储的就是 symbol 对象的引用，从 openjdk 源码中即可验证，openjdk 源码在文末附引用中。</em></p>
<p>以上述表述中可以得知：全局常量池中保存的是 symbol 对象实例的引用，一旦被保存进来，那么这个 symbol 引用维护的对象实例就有了“全局字符串常量的身份”。</p>
<blockquote>
<p>  Class 文件常量池只是 .class 文件中的、静态的；而运行时常量池，是在运行时将所有 Class 文件常量池中的东西加载进来？</p>
<p>  前半句对，后半句半对。运行时常量池是把 Class 文件常量池加载进来，每个类有一个独立的。刚开始运行时常量池里的链接都是符号链接，跟在 Class 文件里一样；边运行边就会把用到的常量转换成直接链接，例如说要 Class A 调用 Foo.bar() 方法，A.class 文件里就会有对该方法的 Methodref 常量，是个符号链接（只有名字没有实体），加载到运行时常量池也还是一样是符号链接，等真的要调用该方法的时候该常量就会被 resolve 为一个直接链接（直接指向要调用的方法的实体）。</p>
</blockquote>
<p>以上表述可以得知：Class 文件常量池中存储的是字面量内容，等到类加载完成之后就会将这些字面量标记未解析，存储在运行时常量池中，注意，此时类只是加载，并且加载后的内容不能直接使用，需要解析之后才能使用。因此只有在调用者要使用的时候才进行解析，变成可使用状态，并且是解析机制是调用多少就解析多少，不会用到的不会解析，因此运行时常量池是动态加载的。</p>
<h3 id="创建字符串对象"><a href="#创建字符串对象" class="headerlink" title="创建字符串对象"></a>创建字符串对象</h3><p>首先 String 不属于 8 种基本数据类型，String 是对象。对象的默认值是 null，所以 String 对象的默认值也是 null；但它又是一种特殊的对象，有其它对象没有的一些特性；</p>
<p>new String() 和 new String(“”) 都是申明一个新的空字符串，是空串不是 null；</p>
<p>创建 String 对象有两种创建方式：</p>
<p>第一种，直接使用双引号直接显示声明：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"木鲸鱼"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>JVM 编译 Test.java 文件之后，生成一个 Test.class 文件（反编译命令：<code>javap -verbose Test</code>），从反编译的内容中可以看出（这里笔者就不贴图了）：<code>"木鲸鱼"</code>这个字符串已经被编译器编译成了的文本字符串字面量，当这个类加载之后，JVM 会将 class 文件常量池中的字面量内容全部加载到这个类的运行时常量池中，等待解析，再进行后续的程序操作。</p>
<p>第二种，使用 new 创建 String 对象：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"木鲸鱼"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过反编译可以发现：<code>"木鲸鱼"</code>字面量存储在 Class 文件常量池中，并观察执行语句可以看出，在 str 变量赋值之前，会进行<code>ldc</code>指令操作（加粗标绿部分），它的作用是从常量池中拉取字符串常量值的引用。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">15</span>         <span class="comment">// java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   #<span class="number">2</span> = Class              #<span class="number">16</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">17</span>            <span class="comment">// 木鲸鱼</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">18</span>         <span class="comment">// java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">19</span>            <span class="comment">// Test</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">20</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               main</span><br><span class="line">  #<span class="number">12</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// "&lt;init&gt;":()V</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">17</span> = Utf8               木鲸鱼</span><br><span class="line">  #<span class="number">18</span> = NameAndType        #<span class="number">7</span>:#<span class="number">21</span>         <span class="comment">// "&lt;init&gt;":(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">19</span> = Utf8               Test</span><br><span class="line">  #<span class="number">20</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">21</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String 木鲸鱼</span></span><br><span class="line">         <span class="number">6</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">10</span></span><br><span class="line">}</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>  <code>ldc</code>：Push item from run-time constant pool，从常量池中加载指定项的引用到栈。</p>
<p>  <code>astore_&lt;n&gt;</code>：Store reference into local variable，将引用赋值给第n个局部变量。</p>
</blockquote>
<p>从上面两个反编译的结果可以看出，只要是双引号引起来的字符串都会被编译器编译成字面量，待类加载完成的之后，就会加载到运行时常量池中，但是注意，没有解析之前，加载的内容是不可以使用的。</p>
<h3 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h3><p><strong>「 代码一 」</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"木鲸鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    System.out.println(intern == str); <span class="comment">//false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过反编译的内容结果可以发现：<code>"木鲸鱼"</code>已经被编译到了 Class 文件中的<code>Constant pool</code>中，在类加载完成的时候，就把<code>"木鲸鱼"</code>字面量内容加载到运行时常量池中，并标注为未解析状态<code>JVM_CONSTANT_UnresolvedString</code>。</p>
<p>执行第一行代码，在栈中的 str 变量在 <code>new</code>操作之前，使用了<code>ldc</code>指令，<code>ldc</code>指令是去全局字符串常量池中查询并获取结果，此时查询之前需要注意，这时的<code>"木鲸鱼"</code>的<code>JVM_CONSTANT_String</code>状态是<code>unresolved</code>（未解析的状态），此时的全局常量池没有此字符串的直接引用，只有<code>"木鲸鱼"</code>字面量的 symbol 对象的引用，于是 JVM 根据<code>"木鲸鱼"</code>的字面量内容中 symbol 对象创建出<code>"木鲸鱼"</code>的 String 对象，并把这个 symbol 符号引用（C++层面的符号引用，所有虚拟机都认识的，不能被虚拟机直接引用）直接转换成直接引用（不用虚拟机的直接引用的值的实现不同），并把这个直接引用返回给查询者，当成功获取到结果之后，就会把<code>"木鲸鱼"</code>字面量的项目类将会改为<code>"JVM_CONSTANT_internString"</code>，因此解析完毕。</p>
<p>进一步证明一下：</p>
<p><strong>「 代码二 」</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">	<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"木鲸鱼"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"木鲸鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str2.intern();</span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">    System.out.println(str1 == str3); <span class="comment">// true</span></span><br><span class="line">    System.out.println(str3 == str4); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>str1 上来就 ldc 了，所以常量池中驻留的引用一定是 “木鲸鱼” 的引用。</p>
<p><strong>「 代码三 」</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"木鲸鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"木鲸鱼"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">    System.out.println(intern == str1); <span class="comment">//false</span></span><br><span class="line">    System.out.println(intern == str2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>第一行代码的执行过程不在赘述，直接看第二行代码执行过程： str2 变量赋值之前，<code>ldc</code> 指令需要从全局字符串常量池中拉取结果，因为在第一行的代码执行完成之后，<code>"木鲸鱼"</code>已经被解析并驻留了，因此不会再创建新的 String 对象，而是直接去全局常量池中查询，发现能获取到直接引用，因此不再将 symbol 对象转换成直接引用了（解析）。</p>
<p><strong>「 代码四 」</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鲸"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    System.out.println(intern == str); <span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面这个结果，看起来很正常，因为 Class 文件常量池中没有<code>"鲸鱼"</code>，所以 str 变量在 intern 的时候，JVM 会先去全局字符串常量池中找一下，看有没有这个<code>"鲸鱼"</code>字符串，发现没有，就将 str 创建的<code>"鲸鱼"</code>对象的堆地址并驻留到全局常量池中，也就是此时，str 有了全局字符串常量的“身份”。</p>
<blockquote>
<p>  注意：<code>String str = new String("鲸") + new String("鱼");</code>执行语句的过程是：先创建<code>new StringBuilder()</code>对象保存到 str_0 变量中，再创建两个隐性的变量 str_1 和 str_2 分别引用<code>new String("鲸")</code>和 <code>new String("鱼")</code>，再将 str_1 和 str_2 局部变量当作参数值，带入 append() 方法进行字符串拼接，拼接完成之后 str_0 变量的值为<code>new StringBuilder("鲸鱼")</code>对象堆地址引用，类的类型为 StringBuilder，使用 toString() 方法进行类型转换，这个 toString() 会创建新的 String 对象。（反编译的内容就不放了，读者自己动手尝试吧）</p>
</blockquote>
<p><strong>「 代码五 」</strong></p>
<p>先使用字符串赋值再 intern() 。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鲸"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"鲸鱼"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">    System.out.println(intern == str1); <span class="comment">//false</span></span><br><span class="line">    System.out.println(intern == str2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>str2 先执行的<code>ldc</code>指令，先去全局常量池中查询，发现没有，于是驻留了自己。</p>
<p><strong>「 代码六 」</strong></p>
<p>在代码四的基础上，将 3、4 行代码互换位置：先 intern() 再直接使用字符串赋值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鲸"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"鱼"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> str1.intern();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"鲸鱼"</span>;</span><br><span class="line">    System.out.println(intern == str1); <span class="comment">//true</span></span><br><span class="line">    System.out.println(intern == str2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>str1 先去全局常量池中查询，发现没有，于是驻留了自己。</p>
]]></content>
      <categories>
        <category>String</category>
      </categories>
      <tags>
        <tag>String#intern</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 MySQL 的快照读、当前读</title>
    <url>/2021/09/16/082/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="普通读"><a href="#普通读" class="headerlink" title="普通读"></a>普通读</h3><p>普通读，也称快照读，英文名：Consistent Read。</p>
<p>普通读就是单纯的 select 语句，不包括下面这两类语句：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select ... for update </span><br><span class="line">select ... lock in share mode</span><br></pre></td></tr></tbody></table></figure>

<h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>当前读，也称锁定读，Locking Read。</p>
<p>当前读，读取的是最新版本，并且需要先获取对应记录的锁，如以下这些 SQL 类型：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select ... for update</span><br><span class="line">select ... lock in share mode</span><br><span class="line">update ...</span><br><span class="line">delete ...</span><br><span class="line">insert ...</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><p>环境准备：</p>
<p>一个 MySQL Server，俩个 MySQL 客户端（笔者使用的是 windows mysql 客户端），一个数据库，一张数据库表，表中存储了些许测试数据。</p>
<h3 id="数据库环境约定"><a href="#数据库环境约定" class="headerlink" title="数据库环境约定"></a>数据库环境约定</h3><p>MySQL 版本及默认事务隔离级别约定</p>
<h4 id="MySQL-Server-版本"><a href="#MySQL-Server-版本" class="headerlink" title="MySQL Server 版本"></a>MySQL Server 版本</h4><p>查看 MySQL Server 版本：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select version();</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/00.png"></p>
<p>MySQL Server 版本为 5.7.27</p>
<blockquote>
<p>  windows 环境安装MySQL 教程请移步至笔者这篇博文：<a href="https://woodwhales.cn/2020/02/27/058/">MySQL 5.7 绿色安装(for windows)</a></p>
</blockquote>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>查看事务隔离级别：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/01.png"></p>
<p>InnoDB 存储引擎的事务隔离级别默认为：可重复读。</p>
<h3 id="关闭自动提交"><a href="#关闭自动提交" class="headerlink" title="关闭自动提交"></a>关闭自动提交</h3><p>MySQL 客户端默认是开启自动提交的，需要手动关闭。</p>
<h4 id="查看自动提交状态"><a href="#查看自动提交状态" class="headerlink" title="查看自动提交状态"></a>查看自动提交状态</h4><p>方式1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select @@autocommit;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/03.png"></p>
<p>1 表示开启自动提交，0 表示关闭自动提交</p>
<p>方式2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">show variables like 'autocommit'\G</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/02.png"></p>
<p>ON 表示开启自动提交，OFF 表示关闭自动提交</p>
<h4 id="关闭自动提交-1"><a href="#关闭自动提交-1" class="headerlink" title="关闭自动提交"></a>关闭自动提交</h4><p>方式1：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set autocommit=0;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/04.png"></p>
<p>方式2：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">set autocommit=OFF;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/05.png"></p>
<h3 id="创建数据库表及测试数据"><a href="#创建数据库表及测试数据" class="headerlink" title="创建数据库表及测试数据"></a>创建数据库表及测试数据</h3><p>执行如下 sql 创建数据库表及测试数据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-- 清空已存在的 woodwhales_test_db 数据库</span><br><span class="line">drop database if exists woodwhales_test_db;</span><br><span class="line"></span><br><span class="line">-- 创建 woodwhales_test_db 数据库</span><br><span class="line">create database woodwhales_test_db;</span><br><span class="line"></span><br><span class="line">-- 使用 woodwhales_test_db 数据库</span><br><span class="line">use woodwhales_db;</span><br><span class="line"></span><br><span class="line">-- 创建 test 数据库表，存储引擎使用 innodb</span><br><span class="line">CREATE TABLE `test_table` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `age` int(10) unsigned DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">begin; -- 开启事务</span><br><span class="line">use woodwhales_test_db; -- 使用 woodwhales_test_db 数据库</span><br><span class="line">insert into test_table(age) values (1),(2); -- 插入测试数据</span><br><span class="line">commit; -- 提交事务</span><br></pre></td></tr></tbody></table></figure>

<h3 id="快照读-实验"><a href="#快照读-实验" class="headerlink" title="快照读-实验"></a>快照读-实验</h3><h4 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h4><p><code>客户端1</code>、<code>客户端2</code>分别开启事务；</p>
<h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p><code>客户端1</code>、<code>客户端2</code>分别查询测试数据库表；</p>
<p><img src="https://image.woodwhales.cn/082/images/06.png"></p>
<p>此时，<code>客户端1</code>、<code>客户端2</code>在各自的事务中看到的库表数据是一样的。</p>
<h4 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h4><p><code>客户端2</code>执行更新语句，但不执行 commit 或者 rollback 命令；</p>
<p><code>客户端2</code>更新 id = 1 的数据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">update test_table set age = 10 where id = 1;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/07.png"></p>
<h4 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h4><p><code>客户端1</code>、<code>客户端2</code>分别查询测试数据库表；</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from test_table;</span><br></pre></td></tr></tbody></table></figure>

<p>俩个客户端执行上述命令之后的结果如下图：</p>
<p><img src="https://image.woodwhales.cn/082/images/08.png"></p>
<p>从上图结果可知：</p>
<p><code>客户端1</code>在自己的事务中查询到的结果与客户端 2 在自己的事务中查询到结果不一致：</p>
<ul>
<li><code>客户端1</code>查询到的还是开启事务之前的版本</li>
<li><code>客户端2</code>查询到的是自己操作数据之后的版本</li>
</ul>
<p>出现读取数据不一致的现象，是因为<code>客户端1</code>的 sql 语句是一个快照读，读取的是事务开启时的库表快照。</p>
<p>读者可能会怀疑，为什么没有读取到<code>客户端2</code>操作后的数据，是不是因为<code>客户端2</code>还没有提交事务呢？</p>
<p>别忘了笔者在数据库环境约定中指明了数据库的隔离级别为可重复读，因此<code>客户端2</code>就算执行了提交事务操作，也不会影响<code>客户端1</code>在当前未提交事务中所读的数据，因为只要事务还没有提交，读取的就是事务开启时的库表快照。</p>
<p>实验证明：<code>客户端2</code>提交事务，并重新查询数据库表：</p>
<p><img src="https://image.woodwhales.cn/082/images/09.png"></p>
<h3 id="当前读-实验"><a href="#当前读-实验" class="headerlink" title="当前读-实验"></a>当前读-实验</h3><p>防止俩个客户端有未提交的事务，影响实验结果。使用其中一个客户端更新数据为初始状态。并将俩个客户端都执行一下 commit 命令，保证俩个客户端开启事务是在“同一起跑线”上。</p>
<p><img src="https://image.woodwhales.cn/082/images/10.png"></p>
<blockquote>
<p>  下述的前三个步骤与上小节的三个步骤一致。</p>
</blockquote>
<h4 id="步骤1-1"><a href="#步骤1-1" class="headerlink" title="步骤1"></a>步骤1</h4><p><code>客户端1</code>、<code>客户端2</code>分别开启事务；</p>
<h4 id="步骤2-1"><a href="#步骤2-1" class="headerlink" title="步骤2"></a>步骤2</h4><p><code>客户端1</code>、<code>客户端2</code>分别查询测试数据库表；</p>
<p><img src="https://image.woodwhales.cn/082/images/06.png"></p>
<h4 id="步骤3-1"><a href="#步骤3-1" class="headerlink" title="步骤3"></a>步骤3</h4><p><code>客户端2</code>执行更新语句，但不执行 commit 或者 rollback 命令；</p>
<p><code>客户端2</code>更新 id = 1 的数据：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">update test_table set age = 10 where id = 1;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/082/images/07.png"></p>
<h4 id="步骤4-1"><a href="#步骤4-1" class="headerlink" title="步骤4"></a>步骤4</h4><p><code>客户端1</code>使用当前读查询：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from test_table for update</span><br></pre></td></tr></tbody></table></figure>

<p><code>客户端1</code>执行上述命令之后，命令行窗口会处于阻塞状态，而<code>客户端2</code>执行上述命令无任何阻塞：</p>
<p><img src="https://image.woodwhales.cn/082/images/11.png"></p>
<p>注意此时的<code>客户端1</code>不会无限阻塞，会阻塞一段时间之后，报出<code>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</code>错误。</p>
<p><img src="https://image.woodwhales.cn/082/images/12.png"></p>
<blockquote>
<p>  InnoDB 存储引擎中<code>innodb_lock_wait_timeout</code>参数控制着锁等待时长，默认获取锁等待 50s，一旦数据库锁超过这个时间就会报错。</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-- 查看锁等待超时时间，单位：秒</span><br><span class="line">show global variables like 'innodb_lock_wait_timeout';</span><br><span class="line">-- 设置锁等待超时时间，单位：秒</span><br><span class="line">set global innodb_lock_wait_timeout=500;</span><br></pre></td></tr></tbody></table></figure>

<p>  <img src="https://image.woodwhales.cn/082/images/13.png"></p>
</blockquote>
<p>由于上述步骤 4 中<code>客户端1</code>查询的是全表的当前最新数据记录，我们知道当前全表中的 id = 1 的数据是<code>客户端2</code>修改了并且没有提交事务，由于事务隔离级别的约束，所以<code>客户端1</code>只能阻塞等待。</p>
<h4 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h4><p>如果步骤 4 中的<code>客户端1</code>查询的不是<code>客户端1</code>已修改但未提交的记录，那么<code>客户端1</code>执行当前读语句是不会阻塞的：</p>
<p><img src="https://image.woodwhales.cn/082/images/14.png"></p>
<h4 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h4><p>先明确当前读的概念，当前读表示强制读取数据的最新状态，并且这个数据状态一定是已事务提交后的数据状态。由于事务隔离级别决定了，不允许产生脏读，所以无论是快照读还是当前读都不可能读取到其他事务未提交的数据状态。</p>
<p>如果步骤 4 中的<code>客户端1</code>执行当前读之前，<code>客户端2</code>进行了事务提交，那么<code>客户端1</code>进行当前读的时候就会读取到数据的最新状态：</p>
<p><img src="https://image.woodwhales.cn/082/images/15.png"></p>
<p>从上图可以看出，<code>客户端1</code>没有被阻塞，而是查询到了数据，但是数据和开启事务时的数据状态不一致，出现了幻读的情况。总结得出，在可重复读的事务隔离级别下，快照读和当前读混用可能会造成幻读。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>发布自己的 jar 包到 Maven 中央仓库 ( mvnrepository.com )</title>
    <url>/2021/09/19/083/</url>
    <content><![CDATA[<blockquote>
<p>  笔者以自己的开源项目：<a href="https://github.com/woodwhales/woodwhales-common">https://github.com/woodwhales/woodwhales-common</a> 为例，演示如何将自己的开源 jar 发布至 maven 中央仓库，即可在 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 官网中搜索到。</p>
</blockquote>
<h2 id="注册-sonatype-的-Jira-帐号"><a href="#注册-sonatype-的-Jira-帐号" class="headerlink" title="注册 sonatype 的 Jira 帐号"></a>注册 sonatype 的 Jira 帐号</h2><p><code>SonaType</code>是什么呢？提供开源项目仓库托管( Open Source Software Repository Hosting，简称 OSSRH )服务。</p>
<blockquote>
<p>注意：记录用户名和账号密码，后续发布 jar 文件时会使用到。</p>
</blockquote>
<p>注册地址: <a href="https://issues.sonatype.org/secure/Signup!default.jspa">https://issues.sonatype.org/secure/Signup!default.jspa</a></p>
<p>注册很简单，重要的是邮箱地址一定要正确，issue 有任何变动都会通过邮件通知。</p>
<h3 id="sonatype-网站设置中文语言"><a href="#sonatype-网站设置中文语言" class="headerlink" title="sonatype 网站设置中文语言"></a>sonatype 网站设置中文语言</h3><p>sonatype 的 Jira 帐号注册成功之后，登录进入首页界面如下：</p>
<p><img src="https://image.woodwhales.cn/083/images/01.png"></p>
<p>点击头像的个人信息设置：</p>
<p><img src="https://image.woodwhales.cn/083/images/02.png"></p>
<p>点击 preferences 设置按钮：</p>
<p><img src="https://image.woodwhales.cn/083/images/03.png"></p>
<p>设置语言及时区：</p>
<p><img src="https://image.woodwhales.cn/083/images/04.png"></p>
<h3 id="申请创建个人仓库工单"><a href="#申请创建个人仓库工单" class="headerlink" title="申请创建个人仓库工单"></a>申请创建个人仓库工单</h3><p>点击页面顶部的<code>创建</code>按钮，创建工单：</p>
<p>项目选择：<code>Community Support - Open Source Project Repository Hosting (OSSRH)</code></p>
<p>问题类型选择：<code>New Project</code></p>
<p><img src="https://image.woodwhales.cn/083/images/05.png"></p>
<p>填写表单信息：</p>
<p><img src="https://image.woodwhales.cn/083/images/06.png"></p>
<p>表单中有如下信息需要填写：</p>
<ul>
<li><code>Summary</code>：描述自己包的作用</li>
<li><code>Description</code>：可写可不写，也是具体描述的</li>
<li><code>Group Id</code>：笔者有自己的域名，所以填写的是 cn.woodwhales.common，如果没有自己的域名，可以填写：github.xxx.yyy 或者 gitee.xxx.yyy。</li>
<li><code>Project URL</code>：填写你的项目的 github 或者 gitee 地址</li>
<li><code>SCM url</code>：填写你项目的 github 或者 gitee 的克隆地址</li>
</ul>
<p>读者可以参考笔者的工单进行填写：<a href="https://issues.sonatype.org/browse/OSSRH-73359">https://issues.sonatype.org/browse/OSSRH-73359</a></p>
<p><img src="https://image.woodwhales.cn/083/images/07.png"></p>
<p>工单提交之后需要等待管理员审核。审核完成，管理员会在下面提示你让你验证这个域名是你的或者证明域名或者 gitee 或者 github 空间是你的。笔者的要求域名解析配置，并且在 github 仓库中临时创建一个的名称为：<code>OSSRH-73359</code>的公开仓库：</p>
<p><img src="https://image.woodwhales.cn/083/images/08.png"></p>
<p>管理员很亲切地给了怎么域名添加解析记录的指导说明：<a href="https://central.sonatype.org/faq/how-to-set-txt-record/">https://central.sonatype.org/faq/how-to-set-txt-record/</a></p>
<p><img src="https://image.woodwhales.cn/083/images/09.png"></p>
<p>笔者的域名在腾讯云平台，进入域名解析平台，添加解析记录，稍等片刻即可收到管理员再次审核通过的信息：</p>
<p><img src="https://image.woodwhales.cn/083/images/10.png"></p>
<p>在 github 仓库中创建临时仓库：</p>
<blockquote>
<p>因为已经完成了验证，所以笔者在完成本博文之后就删除了这个临时仓库。</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/083/images/11.png"></p>
<p>当上述步骤按照管理员要求验证之后，稍等片刻，就会收到管理员验证通过的信息：</p>
<p><img src="https://image.woodwhales.cn/083/images/12.png"></p>
<p>到此，我们可以按照管理员给的配置指南进行下一步操作了，可以不再使用 sonatype 网站。</p>
<p>值得注意是的是，工单的状态也变为<code>已解决</code>状态。</p>
<h2 id="发布指南"><a href="#发布指南" class="headerlink" title="发布指南"></a>发布指南</h2><p>参考管理员给的配置指南：<a href="https://central.sonatype.org/publish/publish-guide/#deployment%EF%BC%8C%E7%AC%94%E8%80%85%E6%98%AF">https://central.sonatype.org/publish/publish-guide/#deployment，笔者是</a> maven 工程，所以点击 maven 工程配置指南：<a href="https://central.sonatype.org/publish/publish-guide/#deployment">https://central.sonatype.org/publish/publish-guide/#deployment</a></p>
<p><img src="https://image.woodwhales.cn/083/images/13.png"></p>
<p>读者如果是其他版本控制工具，找到对应的文档自行配置即可，思路大致相同。</p>
<h3 id="配置-maven-的-settings-xml"><a href="#配置-maven-的-settings-xml" class="headerlink" title="配置 maven 的 settings.xml"></a>配置 maven 的 settings.xml</h3><p>在自己本机的 maven 配置文件 settings.xml 中配置<code>&lt;server&gt;</code>：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>sonatype 的 Jira 帐号<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>sonatype 的 Jira 帐号的密码<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>笔者建议这个<code>&lt;id&gt;ossrh&lt;/id&gt;</code> 不要修改，就使用官方指南的即可。</p>
<h3 id="GPG-签名配置"><a href="#GPG-签名配置" class="headerlink" title="GPG 签名配置"></a>GPG 签名配置</h3><h4 id="下载-GPG"><a href="#下载-GPG" class="headerlink" title="下载 GPG"></a>下载 GPG</h4><p>sonatype 要求发布的 jar 需要使用 GPG 签名，所以需要安装 GPG，并生成密钥对。</p>
<p>GPG 下载地址：</p>
<ul>
<li><p>windows 环境：<a href="https://www.gpg4win.org/download.html">https://www.gpg4win.org/download.html</a></p>
</li>
<li><p>mac 环境：<a href="https://gpgtools.org/">https://gpgtools.org/</a></p>
</li>
</ul>
<blockquote>
<p>GPG 官网有各个环境的安装包下载地址：<a href="https://gnupg.org/download/index.html">https://gnupg.org/download/index.html</a></p>
<p><img src="https://image.woodwhales.cn/083/images/14.png"></p>
</blockquote>
<h4 id="安装-GPG"><a href="#安装-GPG" class="headerlink" title="安装 GPG"></a>安装 GPG</h4><p>安装 GPG 很简单，一直下一步即可安装成功。安装过程中要记得安装目录，后续会有使用到这个路径。</p>
<p>笔者安装在了 c 盘符下：</p>
<p><img src="https://image.woodwhales.cn/083/images/15.png"></p>
<p>值得注意的是 GPG 会自动注册到系统环境变量中，所以我们可以直接在 cmd 窗口中验证是否安装成功：</p>
<p><img src="https://image.woodwhales.cn/083/images/16.png"></p>
<p>展示出 GPG 版本信息表示安装成功。另外，安装成功之后，桌面会出现一个快捷图标：Kleopatra</p>
<p><img src="https://image.woodwhales.cn/083/images/17.png"></p>
<h4 id="生成-GPG-证书（密钥对）"><a href="#生成-GPG-证书（密钥对）" class="headerlink" title="生成 GPG 证书（密钥对）"></a>生成 GPG 证书（密钥对）</h4><blockquote>
<p>关于密码学相关知识，请移步至笔者的另一篇博文：<a href="https://woodwhales.cn/2019/09/27/049/">漫谈密码技术</a></p>
</blockquote>
<p>可以使用 GPG 命令在 cmd 窗口生成，也可以打开 Kleopatra 桌面程序生成。</p>
<h5 id="方式1：命令生成"><a href="#方式1：命令生成" class="headerlink" title="方式1：命令生成"></a>方式1：命令生成</h5><p>命令行生成生成秘钥： <code>gpg --gen-key</code></p>
<p>按提示输入名字， 如：woodwhales，邮箱 <a href="mailto:woodwhales@163.com">woodwhales@163.com</a>，然后选择 (O) kay，输入英文字母 o</p>
<p>弹出设置密码框，记住这个密码，稍后会使用到：</p>
<p><img src="https://image.woodwhales.cn/083/images/18.png"></p>
<p>密码输入完成之后，程序生成密钥对，并展示出 GPG 公钥签名：</p>
<p><img src="https://image.woodwhales.cn/083/images/19.png"></p>
<p>查看本系统已生成的所有密钥对信息： <code>gpg --list-keys</code></p>
<p><img src="https://image.woodwhales.cn/083/images/20.png"></p>
<p>上图中有俩个公钥信息，第一个是笔者写本博文之前创建的，第二个是本博文操作创建的。</p>
<h5 id="方式2：可视化生成"><a href="#方式2：可视化生成" class="headerlink" title="方式2：可视化生成"></a>方式2：可视化生成</h5><p>可视化的生成密钥对比命令行生成友好很多，并且直接展示已生成的所有密钥对信息：</p>
<p><img src="https://image.woodwhales.cn/083/images/21.png"></p>
<p>点击创建个人密钥对：</p>
<p><img src="https://image.woodwhales.cn/083/images/22.png"></p>
<p>输入密钥名称、邮箱，勾选设置密码：</p>
<p><img src="https://image.woodwhales.cn/083/images/23.png"></p>
<p>设置密码：</p>
<p><img src="https://image.woodwhales.cn/083/images/24.png"></p>
<p>生成成功</p>
<p><img src="https://image.woodwhales.cn/083/images/25.png"></p>
<p>系统中又多了一个密钥对。</p>
<blockquote>
<p>如果确认证书不需要使用了，可以右键点击删除。注意：一定要确认好，物理删除了可创建不会回来相同的密钥对了！</p>
</blockquote>
<h4 id="上传公钥证书至公钥服务器"><a href="#上传公钥证书至公钥服务器" class="headerlink" title="上传公钥证书至公钥服务器"></a>上传公钥证书至公钥服务器</h4><p>使用 cmd 命令执行：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 公钥签名</span><br></pre></td></tr></tbody></table></figure>

<p>验证是否成功地上传到了两个服务器：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 公钥签名</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/083/images/28.png"></p>
<h4 id="可能出现的上传失败问题"><a href="#可能出现的上传失败问题" class="headerlink" title="可能出现的上传失败问题"></a>可能出现的上传失败问题</h4><p>命令行上传至 hkp://pool.sks-keyservers.net 可能出现<code>[gpg: keyserver receive failed: No name](https://stackoverflow.com/questions/66217436/gpg-keyserver-receive-failed-no-name)</code>问题。</p>
<h5 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h5><p>可以参考：<a href="https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key">https://central.sonatype.org/publish/requirements/gpg/#distributing-your-public-key</a> 文档中的镜像替换，即将<code>hkp://pool.sks-keyservers.net</code> 替换为镜像列表中的镜像。</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">keyserver.ubuntu.com</span><br><span class="line">keys.openpgp.org</span><br><span class="line">pgp.mit.edu</span><br></pre></td></tr></tbody></table></figure>

<h5 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h5><p>笔者创建至 hkp://pool.sks-keyservers.net 失败了，可以使用 Kleopatra 导出公钥，浏览器访问公钥服务器：<a href="https://keys.openpgp.org/">https://keys.openpgp.org/</a> 官网，然后上传公钥证书，上传成功之后，服务器会给你的邮件发一封确认邮件。</p>
<p><img src="https://image.woodwhales.cn/083/images/26.png"></p>
<p>在搜索框中搜索邮箱得到信息，则表示上传成功：<a href="https://keys.openpgp.org/search?q=woodwhales@163.com">https://keys.openpgp.org/search?q=woodwhales%40163.com</a></p>
<p><img src="https://image.woodwhales.cn/083/images/27.png"></p>
<h3 id="再次配置-maven-的-settings-xml"><a href="#再次配置-maven-的-settings-xml" class="headerlink" title="再次配置 maven 的 settings.xml"></a>再次配置 maven 的 settings.xml</h3><p>在自己本机的 maven 配置文件 settings.xml 中再次配置<code>&lt;profile&gt;</code>：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">gpg.executable</span>&gt;</span>C:\programs\GnuPG\bin\gpg.exe<span class="tag">&lt;/<span class="name">gpg.executable</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">gpg.passphrase</span>&gt;</span>上述步骤中创建的密钥对的密码<span class="tag">&lt;/<span class="name">gpg.passphrase</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述配置中：</p>
<p><code>&lt;id&gt;ossrh&lt;/id&gt;</code>：和<code>&lt;server&gt;</code>中 sonatype 账号的 id 一致</p>
<p><code>&lt;gpg.executable&gt;</code>：gpg.exe 绝对路径，如果不配置，可能在后续发布的时候 maven-gpg-plugin 插件报找不到 gpg.exe 错误。</p>
<p><code>&lt;gpg.passphrase&gt;</code>：上述步骤中创建的密钥对的密码</p>
<h3 id="配置项目中的-pom-xml"><a href="#配置项目中的-pom-xml" class="headerlink" title="配置项目中的 pom.xml"></a>配置项目中的 pom.xml</h3><p>在要发布的 maven 工程的 pom.xml中配置：项目名称、描述、开源协议信息、开发者信息、 发布信息、发布插件：</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.woodwhales.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>woodwhales-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>woodwhales-common<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目描述 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>https://github.com/woodwhales<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/woodwhales/woodwhales-common<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件拷贝时的编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开源协议 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>The Apache Software License, Version2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.apache.org/licenses/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- scm --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>master<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/woodwhales/woodwhales-common<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:git:git://github.com:woodwhales/woodwhales-common.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:git:git://github.com:woodwhales/woodwhales-common.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- issues --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>GitHub Issue Management<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/woodwhales/woodwhales-common/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开发者信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>woodwhales<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>woodwhales<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>woodwhales@163.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://woodwhales.cn/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>+8<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- distributionManagement --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://s01.oss.sonatype.org/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maven 打包时附带源码文件插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 生成 javadoc 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- sonatype staging 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>ossrh<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">nexusUrl</span>&gt;</span>https://s01.oss.sonatype.org/<span class="tag">&lt;/<span class="name">nexusUrl</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">autoReleaseAfterClose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">autoReleaseAfterClose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- maven-gpg 插件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>sign-artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>sign<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>对 maven 工程执行即可发布 jar 至 maven 仓库，注意工程版本不要带有<code>SNAPSHOT</code>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></tbody></table></figure>

<p>发布成功之后，可以在 <a href="https://search.maven.org/">search.maven.org</a> 中搜索到自己刚刚上传的 jar 文件。</p>
<p>并在 <a href="https://s01.oss.sonatype.org/#welcome">https://s01.oss.sonatype.org/#welcome</a> 中使用 sonatype 的 Jira 账号登录，从 <a href="https://s01.oss.sonatype.org/content/groups/public/">https://s01.oss.sonatype.org/content/groups/public/</a> 和 <a href="https://s01.oss.sonatype.org/content/repositories/releases/">https://s01.oss.sonatype.org/content/repositories/releases/</a> 中可以看到发布的 jar 文件。</p>
<p><img src="https://image.woodwhales.cn/083/images/29.png"></p>
<p>另外在 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> 中已可以确认一下 maven central 中也已经同步了：</p>
<p><img src="https://image.woodwhales.cn/083/images/31.png"></p>
<p>maven central 仓库：</p>
<p><img src="https://image.woodwhales.cn/083/images/32.png"></p>
<h3 id="通知管理员关闭-issue"><a href="#通知管理员关闭-issue" class="headerlink" title="通知管理员关闭 issue"></a>通知管理员关闭 issue</h3><p>上述步骤操作完毕之后，能顺利发布 jar 至 releases 仓库，则需要在最开始的工单中评论，请管理员关闭工单。</p>
<p><img src="https://image.woodwhales.cn/083/images/30.png"></p>
<p>并将工单的是否已同步至 central 状态改为 Yes：</p>
<p><img src="https://image.woodwhales.cn/083/images/33.png"></p>
<p>填写已关闭 issuse</p>
<p><img src="https://image.woodwhales.cn/083/images/34.png"></p>
<p>笔者上传自定义开源 jar 文件至 maven 仓库成功之后，在隔一天之后可在 <a href="https://mvnrepository.com/">https://mvnrepository.com</a> 网站搜索到该 jar 信息：<a href="https://mvnrepository.com/search?q=woodwhales">https://mvnrepository.com/search?q=woodwhales</a></p>
<p><img src="https://image.woodwhales.cn/083/images/35.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://central.sonatype.org/publish/publish-guide/#deployment">The Central Repository Documentation</a></p>
<p><a href="https://blog.csdn.net/yanhanhui1/article/details/108093313">发布自己的jar包到Maven中央仓库</a></p>
<p><a href="https://www.ossez.com/t/gpg-maven-upload-your-public-key-and-try-the-operation/785">GPG 使用 Maven 签名后发送到中央仓库提示 Upload your public key and try the operation</a></p>
<p><a href="https://blog.csdn.net/qq_36206259/article/details/120267587?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242">jar maven 中央仓库 GPG问题 deploy 400</a></p>
<p><a href="https://stackoverflow.com/questions/66217436/gpg-keyserver-receive-failed-no-name">gpg: keyserver receive failed: No name</a></p>
<p><a href="https://blog.csdn.net/qq_29649547/article/details/120181909">更新JAR到maven仓库 gpg: keyserver send failed: No name</a></p>
]]></content>
      <categories>
        <category>mvnrepository</category>
      </categories>
      <tags>
        <tag>mvnrepository</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的俩种实现</title>
    <url>/2022/02/13/084/</url>
    <content><![CDATA[<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>每一轮排序选择一个基准点（pivot）进行分区<ol>
<li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li>
<li>当分区完成时，基准点元素的位置就是其最终位置</li>
</ol>
</li>
<li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li>
</ol>
<p>从以上描述可以看出，一个关键在于分区算法，常见的有单边循环（洛穆托分区方案）、双边循环分区方案、霍尔分区方案</p>
<h3 id="单边循环"><a href="#单边循环" class="headerlink" title="单边循环"></a>单边循环</h3><h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><p>1，选择数组最右侧元素作为基准点</p>
<p>例如下图中的数组最右侧元素作为基准点。</p>
<p><img src="https://image.woodwhales.cn/084/images/01.png"></p>
<p>2，数组从左到右依次遍历元素，比基准点小的放置到基准点左边，比基准点大的放置到基准点右边</p>
<p>达到的效果如下图：</p>
<p><img src="https://image.woodwhales.cn/084/images/02.png"></p>
<p>3，步骤 2 之后，基准点将原数组拆分成了俩个子集合。将俩个子集合看作新的集合，重复步骤1，2，直到子集合不能再拆分为止即可完成排序。</p>
<h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><p><img src="https://image.woodwhales.cn/084/images/01.png"></p>
<p>如图示中，使用俩个游标初始值是数组的最左侧位置。</p>
<ol>
<li><p>选择最右元素作为基准点元素</p>
</li>
<li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换，i++</p>
</li>
<li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p>
</li>
<li><p>最后基准点与 i 交换，i 即为分区位置</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 第一遍排序全数组</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="comment">// 地位大于等于高位则不需要进行排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 完成第一遍，将数组按照基准点进行拆分，并得到基准点的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, high);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> arr[high];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pv) {</span><br><span class="line">                swap(arr, i, j);</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        swap(arr, i, high);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> {</span><br><span class="line">        <span class="keyword">if</span> (i != j) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="双边循环"><a href="#双边循环" class="headerlink" title="双边循环"></a>双边循环</h3><h4 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h4><p>1，选择数组最左侧元素作为基准点</p>
<p><img src="https://image.woodwhales.cn/084/images/03.png"></p>
<p>2，使用游标分别从数组的俩端往中间移动，左侧游标找比基准点小的，右侧游标找基准点大的，一旦找到就俩者游标对应的元素互换，直到俩个游标相遇为止。</p>
<p>3，俩个游标相遇的位置就是分区的位置。</p>
<h4 id="代码思路-1"><a href="#代码思路-1" class="headerlink" title="代码思路"></a>代码思路</h4><ol>
<li>选择最左元素作为基准点元素</li>
<li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li>
<li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li>
</ol>
<p>要点</p>
<ol>
<li><p>基准点在左边，并且要先 j 后 i</p>
</li>
<li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p>
</li>
<li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;=</strong> pv ) i++</p>
</li>
</ol>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">int</span>[] arr = {<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>};</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 第一遍排序全数组</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="comment">// 地位大于等于高位则不需要进行排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 完成第一遍，将数组按照基准点进行拆分，并得到基准点的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, p - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, p + <span class="number">1</span>, high);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> arr[low];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> high;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) {</span><br><span class="line">            <span class="comment">// 直到 arr[j] 小于等于基准点</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pv) {</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直到 arr[i] 大于基准点</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pv) {</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 上述俩个while循环保证了 i 和 j 一定会相遇，相遇则互换</span></span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j 的位置就是分区索引位置</span></span><br><span class="line">        swap(arr, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ windows安装</title>
    <url>/2022/03/01/085/</url>
    <content><![CDATA[<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><p>RabbitMQ 是使用 Erlang 语言开发的，所以需要系统环境有 Erlang 环境，RabbitMQ 官网提供了版本对应关系：</p>
<p><a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<img src="https://image.woodwhales.cn/085/images/01.png" style="zoom:80%;">

<p>笔者使用目前 RabbitMQ 最新版本进行安装：</p>
<ul>
<li><p>RabbitMQ：3.9.13 版本</p>
<p>下载地址：<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.13/rabbitmq-server-windows-3.9.13.zip">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.13/rabbitmq-server-windows-3.9.13.zip</a></p>
</li>
<li><p>Erkang：24.2 版本</p>
<p>下载地址：<a href="https://github.com/erlang/otp/releases/download/OTP-24.2/otp_win64_24.2.exe">https://github.com/erlang/otp/releases/download/OTP-24.2/otp_win64_24.2.exe</a></p>
</li>
</ul>
<h3 id="Erlang-安装"><a href="#Erlang-安装" class="headerlink" title="Erlang 安装"></a>Erlang 安装</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>双击安装 otp_win64_24.2.exe，注意记住 Erlang 安装的路径，需要配置到系统环境变量中：<code>ERLANG_HOME</code></p>
<blockquote>
<p>  笔者使用的路径为：C:\programs\erl-24.2.2</p>
</blockquote>
<p><img src="https://image.woodwhales.cn/085/images/02.png"></p>
<p>将其环境变量配置到 Path 中：<code>%ERLANG_HOME%\bin</code></p>
<p><img src="https://image.woodwhales.cn/085/images/03.png"></p>
<p>验证是否安装成功，在 cmd 窗口中输入 erl 命令，显示 Eshell 信息即可。</p>
<p><img src="https://image.woodwhales.cn/085/images/04.png"></p>
<h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><h4 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h4><p>将 RabbitMQ 安装包解压至指定目录并配置到系统变量<code>RABBITMQ_SERVER</code>中即可。</p>
<blockquote>
<p>  笔者使用的路径为：C:\programs\rabbitmq_server-3.9.13</p>
</blockquote>
<p> Path 系统变量中配置：<code>%RABBITMQ_SERVER%\sbin</code></p>
<p><img src="https://image.woodwhales.cn/085/images/05.png"></p>
<h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>安装 RabbitMQ 管理控制台插件，使用管理员模式下的 CMD 窗口执行命令<code>rabbitmq-plugins.bat enable rabbitmq_management</code>即可。</p>
<p><img src="https://image.woodwhales.cn/085/images/06.png"></p>
<blockquote>
<p>  如果出现此异常：unable to perform an operation on node ‘rabbit@xxxx’. Please see diagnostics information and suggestions below…</p>
<p>  解决方法：</p>
<p>  将 C:\Users\Administrator.erlang.cookie 文件复制到 C:\Windows\System32\config\systemprofile 下，替换掉 .erlang.cookie。</p>
<p>  同时删除：C:\Users\Administrator\AppData\Roaming\RabbitMQ目录，重新执行安装 RabbitMQ 管理控制台插件命令即可。</p>
</blockquote>
<h4 id="启动-RabbitMQ"><a href="#启动-RabbitMQ" class="headerlink" title="启动 RabbitMQ"></a>启动 RabbitMQ</h4><p>安装完插件，运行<code>rabbitmq-server start</code>命令即可启动 RabbitMQ。</p>
<p><img src="https://image.woodwhales.cn/085/images/07.png"></p>
<p>此时，浏览器访问：<a href="http://localhost:15672/">http://localhost:15672/</a> 即可看见 RabbitMQ 的控制台登录首页，账号为：guest，密码为：guest</p>
<p><img src="https://image.woodwhales.cn/085/images/08.png"></p>
<h4 id="安装-windows-服务"><a href="#安装-windows-服务" class="headerlink" title="安装 windows 服务"></a>安装 windows 服务</h4><p>使用管理员模式下的 CMD 窗口执行<code>rabbitmq-service install</code>命令即可。</p>
<p><img src="https://image.woodwhales.cn/085/images/10.png"></p>
<p>安装过程中出现安装失败</p>
<p><img src="https://image.woodwhales.cn/085/images/09.png"></p>
<p>删除注册表里的<code>HKEY_LOCAL_MACHINE\SOFTWARE\Ericsson\Erlang\ErlSrv</code>，重新使用管理员模式下的 CMD 运行<code>erl</code>命令，再次执行<code>rabbitmq-service install</code>即可。</p>
<p><img src="https://image.woodwhales.cn/085/images/11.png"></p>
<p>安装好后，将 RabbitMQ 服务启动即可，这样以后就可以开机自启动啦。</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue + Element UI快速入门</title>
    <url>/2022/03/31/086/</url>
    <content><![CDATA[<blockquote>
<p>项目源码：<a href="https://github.com/woodwhales/woodwhales-study/tree/master/woodwhales-vue-demo">https://github.com/woodwhales/woodwhales-study/tree/master/woodwhales-vue-demo</a></p>
</blockquote>
<h2 id="脚手架搭建"><a href="#脚手架搭建" class="headerlink" title="脚手架搭建"></a>脚手架搭建</h2><p><strong>步骤1：全局安装 vue 2.0</strong></p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">cnpm install vue-cli -g</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>  查看 vue 版本命令：<code>vue -V</code></p>
</blockquote>
<p><strong>步骤2：在一个空目录中创建工程</strong></p>
<p>执行 vue 初始化工程命令：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">vue init webpack my-demo</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>当提示到是否安装：<code>Install vue-router?</code>，输入<code>y</code>。</p>
</li>
<li><p>提示是否安装：<code>Use ESLint to lint your code?</code>，输入<code>n</code>。</p>
</li>
<li><p>其他选项全部输入<code>y</code></p>
</li>
</ul>
<p>安装完成，提示如下信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Project initialization finished!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">========================</span></span><br><span class="line"></span><br><span class="line">To get started:</span><br><span class="line"></span><br><span class="line">  cd my-demo</span><br><span class="line">  npm run dev</span><br><span class="line"></span><br><span class="line">Documentation can be found at https://vuejs-templates.github.io/webpack</span><br></pre></td></tr></tbody></table></figure>

<p>根据安装完成的提示，进入 my-demo 目录，执行<code>npm run dev</code>命令，浏览器访问：<a href="http://localhost:8080/">http://localhost:8080</a> 地址即可看到<code>vue-cli</code>脚手架搭建的基础工程。</p>
<p><strong>步骤3（可选）：修改启动端口号</strong></p>
<p>在<code>config/index.js</code>配置文件中，配置了项目的启动基础参数：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">host <span class="comment"># 项目启动的主机名</span></span><br><span class="line">port <span class="comment"># 项目启动的端口号</span></span><br><span class="line">autoOpenBrowser <span class="comment">#是否启动时自动打开浏览器并访问</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="创建自定义组件"><a href="#创建自定义组件" class="headerlink" title="创建自定义组件"></a>创建自定义组件</h2><p>在<code>components</code>文件目录下创建<code>Index.vue</code>文件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    {{ msg }}</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  name: 'Index',</span><br><span class="line">  data () {</span><br><span class="line">    return {</span><br><span class="line">      msg: 'this index page'</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>router/index.js</code>文件中将<code>Index</code>组件引入：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">'@/components/Index'</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>({</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'Index'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Index</span></span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>App.vue</code>文件中将<code>Index</code>组件引入：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id="app"&gt;</span><br><span class="line">    &lt;Index/&gt;</span><br><span class="line">    &lt;!-- &lt;router-view/&gt; --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Index from './components/Index'</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  name: 'App',</span><br><span class="line">  components: {</span><br><span class="line">    Index</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/01.png"></p>
<p>浏览器访问项目，可以看到首页变成了<code>Index</code>组件中的内容：</p>
<p><img src="https://image.woodwhales.cn/086/images/02.png"></p>
<h2 id="引入-element-ui-组件"><a href="#引入-element-ui-组件" class="headerlink" title="引入 element-ui 组件"></a>引入 element-ui 组件</h2><blockquote>
<p>  element-ui 官网：<a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></p>
</blockquote>
<p>停止项目，安装<code>element-ui</code>依赖：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></tbody></table></figure>

<p>安装成功之后，检查<code>package.json</code>配置中是否引入了<code>element-ui</code>：</p>
<p><img src="https://image.woodwhales.cn/086/images/03.png"></p>
<p>在<code>main.js</code>配置中引入<code>element-ui</code>组件：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">import ElementUI from <span class="string">'element-ui'</span>;</span><br><span class="line">import <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/04.png"></p>
<p>对<code>Index.vue</code>组件进行改造，引入 element-ui 的 Container 布局容器：</p>
<blockquote>
<p>  Container 布局容器：<a href="https://element.eleme.cn/#/zh-CN/component/container">https://element.eleme.cn/#/zh-CN/component/container</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-aside width="200px"&gt;{{left}}&lt;/el-aside&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-header&gt;{{header}}&lt;/el-header&gt;</span><br><span class="line">        &lt;el-main&gt;{{main}}&lt;/el-main&gt;</span><br><span class="line">      &lt;/el-container&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  name: 'Index',</span><br><span class="line">  data () {</span><br><span class="line">    return {</span><br><span class="line">      left: 'this is left aside',</span><br><span class="line">      header: 'this is header',</span><br><span class="line">      main: 'this is main'</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .el-header, .el-footer {</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-aside {</span><br><span class="line">    background-color: #D3DCE6;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-main {</span><br><span class="line">    background-color: #E9EEF3;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 160px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  body &gt; .el-container {</span><br><span class="line">    margin-bottom: 40px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-container:nth-child(5) .el-aside,</span><br><span class="line">  .el-container:nth-child(6) .el-aside {</span><br><span class="line">    line-height: 260px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-container:nth-child(7) .el-aside {</span><br><span class="line">    line-height: 320px;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/05.png"></p>
<p>浏览器访问项目，可以看到首页变成了<code>Index</code>组件中的 element-ui 布局样式：</p>
<p><img src="https://image.woodwhales.cn/086/images/06.png"></p>
<h2 id="引入-element-ui-导航菜单"><a href="#引入-element-ui-导航菜单" class="headerlink" title="引入 element-ui 导航菜单"></a>引入 element-ui 导航菜单</h2><blockquote>
<p>NavMenu 导航菜单：<a href="https://element.eleme.cn/#/zh-CN/component/menu">https://element.eleme.cn/#/zh-CN/component/menu</a></p>
</blockquote>
<p>在<code>Index.vue</code>组件中的左侧栏中添加导航菜单代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-aside width="200px"&gt;</span><br><span class="line">        &lt;el-menu</span><br><span class="line">          default-active="2"</span><br><span class="line">          class="el-menu-vertical-demo"</span><br><span class="line">          @open="handleOpen"</span><br><span class="line">          @close="handleClose"&gt;</span><br><span class="line">          &lt;el-submenu index="1"&gt;</span><br><span class="line">            &lt;template slot="title"&gt;</span><br><span class="line">              &lt;i class="el-icon-location"&gt;&lt;/i&gt;</span><br><span class="line">              &lt;span&gt;导航一&lt;/span&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">            &lt;el-menu-item-group&gt;</span><br><span class="line">              &lt;template slot="title"&gt;分组一&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">              &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item-group title="分组2"&gt;</span><br><span class="line">              &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-menu-item-group&gt;</span><br><span class="line">            &lt;el-submenu index="1-4"&gt;</span><br><span class="line">              &lt;template slot="title"&gt;选项4&lt;/template&gt;</span><br><span class="line">              &lt;el-menu-item index="1-4-1"&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;/el-submenu&gt;</span><br><span class="line">          &lt;/el-submenu&gt;</span><br><span class="line">          &lt;el-menu-item index="2"&gt;</span><br><span class="line">            &lt;i class="el-icon-menu"&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span slot="title"&gt;导航二&lt;/span&gt;</span><br><span class="line">          &lt;/el-menu-item&gt;</span><br><span class="line">          &lt;el-menu-item index="3" disabled&gt;</span><br><span class="line">            &lt;i class="el-icon-document"&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span slot="title"&gt;导航三&lt;/span&gt;</span><br><span class="line">          &lt;/el-menu-item&gt;</span><br><span class="line">          &lt;el-menu-item index="4"&gt;</span><br><span class="line">            &lt;i class="el-icon-setting"&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span slot="title"&gt;导航四&lt;/span&gt;</span><br><span class="line">          &lt;/el-menu-item&gt;</span><br><span class="line">        &lt;/el-menu&gt;</span><br><span class="line">      &lt;/el-aside&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-header&gt;{{header}}&lt;/el-header&gt;</span><br><span class="line">        &lt;el-main&gt;{{main}}&lt;/el-main&gt;</span><br><span class="line">      &lt;/el-container&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default {</span><br><span class="line">  name: 'Index',</span><br><span class="line">  data () {</span><br><span class="line">    return {</span><br><span class="line">      left: 'this is left aside',</span><br><span class="line">      header: 'this is header',</span><br><span class="line">      main: 'this is main'</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    handleOpen(key, keyPath) {</span><br><span class="line">      console.log(key, keyPath);</span><br><span class="line">    },</span><br><span class="line">    handleClose(key, keyPath) {</span><br><span class="line">      console.log(key, keyPath);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .el-header, .el-footer {</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-aside {</span><br><span class="line">    background-color: #D3DCE6;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-main {</span><br><span class="line">    background-color: #E9EEF3;</span><br><span class="line">    color: #333;</span><br><span class="line">    text-align: center;</span><br><span class="line">    line-height: 160px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  body &gt; .el-container {</span><br><span class="line">    margin-bottom: 40px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-container:nth-child(5) .el-aside,</span><br><span class="line">  .el-container:nth-child(6) .el-aside {</span><br><span class="line">    line-height: 260px;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  .el-container:nth-child(7) .el-aside {</span><br><span class="line">    line-height: 320px;</span><br><span class="line">  }</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/07.png"></p>
<p><img src="https://image.woodwhales.cn/086/images/08.png"></p>
<p>添加导航菜单效果如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/09.png"></p>
<h2 id="设置-element-ui-导航菜单动态路由"><a href="#设置-element-ui-导航菜单动态路由" class="headerlink" title="设置 element-ui 导航菜单动态路由"></a>设置 element-ui 导航菜单动态路由</h2><p><strong>步骤1：开始导航菜单路由模式</strong></p>
<p>在<code>Index.vue</code>组件中，将菜单<code>&lt;el-menu&gt;</code>标签属性中设置开启使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转，并且在<code>&lt;el-main&gt;</code>标签中增加<code>&lt;router-view/&gt;</code>路由组件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-aside width="200px"&gt;</span><br><span class="line">        &lt;el-menu</span><br><span class="line">          class="el-menu-vertical-demo"</span><br><span class="line">          @open="handleOpen"</span><br><span class="line">          @close="handleClose"</span><br><span class="line">          :default-active="$route.path"</span><br><span class="line">          router&gt;</span><br><span class="line">          &lt;el-menu-item index="/linkMgt"&gt;</span><br><span class="line">            &lt;i class="el-icon-s-grid"&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span slot="title"&gt;链接管理&lt;/span&gt;</span><br><span class="line">          &lt;/el-menu-item&gt;</span><br><span class="line">          &lt;el-menu-item index="/systemConfig"&gt;</span><br><span class="line">            &lt;i class="el-icon-s-tools"&gt;&lt;/i&gt;</span><br><span class="line">            &lt;span slot="title"&gt;系统配置&lt;/span&gt;</span><br><span class="line">          &lt;/el-menu-item&gt;</span><br><span class="line">        &lt;/el-menu&gt;</span><br><span class="line">      &lt;/el-aside&gt;</span><br><span class="line">      &lt;el-container&gt;</span><br><span class="line">        &lt;el-header&gt;{{header}}&lt;/el-header&gt;</span><br><span class="line">        &lt;el-main&gt;&lt;router-view/&gt;&lt;/el-main&gt;</span><br><span class="line">      &lt;/el-container&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/10.png"></p>
<p><strong>步骤2：创建菜单对应的 vue 组件</strong></p>
<p>创建菜单对应的 vue 组件：</p>
<p>SystemConfig.vue</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;系统配置页面&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: "SystemConfig"</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>LinkMgt.vue</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;h1&gt;链接管理页面&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: "LinkMgt"</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3：配置路由</strong></p>
<p>在<code>router/index.js</code>配置中将路由与步骤 2 创建的组件关联：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">'@/components/Index'</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LinkMgt</span> <span class="keyword">from</span> <span class="string">"@/components/LinkMgt"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SystemConfig</span> <span class="keyword">from</span> <span class="string">"@/components/SystemConfig"</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>({</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">'history'</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'Index'</span>,</span><br><span class="line">      <span class="attr">redirect</span>:<span class="string">'LinkMgt'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Index</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'/linkMgt'</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'LinkMgt'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">LinkMgt</span></span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      <span class="attr">path</span>: <span class="string">'/systemConfig'</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">'SystemConfig'</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">SystemConfig</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p>注意：</p>
<ul>
<li>上述配置中对 Router 对象加了<code>mode: 'history'</code>，这样路由地址中就会去除 # 号。</li>
<li>首页路由增加了<code>redirect</code>，访问首页直接重定向到<code>/linkMgt</code></li>
</ul>
<p>导航菜单支持动态路由效果如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/11.gif"></p>
<h2 id="引入-ECharts-组件"><a href="#引入-ECharts-组件" class="headerlink" title="引入 ECharts 组件"></a>引入 ECharts 组件</h2><blockquote>
<p><code>ECharts</code>官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p>
</blockquote>
<p><strong>步骤1：安装 ECharts</strong></p>
<p>停止运行中的项目，在项目根据目录安装<code>ECharts</code>依赖：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2：将 ECharts 定义到 vue 的原型上</strong></p>
<p>在<code>main.js</code>配置文件中将 ECharts 定义到 vue 的原型上：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$echarts</span> = echarts;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/12.png"></p>
<p><strong>步骤3：在组件中引入 ECharts 图表组件</strong></p>
<p>在<code>LinkMgt.vue</code>组件中引入<code>ECharts</code>图表组件：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref="myEcharts" style="width: 600px;height:400px;"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  mounted() {</span><br><span class="line">    this.init();</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    init() {</span><br><span class="line">      let myChart = this.$echarts.init(this.$refs.myEcharts);</span><br><span class="line">      // 绘制图表</span><br><span class="line">      let option;</span><br><span class="line">      option = {</span><br><span class="line">        title: {</span><br><span class="line">          text: 'ECharts demo'</span><br><span class="line">        },</span><br><span class="line">        xAxis: {</span><br><span class="line">          data: ["Java", "C", "C++", "Python", "Go", "Ruby"]</span><br><span class="line">        },</span><br><span class="line">        yAxis: {},</span><br><span class="line">        series: [{</span><br><span class="line">          name: '熟练度',</span><br><span class="line">          type: 'bar',</span><br><span class="line">          data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">        }]</span><br><span class="line">      };</span><br><span class="line"></span><br><span class="line">      // 使用刚指定的配置项和数据显示图表。</span><br><span class="line">      myChart.setOption(option);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>引入 Echarts 效果如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/13.png"></p>
<h2 id="引入-element-ui-动态表格"><a href="#引入-element-ui-动态表格" class="headerlink" title="引入 element-ui 动态表格"></a>引入 element-ui 动态表格</h2><p><strong>步骤1：安装 mock 服务</strong></p>
<p>使用 npm 安装<code>json-server</code>服务：</p>
<blockquote>
<p>  官网地址：<a href="https://github.com/typicode/json-server">https://github.com/typicode/json-server</a></p>
</blockquote>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></tbody></table></figure>

<p>在一个空目录中创建<code>db.json</code>文件：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"tableData"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"code"</span><span class="punctuation">:</span> <span class="string">"0"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"msg"</span><span class="punctuation">:</span> <span class="string">"success"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"data"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"date"</span><span class="punctuation">:</span> <span class="string">"2017-05-22"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"张三"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"address"</span><span class="punctuation">:</span> <span class="string">"上海市普陀区"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span> <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"date"</span><span class="punctuation">:</span> <span class="string">"2018-11-11"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"李四"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"address"</span><span class="punctuation">:</span> <span class="string">"北京市朝阳区"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span> <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"date"</span><span class="punctuation">:</span> <span class="string">"2019-10-06"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"王五"</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">"address"</span><span class="punctuation">:</span> <span class="string">"广东省深圳市"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>在<code>db.json</code>文件所在目录执行命令，启动 mock 服务：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">json-server --watch db.json</span><br></pre></td></tr></tbody></table></figure>

<p><code>json-server</code>服务启动成功如图：</p>
<p><img src="https://image.woodwhales.cn/086/images/14.png"></p>
<p>浏览器访问<a href="http://localhost:3000即可看到`db.json`配置中的">http://localhost:3000即可看到`db.json`配置中的</a> mock 接口：</p>
<p><img src="https://image.woodwhales.cn/086/images/15.png"></p>
<p>点击上图中的<code>tableData</code>接口可以看到响应成功的 json 报文：</p>
<p><img src="https://image.woodwhales.cn/086/images/16.png"></p>
<p><strong>步骤2：引入<code>axios</code>依赖</strong></p>
<p>停止项目运行，在项目根目录下执行安装命令：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></tbody></table></figure>

<p>在<code>main.js</code>配置文件中将 axios 定义到 vue 的原型上：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">import axios from 'axios';</span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/17.png"></p>
<p><strong>步骤3：引入动态表格组件</strong></p>
<blockquote>
<p>  Table 表格：<a href="https://element.eleme.cn/#/zh-CN/component/table">https://element.eleme.cn/#/zh-CN/component/table</a></p>
</blockquote>
<p>在<code>SystemConfig.vue</code>组件中将动态表格组件引入：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-table</span><br><span class="line">    :data="tableData"</span><br><span class="line">    style="width: 100%"&gt;</span><br><span class="line">    &lt;el-table-column</span><br><span class="line">      prop="date"</span><br><span class="line">      label="日期"</span><br><span class="line">      width="180"&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column</span><br><span class="line">      prop="name"</span><br><span class="line">      label="姓名"</span><br><span class="line">      width="180"&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column</span><br><span class="line">      prop="address"</span><br><span class="line">      label="地址"&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">  &lt;/el-table&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default {</span><br><span class="line">  name: "SystemConfig",</span><br><span class="line">  data() {</span><br><span class="line">    return {</span><br><span class="line">      tableData: null</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  mounted() {</span><br><span class="line">    this.getTableData();</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">    getTableData() {</span><br><span class="line">      this.$axios.get('http://localhost:3000/tableData')</span><br><span class="line">        .then(resp =&gt; {</span><br><span class="line">          this.tableData = resp.data.data;</span><br><span class="line">        })</span><br><span class="line">        .catch(error =&gt; {</span><br><span class="line">          console.log(error)</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>由于<code>&lt;el-main&gt;</code>包裹表格导致表格的表头异常高，可以在<code>Index.vue</code>中将<code>.el-main</code>样式中的<code>line-height</code>样式删除：</p>
<p><img src="https://image.woodwhales.cn/086/images/18.png"></p>
<p>整个页面与浏览器边界有“留白”，可以在<code>App.vue</code>中增加样式</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue-demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">html</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span>,</span></span><br><span class="line"><span class="language-css">      <span class="selector-id">#app</span> {</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">      }</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>具体改动如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/19.png"></p>
<p>引入动态表格效果如下：</p>
<p><img src="https://image.woodwhales.cn/086/images/20.png"></p>
]]></content>
      <categories>
        <category>Vue + Element UI</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle 入门学习笔记</title>
    <url>/2022/07/02/087/</url>
    <content><![CDATA[<h2 id="安装-gradle"><a href="#安装-gradle" class="headerlink" title="安装 gradle"></a>安装 gradle</h2><p>gradle 官网：<a href="https://gradle.org/">https://gradle.org/</a></p>
<p>gradle 所有版本下载：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p>
<p>gradle 与 IDEA 版本兼容确认</p>
<p>在 IDEA 安装目录的 <code>plugins\gradle\lib</code> 下有如下gradle相关 jar 文件：</p>
<p><img src="https://image.woodwhales.cn/087/images/01.png"></p>
<p>笔者是 7.4 版本，点击下载二进制文件链接即可下载 gradle 文件：</p>
<p><img src="https://image.woodwhales.cn/087/images/02.png"></p>
<blockquote>
<p>  注意：</p>
<p>  完整版是包含了 gradle 的文档和源码</p>
<p>  安装 gradle 必须要求系统有安装 JDK 1.8 +</p>
<p>  官方安装说明：<a href="https://docs.gradle.org/current/userguide/installation.html">https://docs.gradle.org/current/userguide/installation.html</a></p>
</blockquote>
<p>具体安装教程请移步至：<a href="https://woodwhales.cn/2020/03/14/062/">构建工具maven及gradle的安装及IDE配置</a></p>
<h2 id="gradle-项目目录结构"><a href="#gradle-项目目录结构" class="headerlink" title="gradle 项目目录结构"></a>gradle 项目目录结构</h2><p>Gradle 项目默认目录结构和Maven 项目的目录结构一致，都是基于约定大于配置【Convention Over Configuration】。其完整项目目录结构如下所示：</p>
<p><img src="https://image.woodwhales.cn/087/images/03.png"></p>
<p>上图说明：</p>
<ol>
<li>只有 war 工程才有 webapp 目录，对于普通的 jar 工程并没有 webapp 目录。</li>
<li>gradlew 与 gradlew.bat 执行的 wrapper 目录下的 gradle 指令，不是本地安装的 gradle 指令。</li>
<li>因此如果仅仅使用本地 gradle 构建项目，可以删除 gradlew、gradlew.bat、wrapper文件（及子文件），但是不是可以删除 gradle 文件目录。</li>
<li>gradle 的 build 目录与 maven 的 target 目录类似，gradle 的 src 目录与 maven 的 src 目录一样。</li>
<li>一个工程只有一个 settings.gradle 文件，即 maven 的父子工程中的父工程目录下含该文件，其他子工程不含该文件。</li>
<li>gradle 的 build.gradle 文件与 maven 的 pom.xml 文件类似，一个 project 就含有一个该文件。</li>
</ol>
<h2 id="创建-gradle-项目"><a href="#创建-gradle-项目" class="headerlink" title="创建 gradle 项目"></a>创建 gradle 项目</h2><p>使用 spring 或者 aliyun 提供的脚手架创建基础的 gradle 项目：</p>
<p><a href="https://start.aliyun.com/bootstrap.html">https://start.aliyun.com/bootstrap.html</a></p>
<p><a href="https://start.spring.io/">https://start.spring.io/</a></p>
<p><img src="https://image.woodwhales.cn/087/images/04.png"></p>
<p>将下载的 gradle 项目压缩文件解压，得到如下目录结构：</p>
<p><img src="https://image.woodwhales.cn/087/images/05.png"></p>
<p>上述文件目录中没有 build 目录，因为项目没有编译，等项目编译之后就会有 build 目录了。</p>
<h2 id="gradle-常用命令"><a href="#gradle-常用命令" class="headerlink" title="gradle 常用命令"></a>gradle 常用命令</h2><table>
<thead>
<tr>
<th>gradle 常用命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>gradle clean</td>
<td>清空 build 目录</td>
</tr>
<tr>
<td>gradle classes</td>
<td>编译 src 目录下的代码</td>
</tr>
<tr>
<td>gradle test</td>
<td>编译测试代码，生成测试报告</td>
</tr>
<tr>
<td>gradle build</td>
<td>构建项目</td>
</tr>
<tr>
<td>gradle build -x test</td>
<td>构建项目但是跳过构建测试代码</td>
</tr>
</tbody></table>
<p>注意：gradle 的指令要在含有 build.gradle 的目录位置才能执行。</p>
<p>编译测试代码之后，在 build\reports\tests\test 文件目录下有测试报告。</p>
<p>build 成功的 jar 包在 build\libs 文件目录下。</p>
<h2 id="添加镜像"><a href="#添加镜像" class="headerlink" title="添加镜像"></a>添加镜像</h2><p>Gradle 自带的 Maven 源地址是国外的，该 Maven 源在国内的访问速度是很慢的，除非使用了特别的手段。一般情况下，我们建议使用国内的第三方开放的 Maven 源或企业内部自建 Maven 源。</p>
<p>我们可以在gradle 的init.d 目录下创建以.gradle 结尾的文件，.gradle 文件可以实现在build 开始之前执行，所以可以在这个文件配置一些你想预先加载的操作。</p>
<p>在<code>init.d</code>文件夹创建<code>init.gradle</code>文件：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line">allprojects {</span><br><span class="line">    repositories {</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven { name <span class="string">"Alibaba"</span> ; url <span class="string">"https://maven.aliyun.com/repository/public"</span> } </span><br><span class="line">        maven { name <span class="string">"Bstek"</span> ; url <span class="string">"https://nexus.bsdn.org/content/groups/public/"</span> } </span><br><span class="line">        mavenCentral()</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    buildscript {</span><br><span class="line">        repositories {</span><br><span class="line">            maven { name <span class="string">"Alibaba"</span> ; url <span class="string">'https://maven.aliyun.com/repository/public'</span> } </span><br><span class="line">            maven { name <span class="string">"Bstek"</span> ; url <span class="string">'https://nexus.bsdn.org/content/groups/public/'</span> } </span><br><span class="line">            maven { name <span class="string">"M2"</span> ; url <span class="string">'https://plugins.gradle.org/m2/'</span> }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>mavenLocal()：指定使用maven本地仓库，而本地仓库在配置maven时settings文件指定的仓库位置。gradle 查找 jar包顺序如下：USER_HOME/.m2/settings.xml &gt;&gt; M2_HOME/conf/settings.xml &gt;&gt; USER_HOME/.m2/repository。</p>
<p>阿里云仓库地址请参考：<a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p>
<h2 id="启用-init-gradle-文件的方法"><a href="#启用-init-gradle-文件的方法" class="headerlink" title="启用 init.gradle 文件的方法"></a>启用 init.gradle 文件的方法</h2><ol>
<li>在命令行指定文件，例如：gradle –init-script yourdir/init.gradle -q taskName。可以多次输入此命令来指定多个 init.gradle 文件</li>
<li>把 init.gradle 文件放到 USER_HOME/.gradle/ 目录下</li>
<li>把以 .gradle 结尾的文件放到 USER_HOME/.gradle/init.d/ 目录下</li>
<li>把以 .gradle 结尾的文件放到 GRADLE_HOME/init.d/ 目录下</li>
</ol>
<p>如果存在上面的 4 种方式的 2 种以上，gradle 会按上面的 1-4 序号依次执行这些文件，如果给定目录下存在多个 init 脚本，会按拼音 a-z 顺序执行这些脚本，每个 init 脚本都存在一个对应的 gradle 实例。</p>
<h2 id="gradle-拉取远程依赖存储过程"><a href="#gradle-拉取远程依赖存储过程" class="headerlink" title="gradle 拉取远程依赖存储过程"></a>gradle 拉取远程依赖存储过程</h2><p>gradle 可以通过指定仓库地址为本地 maven 仓库地址和远程仓库地址相结合的方式，避免每次都会去远程仓库下载依赖库。这种方式也有一定的问题，如果本地 maven 仓库有这个依赖，就会从直接加载本地依赖，如果本地仓库没有该依赖，那么还是会从远程下载。但是下载的 jar 不是存储在本地 maven 仓库中，而是放在自己的缓存目录中，默认在 USER_HOME/.gradle/caches 目录，如果我们配置过<code>GRADLE_USER_HOME</code>环境变量，则会放在GRADLE_USER_HOME/caches 目录中。因为 caches下载的文件不是按照 maven 仓库中存放的方式存储，所以gradle 不可以将 gradle caches 指向 maven repository。</p>
<h2 id="Wrapper-包装器"><a href="#Wrapper-包装器" class="headerlink" title="Wrapper 包装器"></a>Wrapper 包装器</h2><p>Gradle Wrapper 实际上就是对 Gradle 的一层包装，用于解决实际开发中可能会遇到的不同的项目需要不同版本的 Gradle。</p>
<p>例如：把自己的代码共享给其他人使用，可能出现如下情况：</p>
<ol>
<li>对方电脑没有安装 gradle</li>
<li>对方电脑安装过 gradle，但是版本太旧了</li>
</ol>
<p>这时候，我们就可以考虑使用官方推荐的 Gradle Wrapper，上有了 Gradle Wrapper 之后，我们本地是可以不配置 Gradle 系统环境变量，下载 Gradle 项目后，使用 gradle 项目中自带的 wrapper 配置可以完成项目构建。</p>
<p>项目中的 gradlew、gradlew.bat 脚本用的就是 wrapper 中规定的gradle版本。</p>
<h3 id="修改-wrapper-中的-gradle-版本"><a href="#修改-wrapper-中的-gradle-版本" class="headerlink" title="修改 wrapper 中的 gradle 版本"></a>修改 wrapper 中的 gradle 版本</h3><p>使用指令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gradle wrapper --gradle-version=7.4.2</span><br></pre></td></tr></tbody></table></figure>

<p>下述是一个 wrapper 配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-7.4.2-bin.zip</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></tbody></table></figure>

<p>上述 wrapper 配置意味着第一次使用 gradlew 或者 gradlew.bat 脚本执行项目构建时，从 distributionUrl 配置的地址下载 gradle 压缩包，保存到 zipStoreBase 和 zipStorePath 配置的文件目录中，解压 gradle 压缩包并保存至 distributionBase 和 distributionPath 配置的文件目录中。</p>
<h3 id="wrapper-执行流程"><a href="#wrapper-执行流程" class="headerlink" title="wrapper 执行流程"></a>wrapper 执行流程</h3><ol>
<li>当我们第一次执行 ./gradlew build 命令的时候，gradlew 会读取 gradle-wrapper.properties 文件的配置信息</li>
<li>准确的将指定版本的 gradle 下载并解压到指定的位置( GRADLE_USER_HOME 目录下的 wrapper/dists 目录中)</li>
<li>并构建本地缓存(GRADLE_USER_HOME目录下的caches目录中)，下次再使用相同版本的 gradle 就不用下载了</li>
<li>之后执行的 ./gradlew 所有命令都是使用指定的 gradle 版本。</li>
</ol>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy 学习笔记</title>
    <url>/2022/07/02/088/</url>
    <content><![CDATA[<p>Groovy 是一种基于Java 平台的面向对象语言。 Groovy 1.0 于 2007 年 1 月 2 日发布，其中 Groovy 2.4 是当前的主要版本。 Groovy 通过 Apache License v 2.0 发布。</p>
<p>Groovy 官网：<a href="https://groovy-lang.org/">https://groovy-lang.org/</a></p>
<p>阿里云镜像下载：<a href="https://mirrors.aliyun.com/apache/groovy/">https://mirrors.aliyun.com/apache/groovy/</a></p>
<h2 id="Groovy-基本语法"><a href="#Groovy-基本语法" class="headerlink" title="Groovy 基本语法"></a>Groovy 基本语法</h2><p>官方文档：<a href="http://www.groovy-lang.org/syntax.html">http://www.groovy-lang.org/syntax.html</a></p>
<ol>
<li><p>在一个 groovy 文件中可以定义类和脚本。</p>
</li>
<li><p>变量、方法建议使用 def 定义，而不使用具体的数据类型定义。</p>
</li>
<li><p>groovy 的注释方式和 Java 一样，有单行和多行俩种。</p>
</li>
<li><p>语句末尾的分号可以省略，groovy 是以换行作为一行代码的结束。</p>
</li>
<li><p>默认类、方法、字段都是 public 修饰。</p>
</li>
<li><p>对象属性的操作：</p>
<ul>
<li>读取：<ul>
<li>对象.属性名</li>
<li>对象的 getter 方法</li>
<li>对象[“属性名”]</li>
</ul>
</li>
<li>赋值：<ul>
<li>对象.属性名 = xxx</li>
<li>对象的 setter 方法</li>
<li>构造器</li>
</ul>
</li>
</ul>
<p>对类属性的操作本质是：通过属性对应的 getter 、setter 方法完成。</p>
</li>
<li><p>方法操作：</p>
<ul>
<li>声明时：参数类型、返回值类型可以省略</li>
<li>调用时：() 可以省略</li>
</ul>
</li>
<li><p>支持顺序结构、分支结构、循环结构、各种运算符（算术、关系、位、赋值、范围运算符）</p>
</li>
<li><p>基本类型也是对象，可以直接调用对象的方法</p>
</li>
<li><p>groovy 中的字符串有单引号、双引号、三引号：</p>
<ul>
<li>单引号：作为字符串常量，没有运算能力</li>
<li>双引号：可以引用变量，使用<code>${}</code>占位，有运算能力</li>
<li>三引号：模板字符串，支持换行</li>
</ul>
</li>
<li><p>数据类型：变量、属性、方法、闭包的参数及方法的返回值类型都是可有可无，都是在变量赋值的时候才决定其类型。</p>
</li>
</ol>
<h2 id="IDEA-创建-Groovy-项目"><a href="#IDEA-创建-Groovy-项目" class="headerlink" title="IDEA 创建 Groovy 项目"></a>IDEA 创建 Groovy 项目</h2><p>使用 idea 创建 Groovy 项目，主要需要指定本地安装的 groovy sdk：</p>
<p><img src="https://image.woodwhales.cn/088/images/01.png"></p>
<h3 id="创建-hello-world-程序"><a href="#创建-hello-world-程序" class="headerlink" title="创建 hello world 程序"></a>创建 hello world 程序</h3><h2 id="groovy-类"><a href="#groovy-类" class="headerlink" title="groovy 类"></a>groovy 类</h2><p>在 src 目录下创建 Demo1.groovy 文件：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        print(<span class="string">'woodwhales.cn'</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过编译后的 class 文件可以看出，当前 Demo1 类实现了 GroovyObject 接口：</p>
<p><img src="https://image.woodwhales.cn/088/images/02.png"></p>
<h2 id="groovy-脚本"><a href="#groovy-脚本" class="headerlink" title="groovy 脚本"></a>groovy 脚本</h2><p>在 src 目录下创建 Demo2.groovy 文件：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> website = <span class="string">'woodwhlaes.cn'</span></span><br><span class="line"></span><br><span class="line">print(website)</span><br></pre></td></tr></tbody></table></figure>

<p>通过编译后的 class 文件可以看出，当前 Demo1 类继承了 Script：</p>
<p><img src="https://image.woodwhales.cn/088/images/03.png"></p>
<h2 id="groovy-闭包"><a href="#groovy-闭包" class="headerlink" title="groovy 闭包"></a>groovy 闭包</h2><p>闭包是一个短的匿名代码块。它通常跨越几行代码。一个方法甚至可以将代码块作为参数。它们是匿名的。</p>
<p>来一个简单的例子：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        <span class="keyword">def</span> closure = { println <span class="string">"woodwhales.cn"</span> };</span><br><span class="line">        closure.call();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，代码<code>{ println "woodwhales.cn" }</code>被称为闭包。此标识符引用的代码块可以使用 call 语句执行。</p>
<p>当我们运行上面的程序，我们将得到以下结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">woodwhales.cn</span><br></pre></td></tr></tbody></table></figure>

<h3 id="闭包中的形式参数"><a href="#闭包中的形式参数" class="headerlink" title="闭包中的形式参数"></a>闭包中的形式参数</h3><p>闭包也可以包含形式参数，以使它们更有用，就像Groovy中的方法一样。</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        <span class="keyword">def</span> closure = { website -&gt; println <span class="string">"welcome ${website}"</span> };</span><br><span class="line">        closure.call(<span class="string">"woodwhales.cn"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的代码示例中，注意使用<code>${website}</code>，这导致 closure 接受一个参数。当通过 closure.call 语句调用闭包时，我们现在可以选择将一个参数传递给闭包。</p>
<p>当我们运行上面的程序，我们将得到以下结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">welcome woodwhales.cn</span><br></pre></td></tr></tbody></table></figure>

<h3 id="闭包和变量"><a href="#闭包和变量" class="headerlink" title="闭包和变量"></a>闭包和变量</h3><p>更正式地，闭包可以在定义闭包时引用变量。以下是如何实现这一点的示例。</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        <span class="keyword">def</span> str1 = <span class="string">"欢迎访问"</span></span><br><span class="line">        <span class="keyword">def</span> closure = { website -&gt; println <span class="string">"${str1} ${website}"</span> };</span><br><span class="line">        closure.call(<span class="string">"woodwhales.cn"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在上面的例子中，除了向闭包传递参数之外，我们还定义了一个名为 str1 的变量。闭包也接受变量和参数。</p>
<p>当我们运行上面的程序，我们将得到以下结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">欢迎访问 woodwhales.cn</span><br></pre></td></tr></tbody></table></figure>

<p>由于参数定义和获取是明确的，<code>{}</code>花括号也可以省略：</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        <span class="keyword">def</span> str1 = <span class="string">"欢迎访问"</span></span><br><span class="line">        <span class="keyword">def</span> closure = { website -&gt; println <span class="string">"$str1 $website"</span> };</span><br><span class="line">        closure.call(<span class="string">"woodwhales.cn"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="在方法中使用闭包"><a href="#在方法中使用闭包" class="headerlink" title="在方法中使用闭包"></a>在方法中使用闭包</h3><p>闭包也可以用作方法的参数。在 Groovy 中，很多用于数据类型（例如列表和集合）的内置方法都有闭包作为参数类型。</p>
<figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> showMe(closure) {</span><br><span class="line">        closure.call(<span class="string">"\n版权所有woodwhales.cn"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> main(String[] args) {</span><br><span class="line">        <span class="keyword">def</span> note = <span class="string">"groovy 学习笔记"</span>;</span><br><span class="line">        <span class="keyword">def</span> closure = { copyright -&gt; println <span class="string">"${note} ${copyright}"</span> }</span><br><span class="line">        Demo4.showMe(closure);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">groovy 学习笔记 </span><br><span class="line">版权所有woodwhales.cn</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>groovy</category>
      </categories>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念左耳朵耗子</title>
    <url>/2023/05/23/089/</url>
    <content><![CDATA[<blockquote>
<p>读者有和左耳朵耗子有关的故事，可以向 <a href="https://github.com/megaease/Remembering-Haoel">Remembering-Haoel</a> 项目提交 PR 进行分享以纪念陈皓前辈。也可以在<a href="https://memorial.megaease.cn/">陈皓追思网站</a>上表达悼念。</p>
</blockquote>
<h2 id="初识博客"><a href="#初识博客" class="headerlink" title="初识博客"></a>初识博客</h2><p>2013 年，大一期末临近，烦于迅雷播放器、360全家桶等各种“流氓功能及陷阱”，萌生了想学编程开发一个纯净的视频播放器。作为非科班的零基础小白，认知中搜索引擎只有百度和bing，搜索网络信息的唯一途径就是百度。</p>
<p>在胡乱搜索的过程中，无意中发现了：酷壳（<a href="https://coolshell.cn/">https://coolshell.cn</a>），博客给我提示了个醒目弹窗：</p>
<p><img src="https://image.woodwhales.cn/089/01.png"></p>
<p>看了《<a href="https://coolshell.cn/articles/9308.html">“作环保的程序员，从不用百度开始”</a>》和《<a href="https://coolshell.cn/articles/7186.html">做个环保主义的程序员</a>》，博客简洁的风格给我留一下一个印象：这个博客作者是个对技术有追求的人。</p>
<p>顺着博客的左侧推荐文章，又阅读了《<a href="https://coolshell.cn/articles/8275.html">对九个超级程序员的采访</a>》，这篇文章是作者翻译的，但通读的过程像是作者亲口告诉我们，什么是卓越的程序员。</p>
<p>鉴于当时在自学 HTML 和 ASP ，一心想学的是如何做出作品，并没有决心要做一名程序员，学编程仅仅是兴趣，搜索的主要内容是“术”不是“道”，没有通读博客中每一遍博文，但心里已经深刻印象，这个叫左耳朵耗子的博客作者是个高手。</p>
<h2 id="认识左耳朵耗子"><a href="#认识左耳朵耗子" class="headerlink" title="认识左耳朵耗子"></a>认识左耳朵耗子</h2><p>后来看到图灵社区对他的采访，那时给我的印象是能被图灵社区采访，第一次看到耗子叔的图片（印象中记得是他在银行做开发时拍摄的），大佬气息扑面而来。</p>
<p><img src="https://image.woodwhales.cn/089/02.jpg"></p>
<p>2016 年，看过耗子叔的《<a href="https://coolshell.cn/articles/17391.html">为什么我不在微信公众号上写文章</a>》，里面讲到一个观点：微信的信息比闭塞的，微信不是真正的互联网，技术人可以在自己的博客上输出自己的观点，不受平台约束、绑架，另外可以提升影响力。苦于自己还是个技术门外汉，唯一能想到对外输出的是到微信公众号发布一些文绉绉的文字。</p>
<p>2017 年 4 月后，看到《初心》系列纪录片《<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996268&amp;idx=1&amp;sn=d94041b9d0a2ef3423c23adae4b1474f&amp;chksm=bdbf067f8ac88f693328b562c2363f2e9026d99357b79da65ef936c030844513bffa42bde3b4&amp;scene=27#wechat_redirect">左耳朵耗子：技术一定会让人失业，但我没有生不逢时</a>》，那时才知道耗子叔现在真人样子，并且他开始创业了，创办了 <a href="https://megaease.com/">MegaEase</a>。</p>
<p>2017 年 10 月中旬，决心放弃本职职位，追随兴趣，裸辞自学编程，转行做一名程序员。能做出让人非议的决定，其中多少也有受耗子叔诸多的博文中透露的技术、人格魅力所影响。希望自己也能成为像耗子叔一样，成为有技术底蕴、技术人魅力的技术人。</p>
<p>在自学编程的过程中，也拜读过《<a href="https://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>》，后来耗子叔与极客时间合作，推出了“专业版程序员技术练级攻略的”——《<a href="https://coolshell.cn/articles/18360.html">程序员练级攻略（2018) 与我的专栏</a>》，对我们技术人来说是如获至宝，耗子叔一如既往秉持“传道”的博文风格，知识体系完整且有深度。练级攻略的核心是给我们打开视野边界、让我们思考问题不要停留于技术知识的浅层面，而是要深入其技术源头、理解技术本质。</p>
<p>耗子叔的博文不仅限于技术知识的沉淀与思考，对于职场、职业的思考也是让人受益匪浅，感谢耗子叔的无私分享。</p>
<p>耗子叔的技术影响力潜移默化的正向影响了我，2018 年我也效仿耗子叔，搭建属于自己的博客：<a href="https://woodwhales.cn/">woodwhales.cn</a>，记录在技术道路上积累的点滴，做个“环保主义程序员”。向耗子叔看齐，做个有技术魅力、影响力的人。</p>
<h2 id="耗子叔一路走好"><a href="#耗子叔一路走好" class="headerlink" title="耗子叔一路走好"></a>耗子叔一路走好</h2><p>我很久不看微信公众号文章，15 日早上坐地铁看到冯大辉的公众号里发了篇博文《清晨的告别》。文中提及一位朋友，生前花了很多时间写博客文章，分享技术心得，让很多人收益。隐隐感觉是为我也熟悉的人，评论区看到有人贴了耗子叔曾经在微博发的三句话翻译：</p>
<p align="center">
Great minds discuss ideas
卓越之识论道，
Average minds discuss events
平常之识论事，
Small minds discuss people
狹隘之识论人。
</p>
卓越的左耳朵耗子，Rest in peace。
]]></content>
      <categories>
        <category>纪念左耳朵耗子</category>
      </categories>
      <tags>
        <tag>纪念左耳朵耗子</tag>
      </tags>
  </entry>
  <entry>
    <title>JetLinks设备接入的认识与理解</title>
    <url>/2023/11/19/090/</url>
    <content><![CDATA[<h2 id="1、认识-JetLinks"><a href="#1、认识-JetLinks" class="headerlink" title="1、认识 JetLinks"></a>1、认识 JetLinks</h2><h3 id="1-1、官网文档"><a href="#1-1、官网文档" class="headerlink" title="1.1、官网文档"></a>1.1、官网文档</h3><p>官网：<a href="https://www.jetlinks.cn/">https://www.jetlinks.cn/</a></p>
<p>JetLinks 有两个产品：<a href="https://www.jetlinks.cn/#/production/iot">JetLinks-lot</a>和<a href="https://www.jetlinks.cn/#/production/view">JetLinks-view</a></p>
<p>官方文档：</p>
<ul>
<li><p><a href="https://hanta.yuque.com/px7kg1/yfac2l">JetLinks 物联网基础平台</a></p>
</li>
<li><p><a href="https://hanta.yuque.com/px7kg1/nn1gdr">JetLinks 物联网平台开发手册</a></p>
</li>
</ul>
<h3 id="1-2、JetLinks"><a href="#1-2、JetLinks" class="headerlink" title="1.2、JetLinks"></a>1.2、JetLinks</h3><p>JetLinks 是可支持多种方式接入设备的物联网设备管理平台</p>
<blockquote>
<p><a href="https://hanta.yuque.com/px7kg1/yfac2l/fwqriw24lp3cy2lw">https://hanta.yuque.com/px7kg1/yfac2l/fwqriw24lp3cy2lw</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/090/03-jetlinks.png"></p>
<p>JetLinks IOT 是一个开源的、企业级的物联网平台，它集成了设备管理、数据安全通信、消息订阅、规则引擎等一系列物联网核心能力，支持以平台适配设备的方式连接海量设备，采集设备数据上云，提供云端API，通过调用云端API实现远程控制。JetLinks物联网平台还支持多种设备接入协议，并提供了丰富的协议库。</p>
<p>支持：多协议（MQTT、HTTP、CoAP、UDP、TCP、WebSocket）自定义编解码插件接入；</p>
<p>支持：云平台对接接入；</p>
<p>支持： ModBus/TCP、OPC UA通道接入；</p>
<p>支持：基于GB/T 28181国标协议视频接入；</p>
<p>支持：自研边缘计算网关接入。</p>
<h3 id="1-3、产品架构的理解"><a href="#1-3、产品架构的理解" class="headerlink" title="1.3、产品架构的理解"></a>1.3、产品架构的理解</h3><blockquote>
<p><a href="https://hanta.yuque.com/px7kg1/yfac2l/tvlxz93cht8zyl94">https://hanta.yuque.com/px7kg1/yfac2l/tvlxz93cht8zyl94</a></p>
</blockquote>
<h4 id="1-3-1、理解1"><a href="#1-3-1、理解1" class="headerlink" title="1.3.1、理解1"></a>1.3.1、理解1</h4><p>通过不同层级功能职责的封装、组合，以支持多设备、多协议接入平台</p>
<p><img src="https://image.woodwhales.cn/090/04-jetlinks.png"></p>
<ol>
<li><p>设备连接层：支持MQTT、TCP、UDP、CoAP、HTTP、WebSocket协议，提供统一设备接入的能力。 </p>
</li>
<li><p>设备管理层：提供设备注册、配置、维护和监控的功能，支持设备属性、状态实时展示和历史属性、设备日志记录查询等。</p>
</li>
<li><p>业务逻辑层：提供规则引擎、数据转发和数据解析等功能，支持多种业务场景下的数据处理和交互操作。</p>
</li>
<li><p>应用开发层：提供RESTAPI和WebSocket接口，支持前端对接和自定义应用开发。同时还提供了可视化的数据展示和操作页面，方便用户快速搭建物联网应用系统。</p>
</li>
</ol>
<h4 id="1-3-2、理解2"><a href="#1-3-2、理解2" class="headerlink" title="1.3.2、理解2"></a>1.3.2、理解2</h4><p>设备接入JetLinks物联网平台后，可实现：设备通讯、数据的采集、认证、流转、存储、分析和实时监控</p>
<p><img src="https://image.woodwhales.cn/090/05-jetlinks.png"></p>
<h4 id="13-3、理解3"><a href="#13-3、理解3" class="headerlink" title="13.3、理解3"></a>13.3、理解3</h4><p>开发者需要自行实现编解码器逻辑，才可以让平台对设备数据进行全面管理</p>
<p><img src="https://image.woodwhales.cn/090/06-jetlinks.png"></p>
<h3 id="1-4、基本概念"><a href="#1-4、基本概念" class="headerlink" title="1.4、基本概念"></a>1.4、基本概念</h3><blockquote>
<p><a href="https://hanta.yuque.com/px7kg1/yfac2l/dagxgfzc3vnul0sn">https://hanta.yuque.com/px7kg1/yfac2l/dagxgfzc3vnul0sn</a></p>
</blockquote>
<h4 id="1-4-1、产品"><a href="#1-4-1、产品" class="headerlink" title="1.4.1、产品"></a>1.4.1、产品</h4><p><strong>产品是指一组具有相同功能和规格的设备集合，通常由同一家生产厂家制造。</strong></p>
<p>设备可能是传感器、执行器、控制器等各种不同类型的物联网设备，它们可以通过网络连接到物联网平台。通过将这些设备组合到一个产品中，企业可以对这些设备进行统一管理和监控，以便更有效地控制其行为和状态。</p>
<h4 id="1-4-2、设备"><a href="#1-4-2、设备" class="headerlink" title="1.4.2、设备"></a>1.4.2、设备</h4><p><strong>设备是指物理存在的、可通过网络连接的单个物联网设备。</strong></p>
<p>设备可以是各种类型的物品，例如传感器、执行器、控制器等。这些设备通过物联网连接到平台，以便与其他设备或应用程序进行通信、交换数据和接收命令。</p>
<h4 id="1-4-3、物模型"><a href="#1-4-3、物模型" class="headerlink" title="1.4.3、物模型"></a>1.4.3、物模型</h4><blockquote>
<p>物模型说明：<a href="http://doc.jetlinks.cn/function-description/metadata_description.html">http://doc.jetlinks.cn/function-description/metadata_description.html</a></p>
</blockquote>
<p><strong>物模型是物理空间中的实体在云端的数字化表示，有 4 个纬度：属性、功能、事件、标签。</strong></p>
<ul>
<li><p>属性：用于描述设备运行时具体信息和状态。例如温湿度传感器包含“温度”、“湿度”两个属性。</p>
</li>
<li><p>功能：设备可被外部调用的能力或方法，可设置输入参数和输出参数。相比于属性，服务可通过一条指令实现更复杂的业务逻辑</p>
</li>
<li><p>事件：用于描述设备上报云端的多个参数，多用于复杂报文结构或设备本身在某个阈值触发的报文。</p>
</li>
<li><p>标签：统一为设备添加拓展字段，添加后将在设备信息页显示。</p>
</li>
</ul>
<p><img src="https://image.woodwhales.cn/090/07-jetlinks.png"></p>
<h2 id="2、开发手册"><a href="#2、开发手册" class="headerlink" title="2、开发手册"></a>2、开发手册</h2><blockquote>
<p>社区版后端工程：</p>
<ul>
<li>github 仓库：<a href="https://github.com/jetlinks/jetlinks-community">https://github.com/jetlinks/jetlinks-community</a></li>
<li>gitee 仓库：<a href="https://gitee.com/jetlinks/jetlinks-community">https://gitee.com/jetlinks/jetlinks-community</a></li>
</ul>
</blockquote>
<h3 id="2-1、模块说明"><a href="#2-1、模块说明" class="headerlink" title="2.1、模块说明"></a>2.1、模块说明</h3><p>社区版系统模块说明：<a href="https://hanta.yuque.com/px7kg1/nn1gdr/gfqb3xmxg8fsvyxf#lR7Pd">https://hanta.yuque.com/px7kg1/nn1gdr/gfqb3xmxg8fsvyxf#lR7Pd</a></p>
<ul>
<li>jetlinks-components   # 组件库<ul>
<li>common-component # 通用组件、工具类等</li>
<li>configure-component # 统一配置模块</li>
<li>dashboard-component # 仪表盘模块</li>
<li>elasticsearch-component # ElasticSearch集成</li>
<li>gateway-component # 网关模块，统一定义网关接口等信息</li>
<li>io-component # IO模块，文件管理等</li>
<li>logging-component # 日志模块</li>
<li>network-component # 网络组件模块,统一定义网络组件规范以及默认实现<ul>
<li>http-component # http模块</li>
<li>mqtt-component # mqtt模块</li>
<li>network-core # 网络组件核心模块</li>
<li>tcp-component # tcp模块</li>
</ul>
</li>
<li>notify-component # 通知模块，统一定义通知规范以及默认实现<ul>
<li>notify-core # 通知模块核心</li>
<li>notify-dingtalk # 钉钉通知模块</li>
<li>notify-email # 邮件通知模块</li>
<li>notify-sms # 短信通知模块</li>
<li>notify-voice # 语音通知模块</li>
<li>notify-webhook # webhook通知模块</li>
<li>notify-wechat # 微信通知模块</li>
</ul>
</li>
<li>protocol-component # 协议模块</li>
<li>relation-component # 关系模块，用于描述物与物之间的关系</li>
<li>rule-engine-component # 规则引擎模块,集成规则引擎通用功能</li>
<li>script-component # 脚本模块，封装脚本引擎</li>
<li>tdengine-component # 对tdengine的支持</li>
<li>things-component # 物管理模块</li>
<li>timeseries-component # 时序数据组件</li>
</ul>
</li>
<li>jetlinks-manager  # 管理功能<ul>
<li>authentication-manager   # 用户，权限管理模块</li>
<li>device-manager   # 设备管理模块</li>
<li>logging-manager   # 日志管理模块</li>
<li>network-manager   # 网络组件管理模块</li>
<li>notify-manager   # 通知管理模块</li>
<li>rule-engine-manager   # 规则引擎管理模块</li>
</ul>
</li>
<li>jetlinks-standalone  #单例模块，启动JetLinks平台</li>
</ul>
<h3 id="2-2、技术选型"><a href="#2-2、技术选型" class="headerlink" title="2.2、技术选型"></a>2.2、技术选型</h3><table>
<thead>
<tr>
<th>技术栈</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Java8</td>
<td>编程语言</td>
</tr>
<tr>
<td>hsweb Framework</td>
<td>业务基础框架</td>
</tr>
<tr>
<td>Spring Boot 2.7.x</td>
<td>响应式web支持</td>
</tr>
<tr>
<td>vert.x，netty</td>
<td>高性能网络框架</td>
</tr>
<tr>
<td>R2DBC</td>
<td>关系型数据库响应式驱动</td>
</tr>
<tr>
<td>Postgresql</td>
<td>关系型数据库，可更换为mysql、sqlserver</td>
</tr>
<tr>
<td>ElasticSearch</td>
<td>设备数据与日志存储，可更换为其他中间件</td>
</tr>
<tr>
<td>Redis</td>
<td>用户信息与权限缓存、设备注册中心缓存</td>
</tr>
<tr>
<td>scalecube</td>
<td>基于JVM的分布式服务框架，支持响应式</td>
</tr>
<tr>
<td>micrometer</td>
<td>监控指标框架</td>
</tr>
</tbody></table>
<h3 id="2-3、必要的开发知识"><a href="#2-3、必要的开发知识" class="headerlink" title="2.3、必要的开发知识"></a>2.3、必要的开发知识</h3><p>响应式编程：<a href="http://doc.jetlinks.cn/dev-guide/reactor.html">http://doc.jetlinks.cn/dev-guide/reactor.html</a></p>
<p>事件驱动：<a href="http://doc.jetlinks.cn/dev-guide/event-driver.html">http://doc.jetlinks.cn/dev-guide/event-driver.html</a></p>
<p>添加自定义模块：<a href="https://hanta.yuque.com/px7kg1/dev/wdymp6flcfa1vwh5">https://hanta.yuque.com/px7kg1/dev/wdymp6flcfa1vwh5</a></p>
<h2 id="3、设备接入流程"><a href="#3、设备接入流程" class="headerlink" title="3、设备接入流程"></a>3、设备接入流程</h2><blockquote>
<p>设备接入流程：<a href="http://doc.jetlinks.cn/function-description/device_message_description.html#%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B">http://doc.jetlinks.cn/function-description/device_message_description.html#%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B</a></p>
<p>HTTP协议设备接入：<a href="https://hanta.yuque.com/px7kg1/yfac2l/qlr6nz5btr5rwrgk">https://hanta.yuque.com/px7kg1/yfac2l/qlr6nz5btr5rwrgk</a></p>
</blockquote>
<h3 id="3-1、流程图"><a href="#3-1、流程图" class="headerlink" title="3.1、流程图"></a>3.1、流程图</h3><p><img src="https://image.woodwhales.cn/090/02-%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B.png"></p>
<h3 id="3-2、开发：协议包"><a href="#3-2、开发：协议包" class="headerlink" title="3.2、开发：协议包"></a>3.2、开发：协议包</h3><p>开发者自行实现自定义协议，官方教程：<a href="http://doc.jetlinks.cn/dev-guide/custom-message-protocol.html">http://doc.jetlinks.cn/dev-guide/custom-message-protocol.html</a></p>
<blockquote>
<p>官方提供了协议开发示例工程：<a href="https://github.com/jetlinks/jetlinks-official-protocol">https://github.com/jetlinks/jetlinks-official-protocol</a></p>
<p>JetLinks 官方协议 jar 包：<a href="https://github.com/jetlinks/jetlinks-official-protocol/blob/v3/package/jetlinks-official-protocol-3.0.0.jar">https://github.com/jetlinks/jetlinks-official-protocol/blob/v3/package/jetlinks-official-protocol-3.0.0.jar</a></p>
</blockquote>
<ol>
<li><p>编写<code>自定义编解码器</code>：</p>
<p> 创建<code>org.jetlinks.core.message.codec.DeviceMessageCodec</code>接口实现类，重写<code>encode()</code>、<code>decode()</code>、<code>getSupportTransport()</code>方法</p>
</li>
<li><p>编写<code>协议的元信息</code></p>
<p> 创建<code>org.jetlinks.core.metadata.DefaultConfigMetadata</code>对象并设置对应属性</p>
</li>
<li><p>编写<code>自定义设备协议支持提供商</code>：</p>
<p> 创建<code>org.jetlinks.core.spi.ProtocolSupportProvider</code>接口实现类，并重写<code>create()</code>方法，</p>
<p> 在<code>create()</code>方法中将：将<code>自定义编解码器</code>注册到协议中</p>
</li>
<li><p>配置路由配置：</p>
<p> 在<code>org.jetlinks.core.spi.ProtocolSupportProvider</code>接口实现类的<code>create()</code>方法中创建<code>org.jetlinks.core.defaults.CompositeProtocolSupport</code>对象，在其中配置路由配置、身份认证（可选）</p>
</li>
</ol>
<h3 id="3-3、添加：协议包"><a href="#3-3、添加：协议包" class="headerlink" title="3.3、添加：协议包"></a>3.3、添加：协议包</h3><p>将协议包上传到协议管理中</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks01.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks02.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks03.png"></p>
<h3 id="3-4、添加：网络组件"><a href="#3-4、添加：网络组件" class="headerlink" title="3.4、添加：网络组件"></a>3.4、添加：网络组件</h3><ol>
<li>配置：本地和公网的接口地址、端口号</li>
<li>配置：接口处理的服务类型</li>
</ol>
<p><img src="https://image.woodwhales.cn/090/jetlinks04.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks05.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks06.png"></p>
<h3 id="3-5、添加：设备接入网关"><a href="#3-5、添加：设备接入网关" class="headerlink" title="3.5、添加：设备接入网关"></a>3.5、添加：设备接入网关</h3><p>将上述的协议包和网络组件进行绑定</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks07.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks08.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks09.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks10.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks11.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks12.png"></p>
<h3 id="3-6、添加：产品"><a href="#3-6、添加：产品" class="headerlink" title="3.6、添加：产品"></a>3.6、添加：产品</h3><ol>
<li><p>配置：产品信息</p>
</li>
<li><p>绑定：上述的自定义网络组件（官方定义：设备接入）</p>
</li>
<li><p>配置：认证信息</p>
</li>
<li><p>配置存储策略</p>
</li>
<li><p>配置：物模型</p>
<ol>
<li>属性定义</li>
<li>功能定义</li>
<li>事件定义</li>
<li>标签定义</li>
</ol>
</li>
<li><p>启用：产品</p>
</li>
</ol>
<p><img src="https://image.woodwhales.cn/090/jetlinks13.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks14.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks15.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks16.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks17.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks18.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks19.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks20.png"></p>
<blockquote>
<ol>
<li><p>行式存储</p>
<p> ElasticSearch-行式存储是系统默认情况下使用的存储方案。每一个属性值都保存为一条索引记录。</p>
<p> 典型应用场景：设备每次只会上报一部分属性， 以及支持读取部分属性数据的时候。</p>
</li>
<li><p>列式存储</p>
<p>  一个属性作为一列，一条属性消息作为一条索引记录进行存储。</p>
<p> 典型应用场景：适合设备每次都上报所有的属性值的场景。</p>
</li>
</ol>
</blockquote>
<p><img src="https://image.woodwhales.cn/090/jetlinks21.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks22.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks23.png"></p>
<h3 id="3-7、添加：设备"><a href="#3-7、添加：设备" class="headerlink" title="3.7、添加：设备"></a>3.7、添加：设备</h3><ol>
<li>配置：设备ID、名称</li>
<li>绑定：上述配置好的产品（只能配置状态是正常的产品，即已启用的产品）</li>
<li>启动：设备</li>
<li>（可选）默认继承了所属产品的物模型。可以配置专属当前设备的物模型</li>
</ol>
<p><img src="https://image.woodwhales.cn/090/jetlinks24.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks25.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks26.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks27.png"></p>
<p><img src="https://image.woodwhales.cn/090/jetlinks28.png"></p>
<h2 id="4、理解协议包"><a href="#4、理解协议包" class="headerlink" title="4、理解协议包"></a>4、理解协议包</h2><blockquote>
<p>关于协议包：<a href="https://hanta.yuque.com/px7kg1/nn1gdr/kcqv8dn8y6778t2a">https://hanta.yuque.com/px7kg1/nn1gdr/kcqv8dn8y6778t2a</a></p>
</blockquote>
<p>协议包主要包含 4 个部分</p>
<ol>
<li><p>数据传输协议：协议包约定了常见的网络通信协议，例如MQTT、HTTP、TCP、CoAP等，来实现物联网设备与JetLinks平台之间的数据传输。开发者可根据设备实际情况选择对应的通信协议。</p>
<p> <img src="https://image.woodwhales.cn/090/jetlinks-%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%9B%BE.jpg"></p>
</li>
<li><p>数据解析标准：协议包定义了一套设备数据解析标准，使得各种类型的物联网设备通过网络协议传输至JetLinks后，根据协议包内的数据解析标准将不同类型的报文转换成平台统一的消息。</p>
<p> <img src="https://image.woodwhales.cn/090/jetlinks-%E5%8D%8F%E8%AE%AE%E5%8C%85.png"></p>
</li>
<li><p>设备管理功能：协议包内可以获取平台内定义的设备数据，包括设备信息、设备配置、设备状态等，方便开发者在接入设备时获取设备相关数据进行自定义的业务逻辑处理。</p>
</li>
<li><p>身份认证：协议包支持物联网设备的身份认证，用户可以在协议包内编写身份认证逻辑来验证连接的客户端身份，以保护设备和数据的安全。</p>
</li>
</ol>
<h2 id="5、理解自定义编解码器开发流程"><a href="#5、理解自定义编解码器开发流程" class="headerlink" title="5、理解自定义编解码器开发流程"></a>5、理解自定义编解码器开发流程</h2><h3 id="5-1、步骤1"><a href="#5-1、步骤1" class="headerlink" title="5.1、步骤1"></a>5.1、步骤1</h3><p>自定义 DeviceMessageCodec 接口实现类，重写 encode()、decode() 方法</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code1.png"></p>
<h4 id="5-1-1、消息编码"><a href="#5-1-1、消息编码" class="headerlink" title="5.1.1、消息编码"></a>5.1.1、消息编码</h4><p>重写 DeviceMessageCodec 接口中的<code>encode()</code>方法</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code4.png"></p>
<h4 id="5-1-2、消息解码"><a href="#5-1-2、消息解码" class="headerlink" title="5.1.2、消息解码"></a>5.1.2、消息解码</h4><p>重写 DeviceMessageCodec 接口中的<code>decode()</code>方法</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code3.png"></p>
<h3 id="5-2、步骤2"><a href="#5-2、步骤2" class="headerlink" title="5.2、步骤2"></a>5.2、步骤2</h3><p>自定义 ProtocolSupportProvider 接口实现类，配置元数据信息</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code2.png"></p>
<h3 id="5-3、步骤3"><a href="#5-3、步骤3" class="headerlink" title="5.3、步骤3"></a>5.3、步骤3</h3><p>配置路由与 DeviceMessage 的绑定关系</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code5.png"></p>
<h3 id="5-4、步骤4"><a href="#5-4、步骤4" class="headerlink" title="5.4、步骤4"></a>5.4、步骤4</h3><p>自定义 Authenticator 接口实现并配置</p>
<p><img src="https://image.woodwhales.cn/090/jetlinks-code6.png"></p>
<h2 id="6、理解编解码涉及的核心类关系"><a href="#6、理解编解码涉及的核心类关系" class="headerlink" title="6、理解编解码涉及的核心类关系"></a>6、理解编解码涉及的核心类关系</h2><blockquote>
<p>协议加载设计：<a href="https://hanta.yuque.com/px7kg1/nn1gdr/gascdx49ia6u4lsf">https://hanta.yuque.com/px7kg1/nn1gdr/gascdx49ia6u4lsf</a></p>
<p>平台统一设备消息定义：<a href="http://doc.jetlinks.cn/function-description/device_message_description.html">http://doc.jetlinks.cn/function-description/device_message_description.html</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/090/%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg"></p>
<h2 id="7、协议包上传逻辑分析"><a href="#7、协议包上传逻辑分析" class="headerlink" title="7、协议包上传逻辑分析"></a>7、协议包上传逻辑分析</h2><h3 id="7-1、步骤1：上传协议-jar"><a href="#7-1、步骤1：上传协议-jar" class="headerlink" title="7.1、步骤1：上传协议 jar"></a>7.1、步骤1：上传协议 jar</h3><h4 id="后端接口"><a href="#后端接口" class="headerlink" title="后端接口"></a>后端接口</h4><p><code>POST</code> </p>
<p>/api/file/upload</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>表单请求，接收参数名为：file 的文件数据对象</p>
<figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line">Content-Disposition: form-data; name="file"; filename="jetlinks-official-protocol-3.0.0.jar"</span><br><span class="line">Content-Type: application/octet-stream</span><br></pre></td></tr></tbody></table></figure>

<p>接口类：<code>org.jetlinks.community.io.file.web.FileManagerController#upload</code></p>
<h4 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h4><ol>
<li><p>获取文件信息，并将文件数据保存到本地指定目录</p>
<ul>
<li><p>默认文件目录为：./data/files/yyyyMMdd/</p>
</li>
<li><p>重命名 jar 文件名，生成规则：md5(uuid())</p>
</li>
<li><p>计算当前文件的 md5 和 sha256 值</p>
</li>
</ul>
</li>
<li><p>将文件相关信息保存到数据库中，数据对象：<code>org.jetlinks.community.io.file.FileEntity</code></p>
</li>
<li><p>保存成功的文件数据记录主键和文件信息一起通过接口返回</p>
</li>
</ol>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>返回文件数据相关记录信息，核心信息：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"success"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"result"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"9c9ce661a1fadb8019ca50145b33a074"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"jetlinks-official-protocol-3.0.0.jar"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"extension"</span><span class="punctuation">:</span> <span class="string">"jar"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"length"</span><span class="punctuation">:</span> <span class="number">102512</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"md5"</span><span class="punctuation">:</span> <span class="string">"24504ceb0d6570b84b86e6180d9fca9f"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"sha256"</span><span class="punctuation">:</span> <span class="string">"fb0c6144ad056326e26eb829c13759b5080da095c7bb02386c7f064ac059f24e"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"createTime"</span><span class="punctuation">:</span> <span class="number">1699859432789</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"creatorId"</span><span class="punctuation">:</span> <span class="string">"1199596756811550720"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"options"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"others"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">            <span class="attr">"accessKey"</span><span class="punctuation">:</span> <span class="string">"c24b19b0c91119c6673fa1a06a4d2ae0"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"status"</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"timestamp"</span><span class="punctuation">:</span> <span class="number">1699859454032</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-2、步骤2：确定协议"><a href="#7-2、步骤2：确定协议" class="headerlink" title="7.2、步骤2：确定协议"></a>7.2、步骤2：确定协议</h3><h4 id="7-2-1、后端接口"><a href="#7-2-1、后端接口" class="headerlink" title="7.2.1、后端接口"></a>7.2.1、后端接口</h4><p><code>PATCH</code> </p>
<p>/api/protocol</p>
<p>接口类：<code>org.jetlinks.community.device.web.ProtocolSupportController</code></p>
<h4 id="7-2-2、请求报文"><a href="#7-2-2、请求报文" class="headerlink" title="7.2.2、请求报文"></a>7.2.2、请求报文</h4><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"id"</span><span class="punctuation">:</span> <span class="string">"1722876422724329472"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"官方协议v3.0"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"description"</span><span class="punctuation">:</span> <span class="string">""</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"jar"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"state"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"creatorId"</span><span class="punctuation">:</span> <span class="string">"1199596756811550720"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"createTime"</span><span class="punctuation">:</span> <span class="number">1699600723328</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"configuration"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"location"</span><span class="punctuation">:</span> <span class="string">"http://localhost:5173/api/file/9c9ce661a1fadb8019ca50145b33a074?accessKey=c24b19b0c91119c6673fa1a06a4d2ae0"</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="7-2-3、处理逻辑"><a href="#7-2-3、处理逻辑" class="headerlink" title="7.2.3、处理逻辑"></a>7.2.3、处理逻辑</h4><ul>
<li>将前端请求的文件信息保存到数据库中，数据对象：<code>org.jetlinks.community.device.entity.ProtocolSupportEntity</code></li>
</ul>
<blockquote>
<p>前端逻辑：将步骤1 的响应结果拼接成：文件地址（用户不可编辑）+ 用户填写的协议包基本信息（名称、类型、说明）</p>
</blockquote>
<p><code>org.jetlinks.community.device.web.ProtocolSupportController</code> 实现了<code>org.hswebframework.web.crud.web.reactive.ReactiveServiceCrudController</code>接口。</p>
<p><code>org.hswebframework.web.crud.web.reactive.ReactiveServiceCrudController</code>接口又继承了三个接口：<code>org.hswebframework.web.crud.web.reactive.ReactiveServiceSaveController</code>、<code>org.hswebframework.web.crud.web.reactive.ReactiveServiceQueryController</code>、<code>org.hswebframework.web.crud.web.reactive.ReactiveServiceDeleteController</code></p>
<p>ProtocolSupportController</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetlinks.community.device.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hswebframework.web.crud.web.reactive.ReactiveServiceCrudController;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.community.device.service.LocalProtocolSupportService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/protocol")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolSupportController</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ReactiveServiceCrudController</span>&lt;ProtocolSupportEntity, String&gt; {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> LocalProtocolSupportService service;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ReactiveServiceCrudController</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hswebframework.web.crud.web.reactive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReactiveServiceCrudController</span>&lt;E, K&gt; <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">ReactiveServiceSaveController</span>&lt;E, K&gt;,</span><br><span class="line">        ReactiveServiceQueryController&lt;E, K&gt;,</span><br><span class="line">        ReactiveServiceDeleteController&lt;E, K&gt; {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>PATH /api/protocol</code> 接口实际由：<code>ReactiveServiceSaveController</code>接口提供的默认 <code>save()</code> 方法处理数据，最终调用<code>getService()</code>方法进行<code>save()</code>操作。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hswebframework.web.crud.web.reactive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hswebframework.web.authorization.annotation.Authorize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReactiveServiceSaveController</span>&lt;E, K&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Authorize(ignore = true)</span></span><br><span class="line">    ReactiveCrudService&lt;E, K&gt; <span class="title function_">getService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PatchMapping</span></span><br><span class="line">    <span class="meta">@Operation(summary = "保存数据", description = "如果传入了id,并且对应数据存在,则尝试覆盖,不存在则新增.")</span></span><br><span class="line">    <span class="keyword">default</span> Mono&lt;SaveResult&gt; <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Flux&lt;E&gt; payload)</span> {</span><br><span class="line">        <span class="keyword">return</span> Authentication</span><br><span class="line">                .currentReactive()</span><br><span class="line">                .flatMapMany(auth -&gt; payload.map(entity -&gt; applyAuthentication(entity, auth)))</span><br><span class="line">                .switchIfEmpty(payload)</span><br><span class="line">                .as(getService()::save);</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于<code>ProtocolSupportController</code>注入了<code>org.jetlinks.community.device.service.LocalProtocolSupportService</code>，并且属性名为：service，因此<code>ProtocolSupportController</code>的<code>getService()</code>就是<code>ReactiveServiceSaveController</code>接口的<code>getService()</code>方法实现。显而易见，确定协议的核心逻辑就在：<code>LocalProtocolSupportService</code>的<code>save()</code>方法。</p>
<p><code>org.jetlinks.community.device.service.LocalProtocolSupportService</code>类继承了<code>org.hswebframework.web.crud.service.GenericReactiveCrudService</code>抽象类，而<code>GenericReactiveCrudService</code>抽象类又实现了<code>org.hswebframework.web.crud.service.ReactiveCrudService</code>接口，在<code>ReactiveCrudService</code>中有<code>save()</code>方法</p>
<p>ProtocolSupportController</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetlinks.community.device.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetlinks.community.reference.DataReferenceManager;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.supports.protocol.management.ProtocolSupportManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalProtocolSupportService</span> <span class="keyword">extends</span> <span class="title class_">GenericReactiveCrudService</span>&lt;ProtocolSupportEntity, String&gt; {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProtocolSupportManager supportManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataReferenceManager referenceManager;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>GenericReactiveCrudService</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hswebframework.web.crud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hswebframework.ezorm.rdb.mapping.ReactiveRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericReactiveCrudService</span>&lt;E, K&gt; <span class="keyword">implements</span> <span class="title class_">ReactiveCrudService</span>&lt;E, K&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ReactiveRepository&lt;E, K&gt; repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReactiveRepository&lt;E, K&gt; <span class="title function_">getRepository</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> repository;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>GenericReactiveCrudService 注入了 ReactiveRepository 接口，该接口的实现类为：<code>org.hswebframework.ezorm.rdb.mapping.defaults.DefaultReactiveRepository</code>，里面实现了<code>save()</code>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hswebframework.ezorm.rdb.mapping.defaults;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hswebframework.ezorm.rdb.mapping.ReactiveRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultReactiveRepository</span>&lt;E, K&gt; <span class="keyword">extends</span> <span class="title class_">DefaultRepository</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ReactiveRepository</span>&lt;E, K&gt; {</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;SaveResult&gt; <span class="title function_">save</span><span class="params">(Publisher&lt;E&gt; data)</span> {</span><br><span class="line">        <span class="keyword">return</span> Flux</span><br><span class="line">                .from(data)</span><br><span class="line">                .collectList()</span><br><span class="line">                .filter(CollectionUtils::isNotEmpty)</span><br><span class="line">                .flatMap(list -&gt; doSave(list).reactive().as(<span class="built_in">this</span>::setupLogger))</span><br><span class="line">                .defaultIfEmpty(SaveResult.of(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述<code>doSave()</code>方法是<code>org.hswebframework.ezorm.rdb.mapping.defaults.DefaultRepository</code>抽象类提供的默认方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hswebframework.ezorm.rdb.mapping.defaults;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hswebframework.ezorm.rdb.mapping.events.EventResultOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DefaultRepository</span>&lt;E&gt; {</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> SaveResultOperator <span class="title function_">doSave</span><span class="params">(Collection&lt;E&gt; data)</span> {</span><br><span class="line">        <span class="type">RDBTableMetadata</span> <span class="variable">table</span> <span class="operator">=</span> getTable();</span><br><span class="line">        <span class="type">UpsertOperator</span> <span class="variable">upsert</span> <span class="operator">=</span> operator.dml().upsert(table.getFullName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EventResultOperator.create(</span><br><span class="line">                () -&gt; {</span><br><span class="line">                    upsert.columns(getProperties());</span><br><span class="line">                    List&lt;String&gt; ignore = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (E e : data) {</span><br><span class="line">                        upsert.values(Stream.of(getProperties())</span><br><span class="line">                                            .map(property -&gt; getInsertColumnValue(e, property, (prop, val) -&gt; ignore.add(prop)))</span><br><span class="line">                                            .toArray());</span><br><span class="line">                    }</span><br><span class="line">                    upsert.ignoreUpdate(ignore.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">                    <span class="keyword">return</span> upsert.execute();</span><br><span class="line">                },</span><br><span class="line">                SaveResultOperator.class,</span><br><span class="line">                table,</span><br><span class="line">                MappingEventTypes.save_before,</span><br><span class="line">                MappingEventTypes.save_after,</span><br><span class="line">                getDefaultContextKeyValue(instance(data),</span><br><span class="line">                                          type(<span class="string">"batch"</span>),</span><br><span class="line">                                          tableMetadata(table),</span><br><span class="line">                                          upsert(upsert))</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述<code>EventResultOperator</code>的<code>create()</code>方法中，发布了<code>EntitySavedEvent&lt;E&gt;</code>事件（通过 Spring的ApplicationEventPublisher 发送事件）。</p>
<p>在<code>org.jetlinks.community.device.service.ProtocolSupportHandler</code>中订阅了<code>EntitySavedEvent&lt;ProtocolSupportEntity&gt;</code>事件：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.jetlinks.community.device.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.core.ProtocolSupport;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.community.reference.DataReferenceManager;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.supports.protocol.management.ProtocolSupportLoader;</span><br><span class="line"><span class="keyword">import</span> org.jetlinks.supports.protocol.management.ProtocolSupportManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolSupportHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataReferenceManager referenceManager;</span><br><span class="line">    <span class="keyword">private</span>       ProtocolSupportLoader  loader;</span><br><span class="line">    <span class="keyword">private</span>       ProtocolSupportManager supportManager;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCreated</span><span class="params">(EntityCreatedEvent&lt;ProtocolSupportEntity&gt; event)</span> {</span><br><span class="line">        event.async(reloadProtocol(event.getEntity()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSaved</span><span class="params">(EntitySavedEvent&lt;ProtocolSupportEntity&gt; event)</span> {</span><br><span class="line">        event.async(reloadProtocol(event.getEntity()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleModify</span><span class="params">(EntityModifyEvent&lt;ProtocolSupportEntity&gt; event)</span> {</span><br><span class="line">        event.async(reloadProtocol(event.getAfter()));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重新加载协议</span></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">reloadProtocol</span><span class="params">(Collection&lt;ProtocolSupportEntity&gt; protocol)</span> {</span><br><span class="line">        <span class="keyword">return</span> Flux</span><br><span class="line">            .fromIterable(protocol)</span><br><span class="line">            .filter(entity -&gt; entity.getState() != <span class="literal">null</span>)</span><br><span class="line">            .map(entity -&gt; entity.getState() == <span class="number">1</span> ? entity.toDeployDefinition() : entity.toUnDeployDefinition())</span><br><span class="line">            .flatMap(def -&gt; loader</span><br><span class="line">                <span class="comment">//加载一下检验是否正确，然后就卸载</span></span><br><span class="line">                .load(def)</span><br><span class="line">                .doOnNext(ProtocolSupport::dispose)</span><br><span class="line">                .thenReturn(def))</span><br><span class="line">            .onErrorMap(err -&gt; <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">"error.unable_to_load_protocol"</span>, <span class="number">500</span>, err.getMessage()))</span><br><span class="line">            .flatMap(supportManager::save)</span><br><span class="line">            .then();</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述<code>ProtocolSupportLoader</code>接口的实现类为<code>org.jetlinks.community.protocol.SpringProtocolSupportLoader</code>，其中<code>load()</code>方法会动态加载 jar 包为<code>org.jetlinks.core.spi.ProtocolSupportProvider</code>接口实现，并执行<code>create()</code>方法。</p>
<h4 id="7-2-4、响应报文"><a href="#7-2-4、响应报文" class="headerlink" title="7.2.4、响应报文"></a>7.2.4、响应报文</h4><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"success"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"result"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"added"</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"updated"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"total"</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"status"</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"timestamp"</span><span class="punctuation">:</span> <span class="number">1699859463951</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="8、加载协议包时机"><a href="#8、加载协议包时机" class="headerlink" title="8、加载协议包时机"></a>8、加载协议包时机</h2><h3 id="8-1、加载协议包时机1"><a href="#8-1、加载协议包时机1" class="headerlink" title="8.1、加载协议包时机1"></a>8.1、加载协议包时机1</h3><p>通过<code>org.jetlinks.community.device.service.ProtocolSupportHandler</code>监听<code>EntityCreatedEvent&lt;ProtocolSupportEntity&gt;</code>、<code>EntitySavedEvent&lt;ProtocolSupportEntity&gt;</code>、<code>EntityModifyEvent&lt;ProtocolSupportEntity&gt;</code>事件，调用<code>ProtocolSupportLoader</code>的<code>load()</code>方法加载协议</p>
<blockquote>
<p>在 ProtocolSupportLoader 的 load() 方法中：会调用 org.jetlinks.core.spi.ProtocolSupportProvider 接口实现，并执行 create() 方法</p>
</blockquote>
<h3 id="8-2、加载协议包时机2"><a href="#8-2、加载协议包时机2" class="headerlink" title="8.2、加载协议包时机2"></a>8.2、加载协议包时机2</h3><p>通过<code>org.jetlinks.community.protocol.LazyInitManagementProtocolSupports</code>实现<code>org.springframework.boot.CommandLineRunner</code>接口，在项目启动时执行<code>init()</code>方法，调用<code>ProtocolSupportLoader</code>的<code>load()</code>方法加载协议</p>
<blockquote>
<p>在 ProtocolSupportLoader 的 load() 方法中：会调用 org.jetlinks.core.spi.ProtocolSupportProvider 接口实现，并执行 create() 方法</p>
</blockquote>
<h2 id="9、设备网关加载机制"><a href="#9、设备网关加载机制" class="headerlink" title="9、设备网关加载机制"></a>9、设备网关加载机制</h2><ol>
<li>通过 DeviceGatewayEventHandler 实现 CommandLineRunner 接口，在项目启动时执行 init() 方法</li>
<li>通过 DeviceGatewayEventHandler 监听 DeviceGatewayEntity 的保存、创建、更新事件</li>
</ol>
<p><img src="https://image.woodwhales.cn/090/%E7%BD%91%E5%85%B3%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png"></p>
]]></content>
      <categories>
        <category>JetLinks</category>
      </categories>
      <tags>
        <tag>AIoT</tag>
        <tag>JetLinks</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装 MySQL</title>
    <url>/2023/12/03/091/</url>
    <content><![CDATA[<p>步骤1：创建宿主机 MySQL 相关文件目录，均放在<code>/data/software/mysql/</code>目录中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p /data/software/mysql/log</span><br><span class="line">mkdir -p /data/software/mysql/data</span><br><span class="line">mkdir -p /data/software/mysql/conf</span><br><span class="line">mkdir -p /data/software/mysql/mysql-files</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：在 /data/software/mysql/conf 中创建 my.cnf 配置文件</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_bin</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">secure-file-priv=/var/lib/mysql</span><br><span class="line">max_allowed_packet=512M</span><br><span class="line">innodb_log_file_size=2GB</span><br><span class="line">transaction-isolation=READ-COMMITTED</span><br><span class="line">binlog_format=row</span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：docker 运行 mySQL。</p>
<blockquote>
<p>下述中宿主服务器 4417 端口映射到 docker 容器中的 3306 端口</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker run -p 4417:3306 --name mysql --restart=always --privileged=true \</span><br><span class="line">-v /data/software/mysql/log:/var/log/mysql \</span><br><span class="line">-v /data/software/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /data/software/mysql/conf:/etc/mysql \</span><br><span class="line">-v /data/software/mysql/mysql-files:/var/lib/mysql-files \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD='123456' -d mysql:latest</span><br></pre></td></tr></tbody></table></figure>

<p>步骤4：设置 root 账号任意IP访问：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> Host<span class="operator">=</span><span class="string">'%'</span> <span class="keyword">where</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">'root'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p>步骤5：修改密码</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">'woodwhales@123'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p>修改密码</p>
<p>在宿主服务器中，找到 /data/software/mysql/conf/my.cnf 配置，在配置内容的下方添加：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></tbody></table></figure>

<p>进入 docker 容器登录 MySQL server 时，不需要输入root账号密码。修改密码之后注意去除上述配置。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ALTER USER 'root'@'%' IDENTIFIED BY 'woodwhales@123';</span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker desktop安装（windows os）</title>
    <url>/2023/12/14/092/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="cmd-属性配置"><a href="#cmd-属性配置" class="headerlink" title="cmd 属性配置"></a>cmd 属性配置</h2><p>步骤1。右键开始菜单并以管理员身份运行 PowerShell，右击窗口框选择：<code>属性</code></p>
<p><img src="https://image.woodwhales.cn/092/images/7.png"></p>
<p>步骤2。在属性中，点击：<code>选项</code>，取消勾选：<code>使用旧版控制台(U)(需要重新重启，影响所有控制台)</code></p>
<p><img src="https://image.woodwhales.cn/092/images/6.png"></p>
<p>步骤3。重启电脑</p>
<h2 id="开启-Hyper-V"><a href="#开启-Hyper-V" class="headerlink" title="开启 Hyper-V"></a>开启 Hyper-V</h2><h3 id="验证-Hyper-V-是否开启成功"><a href="#验证-Hyper-V-是否开启成功" class="headerlink" title="验证 Hyper-V 是否开启成功"></a>验证 Hyper-V 是否开启成功</h3><p>在任务管理器中，查看是否开启了：虚拟化</p>
<p><img src="https://image.woodwhales.cn/092/images/8.png"></p>
<h3 id="方式1：可视化开启"><a href="#方式1：可视化开启" class="headerlink" title="方式1：可视化开启"></a>方式1：可视化开启</h3><p>步骤1。在 win 菜单右击，弹出快捷功能菜单，点击：<code>应用和功能</code></p>
<p><img src="https://image.woodwhales.cn/092/images/2.png"></p>
<p>步骤2。点击：<code>程序和功能</code></p>
<p><img src="https://image.woodwhales.cn/092/images/3.png"></p>
<p>步骤3。点击：<code>启用或关闭 Windows 功能</code></p>
<p><img src="https://image.woodwhales.cn/092/images/4.png"></p>
<p>步骤4。勾选 Hyper-V</p>
<p><img src="https://image.woodwhales.cn/092/images/5.png"></p>
<h3 id="方式2：命令式开启"><a href="#方式2：命令式开启" class="headerlink" title="方式2：命令式开启"></a>方式2：命令式开启</h3><p>在管理员身份运行的 PowerShell，执行以下命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开启-wsl-能力"><a href="#开启-wsl-能力" class="headerlink" title="开启 wsl 能力"></a>开启 wsl 能力</h2><p>在管理员身份运行的 PowerShell，执行以下俩个命令：</p>
<p>命令1：启用”适用于 Linux 的 Windows 子系统”可选功能</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br></pre></td></tr></tbody></table></figure>
<p>命令2：启用”虚拟机平台”可选功能。</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></tbody></table></figure>

<h2 id="设置-wsl-默认安装版本"><a href="#设置-wsl-默认安装版本" class="headerlink" title="设置 wsl 默认安装版本"></a>设置 wsl 默认安装版本</h2><p>在管理员身份运行的 PowerShell，执行以下命令：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="安装-docker-desktop"><a href="#安装-docker-desktop" class="headerlink" title="安装 docker-desktop"></a>安装 docker-desktop</h1><p>步骤1。下载安装包，地址：<a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></p>
<img src="https://image.woodwhales.cn/092/images/1-docker-desktop.png" style="zoom:80%;">

<p>步骤2。右击安装包，使用管理员身份运行。</p>
<p>步骤3。在 Configuration 中勾选：</p>
<ul>
<li>Use WSL 2 instead of Hyper-V (recommended)</li>
<li>Add shortcut to desktop</li>
</ul>
<h1 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h1><p>在<code>docker Engine</code> 中配置：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">"registry-mirrors"</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">"https://xxx.mirror.aliyuncs.com"</span> <span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure>

<p>操作步骤如图：</p>
<p><img src="https://image.woodwhales.cn/092/images/11.png"></p>
<h1 id="docker-desktop-使用"><a href="#docker-desktop-使用" class="headerlink" title="docker desktop 使用"></a>docker desktop 使用</h1><h2 id="搜索拉取镜像"><a href="#搜索拉取镜像" class="headerlink" title="搜索拉取镜像"></a>搜索拉取镜像</h2><p>在软件顶部的搜索框中，搜索要拉取的镜像</p>
<p><img src="https://image.woodwhales.cn/092/images/9.png"></p>
<p>拉取成功的镜像，在<code>Images</code>菜单中可以查看</p>
<p><img src="https://image.woodwhales.cn/092/images/10.png"></p>
<h2 id="创建、启动容器"><a href="#创建、启动容器" class="headerlink" title="创建、启动容器"></a>创建、启动容器</h2><p>在<code>Images</code>中找到要基于哪个镜像创建容器</p>
<p><img src="https://image.woodwhales.cn/092/images/12.png"></p>
<p>点击启动容器后，在提示弹窗中配置容器基本信息</p>
<p><img src="https://image.woodwhales.cn/092/images/13.png"></p>
<p>创建成功的容器，可以在<code>Container</code>中进行查看</p>
<p><img src="https://image.woodwhales.cn/092/images/14.png"></p>
<p>浏览器访问：<a href="http://127.0.0.1:81/">http://127.0.0.1:81/</a> 可以看到 nginx 服务已经成功启动</p>
<p><img src="https://image.woodwhales.cn/092/images/19.png"></p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><p>点击容器名称或者 view details 可以查看容器详细信息</p>
<p><img src="https://image.woodwhales.cn/092/images/15.png"></p>
<p>查看容器文件信息</p>
<p><img src="https://image.woodwhales.cn/092/images/16.png"></p>
<p>查看容器挂载宿主机信息方式1</p>
<p><img src="https://image.woodwhales.cn/092/images/17.png"></p>
<p>查看容器挂载宿主机信息方式2</p>
<p><img src="https://image.woodwhales.cn/092/images/18.png"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 低版本升级至最新版本（centos os）</title>
    <url>/2023/12/15/093/</url>
    <content><![CDATA[<h2 id="卸载低版本-docker"><a href="#卸载低版本-docker" class="headerlink" title="卸载低版本 docker"></a>卸载低版本 docker</h2><p>查看已安装 docker</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum list installed |grep docker</span><br></pre></td></tr></tbody></table></figure>

<p>卸载 docker</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum -y remove docker*</span><br></pre></td></tr></tbody></table></figure>

<h2 id="从阿里下载repo镜像"><a href="#从阿里下载repo镜像" class="headerlink" title="从阿里下载repo镜像"></a>从阿里下载repo镜像</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></tbody></table></figure>

<p>这条命令下载完成后，会把 repo 包放在<code>/etc/yum.repos.d/</code>下</p>
<p>执行下述命令可以查看到已经下载成功的 repo 包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></tbody></table></figure>

<p>查看 repolist：</p>
<p><img src="https://image.woodwhales.cn/093/images/1.png"></p>
<h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">yum install docker-ce -y</span><br></pre></td></tr></tbody></table></figure>

<h2 id="启动-docker"><a href="#启动-docker" class="headerlink" title="启动 docker"></a>启动 docker</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></tbody></table></figure>

<h2 id="查看-docker-版本"><a href="#查看-docker-版本" class="headerlink" title="查看 docker 版本"></a>查看 docker 版本</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></tbody></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></tbody></table></figure>

<h2 id="开机自启动-docker"><a href="#开机自启动-docker" class="headerlink" title="开机自启动 docker"></a>开机自启动 docker</h2><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></tbody></table></figure>

<h2 id="docker-镜像源配置"><a href="#docker-镜像源配置" class="headerlink" title="docker 镜像源配置"></a>docker 镜像源配置</h2><p>创建或修改 /etc/docker/daemon.json 文件，修改为如下形式</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    "registry-mirrors": [</span><br><span class="line">        "http://hub-mirror.c.163.com",</span><br><span class="line">        "https://docker.mirrors.ustc.edu.cn",</span><br><span class="line">        "https://registry.docker-cn.com"</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>加载重启 docker</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>

<p>查看 docker 镜像源配置是否成功：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/093/images/2.png"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL 的 hstore、arrays 数据类型</title>
    <url>/2023/12/27/094/</url>
    <content><![CDATA[<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><p>官网地址：<a href="https://www.postgresql.org/">https://www.postgresql.org/</a></p>
<p>pgSQL 12.0 官网教程：<a href="https://www.postgresql.org/docs/12/index.html">https://www.postgresql.org/docs/12/index.html</a> （PDF 版：<a href="http://172.16.20.122:8190/download/attachments/2031619/postgresql-12-A4.pdf?version=1&amp;modificationDate=1703494025231&amp;api=v2">postgresql-12-A4.pdf</a>）</p>
<h1 id="hstore-数据类型"><a href="#hstore-数据类型" class="headerlink" title="hstore 数据类型"></a>hstore 数据类型</h1><blockquote>
<p>hstore 官网教程：<a href="https://www.postgresql.org/docs/12/hstore.html">https://www.postgresql.org/docs/12/hstore.html</a></p>
<p>hstore 中文教程：<a href="http://www.postgres.cn/docs/12/hstore.html">http://www.postgres.cn/docs/12/hstore.html</a> 或 <a href="https://www.sjkjc.com/postgresql/hstore-type/">https://www.sjkjc.com/postgresql/hstore-type/</a></p>
<p>辅助资料：<a href="https://wiki.postgresql.org/wiki/File:Pg-as-nosql-pgday-fosdem-2013.pdf">https://wiki.postgresql.org/wiki/File:Pg-as-nosql-pgday-fosdem-2013.pdf</a> （附件：<a href="http://172.16.20.122:8190/download/attachments/2031619/Pg-as-nosql-pgday-fosdem-2013.pdf?version=1&amp;modificationDate=1703496093478&amp;api=v2">Pg-as-nosql-pgday-fosdem-2013.pdf</a>）</p>
</blockquote>
<h2 id="hstore-数据类型-1"><a href="#hstore-数据类型-1" class="headerlink" title="hstore 数据类型"></a>hstore 数据类型</h2><p>Postgres hstore 是 PostgreSQL 数据库中的一种特殊数据类型，它允许我们以键值对的形式保存和操作任意数量的数据。</p>
<p>hstore 类型的数据可以在查询时更加方便地进行复杂的条件搜索和匹配。我们可以使用 hstore 数据类型来存储 JSON 数据、动态属性集、键值对配置等复杂数据结构。</p>
<p>PostgreSQL <code>HSTORE</code> 数据类型很适合存储无规则的字典值，比如电子产品的属性，服装的规格等。</p>
<h3 id="hstore-数据格式"><a href="#hstore-数据格式" class="headerlink" title="hstore 数据格式"></a>hstore 数据格式</h3><p>HSTORE 类型字段是存储 k-v 数据的集合，key 和 value 之间使用 =&gt; 进行映射。多个 k-v 对之间使用英文逗号分隔</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">"key1=&gt;value1"[, "key2=&gt;value2", ...]</span><br></pre></td></tr></tbody></table></figure>

<p>这里：</p>
<ul>
<li><code>"key1=&gt;value1"</code> 是一个键值对。 如果键和值中不包含空格，可以省略双引号。</li>
<li>多个键值对之间使用逗号分隔。</li>
<li>键和值都是文本值。</li>
</ul>
<h3 id="启用-hstore"><a href="#启用-hstore" class="headerlink" title="启用 hstore"></a>启用 hstore</h3><p>PostgreSQL <code>HSTORE</code> 数据类型在 hstore 模块中实现。要使用 PostgreSQL <code>HSTORE</code> 类型，需要启用扩展：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION hstore;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="hstore-数据类型操作示例"><a href="#hstore-数据类型操作示例" class="headerlink" title="hstore 数据类型操作示例"></a>hstore 数据类型操作示例</h2><h3 id="库表数据准备"><a href="#库表数据准备" class="headerlink" title="库表数据准备"></a>库表数据准备</h3><p>创建示例库表</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> "users" (</span><br><span class="line">  "id" serial <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  "username" <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  "config" hstore</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> "users"."id" <span class="keyword">IS</span> <span class="string">'主键'</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> "users"."username" <span class="keyword">IS</span> <span class="string">'用户名称'</span>;</span><br><span class="line">COMMENT <span class="keyword">ON</span> <span class="keyword">COLUMN</span> "users"."config" <span class="keyword">IS</span> <span class="string">'用户属性配置'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>创建数据</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users ( username, config )</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'tom'</span>,<span class="string">'"language"=&gt;"Chinese","weight"=&gt;"45 kg","email"=&gt;"tom@xx.com"'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users ( username, config )</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'jack'</span>,<span class="string">'"language"=&gt;"English","weight"=&gt;"56 kg","email"=&gt;"jack123@xx.com"'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users ( username, config )</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'rose'</span>,<span class="string">'"language"=&gt;"Chinese","weight"=&gt;"66.6 kg","email"=&gt;"rose567@xx.com"'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users ( username, config )</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'tony'</span>,<span class="string">'"language"=&gt;"English","weight"=&gt;"50.2 kg","job"=&gt;"barber"'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users ( username, config )</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'jenny'</span>,<span class="string">'"language"=&gt;"Chinese","job"=&gt;"chef","hight"=&gt;"187"'</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>得到如下基础数据：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/1.png"></p>
<h3 id="查询-hstore-列"><a href="#查询-hstore-列" class="headerlink" title="查询 hstore 列"></a>查询 hstore 列</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	config </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/2.png"></p>
<h3 id="查询指定-key-的数值"><a href="#查询指定-key-的数值" class="headerlink" title="查询指定 key 的数值"></a>查询指定 key 的数值</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	config <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">'email'</span> <span class="keyword">AS</span> user_email </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/3.png"></p>
<h3 id="where-条件查询"><a href="#where-条件查询" class="headerlink" title="where 条件查询"></a>where 条件查询</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	config <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">'language'</span> <span class="operator">=</span> <span class="string">'Chinese'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/4.png"></p>
<h3 id="更新-k-v-对"><a href="#更新-k-v-对" class="headerlink" title="更新 k-v 对"></a>更新 k-v 对</h3><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users </span><br><span class="line"><span class="keyword">set</span> config <span class="operator">=</span> config <span class="operator">||</span> hstore(<span class="string">'email'</span>, <span class="string">'rose345@xx.com'</span>) </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	username <span class="operator">=</span> <span class="string">'rose'</span> returning <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>returning *</code> 表示返回成功影响行数的所有列信息</p>
<p><img src="https://image.woodwhales.cn/094/images/5.png"></p>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users </span><br><span class="line"><span class="keyword">set</span> config[<span class="string">'email'</span>] <span class="operator">=</span> <span class="string">'rose3456@xx.com'</span> </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	username <span class="operator">=</span> <span class="string">'rose'</span> returning <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>returning *</code> 表示返回成功影响行数的所有列信息</p>
<p><img src="https://image.woodwhales.cn/094/images/6.png"></p>
<h3 id="插入-k-v-对"><a href="#插入-k-v-对" class="headerlink" title="插入 k-v 对"></a>插入 k-v 对</h3><p>和更新语法一致</p>
<h4 id="方式1-1"><a href="#方式1-1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users </span><br><span class="line"><span class="keyword">set</span> config[<span class="string">'address'</span>] <span class="operator">=</span> <span class="string">'beijing'</span> </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	username <span class="operator">=</span> <span class="string">'rose'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>returning *</code> 表示返回成功影响行数的所有列信息</p>
<p><img src="https://image.woodwhales.cn/094/images/7.png"></p>
<h4 id="方式2-1"><a href="#方式2-1" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users </span><br><span class="line"><span class="keyword">SET</span> config <span class="operator">=</span> config <span class="operator">||</span> hstore ( <span class="string">'address'</span>, <span class="string">'shanghai'</span> ) </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	username <span class="operator">=</span> <span class="string">'tom'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>returning *</code> 表示返回成功影响行数的所有列信息</p>
<p><img src="https://image.woodwhales.cn/094/images/8.png"></p>
<h3 id="删除-k-v-对"><a href="#删除-k-v-对" class="headerlink" title="删除 k-v 对"></a>删除 k-v 对</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users </span><br><span class="line"><span class="keyword">SET</span> config <span class="operator">=</span> <span class="keyword">DELETE</span> ( config, <span class="string">'address'</span> ) </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	username <span class="operator">=</span> <span class="string">'tom'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>returning *</code> 表示返回成功影响行数的所有列信息</p>
<p><img src="https://image.woodwhales.cn/094/images/9.png"></p>
<h3 id="查询-hstore-列含有指定-key"><a href="#查询-hstore-列含有指定-key" class="headerlink" title="查询 hstore 列含有指定 key"></a>查询 hstore 列含有指定 key</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  	config<span class="operator">-</span><span class="operator">&gt;</span><span class="string">'job'</span> <span class="keyword">as</span> job,</span><br><span class="line">  	config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	config ? [<span class="string">'job'</span>, <span class="string">'address'</span>];</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/10.png"></p>
<h3 id="查询-hstore-列包含在指定-key-集合中"><a href="#查询-hstore-列包含在指定-key-集合中" class="headerlink" title="查询 hstore 列包含在指定 key 集合中"></a>查询 hstore 列包含在指定 key 集合中</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  	config<span class="operator">-</span><span class="operator">&gt;</span><span class="string">'job'</span> <span class="keyword">as</span> job,</span><br><span class="line">  	config<span class="operator">-</span><span class="operator">&gt;</span><span class="string">'address'</span> <span class="keyword">as</span> address,</span><br><span class="line">  	config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	config ?<span class="operator">|</span> <span class="keyword">ARRAY</span>[<span class="string">'job'</span>, <span class="string">'address'</span>];</span><br></pre></td></tr></tbody></table></figure>

<p><code>?| ARRAY['job', 'address']</code> 表示查询记录的 hstore 字段中 key 是否包含在指定字符串数组中。</p>
<p><img src="https://image.woodwhales.cn/094/images/11.png"></p>
<h3 id="查询-hstore-列全量包含指定-key-集合"><a href="#查询-hstore-列全量包含指定-key-集合" class="headerlink" title="查询 hstore 列全量包含指定 key 集合"></a>查询 hstore 列全量包含指定 key 集合</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">    config<span class="operator">-</span><span class="operator">&gt;</span><span class="string">'email'</span> <span class="keyword">as</span> email,</span><br><span class="line">	config<span class="operator">-</span><span class="operator">&gt;</span><span class="string">'address'</span> <span class="keyword">as</span> address,</span><br><span class="line">  config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	config ?<span class="operator">&amp;</span> <span class="keyword">ARRAY</span>[<span class="string">'email'</span>, <span class="string">'address'</span>];</span><br></pre></td></tr></tbody></table></figure>

<p><code>?&amp; ARRAY['job', 'address']</code> 表示查询记录的 hstore 字段中 key 必须被指定字符串数组中所有元素包含。</p>
<p><img src="https://image.woodwhales.cn/094/images/12.png"></p>
<h3 id="查询-hstore-列所有-key"><a href="#查询-hstore-列所有-key" class="headerlink" title="查询 hstore 列所有 key"></a>查询 hstore 列所有 key</h3><h4 id="方式1-2"><a href="#方式1-2" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">	akeys ( config ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/13.png"></p>
<h4 id="方式2-2"><a href="#方式2-2" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">	skeys ( config ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/14.png"></p>
<h3 id="查询-hstore-列所有-key-并去重"><a href="#查询-hstore-列所有-key-并去重" class="headerlink" title="查询 hstore 列所有 key 并去重"></a>查询 hstore 列所有 key 并去重</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">UNNEST</span></span><br><span class="line">	( akeys ( config ) ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/17.png"></p>
<h3 id="查询-hstore-列所有-value"><a href="#查询-hstore-列所有-value" class="headerlink" title="查询 hstore 列所有 value"></a>查询 hstore 列所有 value</h3><h4 id="方式1-3"><a href="#方式1-3" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">	avals ( config ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/15.png"></p>
<h4 id="方式2-3"><a href="#方式2-3" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">	svals ( config ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/16.png"></p>
<h3 id="查询-hstore-列所有-value-并去重"><a href="#查询-hstore-列所有-value-并去重" class="headerlink" title="查询 hstore 列所有 value 并去重"></a>查询 hstore 列所有 value 并去重</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">UNNEST</span></span><br><span class="line">	( avals ( config ) ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/18.png"></p>
<h3 id="合并-k-v-对"><a href="#合并-k-v-对" class="headerlink" title="合并 k-v 对"></a>合并 k-v 对</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  config ::hstore <span class="operator">||</span> <span class="string">'"email"=&gt;"tom"'</span> ::hstore <span class="keyword">as</span> newconfig,</span><br><span class="line">  config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> username <span class="operator">=</span> <span class="string">'jack'</span></span><br></pre></td></tr></tbody></table></figure>

<p>注意：<code>||</code>从左到右进行合并，如果 key 相同则后者覆盖掉前者 </p>
<p><img src="https://image.woodwhales.cn/094/images/19.png"></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  <span class="string">'"email"=&gt;"tom"'</span> ::hstore <span class="operator">||</span> config ::hstore <span class="keyword">as</span> newconfig,</span><br><span class="line">  config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> username <span class="operator">=</span> <span class="string">'jack'</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/20.png"></p>
<h3 id="查询-hstore-列表包含指定-k-v-对"><a href="#查询-hstore-列表包含指定-k-v-对" class="headerlink" title="查询 hstore 列表包含指定 k-v 对"></a>查询 hstore 列表包含指定 k-v 对</h3><p>查询包含：”language”=&gt;”English” 的记录</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  config	</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"> config ::hstore @<span class="operator">&gt;</span> <span class="string">'"language"=&gt;"English"'</span> ::hstore</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/21.png"></p>
<h3 id="过滤指定-key-集合"><a href="#过滤指定-key-集合" class="headerlink" title="过滤指定 key 集合"></a>过滤指定 key 集合</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  config ::hstore <span class="operator">-</span> <span class="keyword">ARRAY</span>[<span class="string">'hight'</span>,<span class="string">'language'</span>] <span class="keyword">as</span> newconfig,</span><br><span class="line">	config</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  username <span class="operator">=</span> <span class="string">'jenny'</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/22.png"></p>
<h3 id="过滤指定-key"><a href="#过滤指定-key" class="headerlink" title="过滤指定 key"></a>过滤指定 key</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	username,</span><br><span class="line">  config ::hstore <span class="operator">-</span> <span class="string">'hight'</span> ::text <span class="keyword">as</span> newconfig,</span><br><span class="line">	config</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	users </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  username <span class="operator">=</span> <span class="string">'jenny'</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/23.png"></p>
<h1 id="Arrays-数据类型"><a href="#Arrays-数据类型" class="headerlink" title="Arrays 数据类型"></a>Arrays 数据类型</h1><blockquote>
<p>Arrays 官网教程：<a href="https://www.postgresql.org/docs/12/arrays.html">https://www.postgresql.org/docs/12/arrays.html</a></p>
<p>hstore 中文教程：<a href="http://www.postgres.cn/docs/12/arrays.html">http://www.postgres.cn/docs/12/arrays.html</a> 或 <a href="https://www.sjkjc.com/postgresql/array-type/">https://www.sjkjc.com/postgresql/array-type/</a></p>
</blockquote>
<h2 id="arrays-列增加新元素"><a href="#arrays-列增加新元素" class="headerlink" title="arrays 列增加新元素"></a>arrays 列增加新元素</h2><h3 id="方式1-4"><a href="#方式1-4" class="headerlink" title="方式1"></a>方式1</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_hobbies</span><br><span class="line"><span class="keyword">SET</span> hobbies <span class="operator">=</span> ARRAY_APPEND(hobbies, <span class="string">'draw'</span>)</span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">'rose'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/28.png"></p>
<h3 id="方式2-4"><a href="#方式2-4" class="headerlink" title="方式2"></a>方式2</h3><p>等同于：<code>array_cat（hobbies, ARRAY['cook'])</code></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_hobbies</span><br><span class="line"><span class="keyword">SET</span> hobbies <span class="operator">=</span> hobbies <span class="operator">||</span> <span class="keyword">ARRAY</span>[<span class="string">'cook'</span>]</span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">'rose'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/29.png"></p>
<h2 id="查看-arrays-列"><a href="#查看-arrays-列" class="headerlink" title="查看 arrays 列"></a>查看 arrays 列</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    username,</span><br><span class="line">    hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    user_hobbies;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/24.png"></p>
<h2 id="操作数组类型列"><a href="#操作数组类型列" class="headerlink" title="操作数组类型列"></a>操作数组类型列</h2><h3 id="arrays-列中元素是否存在指定元素"><a href="#arrays-列中元素是否存在指定元素" class="headerlink" title="arrays 列中元素是否存在指定元素"></a>arrays 列中元素是否存在指定元素</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  username,</span><br><span class="line">  hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  user_hobbies</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="string">'football'</span> <span class="operator">=</span> <span class="keyword">ANY</span> (hobbies);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/25.png"></p>
<h3 id="arrays-列中元素是否存在于指定数组"><a href="#arrays-列中元素是否存在于指定数组" class="headerlink" title="arrays 列中元素是否存在于指定数组"></a>arrays 列中元素是否存在于指定数组</h3><blockquote>
<p>使用 <code>&amp;&amp;</code> 运算符来检查两个数组是否有交集，如果有交集，就表示数组中的任一元素存在于目标数组中。</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  username,</span><br><span class="line">  hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  user_hobbies</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">array</span>[<span class="string">'football'</span>, <span class="string">'dance'</span>] <span class="operator">&amp;&amp;</span> hobbies;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/26.png"></p>
<h3 id="arrays-列中元素均不存在于指定数组"><a href="#arrays-列中元素均不存在于指定数组" class="headerlink" title="arrays 列中元素均不存在于指定数组"></a>arrays 列中元素均不存在于指定数组</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  username,</span><br><span class="line">  hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  user_hobbies</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">not</span>(<span class="keyword">array</span>[<span class="string">'basketball'</span>, <span class="string">'football'</span>] <span class="operator">&amp;&amp;</span> hobbies);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/27.png"></p>
<h3 id="指定数组是否为-arrays-列的子集"><a href="#指定数组是否为-arrays-列的子集" class="headerlink" title="指定数组是否为 arrays 列的子集"></a>指定数组是否为 arrays 列的子集</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  username,</span><br><span class="line">  hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  user_hobbies</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">array</span>[<span class="string">'dance'</span>, <span class="string">'cook'</span>] <span class="operator">&lt;</span>@ hobbies;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/30.png"></p>
<h3 id="arrays-列是否为指定数组的子集"><a href="#arrays-列是否为指定数组的子集" class="headerlink" title="arrays 列是否为指定数组的子集"></a>arrays 列是否为指定数组的子集</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  username,</span><br><span class="line">  hobbies</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  user_hobbies</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">array</span>[<span class="string">'basketball'</span>, <span class="string">'football'</span>] @<span class="operator">&gt;</span> hobbies;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/31.png"></p>
<h3 id="arrays-列中移除指定元素"><a href="#arrays-列中移除指定元素" class="headerlink" title="arrays 列中移除指定元素"></a>arrays 列中移除指定元素</h3><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> user_hobbies </span><br><span class="line"><span class="keyword">SET</span> hobbies <span class="operator">=</span> array_remove ( hobbies, <span class="string">'cook'</span> ) </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	username <span class="operator">=</span> <span class="string">'rose'</span> RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/094/images/32.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.sjkjc.com/postgresql/hstore-type/">https://www.sjkjc.com/postgresql/hstore-type/</a></p>
<p><a href="https://geek-docs.com/postgresql/postgresql-questions/455_postgresql_postgres_hstore_gin_vs_gist_index_performance.html">https://geek-docs.com/postgresql/postgresql-questions/455_postgresql_postgres_hstore_gin_vs_gist_index_performance.html</a></p>
<p><a href="http://www.freeoa.net/osuport/db/pg-type-hstore-jsonb_3367.html">http://www.freeoa.net/osuport/db/pg-type-hstore-jsonb_3367.html</a></p>
<p><a href="https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-hstore/">https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-hstore/</a></p>
<p><a href="https://www.dbvis.com/thetable/storing-unstructured-data-with-hstore-in-postgresql/">https://www.dbvis.com/thetable/storing-unstructured-data-with-hstore-in-postgresql/</a></p>
<p><a href="https://blog.csdn.net/neweastsun/article/details/92849375">https://blog.csdn.net/neweastsun/article/details/92849375</a></p>
]]></content>
      <categories>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>安装JDK21（windows、centos）</title>
    <url>/2023/12/28/095/</url>
    <content><![CDATA[<h1 id="windows-系统"><a href="#windows-系统" class="headerlink" title="windows 系统"></a>windows 系统</h1><h2 id="安装-JDK21"><a href="#安装-JDK21" class="headerlink" title="安装 JDK21"></a>安装 JDK21</h2><p>清华大学镜像下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/Adoptium/21/jdk/x64/windows/OpenJDK21U-jdk_x64_windows_hotspot_21.0.1_12.msi">https://mirrors.tuna.tsinghua.edu.cn/Adoptium/21/jdk/x64/windows/OpenJDK21U-jdk_x64_windows_hotspot_21.0.1_12.msi</a></p>
<p>oracle 官网下载：<a href="https://www.oracle.com/cn/java/technologies/downloads/#jdk21-windows">https://www.oracle.com/cn/java/technologies/downloads/#jdk21-windows</a></p>
<blockquote>
<p>adoptium github 仓库下载：<a href="https://github.com/adoptium/temurin21-binaries/releases">https://github.com/adoptium/temurin21-binaries/releases</a></p>
<p>openJDK 历史归档下载：<a href="https://jdk.java.net/archive/">https://jdk.java.net/archive/</a></p>
<p>oracle 官网历史归档下载：<a href="https://www.oracle.com/java/technologies/javase/jdk21-archive-downloads.html">https://www.oracle.com/java/technologies/javase/jdk21-archive-downloads.html</a></p>
</blockquote>
<p>双击 JDK 安装包，按照安装向导进行安装即可。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>adoptium 安装包时，注意选择安装到自定义的安装目录，便于后续配置<code>JAVA_HOME</code>。</li>
</ul>
<p><img src="https://image.woodwhales.cn/095/images/jdk2.png"></p>
<ul>
<li>oracle 安装包，注意选择安装到自定义的安装目录，便于后续配置<code>JAVA_HOME</code>。</li>
</ul>
<p><a href="https://image.woodwhales.cn/095/images/oracle_jdk1.png"></a></p>
<h2 id="配置-JAVA-HOME-系统环境变量"><a href="#配置-JAVA-HOME-系统环境变量" class="headerlink" title="配置 JAVA_HOME 系统环境变量"></a>配置 JAVA_HOME 系统环境变量</h2><p>步骤1：右击 win 菜单，弹出快捷选项，选择：系统</p>
<p><img src="https://image.woodwhales.cn/095/images/jdk4.png"></p>
<p>步骤2：点击：高级系统设置</p>
<p><img src="https://image.woodwhales.cn/095/images/jdk5.png"></p>
<p>步骤3：点击：环境变量</p>
<p><img src="https://image.woodwhales.cn/095/images/jdk6.png"></p>
<p>步骤2：在“系统变量(S)”中添加：JAVA_HOME 系统变量</p>
<p><img src="https://image.woodwhales.cn/095/images/jdk7.png"></p>
<p>步骤3：在系统变量的 PATH 中添加：<code>%JAVA_HOME%/bin</code></p>
<p><img src="https://image.woodwhales.cn/095/images/jdk8.png"></p>
<p>步骤4：查看 JAVA_HOME 系统环境变量是否生效：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">%JAVA_HOME%</span></span><br></pre></td></tr></tbody></table></figure>

<p>步骤5：查看 JAVA 版本信息</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure>

<h1 id="centos-系统"><a href="#centos-系统" class="headerlink" title="centos 系统"></a>centos 系统</h1><h2 id="安装-JDK-21"><a href="#安装-JDK-21" class="headerlink" title="安装 JDK 21"></a>安装 JDK 21</h2><p>强烈推荐使用 <a href="https://adoptium.net/zh-CN/">Eclipse Temurin</a> 平台发行的JDK LST 版本进行安装</p>
<blockquote>
<p>Eclipse Temurin 是由基于 OpenJDK 的开源 Java SE 产生的构建版本。Temurin 适用于平台广泛。</p>
<p>Eclipse Temurin 的前身是著名的 AdoptOpenJDK，更新到 jdk16 后就停止更新了。因为 AdoptOpenJDK 移交给 Eclipse 基金会后改名为：Adoptium Eclipse Temurin，后续维护工作就交给 Eclipse 基金会了。</p>
</blockquote>
<p>步骤1：创建 /etc/yum.repos.d/Adoptium.repo</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">touch /etc/yum.repos.d/Adoptium.repo</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：将下述配置写入 /etc/yum.repos.d/Adoptium.repo</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">name</span>=Adoptium</span><br><span class="line"><span class="attr">baseurl</span>=https://mirrors.tuna.tsinghua.edu.cn/Adoptium/rpm/centos<span class="variable">$releasever</span>-<span class="variable">$basearch</span>/</span><br><span class="line"><span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">gpgcheck</span>=<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：更新 yum 缓存</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo yum makecache</span><br></pre></td></tr></tbody></table></figure>

<p>步骤4：查看 yum 可以安装 jdk 信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum list | grep jdk</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/095/images/1.png"></p>
<p>步骤5：安装 jdk21</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">yum install -y temurin-21-jdk.x86_64</span><br></pre></td></tr></tbody></table></figure>

<p>步骤6：查看系统上已经安装的 JDK 列表</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/095/images/2.png"></p>
<h2 id="配置-JAVA-HOME-系统环境变量-1"><a href="#配置-JAVA-HOME-系统环境变量-1" class="headerlink" title="配置 JAVA_HOME 系统环境变量"></a>配置 JAVA_HOME 系统环境变量</h2><p>步骤1：配置 JAVA_HOME 系统环境变量，执行如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：在配置文件的最末尾行增加下述配置</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line">export <span class="attr">JAVA_HOME</span>=/usr/lib/jvm/temurin-<span class="number">21</span>-jdk/</span><br><span class="line">export <span class="attr">PATH</span>=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：配置生效，执行如下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure>

<p>步骤4：查看 JAVA_HOME 系统环境变量是否生效：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></tbody></table></figure>

<p>步骤5：查看 JAVA 版本信息</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>JDK21</category>
      </categories>
      <tags>
        <tag>JDK21</tag>
      </tags>
  </entry>
  <entry>
    <title>认识机器学习</title>
    <url>/2024/01/01/096/</url>
    <content><![CDATA[<blockquote>
<p>PPT 演示文件：<a href="https://image.woodwhales.cn/096/images/%E8%AE%A4%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%90woodwhales.cn%E3%80%91.pptx">认识机器学习【woodwhales.cn】.pptx</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/096/images/00.png"></p>
<h1 id="生活中的问题1：居民家庭生活用气价格"><a href="#生活中的问题1：居民家庭生活用气价格" class="headerlink" title="生活中的问题1：居民家庭生活用气价格"></a>生活中的问题1：居民家庭生活用气价格</h1><p>北京燃气小程序在线咨询，查询北京居民家庭生活用气价格</p>
<img src="https://image.woodwhales.cn/096/images/01.png" style="zoom:50%;">

<p>上图价格梯度，可以由文字转换成表格：</p>
<p>第一档用气量为0-350（含）立方米，气价为2.61元/m³； </p>
<p>第二档用气量在350-500（含）立方米之间，气价为每立方米2.83元/m³；</p>
<p>第三档用气量为500立方米以上，气价为每立方米4.23元/m³。</p>
<table>
<thead>
<tr>
<th>分档</th>
<th>用气量（立方米）</th>
<th>价格（元/立方米）</th>
</tr>
</thead>
<tbody><tr>
<td>第一档</td>
<td>0-350（含）</td>
<td>2.61</td>
</tr>
<tr>
<td>第二档</td>
<td>350-500（含）</td>
<td>2.83</td>
</tr>
<tr>
<td>第三档</td>
<td>500以上</td>
<td>4.23</td>
</tr>
</tbody></table>
<p>某居民使用一些天然气之后，需要知道应该支付多少费用，该使用什么函数来计算：居民家庭生活用气量 x 与 价格 f(x) 的关系：</p>
<p><img src="https://image.woodwhales.cn/096/images/02.png"></p>
<p>利用初中数学知识，可以得到居民家庭生活用气量 x 与 价格 f(x) 的函数关系为：</p>
<p><img src="https://image.woodwhales.cn/096/images/03.png"></p>
<h1 id="生活中的问题2：北京市部分区域二手房房价"><a href="#生活中的问题2：北京市部分区域二手房房价" class="headerlink" title="生活中的问题2：北京市部分区域二手房房价"></a>生活中的问题2：北京市部分区域二手房房价</h1><p>以 2023年11月30日北京市部分区域二手房房价为例</p>
<p><img src="https://image.woodwhales.cn/096/images/04.png"></p>
<p>如何从上图的二手房真实价格中，找出面积和房价的函数关系？</p>
<p><img src="https://image.woodwhales.cn/096/images/05.png"></p>
<h1 id="二手房价的数学函数表达"><a href="#二手房价的数学函数表达" class="headerlink" title="二手房价的数学函数表达"></a>二手房价的数学函数表达</h1><p>将上章节中的面积和房价形成一个个二位坐标点信息，放到二位坐标系中，能否找到一条直线或者曲线来表达：面积和房价的关系：</p>
<p><img src="https://image.woodwhales.cn/096/images/06.png"></p>
<p>从直觉来看，可以绘制如下可能的函数直线或曲线：</p>
<p><img src="https://image.woodwhales.cn/096/images/07.png"></p>
<p>从上图中可以看到：蓝色和橙色函数均可以表达面积和房价的关系，但是哪一条是最合适的需要有充分的说服力。</p>
<p><img src="https://image.woodwhales.cn/096/images/08.png"></p>
<p>我们知道，房价的影响因素很多，还有诸多因素：</p>
<p><img src="https://image.woodwhales.cn/096/images/09.png"></p>
<p>每一个影响因素可以使用形如面积和房价的函数关系式表达，所有因素之和最终决定了房价：</p>
<p><img src="https://image.woodwhales.cn/096/images/10.png"></p>
<p>从上述房价的函数式可以知道，房价最终是由 w 和 b 决定。</p>
<p><img src="https://image.woodwhales.cn/096/images/11.png"></p>
<p>结合线性代数的矩阵转置基础知识，可以将上述函数式简化表达：</p>
<p><img src="https://image.woodwhales.cn/096/images/12.png"></p>
<p>假设我们已经找到参数对（W1, b1）是房价函数的可能最优解，那么如何来确认这个参数对就一定是最优解呢？</p>
<p><img src="https://image.woodwhales.cn/096/images/13.png"></p>
<p>正如上图所说：如果存在某个函数存在，使得能精准预测所有真实结果，则该函数为最优解。但是现实情况中，可能没有最完美的函数。那如何在所有“差的”函数中找到“最不差的”？</p>
<p>利用高中的期望知识可以得到：真实值 – 预测值 = 差值（代价），所有差值之和最小则为最优解。即：只要存在参数对（W1, b1）利用房价函数的得到的所有房价和其真实房价差距最小则为最优解。</p>
<p><img src="https://image.woodwhales.cn/096/images/14.png"></p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>从上述可以得到下述三个函数式</p>
<p><img src="https://image.woodwhales.cn/096/images/15.png"></p>
<p>将上图中的下方俩个函数带入第一个函数，可以简化成如下：</p>
<p><img src="https://image.woodwhales.cn/096/images/16.png"></p>
<p>对于函数 g(w,b) 的参数对 (w,b) 数值进行穷举，会得到诸多 g 和 g（w, b）的数据对，将这些数据对绘制到三维坐标系中，可以表示为如下图：</p>
<p><img src="https://image.woodwhales.cn/096/images/17.png"></p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>从上图可以看到，三维坐标系中的函数图像”最低处“就是方差最小的地方，也就是参数对（w, b）对于房价函数的最优解。求“最低点”的方法叫：梯度下降算法。</p>
<p><img src="https://image.woodwhales.cn/096/images/18.png"></p>
<p>通过上述推理，可以得知，想要找到房价函数的最优解，就是在找代价函数的最优解。</p>
<h2 id="类推其他问题"><a href="#类推其他问题" class="headerlink" title="类推其他问题"></a>类推其他问题</h2><p>生活中除了房价问题，还有很多类似问题都是需要人类找到最优的函数：</p>
<p><img src="https://image.woodwhales.cn/096/images/19.png"></p>
<p>上图中函数就是在解答相应的问题，那么谁来解决帮我们找到最优函数呢？答案不言而喻。</p>
<p><img src="https://image.woodwhales.cn/096/images/20.png"></p>
<h1 id="常见的机器学习问题"><a href="#常见的机器学习问题" class="headerlink" title="常见的机器学习问题"></a>常见的机器学习问题</h1><p>常见的机器学习问题可以归类为：回归问题、分类问题、聚类问题</p>
<p><img src="https://image.woodwhales.cn/096/images/21.png"></p>
<h1 id="机器学习算法的分类"><a href="#机器学习算法的分类" class="headerlink" title="机器学习算法的分类"></a>机器学习算法的分类</h1><p>按学习的方式来划分：</p>
<ul>
<li>监督学习</li>
<li>非监督学习</li>
<li>半监督学习</li>
<li>强化学习</li>
</ul>
<p><img src="https://image.woodwhales.cn/096/images/22.png"></p>
<p>按功能来划分：</p>
<p><img src="https://image.woodwhales.cn/096/images/23.png"></p>
<h1 id="AI、ML、DL、-AIGC"><a href="#AI、ML、DL、-AIGC" class="headerlink" title="AI、ML、DL、 AIGC"></a>AI、ML、DL、 AIGC</h1><p>AI、ML、DL、 AIGC 四者的关系如图：</p>
<p><img src="https://image.woodwhales.cn/096/images/24.png"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="文字资料"><a href="#文字资料" class="headerlink" title="文字资料"></a>文字资料</h2><p><a href="https://nndl.github.io/">神经网络与深度学习-邱锡鹏</a></p>
<p><a href="https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471">https://medium.com/@ageitgey/machine-learning-is-fun-80ea3ec3c471#.ak1of1xbg</a></p>
<p><a href="https://synoptek.com/insights/it-blogs/data-insights/ai-ml-dl-and-generative-ai-face-off-a-comparative-analysis/">https://synoptek.com/insights/it-blogs/data-insights/ai-ml-dl-and-generative-ai-face-off-a-comparative-analysis/</a></p>
<p><a href="https://feisky.xyz/machine-learning/basic.html">https://feisky.xyz/machine-learning/basic.html</a></p>
<p><a href="https://cloud.google.com/learn/what-is-artificial-intelligence?hl=zh-cn">https://cloud.google.com/learn/what-is-artificial-intelligence?hl=zh-cn</a></p>
<h2 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h2><blockquote>
<p>下述视频资料可以在 B 站上找到同名视频</p>
</blockquote>
<p><a href="https://youtu.be/5A9bmW1qTpk?si=B5uyHKIgaigHaP7Z">机器能像人一样思考吗？人工智能（一）机器学习和神经网络</a></p>
<p><a href="https://youtu.be/AFlIM0jSI9I?si=o3MJahbFvRi7Q_3t">人脸识别啥原理？人工智能（二）卷积神经网络</a></p>
<p><a href="https://youtu.be/MU03tMR1-CU?si=5WBer2agKph98Ira">“神经网络”是什么？如何直观理解它的能力极限？它是如何无限逼近真理的？</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda 安装 for windows</title>
    <url>/2024/01/01/097/</url>
    <content><![CDATA[<h2 id="下载-anaconda"><a href="#下载-anaconda" class="headerlink" title="下载 anaconda"></a>下载 anaconda</h2><p>官网下载地址：<a href="https://www.anaconda.com/download#downloads">https://www.anaconda.com/download#downloads</a></p>
<blockquote>
<p>anaconda 官网：<a href="https://www.anaconda.com/">https://www.anaconda.com/</a></p>
<p>历史版本下载地址：<a href="https://repo.anaconda.com/archive/">https://repo.anaconda.com/archive/</a></p>
<p>清华镜像安装包下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>
<p>阿里云镜像安装包下载地址：<a href="http://mirrors.aliyun.com/anaconda/archive/">http://mirrors.aliyun.com/anaconda/archive/</a></p>
<p>github 仓库：<a href="https://github.com/ultralytics/ultralytics/blob/main/README.zh-CN.md">https://github.com/ultralytics/ultralytics/blob/main/README.zh-CN.md</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/097/images/01.png"></p>
<h2 id="安装-anaconda"><a href="#安装-anaconda" class="headerlink" title="安装 anaconda"></a>安装 anaconda</h2><p>步骤1：右击安装包，使用：管理员身份运行</p>
<p><img src="https://image.woodwhales.cn/097/images/02.png"></p>
<p>步骤2：同意协议</p>
<p><img src="https://image.woodwhales.cn/097/images/03.png"></p>
<p>步骤3：为所有用户安装</p>
<p><img src="https://image.woodwhales.cn/097/images/04.png"></p>
<p>步骤4：选择要安装的路径，建议使用默认路径</p>
<p><img src="https://image.woodwhales.cn/097/images/05.png"></p>
<p>步骤5：默认安装配置勾选了前俩项，不需要改动</p>
<p><img src="https://image.woodwhales.cn/097/images/06.png"></p>
<p>步骤6：进入安装界面</p>
<p><img src="https://image.woodwhales.cn/097/images/07.png"></p>
<p>步骤7：安装进度信息最后提示：完成，表示安装完毕</p>
<p><img src="https://image.woodwhales.cn/097/images/08.png"></p>
<p>步骤8：直接下一步</p>
<p><img src="https://image.woodwhales.cn/097/images/09.png"></p>
<p>步骤9：确认全部安装完毕</p>
<p><img src="https://image.woodwhales.cn/097/images/10.png"></p>
<h2 id="系统环境变量配置"><a href="#系统环境变量配置" class="headerlink" title="系统环境变量配置"></a>系统环境变量配置</h2><p>步骤1：将 anaconda 安装目录配置到系统环境变量中</p>
<p><img src="https://image.woodwhales.cn/097/images/11.png"></p>
<p>步骤2：在 cmd 窗口中，执行<code>conda info</code> 命令验证是否配置成功，出现 conda 信息表示配置成功</p>
<p><img src="https://image.woodwhales.cn/097/images/12.png"></p>
<h2 id="anaconda-镜像配置"><a href="#anaconda-镜像配置" class="headerlink" title="anaconda 镜像配置"></a>anaconda 镜像配置</h2><h3 id="使用清华大学镜像"><a href="#使用清华大学镜像" class="headerlink" title="使用清华大学镜像"></a>使用清华大学镜像</h3><p>镜像官网地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p>
<p>步骤1：在 cmd 窗口中运行：<code> conda config --set show_channel_urls yes</code>命令，会在系统的用户目录下生成<code>.condarc</code>文件</p>
<p>步骤2：将<code>.condarc</code>文件中的内容替换为：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">deepmodeling:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用阿里云镜像"><a href="#使用阿里云镜像" class="headerlink" title="使用阿里云镜像"></a>使用阿里云镜像</h3><p>镜像官网地址：<a href="https://developer.aliyun.com/mirror/anaconda">https://developer.aliyun.com/mirror/anaconda</a></p>
<p>步骤1：在 cmd 窗口中运行：<code> conda config --set show_channel_urls yes</code>命令，会在系统的用户目录下生成<code>.condarc</code>文件</p>
<p>步骤2：将<code>.condarc</code>文件中的内容替换为：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://mirrors.aliyun.com/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://mirrors.aliyun.com/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">http://mirrors.aliyun.com/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">http://mirrors.aliyun.com/anaconda/cloud</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="conda-常用命令"><a href="#conda-常用命令" class="headerlink" title="conda 常用命令"></a>conda 常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>命令解释</th>
</tr>
</thead>
<tbody><tr>
<td>conda list</td>
<td>查看安装了哪些包</td>
</tr>
<tr>
<td>conda env list 或 conda info -e</td>
<td>查看当前存在哪些虚拟环境</td>
</tr>
<tr>
<td>conda update conda</td>
<td>检查更新当前 conda</td>
</tr>
<tr>
<td>conda config –show-sources</td>
<td>查看 conda 镜像</td>
</tr>
</tbody></table>
<h2 id="PyCharm-安装及环境配置"><a href="#PyCharm-安装及环境配置" class="headerlink" title="PyCharm 安装及环境配置"></a>PyCharm 安装及环境配置</h2><p>步骤1：从官网下载：<a href="https://www.jetbrains.com/pycharm/%E5%B9%B6%E5%AE%89%E8%A3%85">https://www.jetbrains.com/pycharm/并安装</a> PyCharm</p>
<p>步骤2：创建新的 Project，指定 python interpreter 环境</p>
<p><img src="https://image.woodwhales.cn/097/images/pycharm01.png"></p>
<p><img src="https://image.woodwhales.cn/097/images/pycharm02.png"></p>
]]></content>
      <categories>
        <category>anaconda</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 安装 Minio</title>
    <url>/2024/01/09/098/</url>
    <content><![CDATA[<h1 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h1><p>官网地址：<a href="https://min.io/">https://min.io/</a></p>
<p>Minio 需要使用到：服务端口（默认为 9000）和控制台端口（默认为 9001）</p>
<ul>
<li><p>服务端口</p>
<p>  默认：9000</p>
<p>  用于提供 Minio 对象存储服务。浏览器或者客户端可以通过该端口上传、下载和管理存储桶中的对象数据。</p>
</li>
<li><p>控制台端口</p>
<p>  默认：9001</p>
<p>  用于提供 Minio 的 Web 管理控制台服务。浏览器访问该端口就是访问 MinIO 控制台。</p>
</li>
</ul>
<h1 id="docker-安装-MinIO"><a href="#docker-安装-MinIO" class="headerlink" title="docker 安装 MinIO"></a>docker 安装 MinIO</h1><p>步骤1：拉取 minio 镜像</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：宿主机创建 minio 配置及数据目录</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p /data/minio/config</span><br><span class="line">mkdir -p /data/minio/data</span><br></pre></td></tr></tbody></table></figure>

<p>步骤3：docker 启动 minio</p>
<blockquote>
<p>执行下述命令前，检查宿主机映射的端口号是否被占用。</p>
<p>方式1：使用 netstat 命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">netstat -tuln | grep &lt;端口号&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>方式2：使用 lsof 命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">lsof -i :&lt;端口号&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>方式3：使用 ss 命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ss -tuln | grep &lt;端口号&gt;</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>下述命令，将宿主机的 9500 端口映射到 9000，9501 d端口映射到 90001。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d --restart=always \</span><br><span class="line">--name minio \</span><br><span class="line">--network=host \</span><br><span class="line">-p 9500:9000 \</span><br><span class="line">-p 9501:9001 \</span><br><span class="line">-e "MINIO_ACCESS_KEY=minioadmin" \</span><br><span class="line">-e "MINIO_SECRET_KEY=minioadmin" \</span><br><span class="line">-v /data/minio/data:/data \</span><br><span class="line">-v /data/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data \</span><br><span class="line">--address ":9500" --console-address ":9501"</span><br></pre></td></tr></tbody></table></figure>

<p>上述：<code>--address</code> 来指定 Minio 服务的服务监听端口，<code>--console-address</code> 来指定 Minio 控制台的监听端口。</p>
<p>步骤4：验证 minio 服务</p>
<p>假设宿主机的IP为：192.168.100.100，浏览器访问 minio 服务：<a href="http://192.168.100.100:9521/">http://192.168.100.100:9521</a></p>
]]></content>
      <categories>
        <category>Minio</category>
      </categories>
      <tags>
        <tag>Minio</tag>
      </tags>
  </entry>
  <entry>
    <title>解决在 yolov8 训练自己的数据集时，matplotlib 中文乱码问题</title>
    <url>/2024/03/20/099/</url>
    <content><![CDATA[<p>在 yolov8 训练自己的数据集时，如果 class 字典使用了中文，则在训练过程中会出现形如下面的警告：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">C:\Users\woodwhales\AppData\Roaming\Python\Python311\site-packages\ultralytics\utils\metrics.py:427: UserWarning: Glyph 26222 (\N{CJK UNIFIED IDEOGRAPH-666E}) missing from current font.</span><br><span class="line">  fig.savefig(plot_fname, dpi=250)</span><br></pre></td></tr></tbody></table></figure>

<h1 id="步骤1：找到-matplotlib-的字体文件目录"><a href="#步骤1：找到-matplotlib-的字体文件目录" class="headerlink" title="步骤1：找到 matplotlib 的字体文件目录"></a>步骤1：找到 matplotlib 的字体文件目录</h1><p>执行下述 python 脚本：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="built_in">print</span>(matplotlib.matplotlib_fname())</span><br></pre></td></tr></tbody></table></figure>

<p>执行上述脚本后，可以看到 matplotlibrc 文件的所在目录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\programs\anaconda3\Lib\site-packages\matplotlib\mpl-data\matplotlibrc</span><br></pre></td></tr></tbody></table></figure>

<h1 id="步骤2：将中文字体保存到-matplotlib"><a href="#步骤2：将中文字体保存到-matplotlib" class="headerlink" title="步骤2：将中文字体保存到 matplotlib"></a>步骤2：将中文字体保存到 matplotlib</h1><p>在步骤1 的基础上，可以得到 matplotlib 的文件根目录是：C:\programs\anaconda3\Lib\site-packages\matplotlib\mpl-data，那么字体文件目录就在 C:\programs\anaconda3\Lib\site-packages\matplotlib\mpl-data<strong>\fonts\ttf</strong></p>
<p>在 ttf 文件目录中拷贝中文字体，格式要求为 ttf，笔者使用的是微软雅黑，可以在这里下载：<a href="https://image.woodwhales.cn/099/images/microsoft-yahei.zip">Microsoft YaHei.zip</a></p>
<blockquote>
<p>windows系统中都有微软雅黑，文件目录为：C:\Windows\Fonts，但是其格式为 ttc，可以使用这个网站在线转换为 ttf：<a href="https://transfonter.org/ttc-unpack">https://transfonter.org/ttc-unpack</a></p>
</blockquote>
<p><img src="https://image.woodwhales.cn/099/images/01.png"></p>
<h1 id="步骤3：清除-matplotlib-缓存"><a href="#步骤3：清除-matplotlib-缓存" class="headerlink" title="步骤3：清除 matplotlib 缓存"></a>步骤3：清除 matplotlib 缓存</h1><p>执行下述 python 脚本：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">shutil.rmtree(matplotlib.get_cachedir())</span><br></pre></td></tr></tbody></table></figure>

<h1 id="步骤4：检查中文字体是否生效"><a href="#步骤4：检查中文字体是否生效" class="headerlink" title="步骤4：检查中文字体是否生效"></a>步骤4：检查中文字体是否生效</h1><p>执行下述 python 脚本：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.font_manager</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>([f <span class="keyword">for</span> f <span class="keyword">in</span> matplotlib.font_manager.fontManager.ttflist <span class="keyword">if</span> <span class="string">'Microsoft YaHei'</span> <span class="keyword">in</span> f.name])</span><br></pre></td></tr></tbody></table></figure>

<p>可以得到对应字体信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[FontEntry(fname='C:\\programs\\anaconda3\\Lib\\site-packages\\matplotlib\\mpl-data\\fonts\\ttf\\Microsoft YaHei.ttf', name='Microsoft YaHei', style='normal', variant='normal', weight=400, stretch='normal', size='scalable'), FontEntry(fname='C:\\Windows\\Fonts\\msyhbd.ttc', name='Microsoft YaHei', style='normal', variant='normal', weight=700, stretch='normal', size='scalable'), FontEntry(fname='C:\\Windows\\Fonts\\msyh.ttc', name='Microsoft YaHei', style='normal', variant='normal', weight=400, stretch='normal', size='scalable'), FontEntry(fname='C:\\Windows\\Fonts\\msyhl.ttc', name='Microsoft YaHei', style='normal', variant='normal', weight=290, stretch='normal', size='scalable')]</span><br></pre></td></tr></tbody></table></figure>

<h1 id="步骤5：matplotlib-使用中文字体"><a href="#步骤5：matplotlib-使用中文字体" class="headerlink" title="步骤5：matplotlib 使用中文字体"></a>步骤5：matplotlib 使用中文字体</h1><p>在训练集脚本的最开始，增加如下代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">matplotlib.rcParams[<span class="string">'font.family'</span>] = [<span class="string">'Microsoft YaHei'</span>]</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>yolov8</category>
      </categories>
      <tags>
        <tag>yolov8</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx常见自定义配置</title>
    <url>/2024/08/25/100/</url>
    <content><![CDATA[<blockquote>
<p>nginx 官网：<a href="https://nginx.org/">https://nginx.org</a></p>
<p>安装包下载地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p>
</blockquote>
<p>推荐下载 Mainline version，笔者以 <a href="https://nginx.org/download/nginx-1.27.1.zip">nginx/Windows-1.27.1</a> 为例：</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>下图为 vsCode 打开 nginx-1.27.1 程序目录文件夹视图：</p>
<p><img src="https://image.woodwhales.cn/100/images/01.png"></p>
<p>核心配置文件目录：conf 中存在核心配置文件：nginx.conf，默认配置如下（去除了注释）：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述配置，默认监听 80 端口，请求异常状态码为：500、502、503、504 时，均展示 html 文件目录中的 50x.html</p>
<h2 id="自定义-nginx-配置效果"><a href="#自定义-nginx-配置效果" class="headerlink" title="自定义 nginx 配置效果"></a>自定义 nginx 配置效果</h2><p>自定义配置达到效果如下图：</p>
<p><img src="https://image.woodwhales.cn/100/images/04.png"></p>
<p>监听 82 端口：</p>
<ul>
<li>/html 代理本地 html 静态页面</li>
<li>/file 代理本地文件资源</li>
<li>/api 代理本地 web 服务</li>
</ul>
<h3 id="步骤1：指定加载自定义配置文件"><a href="#步骤1：指定加载自定义配置文件" class="headerlink" title="步骤1：指定加载自定义配置文件"></a>步骤1：指定加载自定义配置文件</h3><p>在 conf/nginx.conf 配置中包含指定配置文件目录：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 添加自定义 nginx 配置目录</span><br><span class="line">include ../conf.d/*.conf;</span><br></pre></td></tr></tbody></table></figure>

<p>在 nginx 配置根目录中创建：conf.d 文件目录，nginx 运行时会加载这个目录下的所有 nginx 配置文件</p>
<p><img src="https://image.woodwhales.cn/100/images/03.png"></p>
<h3 id="步骤2：自定义反向代理"><a href="#步骤2：自定义反向代理" class="headerlink" title="步骤2：自定义反向代理"></a>步骤2：自定义反向代理</h3><p>在 conf.d/my.conf 配置文件中配置自定义 server 配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 自定义 nginx 配置</span><br><span class="line"></span><br><span class="line">server {</span><br><span class="line">    listen       82;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    # 反向代理静态页面</span><br><span class="line">	location /html {</span><br><span class="line">        # 可以使用相对路径，static_html 文件目录在 nginx 安装根目录中</span><br><span class="line">        # 也可以使用绝对路径 D:/nginx-1.27.1/static_html</span><br><span class="line">		alias  static_html/;</span><br><span class="line">		index  index.html;</span><br><span class="line">	}</span><br><span class="line"> </span><br><span class="line">    # 映射本地文件目录</span><br><span class="line">    location /file {</span><br><span class="line">        # 可以使用相对路径，static_html 文件目录在 nginx 安装根目录中</span><br><span class="line">        # 也可以使用绝对路径 D:/nginx-1.27.1/static_html</span><br><span class="line">        alias   static_file/;</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    location /api/ {</span><br><span class="line">		proxy_set_header Host $http_host;</span><br><span class="line">		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">		proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">		proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">        client_max_body_size 2048m;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/100/images/02.png"></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>已docker容器运行的postgreSQL安装postgis插件</title>
    <url>/2024/08/25/101/</url>
    <content><![CDATA[<h2 id="安装环境确认"><a href="#安装环境确认" class="headerlink" title="安装环境确认"></a>安装环境确认</h2><h3 id="PostgreSQL-版本"><a href="#PostgreSQL-版本" class="headerlink" title="PostgreSQL 版本"></a>PostgreSQL 版本</h3><p>链接 PostgreSQL 数据库，查看数据库版本号</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> version();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>笔者的版本号为：</p>
<p>PostgreSQL 12.13 (Debian 12.13-1.pgdg110+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 10.2.1-6) 10.2.1 20210110, 64-bit</p>
</blockquote>
<h3 id="查看已安装插件"><a href="#查看已安装插件" class="headerlink" title="查看已安装插件"></a>查看已安装插件</h3><p>查看 PostgreSQL 已安装插件</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_extension;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可安装插件查询"><a href="#可安装插件查询" class="headerlink" title="可安装插件查询"></a>可安装插件查询</h3><p>查看 PostgreSQL 是否可安装 PostGIS 插件</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_available_extensions <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">'postgis'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上述 sql 执行结果展示了 PostGIS 记录，则跳转到下下章节直接安装 PostGIS 插件，否则请参见下章节。</p>
<h2 id="docker-容器中安装-PostGIS-软件"><a href="#docker-容器中安装-PostGIS-软件" class="headerlink" title="docker 容器中安装 PostGIS 软件"></a>docker 容器中安装 PostGIS 软件</h2><h3 id="进入-docker-容器"><a href="#进入-docker-容器" class="headerlink" title="进入 docker 容器"></a>进入 docker 容器</h3><p>步骤1：查看 docker 容器的 IMAGE_ID</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：进入 docker 容器</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker exec -it {IMAGE_ID} /bin/bash</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Ubuntu-软件源更换为国内镜像源"><a href="#Ubuntu-软件源更换为国内镜像源" class="headerlink" title="Ubuntu 软件源更换为国内镜像源"></a>Ubuntu 软件源更换为国内镜像源</h3><p>步骤1：备份软件源配置：/etc/apt/sources.list</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></tbody></table></figure>

<p>步骤2：使用 vi 命令将源域名改为：mirrors.tuna.tsinghua.edu.cn 或者 mirrors.aliyun.com</p>
<p><img src="https://image.woodwhales.cn/101/images/01.png"></p>
<p>deb.debian.org 换为：mirrors.tuna.tsinghua.edu.cn</p>
<p><img src="https://image.woodwhales.cn/101/images/02.png"></p>
<p>步骤3：更新软件包列表</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt-get update</span><br></pre></td></tr></tbody></table></figure>

<h3 id="安装-postgis"><a href="#安装-postgis" class="headerlink" title="安装 postgis"></a>安装 postgis</h3><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt install -y postgis</span><br></pre></td></tr></tbody></table></figure>

<h3 id="安装-postgis-3-scripts"><a href="#安装-postgis-3-scripts" class="headerlink" title="安装 postgis-3-scripts"></a>安装 postgis-3-scripts</h3><p>安装对应 PostgreSQL 版本的 postgresql-{version}-postgis-3-scripts，笔者的 PostgreSQL 版本是 12，则安装<code>postgresql-12-postgis-3-scripts</code></p>
<blockquote>
<p>postgresql 版本与postgis版本对应关系：<a href="https://trac.osgeo.org/postgis/wiki/UsersWikiPostgreSQLPostGIS">https://trac.osgeo.org/postgis/wiki/UsersWikiPostgreSQLPostGIS</a></p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">apt install -y postgresql-12-postgis-3-scripts</span><br></pre></td></tr></tbody></table></figure>

<h2 id="PostgreSQL-安装-PostGIS-插件"><a href="#PostgreSQL-安装-PostGIS-插件" class="headerlink" title="PostgreSQL 安装 PostGIS 插件"></a>PostgreSQL 安装 PostGIS 插件</h2><p>安装 PostGIS 插件 </p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION postgis;</span><br></pre></td></tr></tbody></table></figure>

<p>查看 PostGIS 版本</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> postgis_version();</span><br></pre></td></tr></tbody></table></figure>

<p>查看 PostGIS 完整版本</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> postgis_full_version();</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>postgreSQL</category>
      </categories>
      <tags>
        <tag>postgis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装 Harbor 教程（搭建 Docker 私有仓库 harbor 避坑指南）</title>
    <url>/2025/05/24/102/</url>
    <content><![CDATA[<h2 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h2><p>操作系统版本：<code>CentOS Linux release 7.9.2009 (Core)</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cat /etc/centos-release</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">cat /etc/os-release</span><br></pre></td></tr></tbody></table></figure>

<p>内核版本：<code>3.10.0-957.el7.x86_64</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">cat /proc/version</span><br></pre></td></tr></tbody></table></figure>

<p>系统架构：<code>x86_64</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">arch</span><br></pre></td></tr></tbody></table></figure>

<p>docker 版本：<code>Docker version 26.1.4, build 5650f9b</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></tbody></table></figure>

<p>docker-compose 版本：<code>Docker Compose version v2.36.1</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></tbody></table></figure>

<p>harbor 版本：<code>v2.13.0</code></p>
<blockquote>
<p>这里一定要使用 v2.13.0，笔者也尝试了不同版本，部分版本确实存在坑。类似问题 issue 可以参见：<a href="https://github.com/goharbor/harbor/issues/21996">https://github.com/goharbor/harbor/issues/21996</a></p>
</blockquote>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="系统磁盘空间检查"><a href="#系统磁盘空间检查" class="headerlink" title="系统磁盘空间检查"></a>系统磁盘空间检查</h3><p>首先确认 docker 数据存储目录，查看磁盘空间是否充足可用</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/102/images/01.jpg"></p>
<h3 id="docker-数据存储目录检查"><a href="#docker-数据存储目录检查" class="headerlink" title="docker 数据存储目录检查"></a>docker 数据存储目录检查</h3><p>查看 docker 数据存储目录，默认是：<code>/var/lib/docker</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/102/images/02.jpg"></p>
<p>对比存在磁盘不足，可以修改 docker 数据存储目录。</p>
<p>笔者以改为<code>/home/docker</code>为例：</p>
<p><strong>步骤1</strong>：创建对应目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p /home/docker</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2</strong>：注意 docker 旧的数据需要迁移过去：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp -a /var/lib/docker /home/docker/</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3</strong>：再配置<code>daemon.json</code>的<code>data-root</code>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4</strong>：填写<code>data-root</code>配置为指定数据存储目录：</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"data-root"</span><span class="punctuation">:</span> <span class="string">"/home/docker"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"live-restore"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">"registry-mirrors"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>配置<code>docker live-restore</code>，这样再重启 dockerd 时，就不会重启容器。</li>
</ul>
<p><strong>步骤5</strong>：执行配置重载命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">kill -SIGHUP $(pidof dockerd)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤6</strong>：执行配置重载命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤7</strong>：再重启 docker：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤8</strong>：再次执行docker info 查看是否修改正确：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></tbody></table></figure>

<h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>参见笔者的另一篇文章：<a href="https://woodwhales.cn/2020/05/28/069/#%E5%AE%89%E8%A3%85-docker">Docker 安装</a></p>
<h2 id="docker-compose-安装"><a href="#docker-compose-安装" class="headerlink" title="docker-compose 安装"></a>docker-compose 安装</h2><p><strong>步骤1</strong>：切换到指定目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd /usr/local/bin/</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2</strong>：从 github 下载 docker-compose 可执行包：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget https://github.com/docker/compose/releases/download/v2.36.1/docker-compose-linux-x86_64 -O docker-compose</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3</strong>：添加执行权限：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4</strong>：在任意位置执行 docker-compose 命令输出版本信息，即安装成功：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></tbody></table></figure>

<h2 id="docker-安装-redis"><a href="#docker-安装-redis" class="headerlink" title="docker 安装 redis"></a>docker 安装 redis</h2><p><strong>步骤1</strong>：创建对应目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置目录</span></span><br><span class="line">mkdir -p /home/redis/conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据目录</span></span><br><span class="line">mkdir -p /home/redis/data</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2</strong>：切换到 redis 配置文件目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd /home/redis/conf</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3</strong>：下载配置文件</p>
<blockquote>
<p><a href="https://redis.io/docs/latest/operate/oss_and_stack/management/config/">https://redis.io/docs/latest/operate/oss_and_stack/management/config/</a> 下载对应版本的配置文件</p>
</blockquote>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/redis/redis/7.4/redis.conf</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4</strong>：修改 redis.conf 配置文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vim /home/redis/conf/redis.conf</span><br></pre></td></tr></tbody></table></figure>

<p>更新如下配置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">requirepass redis@123</span><br><span class="line">dir /data</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤5</strong>：docker 拉取 redis 镜像：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull redis:7.4</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤6</strong>：启动 redis</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d --name redis7.4 \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-v /home/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-v /home/redis/data:/data \</span><br><span class="line">redis:7.4 \</span><br><span class="line">redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤7</strong>：查看容器日志检查是否启动成功：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker logs -f redis7.4</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到：Ready to accept connections tcp 字样表示启动成功。</p>
<p><img src="https://image.woodwhales.cn/102/images/03.jpg"></p>
<h2 id="docker-安装-postgreSQL"><a href="#docker-安装-postgreSQL" class="headerlink" title="docker 安装 postgreSQL"></a>docker 安装 postgreSQL</h2><blockquote>
<p>笔者安装的是带 postgis 版本的，方便后续地理坐标数据存储</p>
</blockquote>
<p><strong>步骤1</strong>：创建 postgreSQL 数据目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir /home/postgresql/data</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2</strong>：拉取 postgis/postgis 镜像</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull postgis/postgis:16-3.5</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3</strong>：启动 postgreSQL 容器：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d --name postgresql16 \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 5432:5432 \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">-e POSTGRES_USER=postgres \</span><br><span class="line">-e POSTGRES_PASSWORD=postgres \</span><br><span class="line">-v /home/postgresql/data:/var/lib/postgresql/data \</span><br><span class="line">postgis/postgis:16-3.5</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4</strong>：查看容器日志检查是否启动成功：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker logs -f postgresql16</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到：database system is ready to accept connections 字样表示启动成功。</p>
<p><img src="https://image.woodwhales.cn/102/images/04.jpg"></p>
<p>也可以使用下述命令查询 postgreSQL 的版本信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker exec postgresql16 psql -U postgres -c "SELECT version();"</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/102/images/06.jpg"></p>
<h2 id="docker-安装-harbor"><a href="#docker-安装-harbor" class="headerlink" title="docker 安装 harbor"></a>docker 安装 harbor</h2><p><strong>步骤1</strong>：创建 harbor 安装目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mkdir -p /home/harbor/data</span><br><span class="line">mkdir -p /home/harbor/ssh</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤2</strong>：切换到指定目录：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd /home/harbor/</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤3</strong>：使用 openssl 生成证书，依次执行下述命令</p>
<ul>
<li>注意：如果不配置 https 或者有正式的 ssl 域名证书，则忽略本步骤。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 ca.key</span></span><br><span class="line">openssl genrsa -out /home/harbor/ssh/ca.key 4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 ca.key 签发 ca.crt 证书</span></span><br><span class="line">openssl req -x509 -new -nodes -sha512 -days 3650 \</span><br><span class="line">-subj "/C=CN/CN=localhost" \</span><br><span class="line">-key /home/harbor/ssh/ca.key \</span><br><span class="line">-out /home/harbor/ssh/ca.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成 harbor.key</span></span><br><span class="line">openssl genrsa -out /home/harbor/ssh/harbor.key 4096</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 harbor.key 签名并生成 harbor.csr 证书</span></span><br><span class="line">openssl req -sha512 -new \</span><br><span class="line">    -subj "/C=CN/CN=localhost" \</span><br><span class="line">    -key /home/harbor/ssh/harbor.key \</span><br><span class="line">    -out /home/harbor/ssh/harbor.csr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据 ca.key 和 ca.crt 证书 签名并认证 harbor.csr 证书</span></span><br><span class="line">openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">-CA /home/harbor/ssh/ca.crt \</span><br><span class="line">-CAkey /home/harbor/ssh/ca.key \</span><br><span class="line">-CAcreateserial \</span><br><span class="line">-in /home/harbor/ssh/harbor.csr \</span><br><span class="line">-out /home/harbor/ssh/harbor.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 harbor.crt 格式化成 harbor.cert</span></span><br><span class="line">openssl x509 -inform PEM \</span><br><span class="line">-in /home/harbor/ssh/harbor.crt \</span><br><span class="line">-out /home/harbor/ssh/harbor.cert</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤4</strong>：从 github 下载离线版本安装包：<a href="https://github.com/goharbor/harbor/releases/download/v2.13.0/harbor-offline-installer-v2.13.0.tgz">harbor-offline-installer-v2.13.0.tgz</a></p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">wget https://github.com/goharbor/harbor/releases/download/v2.13.0/harbor-offline-installer-v2.13.0.tgz -O harbor-offline-installer-v2.13.0.tgz</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤5</strong>：解压 tgz 文件：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">tar xzvf /home/harbor/harbor-offline-installer-v2.13.0.tgz</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤6</strong>：配置文件信息配置</p>
<p>解压成功之后，需要进入 harbor 文件夹，可以看到下述文件：</p>
<p><img src="https://image.woodwhales.cn/102/images/05.jpg"></p>
<p>里面有个模板配置文件<code>harbor.yml.tmpl</code>，需要复制并重命名成<code>harbor.yml</code>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cp /home/harbor/harbor/harbor.yml.tmpl /home/harbor/harbor/harbor.yml</span><br></pre></td></tr></tbody></table></figure>

<p>将配置文件中的下述信息进行自定义配置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">hostname:</span> <span class="string">宿主机的IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http 端口默认为 80，改为1440，这个端口是宿主机映射到容器的 http 端口</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">1440</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释 https 配置，不开启 https</span></span><br><span class="line"><span class="comment">#https:</span></span><br><span class="line">  <span class="comment"># https 端口默认为443，如果配置了，则这个端口是宿主机映射到容器的 https 端口</span></span><br><span class="line">  <span class="comment"># port: 443</span></span><br><span class="line">  <span class="comment"># ssl 证书</span></span><br><span class="line">  <span class="comment"># certificate: /your/certificate/path</span></span><br><span class="line">  <span class="comment"># ssl 证书私钥</span></span><br><span class="line">  <span class="comment"># private_key:  /your/private/key/path</span></span><br><span class="line">  <span class="comment"># strong_ssl_ciphers: false</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># https 访问地址，这里配置，则 hostname 不生效</span></span><br><span class="line"><span class="attr">external_url:</span> <span class="string">http://宿主机的IP:1440</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认密码</span></span><br><span class="line"><span class="attr">harbor_admin_password:</span> <span class="string">Harbor12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 宿主机挂载 harbor 数据文件目录</span></span><br><span class="line"><span class="attr">data_volume:</span> <span class="string">/home/harbor/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用外部 postgreSQL 数据库</span></span><br><span class="line"><span class="attr">external_database:</span></span><br><span class="line">  <span class="attr">harbor:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">宿主机的IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line">    <span class="attr">db_name:</span> <span class="string">harbor_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="comment"># 不启用 SSL 模式</span></span><br><span class="line">    <span class="attr">ssl_mode:</span> <span class="string">disable</span></span><br><span class="line">    <span class="comment"># 空闲连接池的最大连接数。如果 &lt;=0，则不保留任何空闲连接。默认值为 2</span></span><br><span class="line">    <span class="attr">max_idle_conns:</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 数据库的最大打开连接数。如果 &lt;= 0，则打开连接数不受限制。默认值为 0</span></span><br><span class="line">    <span class="attr">max_open_conns:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用外部 redis 数据库</span></span><br><span class="line"><span class="attr">external_redis:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">宿主机IP:6379</span></span><br><span class="line">  <span class="comment"># 宿主机的redis密码，如果没有密码则不需要填写</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">redis@123</span></span><br></pre></td></tr></tbody></table></figure>

<p>上述配置中，如果配置了<code>https</code>，则<code>external_url</code>需要配置为：<code>https://</code> + 宿主机 IP 或者 域名 + <code>https.port</code>，浏览器访问时，证书信息如下：</p>
<p><img src="https://image.woodwhales.cn/102/images/11.jpg"></p>
<p><strong>步骤7</strong>：创建数据库</p>
<p>注意上述配置了数据库使用宿主机的 postgreSQL，因此需要在宿主机的 pgSQL 数据库中创建对应的数据库：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker exec -it postgresql16 psql -U postgres -c "CREATE DATABASE harbor_db;"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤8</strong>：执行预处理程序：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">/home/harbor/harbor/prepare</span><br></pre></td></tr></tbody></table></figure>

<p>预处理脚本执行成功，则会出现 Generated configuration file: /compose_location/docker-compose.yml 字样。</p>
<p><img src="https://image.woodwhales.cn/102/images/07.jpg"></p>
<p>此时当前文件夹下出现了<code>docker-compose.yml</code>文件，</p>
<p><strong>注意</strong>：上述配置再次改动后，需要重新执行 prepare 脚本，重新生成 docker-compose.yml 文件。</p>
<ul>
<li>重置数据库</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker exec -it postgresql16 psql -U postgres -c "DROP DATABASE IF EXISTS harbor_db;" -c "CREATE DATABASE harbor_db;"</span><br></pre></td></tr></tbody></table></figure>

<p>出现 DROP DATABASE、CREATE DATABASE 字样，表示重新创建数据库成功。</p>
<ul>
<li>删除历史数据</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">rm -rf /home/harbor/data/*</span><br></pre></td></tr></tbody></table></figure>

<p><strong>步骤9</strong>：启动 harbor 服务</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">sh /home/harbor/harbor/install.sh</span><br></pre></td></tr></tbody></table></figure>

<p>执行完成，出现 Harbor has been installed and started successfully 字样表示启动成功</p>
<p><img src="https://image.woodwhales.cn/102/images/08.jpg"></p>
<p>此时浏览器访问：<code>http://宿主机IP:1440</code>即可打开 harbor 控制台页面。此时浏览器可能出现证书不安全提示，强制访问即可。</p>
<p><img src="https://image.woodwhales.cn/102/images/09.jpg"></p>
<p>账号为：admin，密码为：Harbor12345。登录成功页面如下，强烈建议及时修改管理员账号密码</p>
<p><img src="https://image.woodwhales.cn/102/images/12.jpg"></p>
<p><strong>步骤9</strong>：如果需要卸载 harbor 服务，则执行：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换至 harbor 文件目录</span></span><br><span class="line">cd /home/harbor/harbor</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除所有harbor相关容器</span></span><br><span class="line">docker-compose down -v</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除数据库，重新创建数据库</span></span><br><span class="line">docker exec -it postgresql16 psql -U postgres -c "DROP DATABASE IF EXISTS harbor_db;" -c "CREATE DATABASE harbor_db;"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除harbor数据存储目录</span></span><br><span class="line">rm -rf /home/harbor/data/*</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/102/images/10.jpg"></p>
<h2 id="harbor-控制台配置"><a href="#harbor-控制台配置" class="headerlink" title="harbor 控制台配置"></a>harbor 控制台配置</h2><h3 id="修改主题色"><a href="#修改主题色" class="headerlink" title="修改主题色"></a>修改主题色</h3><p>左下角切换主题色</p>
<p><img src="https://image.woodwhales.cn/102/images/13.jpg"></p>
<h3 id="创建镜像仓库"><a href="#创建镜像仓库" class="headerlink" title="创建镜像仓库"></a>创建镜像仓库</h3><p>在<code>系统管理</code>的<code>仓库管理</code>中创建新的仓库：</p>
<p><img src="https://image.woodwhales.cn/102/images/15.jpg"></p>
<p><img src="https://image.woodwhales.cn/102/images/16.png"></p>
<p>填写目标信息之后，点击确定，列表展示了仓库信息。</p>
<p><img src="https://image.woodwhales.cn/102/images/17.png"></p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>点击<code>项目</code>菜单，创建新的项目</p>
<p><img src="https://image.woodwhales.cn/102/images/14.jpg"></p>
<p>填写项目名称为<code>image</code>，并开启镜像代理：</p>
<ul>
<li>注意：开启了镜像代理，则该项目不能向其推送镜像。访问级别是公开的则所有人可拉取该项目下的镜像。</li>
</ul>
<p><img src="https://image.woodwhales.cn/102/images/18.png"></p>
<p>上述配置好后，在已经搭建了 harbor 的服务器上，拉取测试镜像：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull 127.0.0.1:1444/image/hello-world</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://image.woodwhales.cn/102/images/19.png"></p>
<p>此时登录 harbor 控制台可以看到已经拉取成功的镜像。</p>
<h2 id="宿主机-nginx-配置"><a href="#宿主机-nginx-配置" class="headerlink" title="宿主机 nginx 配置"></a>宿主机 nginx 配置</h2><p>nginx 配置示例如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">upstream harbor {</span><br><span class="line">  # harbor 服务端口</span><br><span class="line">  server 宿主机IP:1440;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">server {</span><br><span class="line">  # 暴露给公网的 https 端口</span><br><span class="line">  listen 1444 ssl;</span><br><span class="line">  server_tokens off;</span><br><span class="line">  server_name _;</span><br><span class="line">  # ssl 证书文件路径</span><br><span class="line">  ssl_certificate /data/ssh/public.pem;</span><br><span class="line">  # ssl 证书私钥文件路径</span><br><span class="line">  ssl_certificate_key /data/ssh/private.key;</span><br><span class="line">  ssl_session_timeout 5m;</span><br><span class="line">  add_header Accept-Ranges bytes;</span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">  client_max_body_size 0;</span><br><span class="line"></span><br><span class="line">  location /v2/ {</span><br><span class="line">    proxy_pass http://harbor/v2/;</span><br><span class="line">    proxy_set_header Host $http_host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line">    proxy_set_header Authorization $http_authorization;</span><br><span class="line">    proxy_pass_header Authorization;</span><br><span class="line">    client_max_body_size 0;</span><br><span class="line">    proxy_request_buffering off;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  location ~^/(service|c|image)/ {</span><br><span class="line">    proxy_pass http://harbor;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  location / {</span><br><span class="line">    # 只允许内网IP可以访问控制台，外网IP访问直接 403</span><br><span class="line">    allow 10.0.0.0/8;</span><br><span class="line">    allow 192.168.0.0/16;</span><br><span class="line">    allow 172.16.0.0/16;</span><br><span class="line">    allow 172.21.0.0/16;</span><br><span class="line">    deny all;</span><br><span class="line">    proxy_pass http://harbor;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  error_page 403 /403.html;</span><br><span class="line">  location = /403.html {</span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line">    internal;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  proxy_intercept_errors on;</span><br><span class="line">  fastcgi_intercept_errors on;</span><br><span class="line"></span><br><span class="line">  error_log /var/log/nginx/harbor_error.log error;</span><br><span class="line">  access_log /var/log/nginx/harbor.log main;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意上述配置自定义了<code>403.html</code>，需要在<code>/usr/share/nginx/html</code>目录中创建<code>403.html</code>：</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>403 Forbidden<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>403 Forbidden<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>You don't have permission to access this resource.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>harbor</category>
      </categories>
      <tags>
        <tag>harbor</tag>
      </tags>
  </entry>
</search>
